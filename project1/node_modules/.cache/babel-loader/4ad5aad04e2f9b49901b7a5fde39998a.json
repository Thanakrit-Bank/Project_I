{"ast":null,"code":"import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport { isObject, lineString } from '@turf/helpers';\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @name lineSliceAlong\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\n\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var coords;\n  var slice = []; // Validation\n\n  if (line.type === \"Feature\") coords = line.geometry.coordinates;else if (line.type === \"LineString\") coords = line.coordinates;else throw new Error(\"input must be a LineString Feature or Geometry\");\n  var origCoordsLength = coords.length;\n  var travelled = 0;\n  var overshot, direction, interpolated;\n\n  for (var i = 0; i < coords.length; i++) {\n    if (startDist >= travelled && i === coords.length - 1) break;else if (travelled > startDist && slice.length === 0) {\n      overshot = startDist - travelled;\n\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n    }\n\n    if (travelled >= stopDist) {\n      overshot = stopDist - travelled;\n\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n      return lineString(slice);\n    }\n\n    if (travelled >= startDist) {\n      slice.push(coords[i]);\n    }\n\n    if (i === coords.length - 1) {\n      return lineString(slice);\n    }\n\n    travelled += distance(coords[i], coords[i + 1], options);\n  }\n\n  if (travelled < startDist && coords.length === origCoordsLength) throw new Error(\"Start position is beyond line\");\n  var last = coords[coords.length - 1];\n  return lineString([last, last]);\n}\n\nexport default lineSliceAlong;","map":{"version":3,"names":["bearing","distance","destination","isObject","lineString","lineSliceAlong","line","startDist","stopDist","options","Error","coords","slice","type","geometry","coordinates","origCoordsLength","length","travelled","overshot","direction","interpolated","i","push","last"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/line-slice-along/dist/es/index.js"],"sourcesContent":["import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport { isObject, lineString } from '@turf/helpers';\n\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @name lineSliceAlong\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n\n  var coords;\n  var slice = [];\n\n  // Validation\n  if (line.type === \"Feature\") coords = line.geometry.coordinates;\n  else if (line.type === \"LineString\") coords = line.coordinates;\n  else throw new Error(\"input must be a LineString Feature or Geometry\");\n  var origCoordsLength = coords.length;\n  var travelled = 0;\n  var overshot, direction, interpolated;\n  for (var i = 0; i < coords.length; i++) {\n    if (startDist >= travelled && i === coords.length - 1) break;\n    else if (travelled > startDist && slice.length === 0) {\n      overshot = startDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n    }\n\n    if (travelled >= stopDist) {\n      overshot = stopDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n      return lineString(slice);\n    }\n\n    if (travelled >= startDist) {\n      slice.push(coords[i]);\n    }\n\n    if (i === coords.length - 1) {\n      return lineString(slice);\n    }\n\n    travelled += distance(coords[i], coords[i + 1], options);\n  }\n\n  if (travelled < startDist && coords.length === origCoordsLength)\n    throw new Error(\"Start position is beyond line\");\n\n  var last = coords[coords.length - 1];\n  return lineString([last, last]);\n}\n\nexport default lineSliceAlong;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}