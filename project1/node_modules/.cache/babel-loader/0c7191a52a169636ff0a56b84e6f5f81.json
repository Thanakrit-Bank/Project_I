{"ast":null,"code":"\"use strict\";\n\nvar Distance = require(\"./distance.js\"),\n    eudist = Distance.eudist,\n    dist = Distance.dist;\n\nmodule.exports = {\n  kmrand: function kmrand(data, k) {\n    var map = {},\n        ks = [],\n        t = k << 2;\n    var len = data.length;\n    var multi = data[0].length > 0;\n\n    while (ks.length < k && t-- > 0) {\n      var d = data[Math.floor(Math.random() * len)];\n      var key = multi ? d.join(\"_\") : \"\" + d;\n\n      if (!map[key]) {\n        map[key] = true;\n        ks.push(d);\n      }\n    }\n\n    if (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n  },\n\n  /**\n   * K-means++ initial centroid selection\n   */\n  kmpp: function kmpp(data, k) {\n    var distance = data[0].length ? eudist : dist;\n    var ks = [],\n        len = data.length;\n    var multi = data[0].length > 0;\n    var map = {}; // First random centroid\n\n    var c = data[Math.floor(Math.random() * len)];\n    var key = multi ? c.join(\"_\") : \"\" + c;\n    ks.push(c);\n    map[key] = true; // Retrieve next centroids\n\n    while (ks.length < k) {\n      // Min Distances between current centroids and data points\n      var dists = [],\n          lk = ks.length;\n      var dsum = 0,\n          prs = [];\n\n      for (var i = 0; i < len; i++) {\n        var min = Infinity;\n\n        for (var j = 0; j < lk; j++) {\n          var _dist = distance(data[i], ks[j]);\n\n          if (_dist <= min) min = _dist;\n        }\n\n        dists[i] = min;\n      } // Sum all min distances\n\n\n      for (var _i = 0; _i < len; _i++) {\n        dsum += dists[_i];\n      } // Probabilities and cummulative prob (cumsum)\n\n\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        prs[_i2] = {\n          i: _i2,\n          v: data[_i2],\n          pr: dists[_i2] / dsum,\n          cs: 0\n        };\n      } // Sort Probabilities\n\n\n      prs.sort(function (a, b) {\n        return a.pr - b.pr;\n      }); // Cummulative Probabilities\n\n      prs[0].cs = prs[0].pr;\n\n      for (var _i3 = 1; _i3 < len; _i3++) {\n        prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n      } // Randomize\n\n\n      var rnd = Math.random(); // Gets only the items whose cumsum >= rnd\n\n      var idx = 0;\n\n      while (idx < len - 1 && prs[idx++].cs < rnd) {}\n\n      ks.push(prs[idx - 1].v);\n      /*\n      let done = false;\n      while(!done) {\n      \t// this is our new centroid\n      \tc = prs[idx-1].v\n      \tkey = multi? c.join(\"_\") : `${c}`;\n      \tif(!map[key]) {\n      \t\tmap[key] = true;\n      \t\tks.push(c);\n      \t\tdone = true;\n      \t}\n      \telse {\n      \t\tidx++;\n      \t}\n      }\n      */\n    }\n\n    return ks;\n  }\n};","map":{"version":3,"mappings":"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","names":["Distance","require","eudist","dist","module","exports","kmrand","data","k","map","ks","t","len","length","multi","d","Math","floor","random","key","join","push","Error","kmpp","distance","c","dists","lk","dsum","prs","i","min","Infinity","j","v","pr","cs","sort","a","b","rnd","idx"],"sources":["D:\\Project\\Mix_Project\\Project_I\\project1\\node_modules\\skmeans\\kinit.js"],"sourcesContent":["const\n\tDistance = require(\"./distance.js\"),\n\teudist = Distance.eudist,\n\tdist = Distance.dist;\n\nmodule.exports = {\n\tkmrand(data,k) {\n\t\tvar map = {}, ks = [], t = k<<2;\n\t\tvar len = data.length;\n\t\tvar multi = data[0].length>0;\n\n\t\twhile(ks.length<k && (t--)>0) {\n\t\t\tlet d = data[Math.floor(Math.random()*len)];\n\t\t\tlet key = multi? d.join(\"_\") : `${d}`;\n\t\t\tif(!map[key]) {\n\t\t\t\tmap[key] = true;\n\t\t\t\tks.push(d);\n\t\t\t}\n\t\t}\n\n\t\tif(ks.length<k) throw new Error(\"Error initializating clusters\");\n\t\telse return ks;\n\t},\n\n\t/**\n\t * K-means++ initial centroid selection\n\t */\n\tkmpp(data,k) {\n\t\tvar distance = data[0].length? eudist : dist;\n\t\tvar ks = [], len = data.length;\n\t\tvar multi = data[0].length>0;\n\t\tvar map = {};\n\n\t\t// First random centroid\n\t\tvar c = data[Math.floor(Math.random()*len)];\n\t\tvar key = multi? c.join(\"_\") : `${c}`;\n\t\tks.push(c);\n\t\tmap[key] = true;\n\n\t\t// Retrieve next centroids\n\t\twhile(ks.length<k) {\n\t\t\t// Min Distances between current centroids and data points\n\t\t\tlet dists = [], lk = ks.length;\n\t\t\tlet dsum = 0, prs = [];\n\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tlet min = Infinity;\n\t\t\t\tfor(let j=0;j<lk;j++) {\n\t\t\t\t\tlet dist = distance(data[i],ks[j]);\n\t\t\t\t\tif(dist<=min) min = dist;\n\t\t\t\t}\n\t\t\t\tdists[i] = min;\n\t\t\t}\n\n\t\t\t// Sum all min distances\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tdsum += dists[i]\n\t\t\t}\n\n\t\t\t// Probabilities and cummulative prob (cumsum)\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tprs[i] = {i:i, v:data[i],\tpr:dists[i]/dsum, cs:0}\n\t\t\t}\n\n\t\t\t// Sort Probabilities\n\t\t\tprs.sort((a,b)=>a.pr-b.pr);\n\n\t\t\t// Cummulative Probabilities\n\t\t\tprs[0].cs = prs[0].pr;\n\t\t\tfor(let i=1;i<len;i++) {\n\t\t\t\tprs[i].cs = prs[i-1].cs + prs[i].pr;\n\t\t\t}\n\n\t\t\t// Randomize\n\t\t\tlet rnd = Math.random();\n\n\t\t\t// Gets only the items whose cumsum >= rnd\n\t\t\tlet idx = 0;\n\t\t\twhile(idx<len-1 && prs[idx++].cs<rnd);\n\t\t\tks.push(prs[idx-1].v);\n\t\t\t/*\n\t\t\tlet done = false;\n\t\t\twhile(!done) {\n\t\t\t\t// this is our new centroid\n\t\t\t\tc = prs[idx-1].v\n\t\t\t\tkey = multi? c.join(\"_\") : `${c}`;\n\t\t\t\tif(!map[key]) {\n\t\t\t\t\tmap[key] = true;\n\t\t\t\t\tks.push(c);\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\treturn ks;\n\t}\n\n}\n"]},"metadata":{},"sourceType":"script"}