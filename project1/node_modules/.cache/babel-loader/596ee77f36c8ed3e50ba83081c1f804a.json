{"ast":null,"code":"import { flattenEach } from '@turf/meta';\nimport { getType, getCoords } from '@turf/invariant';\nimport { isObject, lineString, multiLineString, lengthToDegrees } from '@turf/helpers';\n/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\n\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\n\n\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\n\n\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\n\n\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\n\n\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\n\n\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection = add(p, scalarMult(t, r));\n  return intersection;\n}\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\n\n\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\n\n\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @name lineOffset\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\n\n\nfunction lineOffset(geojson, distance, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units; // Valdiation\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance)) throw new Error(\"distance is required\");\n  var type = getType(geojson);\n  var properties = geojson.properties;\n\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);\n      });\n      return multiLineString(coords, properties);\n\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\n\n\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);\n      segments.push(segment);\n\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords); // Handling for line segments that aren't straight\n\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n\n        finalCoords.push(seg2Coords[0]);\n\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      } // Handling for lines that only have 1 segment\n\n\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\n\n\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\n  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;\n  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;\n  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;\n  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;\n  return [[out1x, out1y], [out2x, out2y]];\n}\n\nexport default lineOffset;","map":{"version":3,"names":["flattenEach","getType","getCoords","isObject","lineString","multiLineString","lengthToDegrees","ab","segment","start","end","crossProduct","v1","v2","add","sub","scalarMult","s","v","intersectSegments","a","b","p","r","q","cross","qmp","numerator","t","intersection","isParallel","lineOffset","geojson","distance","options","Error","units","undefined","isNaN","type","properties","lineOffsetFeature","coords","feature","push","geometry","coordinates","line","segments","offsetDegrees","finalCoords","forEach","currentCoords","index","length","processSegment","seg2Coords","intersects","point1","point2","offset","L","Math","sqrt","out1x","out2x","out1y","out2y"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/line-offset/dist/es/index.js"],"sourcesContent":["import { flattenEach } from '@turf/meta';\nimport { getType, getCoords } from '@turf/invariant';\nimport { isObject, lineString, multiLineString, lengthToDegrees } from '@turf/helpers';\n\n/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\n\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\n\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection = add(p, scalarMult(t, r));\n  return intersection;\n}\n\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\n\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @name lineOffset\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\nfunction lineOffset(geojson, distance, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n\n  // Valdiation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n\n  var type = getType(geojson);\n  var properties = geojson.properties;\n\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(\n          lineOffsetFeature(feature, distance, units).geometry.coordinates\n        );\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(\n        currentCoords,\n        coords[index + 1],\n        offsetDegrees\n      );\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n\n        // Handling for line segments that aren't straight\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      // Handling for lines that only have 1 segment\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\n\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt(\n    (point1[0] - point2[0]) * (point1[0] - point2[0]) +\n      (point1[1] - point2[1]) * (point1[1] - point2[1])\n  );\n\n  var out1x = point1[0] + (offset * (point2[1] - point1[1])) / L;\n  var out2x = point2[0] + (offset * (point2[1] - point1[1])) / L;\n  var out1y = point1[1] + (offset * (point1[0] - point2[0])) / L;\n  var out2y = point2[1] + (offset * (point1[0] - point2[0])) / L;\n  return [\n    [out1x, out1y],\n    [out2x, out2y],\n  ];\n}\n\nexport default lineOffset;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}