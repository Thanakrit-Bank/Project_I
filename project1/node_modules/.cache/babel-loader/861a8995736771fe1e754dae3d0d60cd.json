{"ast":null,"code":"// https://en.wikipedia.org/wiki/Rhumb_line\nimport { convertLength, degreesToRadians, earthRadius, point } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\r\n * Returns the destination {@link Point} having travelled the given distance along a Rhumb line from the\r\n * origin Point with the (varant) given bearing.\r\n *\r\n * @name rhumbDestination\r\n * @param {Coord} origin starting point\r\n * @param {number} distance distance from the starting point\r\n * @param {number} bearing varant bearing angle ranging from -180 to 180 degrees from north\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\r\n * @param {Object} [options.properties={}] translate properties to destination point\r\n * @returns {Feature<Point>} Destination point.\r\n * @example\r\n * var pt = turf.point([-75.343, 39.984], {\"marker-color\": \"F00\"});\r\n * var distance = 50;\r\n * var bearing = 90;\r\n * var options = {units: 'miles'};\r\n *\r\n * var destination = turf.rhumbDestination(pt, distance, bearing, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [pt, destination]\r\n * destination.properties['marker-color'] = '#00F';\r\n */\n\nfunction rhumbDestination(origin, distance, bearing, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var wasNegativeDistance = distance < 0;\n  var distanceInMeters = convertLength(Math.abs(distance), options.units, \"meters\");\n  if (wasNegativeDistance) distanceInMeters = -Math.abs(distanceInMeters);\n  var coords = getCoord(origin);\n  var destination = calculateRhumbDestination(coords, distanceInMeters, bearing); // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n  // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n\n  destination[0] += destination[0] - coords[0] > 180 ? -360 : coords[0] - destination[0] > 180 ? 360 : 0;\n  return point(destination, options.properties);\n}\n/**\r\n * Returns the destination point having travelled along a rhumb line from origin point the given\r\n * distance on the  given bearing.\r\n * Adapted from Geodesy: http://www.movable-type.co.uk/scripts/latlong.html#rhumblines\r\n *\r\n * @private\r\n * @param   {Array<number>} origin - point\r\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\r\n * @param   {number} bearing - Bearing in degrees from north.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {Array<number>} Destination point.\r\n */\n\n\nfunction calculateRhumbDestination(origin, distance, bearing, radius) {\n  // φ => phi\n  // λ => lambda\n  // ψ => psi\n  // Δ => Delta\n  // δ => delta\n  // θ => theta\n  radius = radius === undefined ? earthRadius : Number(radius);\n  var delta = distance / radius; // angular distance in radians\n\n  var lambda1 = origin[0] * Math.PI / 180; // to radians, but without normalize to 𝜋\n\n  var phi1 = degreesToRadians(origin[1]);\n  var theta = degreesToRadians(bearing);\n  var DeltaPhi = delta * Math.cos(theta);\n  var phi2 = phi1 + DeltaPhi; // check for some daft bugger going past the pole, normalise latitude if so\n\n  if (Math.abs(phi2) > Math.PI / 2) {\n    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n  }\n\n  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)); // E-W course becomes ill-conditioned with 0/0\n\n  var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n  var DeltaLambda = delta * Math.sin(theta) / q;\n  var lambda2 = lambda1 + DeltaLambda;\n  return [(lambda2 * 180 / Math.PI + 540) % 360 - 180, phi2 * 180 / Math.PI]; // normalise to −180..+180°\n}\n\nexport default rhumbDestination;","map":{"version":3,"names":["convertLength","degreesToRadians","earthRadius","point","getCoord","rhumbDestination","origin","distance","bearing","options","wasNegativeDistance","distanceInMeters","Math","abs","units","coords","destination","calculateRhumbDestination","properties","radius","undefined","Number","delta","lambda1","PI","phi1","theta","DeltaPhi","cos","phi2","DeltaPsi","log","tan","q","DeltaLambda","sin","lambda2"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/rhumb-destination/dist/es/index.js"],"sourcesContent":["// https://en.wikipedia.org/wiki/Rhumb_line\r\nimport { convertLength, degreesToRadians, earthRadius, point, } from \"@turf/helpers\";\r\nimport { getCoord } from \"@turf/invariant\";\r\n/**\r\n * Returns the destination {@link Point} having travelled the given distance along a Rhumb line from the\r\n * origin Point with the (varant) given bearing.\r\n *\r\n * @name rhumbDestination\r\n * @param {Coord} origin starting point\r\n * @param {number} distance distance from the starting point\r\n * @param {number} bearing varant bearing angle ranging from -180 to 180 degrees from north\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\r\n * @param {Object} [options.properties={}] translate properties to destination point\r\n * @returns {Feature<Point>} Destination point.\r\n * @example\r\n * var pt = turf.point([-75.343, 39.984], {\"marker-color\": \"F00\"});\r\n * var distance = 50;\r\n * var bearing = 90;\r\n * var options = {units: 'miles'};\r\n *\r\n * var destination = turf.rhumbDestination(pt, distance, bearing, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [pt, destination]\r\n * destination.properties['marker-color'] = '#00F';\r\n */\r\nfunction rhumbDestination(origin, distance, bearing, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var wasNegativeDistance = distance < 0;\r\n    var distanceInMeters = convertLength(Math.abs(distance), options.units, \"meters\");\r\n    if (wasNegativeDistance)\r\n        distanceInMeters = -Math.abs(distanceInMeters);\r\n    var coords = getCoord(origin);\r\n    var destination = calculateRhumbDestination(coords, distanceInMeters, bearing);\r\n    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\r\n    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\r\n    destination[0] +=\r\n        destination[0] - coords[0] > 180\r\n            ? -360\r\n            : coords[0] - destination[0] > 180\r\n                ? 360\r\n                : 0;\r\n    return point(destination, options.properties);\r\n}\r\n/**\r\n * Returns the destination point having travelled along a rhumb line from origin point the given\r\n * distance on the  given bearing.\r\n * Adapted from Geodesy: http://www.movable-type.co.uk/scripts/latlong.html#rhumblines\r\n *\r\n * @private\r\n * @param   {Array<number>} origin - point\r\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\r\n * @param   {number} bearing - Bearing in degrees from north.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {Array<number>} Destination point.\r\n */\r\nfunction calculateRhumbDestination(origin, distance, bearing, radius) {\r\n    // φ => phi\r\n    // λ => lambda\r\n    // ψ => psi\r\n    // Δ => Delta\r\n    // δ => delta\r\n    // θ => theta\r\n    radius = radius === undefined ? earthRadius : Number(radius);\r\n    var delta = distance / radius; // angular distance in radians\r\n    var lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to 𝜋\r\n    var phi1 = degreesToRadians(origin[1]);\r\n    var theta = degreesToRadians(bearing);\r\n    var DeltaPhi = delta * Math.cos(theta);\r\n    var phi2 = phi1 + DeltaPhi;\r\n    // check for some daft bugger going past the pole, normalise latitude if so\r\n    if (Math.abs(phi2) > Math.PI / 2) {\r\n        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\r\n    }\r\n    var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\r\n    // E-W course becomes ill-conditioned with 0/0\r\n    var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\r\n    var DeltaLambda = (delta * Math.sin(theta)) / q;\r\n    var lambda2 = lambda1 + DeltaLambda;\r\n    return [\r\n        (((lambda2 * 180) / Math.PI + 540) % 360) - 180,\r\n        (phi2 * 180) / Math.PI,\r\n    ]; // normalise to −180..+180°\r\n}\r\nexport default rhumbDestination;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}