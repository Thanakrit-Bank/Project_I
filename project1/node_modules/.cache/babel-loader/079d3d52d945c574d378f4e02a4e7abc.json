{"ast":null,"code":"import bbox from '@turf/bbox';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport distance from '@turf/distance';\nimport scale from '@turf/transform-scale';\nimport cleanCoords from '@turf/clean-coords';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport { getCoord, getType, getGeom } from '@turf/invariant';\nimport { isObject, featureCollection, isNumber, point, feature, lineString } from '@turf/helpers'; // javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node) {\n  var curr = node,\n      path = [];\n\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return node.f;\n  });\n}\n/**\r\n * Astar\r\n * @private\r\n */\n\n\nvar astar = {\n  /**\r\n   * Perform an A* Search on a graph given a start and end node.\r\n   *\r\n   * @private\r\n   * @memberof astar\r\n   * @param {Graph} graph Graph\r\n   * @param {GridNode} start Start\r\n   * @param {GridNode} end End\r\n   * @param {Object} [options] Options\r\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\r\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\r\n   * @returns {Object} Search\r\n   */\n  search: function search(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\n        closest = options.closest || false;\n    var openHeap = getHeap(),\n        closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop(); // End case -- result has been found, return the traced path.\n\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      } // Normal case -- move currentNode from open to closed, process each of its neighbors.\n\n\n      currentNode.closed = true; // Find all neighbors for the current node.\n\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        } // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n\n\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n            beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    } // No result was found - empty array signifies failure to find path.\n\n\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function manhattan(pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function diagonal(pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    }\n  },\n  cleanNode: function cleanNode(node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n/**\r\n * A graph memory structure\r\n *\r\n * @private\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options] Options\r\n * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\r\n * @returns {void} Graph\r\n */\n\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n\n  this.init();\n}\n\nGraph.prototype.init = function () {\n  this.dirtyNodes = [];\n\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function () {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function (node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function (node) {\n  var ret = [],\n      x = node.x,\n      y = node.y,\n      grid = this.grid; // West\n\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  } // East\n\n\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  } // South\n\n\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  } // North\n\n\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    } // Southeast\n\n\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    } // Northwest\n\n\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    } // Northeast\n\n\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function () {\n  var graphString = [],\n      nodes = this.grid,\n      // when using grid\n  rowDebug,\n      row,\n      y,\n      l;\n\n  for (var x = 0, len = nodes.length; x < len; x++) {\n    rowDebug = [];\n    row = nodes[x];\n\n    for (y = 0, l = row.length; y < l; y++) {\n      rowDebug.push(row[y].weight);\n    }\n\n    graphString.push(rowDebug.join(\" \"));\n  }\n\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function () {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function (fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n    return this.weight * 1.41421;\n  }\n\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function () {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element); // Allow it to sink down.\n\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0]; // Get the element at the end of the array.\n\n    var end = this.content.pop(); // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n\n    return result;\n  },\n  remove: function remove(node) {\n    var i = this.content.indexOf(node); // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function size() {\n    return this.content.length;\n  },\n  rescoreElement: function rescoreElement(node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function sinkDown(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n]; // When at 0, an element can not sink any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = (n + 1 >> 1) - 1,\n          parent = this.content[parentN]; // Swap the elements if the parent is greater.\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent; // Update 'n' to continue at the new position.\n\n        n = parentN; // Found a parent that is less, no need to sink any further.\n      } else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function bubbleUp(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = n + 1 << 1,\n          child1N = child2N - 1; // This is used to store the new position of the element, if any.\n\n      var swap = null,\n          child1Score; // If the first child exists (is inside the array)...\n\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.\n\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      } // Do the same checks for the other child.\n\n\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      } // If the element needs to be moved, swap it, and continue.\n\n\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap; // Otherwise, we are done.\n      } else {\n        break;\n      }\n    }\n  }\n};\n/**\r\n * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with\r\n * any {@link Feature} in {@link FeatureCollection<Polygon>| obstacles}\r\n *\r\n * @name shortestPath\r\n * @param {Coord} start point\r\n * @param {Coord} end point\r\n * @param {Object} [options={}] optional parameters\r\n * @param {Geometry|Feature|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel\r\n * @param {number} [options.minDistance] minimum distance between shortest path and obstacles\r\n * @param {string} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...\r\n * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated\r\n * @returns {Feature<LineString>} shortest path between start and end\r\n * @example\r\n * var start = [-5, -6];\r\n * var end = [9, -6];\r\n * var options = {\r\n *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]])\r\n * };\r\n *\r\n * var path = turf.shortestPath(start, end, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [start, end, options.obstacles, path];\r\n */\n\nfunction shortestPath(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var resolution = options.resolution;\n  var minDistance = options.minDistance;\n  var obstacles = options.obstacles || featureCollection([]); // validation\n\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if (resolution && !isNumber(resolution) || resolution <= 0) throw new Error(\"options.resolution must be a number, greater than 0\");\n  if (minDistance) throw new Error(\"options.minDistance is not yet implemented\"); // Normalize Inputs\n\n  var startCoord = getCoord(start);\n  var endCoord = getCoord(end);\n  start = point(startCoord);\n  end = point(endCoord); // Handle obstacles\n\n  switch (getType(obstacles)) {\n    case \"FeatureCollection\":\n      if (obstacles.features.length === 0) return lineString([startCoord, endCoord]);\n      break;\n\n    case \"Polygon\":\n      obstacles = featureCollection([feature(getGeom(obstacles))]);\n      break;\n\n    default:\n      throw new Error(\"invalid obstacles\");\n  } // define path grid area\n\n\n  var collection = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  var box = bbox(scale(bboxPolygon(bbox(collection)), 1.15)); // extend 15%\n\n  if (!resolution) {\n    var width = distance([box[0], box[1]], [box[2], box[1]], options);\n    resolution = width / 100;\n  }\n\n  collection.features.pop();\n  collection.features.pop();\n  var west = box[0];\n  var south = box[1];\n  var east = box[2];\n  var north = box[3];\n  var xFraction = resolution / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = resolution / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n  var bboxHorizontalSide = east - west;\n  var bboxVerticalSide = north - south;\n  var columns = Math.floor(bboxHorizontalSide / cellWidth);\n  var rows = Math.floor(bboxVerticalSide / cellHeight); // adjust origin of the grid\n\n  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\n  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2; // loop through points only once to speed up process\n  // define matrix grid for A-star algorithm\n\n  var pointMatrix = [];\n  var matrix = [];\n  var closestToStart = [];\n  var closestToEnd = [];\n  var minDistStart = Infinity;\n  var minDistEnd = Infinity;\n  var currentY = north - deltaY;\n  var r = 0;\n\n  while (currentY >= south) {\n    // var currentY = south + deltaY;\n    var matrixRow = [];\n    var pointMatrixRow = [];\n    var currentX = west + deltaX;\n    var c = 0;\n\n    while (currentX <= east) {\n      var pt = point([currentX, currentY]);\n      var isInsideObstacle = isInside(pt, obstacles); // feed obstacles matrix\n\n      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar\n      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea\n      // map point's coords\n\n      pointMatrixRow.push(currentX + \"|\" + currentY); // set closest points\n\n      var distStart = distance(pt, start); // if (distStart < minDistStart) {\n\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = {\n          x: c,\n          y: r\n        };\n      }\n\n      var distEnd = distance(pt, end); // if (distEnd < minDistEnd) {\n\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = {\n          x: c,\n          y: r\n        };\n      }\n\n      currentX += cellWidth;\n      c++;\n    }\n\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  } // find path on matrix grid\n  // javascript-astar ----------------------\n\n\n  var graph = new Graph(matrix, {\n    diagonal: true\n  });\n  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];\n  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];\n  var result = astar.search(graph, startOnMatrix, endOnMatrix);\n  var path = [startCoord];\n  result.forEach(function (coord) {\n    var coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  });\n  path.push(endCoord); // ---------------------------------------\n  // astar-andrea ------------------------\n  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');\n  // var path = [start.geometry.coordinates];\n  // result.forEach(function (coord) {\n  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');\n  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  // });\n  // path.push(end.geometry.coordinates);\n  // ---------------------------------------\n\n  return cleanCoords(lineString(path));\n}\n/**\r\n * Checks if Point is inside any of the Polygons\r\n *\r\n * @private\r\n * @param {Feature<Point>} pt to check\r\n * @param {FeatureCollection<Polygon>} polygons features\r\n * @returns {boolean} if inside or not\r\n */\n\n\nfunction isInside(pt, polygons) {\n  for (var i = 0; i < polygons.features.length; i++) {\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport default shortestPath;","map":{"version":3,"names":["bbox","booleanPointInPolygon","distance","scale","cleanCoords","bboxPolygon","getCoord","getType","getGeom","isObject","featureCollection","isNumber","point","feature","lineString","pathTo","node","curr","path","parent","unshift","getHeap","BinaryHeap","f","astar","search","graph","start","end","options","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","closestNode","h","push","size","currentNode","pop","closed","neighbors","i","il","length","neighbor","isWall","gScore","g","getCost","beenVisited","visited","markDirty","rescoreElement","pos0","pos1","d1","Math","abs","x","d2","y","diagonal","D","D2","sqrt","min","cleanNode","Graph","gridIn","nodes","grid","row","GridNode","init","prototype","dirtyNodes","ret","toString","graphString","rowDebug","l","len","weight","join","fromNeighbor","scoreFunction","content","element","sinkDown","result","bubbleUp","remove","indexOf","n","parentN","elemScore","child2N","child1N","swap","child1Score","child1","child2","child2Score","shortestPath","Error","resolution","minDistance","obstacles","startCoord","endCoord","features","collection","box","width","west","south","east","north","xFraction","cellWidth","yFraction","cellHeight","bboxHorizontalSide","bboxVerticalSide","columns","floor","rows","deltaX","deltaY","pointMatrix","matrix","closestToStart","closestToEnd","minDistStart","Infinity","minDistEnd","currentY","r","matrixRow","pointMatrixRow","currentX","c","pt","isInsideObstacle","isInside","distStart","distEnd","startOnMatrix","endOnMatrix","forEach","coord","coords","split","polygons"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/shortest-path/dist/es/index.js"],"sourcesContent":["import bbox from '@turf/bbox';\r\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\r\nimport distance from '@turf/distance';\r\nimport scale from '@turf/transform-scale';\r\nimport cleanCoords from '@turf/clean-coords';\r\nimport bboxPolygon from '@turf/bbox-polygon';\r\nimport { getCoord, getType, getGeom } from '@turf/invariant';\r\nimport { isObject, featureCollection, isNumber, point, feature, lineString } from '@turf/helpers';\r\n\r\n// javascript-astar 0.4.1\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n\r\nfunction pathTo(node) {\r\n  var curr = node,\r\n    path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function (node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\n/**\r\n * Astar\r\n * @private\r\n */\r\nvar astar = {\r\n  /**\r\n   * Perform an A* Search on a graph given a start and end node.\r\n   *\r\n   * @private\r\n   * @memberof astar\r\n   * @param {Graph} graph Graph\r\n   * @param {GridNode} start Start\r\n   * @param {GridNode} end End\r\n   * @param {Object} [options] Options\r\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\r\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\r\n   * @returns {Object} Search\r\n   */\r\n  search: function (graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\r\n      closest = options.closest || false;\r\n\r\n    var openHeap = getHeap(),\r\n      closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\r\n          beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (\r\n              neighbor.h < closestNode.h ||\r\n              (neighbor.h === closestNode.h && neighbor.g < closestNode.g)\r\n            ) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function (pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function (pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\r\n    },\r\n  },\r\n  cleanNode: function (node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  },\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n *\r\n * @private\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options] Options\r\n * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\r\n * @returns {void} Graph\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function () {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function () {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function (node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function (node) {\r\n  var ret = [],\r\n    x = node.x,\r\n    y = node.y,\r\n    grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function () {\r\n  var graphString = [],\r\n    nodes = this.grid, // when using grid\r\n    rowDebug,\r\n    row,\r\n    y,\r\n    l;\r\n  for (var x = 0, len = nodes.length; x < len; x++) {\r\n    rowDebug = [];\r\n    row = nodes[x];\r\n    for (y = 0, l = row.length; y < l; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function () {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function (fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function () {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function (element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function () {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function (node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function () {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function (node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function (n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1,\r\n        parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n        // Found a parent that is less, no need to sink any further.\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function (n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length,\r\n      element = this.content[n],\r\n      elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1,\r\n        child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null,\r\n        child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N],\r\n          child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n        // Otherwise, we are done.\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with\r\n * any {@link Feature} in {@link FeatureCollection<Polygon>| obstacles}\r\n *\r\n * @name shortestPath\r\n * @param {Coord} start point\r\n * @param {Coord} end point\r\n * @param {Object} [options={}] optional parameters\r\n * @param {Geometry|Feature|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel\r\n * @param {number} [options.minDistance] minimum distance between shortest path and obstacles\r\n * @param {string} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...\r\n * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated\r\n * @returns {Feature<LineString>} shortest path between start and end\r\n * @example\r\n * var start = [-5, -6];\r\n * var end = [9, -6];\r\n * var options = {\r\n *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]])\r\n * };\r\n *\r\n * var path = turf.shortestPath(start, end, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [start, end, options.obstacles, path];\r\n */\r\nfunction shortestPath(start, end, options) {\r\n  // Optional parameters\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var resolution = options.resolution;\r\n  var minDistance = options.minDistance;\r\n  var obstacles = options.obstacles || featureCollection([]);\r\n\r\n  // validation\r\n  if (!start) throw new Error(\"start is required\");\r\n  if (!end) throw new Error(\"end is required\");\r\n  if ((resolution && !isNumber(resolution)) || resolution <= 0)\r\n    throw new Error(\"options.resolution must be a number, greater than 0\");\r\n  if (minDistance)\r\n    throw new Error(\"options.minDistance is not yet implemented\");\r\n\r\n  // Normalize Inputs\r\n  var startCoord = getCoord(start);\r\n  var endCoord = getCoord(end);\r\n  start = point(startCoord);\r\n  end = point(endCoord);\r\n\r\n  // Handle obstacles\r\n  switch (getType(obstacles)) {\r\n    case \"FeatureCollection\":\r\n      if (obstacles.features.length === 0)\r\n        return lineString([startCoord, endCoord]);\r\n      break;\r\n    case \"Polygon\":\r\n      obstacles = featureCollection([feature(getGeom(obstacles))]);\r\n      break;\r\n    default:\r\n      throw new Error(\"invalid obstacles\");\r\n  }\r\n\r\n  // define path grid area\r\n  var collection = obstacles;\r\n  collection.features.push(start);\r\n  collection.features.push(end);\r\n  var box = bbox(scale(bboxPolygon(bbox(collection)), 1.15)); // extend 15%\r\n  if (!resolution) {\r\n    var width = distance([box[0], box[1]], [box[2], box[1]], options);\r\n    resolution = width / 100;\r\n  }\r\n  collection.features.pop();\r\n  collection.features.pop();\r\n\r\n  var west = box[0];\r\n  var south = box[1];\r\n  var east = box[2];\r\n  var north = box[3];\r\n\r\n  var xFraction = resolution / distance([west, south], [east, south], options);\r\n  var cellWidth = xFraction * (east - west);\r\n  var yFraction = resolution / distance([west, south], [west, north], options);\r\n  var cellHeight = yFraction * (north - south);\r\n\r\n  var bboxHorizontalSide = east - west;\r\n  var bboxVerticalSide = north - south;\r\n  var columns = Math.floor(bboxHorizontalSide / cellWidth);\r\n  var rows = Math.floor(bboxVerticalSide / cellHeight);\r\n  // adjust origin of the grid\r\n  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\r\n  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;\r\n\r\n  // loop through points only once to speed up process\r\n  // define matrix grid for A-star algorithm\r\n  var pointMatrix = [];\r\n  var matrix = [];\r\n\r\n  var closestToStart = [];\r\n  var closestToEnd = [];\r\n  var minDistStart = Infinity;\r\n  var minDistEnd = Infinity;\r\n  var currentY = north - deltaY;\r\n  var r = 0;\r\n  while (currentY >= south) {\r\n    // var currentY = south + deltaY;\r\n    var matrixRow = [];\r\n    var pointMatrixRow = [];\r\n    var currentX = west + deltaX;\r\n    var c = 0;\r\n    while (currentX <= east) {\r\n      var pt = point([currentX, currentY]);\r\n      var isInsideObstacle = isInside(pt, obstacles);\r\n      // feed obstacles matrix\r\n      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar\r\n      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea\r\n      // map point's coords\r\n      pointMatrixRow.push(currentX + \"|\" + currentY);\r\n      // set closest points\r\n      var distStart = distance(pt, start);\r\n      // if (distStart < minDistStart) {\r\n      if (!isInsideObstacle && distStart < minDistStart) {\r\n        minDistStart = distStart;\r\n        closestToStart = { x: c, y: r };\r\n      }\r\n      var distEnd = distance(pt, end);\r\n      // if (distEnd < minDistEnd) {\r\n      if (!isInsideObstacle && distEnd < minDistEnd) {\r\n        minDistEnd = distEnd;\r\n        closestToEnd = { x: c, y: r };\r\n      }\r\n      currentX += cellWidth;\r\n      c++;\r\n    }\r\n    matrix.push(matrixRow);\r\n    pointMatrix.push(pointMatrixRow);\r\n    currentY -= cellHeight;\r\n    r++;\r\n  }\r\n\r\n  // find path on matrix grid\r\n\r\n  // javascript-astar ----------------------\r\n  var graph = new Graph(matrix, { diagonal: true });\r\n  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];\r\n  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];\r\n  var result = astar.search(graph, startOnMatrix, endOnMatrix);\r\n\r\n  var path = [startCoord];\r\n  result.forEach(function (coord) {\r\n    var coords = pointMatrix[coord.x][coord.y].split(\"|\");\r\n    path.push([+coords[0], +coords[1]]); // make sure coords are numbers\r\n  });\r\n  path.push(endCoord);\r\n  // ---------------------------------------\r\n\r\n  // astar-andrea ------------------------\r\n  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');\r\n  // var path = [start.geometry.coordinates];\r\n  // result.forEach(function (coord) {\r\n  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');\r\n  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers\r\n  // });\r\n  // path.push(end.geometry.coordinates);\r\n  // ---------------------------------------\r\n\r\n  return cleanCoords(lineString(path));\r\n}\r\n\r\n/**\r\n * Checks if Point is inside any of the Polygons\r\n *\r\n * @private\r\n * @param {Feature<Point>} pt to check\r\n * @param {FeatureCollection<Polygon>} polygons features\r\n * @returns {boolean} if inside or not\r\n */\r\nfunction isInside(pt, polygons) {\r\n  for (var i = 0; i < polygons.features.length; i++) {\r\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default shortestPath;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}