{"ast":null,"code":"import { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport pointToLineDistance from \"@turf/point-to-line-distance\";\nimport objectAssign from \"object-assign\";\n/**\n * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,\n * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.\n *\n * @name nearestPointToLine\n * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection\n * @param {Feature|Geometry<LineString>} line Line Feature\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units='kilometers'] unit of the output distance property\n * (eg: degrees, radians, miles, or kilometers)\n * @param {Object} [options.properties={}] Translate Properties to Point\n * @returns {Feature<Point>} the closest point\n * @example\n * var pt1 = turf.point([0, 0]);\n * var pt2 = turf.point([0.5, 0.5]);\n * var points = turf.featureCollection([pt1, pt2]);\n * var line = turf.lineString([[1,1], [-1,1]]);\n *\n * var nearest = turf.nearestPointToLine(points, line);\n *\n * //addToMap\n * var addToMap = [nearest, line];\n */\n\nfunction nearestPointToLine(points, line, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var units = options.units;\n  var properties = options.properties || {}; // validation\n\n  var pts = normalize(points);\n\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n\n  var dist = Infinity;\n  var pt = null;\n  featureEach(pts, function (point) {\n    var d = pointToLineDistance(point, line, {\n      units: units\n    });\n\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  /**\n   * Translate Properties to final Point, priorities:\n   * 1. options.properties\n   * 2. inherent Point properties\n   * 3. dist custom properties created by NearestPointToLine\n   */\n\n  if (pt) {\n    pt.properties = objectAssign({\n      dist: dist\n    }, pt.properties, properties);\n  } // if (pt) { pt.properties = objectAssign({dist}, pt.properties, properties); }\n\n\n  return pt;\n}\n/**\n * Convert Collection to FeatureCollection\n *\n * @private\n * @param {FeatureCollection|GeometryCollection} points Points\n * @returns {FeatureCollection<Point>} points\n */\n\n\nfunction normalize(points) {\n  var features = [];\n  var type = points.geometry ? points.geometry.type : points.type;\n\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, function (geom) {\n        if (geom.type === \"Point\") {\n          features.push({\n            type: \"Feature\",\n            properties: {},\n            geometry: geom\n          });\n        }\n      });\n      return {\n        type: \"FeatureCollection\",\n        features: features\n      };\n\n    case \"FeatureCollection\":\n      points.features = points.features.filter(function (feature) {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\n\nexport default nearestPointToLine;","map":{"version":3,"names":["getType","featureEach","geomEach","pointToLineDistance","objectAssign","nearestPointToLine","points","line","options","units","properties","pts","normalize","features","length","Error","dist","Infinity","pt","point","d","type","geometry","geom","push","filter","feature"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/nearest-point-to-line/dist/es/index.js"],"sourcesContent":["import { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport pointToLineDistance from \"@turf/point-to-line-distance\";\nimport objectAssign from \"object-assign\";\n/**\n * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,\n * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.\n *\n * @name nearestPointToLine\n * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection\n * @param {Feature|Geometry<LineString>} line Line Feature\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units='kilometers'] unit of the output distance property\n * (eg: degrees, radians, miles, or kilometers)\n * @param {Object} [options.properties={}] Translate Properties to Point\n * @returns {Feature<Point>} the closest point\n * @example\n * var pt1 = turf.point([0, 0]);\n * var pt2 = turf.point([0.5, 0.5]);\n * var points = turf.featureCollection([pt1, pt2]);\n * var line = turf.lineString([[1,1], [-1,1]]);\n *\n * var nearest = turf.nearestPointToLine(points, line);\n *\n * //addToMap\n * var addToMap = [nearest, line];\n */\nfunction nearestPointToLine(points, line, options) {\n    if (options === void 0) { options = {}; }\n    var units = options.units;\n    var properties = options.properties || {};\n    // validation\n    var pts = normalize(points);\n    if (!pts.features.length) {\n        throw new Error(\"points must contain features\");\n    }\n    if (!line) {\n        throw new Error(\"line is required\");\n    }\n    if (getType(line) !== \"LineString\") {\n        throw new Error(\"line must be a LineString\");\n    }\n    var dist = Infinity;\n    var pt = null;\n    featureEach(pts, function (point) {\n        var d = pointToLineDistance(point, line, { units: units });\n        if (d < dist) {\n            dist = d;\n            pt = point;\n        }\n    });\n    /**\n     * Translate Properties to final Point, priorities:\n     * 1. options.properties\n     * 2. inherent Point properties\n     * 3. dist custom properties created by NearestPointToLine\n     */\n    if (pt) {\n        pt.properties = objectAssign({ dist: dist }, pt.properties, properties);\n    }\n    // if (pt) { pt.properties = objectAssign({dist}, pt.properties, properties); }\n    return pt;\n}\n/**\n * Convert Collection to FeatureCollection\n *\n * @private\n * @param {FeatureCollection|GeometryCollection} points Points\n * @returns {FeatureCollection<Point>} points\n */\nfunction normalize(points) {\n    var features = [];\n    var type = points.geometry ? points.geometry.type : points.type;\n    switch (type) {\n        case \"GeometryCollection\":\n            geomEach(points, function (geom) {\n                if (geom.type === \"Point\") {\n                    features.push({ type: \"Feature\", properties: {}, geometry: geom });\n                }\n            });\n            return { type: \"FeatureCollection\", features: features };\n        case \"FeatureCollection\":\n            points.features = points.features.filter(function (feature) {\n                return feature.geometry.type === \"Point\";\n            });\n            return points;\n        default:\n            throw new Error(\"points must be a Point Collection\");\n    }\n}\nexport default nearestPointToLine;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}