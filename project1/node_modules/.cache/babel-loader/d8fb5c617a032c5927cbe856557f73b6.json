{"ast":null,"code":"import clone from '@turf/clone';\nimport center from '@turf/center';\nimport centroid from '@turf/centroid';\nimport turfBBox from '@turf/bbox';\nimport rhumbBearing from '@turf/rhumb-bearing';\nimport rhumbDistance from '@turf/rhumb-distance';\nimport rhumbDestination from '@turf/rhumb-destination';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { isObject, point } from '@turf/helpers';\nimport { getType, getCoords, getCoord } from '@turf/invariant';\n/**\r\n * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).\r\n * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.\r\n *\r\n * @name transformScale\r\n * @param {GeoJSON} geojson GeoJSON to be scaled\r\n * @param {number} factor of scaling, positive or negative values greater than 0\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\r\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\r\n * @returns {GeoJSON} scaled GeoJSON\r\n * @example\r\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\r\n * var scaledPoly = turf.transformScale(poly, 3);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly, scaledPoly];\r\n * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};\r\n */\n\nfunction transformScale(geojson, factor, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var origin = options.origin;\n  var mutate = options.mutate; // Input validation\n\n  if (!geojson) throw new Error(\"geojson required\");\n  if (typeof factor !== \"number\" || factor === 0) throw new Error(\"invalid factor\");\n  var originIsPoint = Array.isArray(origin) || typeof origin === \"object\"; // Clone geojson to avoid side effects\n\n  if (mutate !== true) geojson = clone(geojson); // Scale each Feature separately\n\n  if (geojson.type === \"FeatureCollection\" && !originIsPoint) {\n    featureEach(geojson, function (feature, index) {\n      geojson.features[index] = scale(feature, factor, origin);\n    });\n    return geojson;\n  } // Scale Feature/Geometry\n\n\n  return scale(geojson, factor, origin);\n}\n/**\r\n * Scale Feature/Geometry\r\n *\r\n * @private\r\n * @param {Feature|Geometry} feature GeoJSON Feature/Geometry\r\n * @param {number} factor of scaling, positive or negative values greater than 0\r\n * @param {string|Coord} [origin=\"centroid\"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\r\n * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry\r\n */\n\n\nfunction scale(feature, factor, origin) {\n  // Default params\n  var isPoint = getType(feature) === \"Point\";\n  origin = defineOrigin(feature, origin); // Shortcut no-scaling\n\n  if (factor === 1 || isPoint) return feature; // Scale each coordinate\n\n  coordEach(feature, function (coord) {\n    var originalDistance = rhumbDistance(origin, coord);\n    var bearing = rhumbBearing(origin, coord);\n    var newDistance = originalDistance * factor;\n    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));\n    coord[0] = newCoord[0];\n    coord[1] = newCoord[1];\n    if (coord.length === 3) coord[2] *= factor;\n  });\n  return feature;\n}\n/**\r\n * Define Origin\r\n *\r\n * @private\r\n * @param {GeoJSON} geojson GeoJSON\r\n * @param {string|Coord} origin sw/se/nw/ne/center/centroid\r\n * @returns {Feature<Point>} Point origin\r\n */\n\n\nfunction defineOrigin(geojson, origin) {\n  // Default params\n  if (origin === undefined || origin === null) origin = \"centroid\"; // Input Coord\n\n  if (Array.isArray(origin) || typeof origin === \"object\") return getCoord(origin); // Define BBox\n\n  var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson);\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  switch (origin) {\n    case \"sw\":\n    case \"southwest\":\n    case \"westsouth\":\n    case \"bottomleft\":\n      return point([west, south]);\n\n    case \"se\":\n    case \"southeast\":\n    case \"eastsouth\":\n    case \"bottomright\":\n      return point([east, south]);\n\n    case \"nw\":\n    case \"northwest\":\n    case \"westnorth\":\n    case \"topleft\":\n      return point([west, north]);\n\n    case \"ne\":\n    case \"northeast\":\n    case \"eastnorth\":\n    case \"topright\":\n      return point([east, north]);\n\n    case \"center\":\n      return center(geojson);\n\n    case undefined:\n    case null:\n    case \"centroid\":\n      return centroid(geojson);\n\n    default:\n      throw new Error(\"invalid origin\");\n  }\n}\n\nexport default transformScale;","map":{"version":3,"names":["clone","center","centroid","turfBBox","rhumbBearing","rhumbDistance","rhumbDestination","featureEach","coordEach","isObject","point","getType","getCoords","getCoord","transformScale","geojson","factor","options","Error","origin","mutate","originIsPoint","Array","isArray","type","feature","index","features","scale","isPoint","defineOrigin","coord","originalDistance","bearing","newDistance","newCoord","length","undefined","bbox","west","south","east","north"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/transform-scale/dist/es/index.js"],"sourcesContent":["import clone from '@turf/clone';\r\nimport center from '@turf/center';\r\nimport centroid from '@turf/centroid';\r\nimport turfBBox from '@turf/bbox';\r\nimport rhumbBearing from '@turf/rhumb-bearing';\r\nimport rhumbDistance from '@turf/rhumb-distance';\r\nimport rhumbDestination from '@turf/rhumb-destination';\r\nimport { featureEach, coordEach } from '@turf/meta';\r\nimport { isObject, point } from '@turf/helpers';\r\nimport { getType, getCoords, getCoord } from '@turf/invariant';\r\n\r\n/**\r\n * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).\r\n * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.\r\n *\r\n * @name transformScale\r\n * @param {GeoJSON} geojson GeoJSON to be scaled\r\n * @param {number} factor of scaling, positive or negative values greater than 0\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\r\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\r\n * @returns {GeoJSON} scaled GeoJSON\r\n * @example\r\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\r\n * var scaledPoly = turf.transformScale(poly, 3);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly, scaledPoly];\r\n * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};\r\n */\r\nfunction transformScale(geojson, factor, options) {\r\n  // Optional parameters\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var origin = options.origin;\r\n  var mutate = options.mutate;\r\n\r\n  // Input validation\r\n  if (!geojson) throw new Error(\"geojson required\");\r\n  if (typeof factor !== \"number\" || factor === 0)\r\n    throw new Error(\"invalid factor\");\r\n  var originIsPoint = Array.isArray(origin) || typeof origin === \"object\";\r\n\r\n  // Clone geojson to avoid side effects\r\n  if (mutate !== true) geojson = clone(geojson);\r\n\r\n  // Scale each Feature separately\r\n  if (geojson.type === \"FeatureCollection\" && !originIsPoint) {\r\n    featureEach(geojson, function (feature, index) {\r\n      geojson.features[index] = scale(feature, factor, origin);\r\n    });\r\n    return geojson;\r\n  }\r\n  // Scale Feature/Geometry\r\n  return scale(geojson, factor, origin);\r\n}\r\n\r\n/**\r\n * Scale Feature/Geometry\r\n *\r\n * @private\r\n * @param {Feature|Geometry} feature GeoJSON Feature/Geometry\r\n * @param {number} factor of scaling, positive or negative values greater than 0\r\n * @param {string|Coord} [origin=\"centroid\"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\r\n * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry\r\n */\r\nfunction scale(feature, factor, origin) {\r\n  // Default params\r\n  var isPoint = getType(feature) === \"Point\";\r\n  origin = defineOrigin(feature, origin);\r\n\r\n  // Shortcut no-scaling\r\n  if (factor === 1 || isPoint) return feature;\r\n\r\n  // Scale each coordinate\r\n  coordEach(feature, function (coord) {\r\n    var originalDistance = rhumbDistance(origin, coord);\r\n    var bearing = rhumbBearing(origin, coord);\r\n    var newDistance = originalDistance * factor;\r\n    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));\r\n    coord[0] = newCoord[0];\r\n    coord[1] = newCoord[1];\r\n    if (coord.length === 3) coord[2] *= factor;\r\n  });\r\n\r\n  return feature;\r\n}\r\n\r\n/**\r\n * Define Origin\r\n *\r\n * @private\r\n * @param {GeoJSON} geojson GeoJSON\r\n * @param {string|Coord} origin sw/se/nw/ne/center/centroid\r\n * @returns {Feature<Point>} Point origin\r\n */\r\nfunction defineOrigin(geojson, origin) {\r\n  // Default params\r\n  if (origin === undefined || origin === null) origin = \"centroid\";\r\n\r\n  // Input Coord\r\n  if (Array.isArray(origin) || typeof origin === \"object\")\r\n    return getCoord(origin);\r\n\r\n  // Define BBox\r\n  var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson);\r\n  var west = bbox[0];\r\n  var south = bbox[1];\r\n  var east = bbox[2];\r\n  var north = bbox[3];\r\n\r\n  switch (origin) {\r\n    case \"sw\":\r\n    case \"southwest\":\r\n    case \"westsouth\":\r\n    case \"bottomleft\":\r\n      return point([west, south]);\r\n    case \"se\":\r\n    case \"southeast\":\r\n    case \"eastsouth\":\r\n    case \"bottomright\":\r\n      return point([east, south]);\r\n    case \"nw\":\r\n    case \"northwest\":\r\n    case \"westnorth\":\r\n    case \"topleft\":\r\n      return point([west, north]);\r\n    case \"ne\":\r\n    case \"northeast\":\r\n    case \"eastnorth\":\r\n    case \"topright\":\r\n      return point([east, north]);\r\n    case \"center\":\r\n      return center(geojson);\r\n    case undefined:\r\n    case null:\r\n    case \"centroid\":\r\n      return centroid(geojson);\r\n    default:\r\n      throw new Error(\"invalid origin\");\r\n  }\r\n}\r\n\r\nexport default transformScale;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}