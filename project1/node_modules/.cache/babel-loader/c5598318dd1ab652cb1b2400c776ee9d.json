{"ast":null,"code":"import { coordAll, featureEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, isNumber, featureCollection } from '@turf/helpers';\nimport centerMean from '@turf/center-mean';\nimport pointsWithinPolygon from '@turf/points-within-polygon';\nimport ellipse from '@turf/ellipse';\n/**\r\n * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,\r\n * also known as a “directional distribution.” The standard deviational ellipse\r\n * aims to show the direction and the distribution of a dataset by drawing\r\n * an ellipse that contains about one standard deviation’s worth (~ 70%) of the\r\n * data.\r\n *\r\n * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)\r\n * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)\r\n *\r\n * **Bibliography**\r\n *\r\n * • Robert S. Yuill, “The Standard Deviational Ellipse; An Updated Tool for\r\n * Spatial Description,” _Geografiska Annaler_ 53, no. 1 (1971): 28–39,\r\n * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.\r\n *\r\n * • Paul Hanly Furfey, “A Note on Lefever’s “Standard Deviational Ellipse,”\r\n * _American Journal of Sociology_ 33, no. 1 (1927): 94—98,\r\n * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.\r\n *\r\n *\r\n * @name standardDeviationalEllipse\r\n * @param {FeatureCollection<Point>} points GeoJSON points\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.weight] the property name used to weight the center\r\n * @param {number} [options.steps=64] number of steps for the polygon\r\n * @param {Object} [options.properties={}] properties to pass to the resulting ellipse\r\n * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.\r\n * @example\r\n *\r\n * var bbox = [-74, 40.72, -73.98, 40.74];\r\n * var points = turf.randomPoint(400, {bbox: bbox});\r\n * var sdEllipse = turf.standardDeviationalEllipse(points);\r\n *\r\n * //addToMap\r\n * var addToMap = [points, sdEllipse];\r\n *\r\n */\n\nfunction standardDeviationalEllipse(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var steps = options.steps || 64;\n  var weightTerm = options.weight;\n  var properties = options.properties || {}; // Validation:\n\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isObject(properties)) throw new Error(\"properties must be a number\"); // Calculate mean center & number of features:\n\n  var numberOfFeatures = coordAll(points).length;\n  var meanCenter = centerMean(points, {\n    weight: weightTerm\n  }); // Calculate angle of rotation:\n  // [X, Y] = mean center of all [x, y].\n  // theta = arctan( (A + B) / C )\n  // A = sum((x - X)^2) - sum((y - Y)^2)\n  // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))\n  // C = 2(sum((x - X)(y - Y)))\n\n  var xDeviationSquaredSum = 0;\n  var yDeviationSquaredSum = 0;\n  var xyDeviationSum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\n    xyDeviationSum += deviation.x * deviation.y * weight;\n  });\n  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;\n  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\n  var bigC = 2 * xyDeviationSum;\n  var theta = Math.atan((bigA + bigB) / bigC);\n  var thetaDeg = theta * 180 / Math.PI; // Calculate axes:\n  // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))\n  // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))\n\n  var sigmaXsum = 0;\n  var sigmaYsum = 0;\n  var weightsum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    sigmaXsum += Math.pow(deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta), 2) * weight;\n    sigmaYsum += Math.pow(deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta), 2) * weight;\n    weightsum += weight;\n  });\n  var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);\n  var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);\n  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\n    units: \"degrees\",\n    angle: thetaDeg,\n    steps: steps,\n    properties: properties\n  });\n  var pointsWithinEllipse = pointsWithinPolygon(points, featureCollection([theEllipse]));\n  var standardDeviationalEllipseProperties = {\n    meanCenterCoordinates: getCoords(meanCenter),\n    semiMajorAxis: sigmaX,\n    semiMinorAxis: sigmaY,\n    numberOfFeatures: numberOfFeatures,\n    angle: thetaDeg,\n    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures\n  };\n  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;\n  return theEllipse;\n}\n/**\r\n * Get x_i - X and y_i - Y\r\n *\r\n * @private\r\n * @param {Array} coordinates Array of [x_i, y_i]\r\n * @param {Array} center Array of [X, Y]\r\n * @returns {Object} { x: n, y: m }\r\n */\n\n\nfunction getDeviations(coordinates, center) {\n  return {\n    x: coordinates[0] - center[0],\n    y: coordinates[1] - center[1]\n  };\n}\n\nexport default standardDeviationalEllipse;","map":{"version":3,"names":["coordAll","featureEach","getCoords","isObject","isNumber","featureCollection","centerMean","pointsWithinPolygon","ellipse","standardDeviationalEllipse","points","options","Error","steps","weightTerm","weight","properties","numberOfFeatures","length","meanCenter","xDeviationSquaredSum","yDeviationSquaredSum","xyDeviationSum","point","deviation","getDeviations","Math","pow","x","y","bigA","bigB","sqrt","bigC","theta","atan","thetaDeg","PI","sigmaXsum","sigmaYsum","weightsum","cos","sin","sigmaX","sigmaY","theEllipse","units","angle","pointsWithinEllipse","standardDeviationalEllipseProperties","meanCenterCoordinates","semiMajorAxis","semiMinorAxis","percentageWithinEllipse","coordinates","center"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/standard-deviational-ellipse/dist/es/index.js"],"sourcesContent":["import { coordAll, featureEach } from '@turf/meta';\r\nimport { getCoords } from '@turf/invariant';\r\nimport { isObject, isNumber, featureCollection } from '@turf/helpers';\r\nimport centerMean from '@turf/center-mean';\r\nimport pointsWithinPolygon from '@turf/points-within-polygon';\r\nimport ellipse from '@turf/ellipse';\r\n\r\n/**\r\n * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,\r\n * also known as a “directional distribution.” The standard deviational ellipse\r\n * aims to show the direction and the distribution of a dataset by drawing\r\n * an ellipse that contains about one standard deviation’s worth (~ 70%) of the\r\n * data.\r\n *\r\n * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)\r\n * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)\r\n *\r\n * **Bibliography**\r\n *\r\n * • Robert S. Yuill, “The Standard Deviational Ellipse; An Updated Tool for\r\n * Spatial Description,” _Geografiska Annaler_ 53, no. 1 (1971): 28–39,\r\n * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.\r\n *\r\n * • Paul Hanly Furfey, “A Note on Lefever’s “Standard Deviational Ellipse,”\r\n * _American Journal of Sociology_ 33, no. 1 (1927): 94—98,\r\n * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.\r\n *\r\n *\r\n * @name standardDeviationalEllipse\r\n * @param {FeatureCollection<Point>} points GeoJSON points\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.weight] the property name used to weight the center\r\n * @param {number} [options.steps=64] number of steps for the polygon\r\n * @param {Object} [options.properties={}] properties to pass to the resulting ellipse\r\n * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.\r\n * @example\r\n *\r\n * var bbox = [-74, 40.72, -73.98, 40.74];\r\n * var points = turf.randomPoint(400, {bbox: bbox});\r\n * var sdEllipse = turf.standardDeviationalEllipse(points);\r\n *\r\n * //addToMap\r\n * var addToMap = [points, sdEllipse];\r\n *\r\n */\r\nfunction standardDeviationalEllipse(points, options) {\r\n  // Optional params\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var steps = options.steps || 64;\r\n  var weightTerm = options.weight;\r\n  var properties = options.properties || {};\r\n\r\n  // Validation:\r\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\r\n  if (!isObject(properties)) throw new Error(\"properties must be a number\");\r\n\r\n  // Calculate mean center & number of features:\r\n  var numberOfFeatures = coordAll(points).length;\r\n  var meanCenter = centerMean(points, { weight: weightTerm });\r\n\r\n  // Calculate angle of rotation:\r\n  // [X, Y] = mean center of all [x, y].\r\n  // theta = arctan( (A + B) / C )\r\n  // A = sum((x - X)^2) - sum((y - Y)^2)\r\n  // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))\r\n  // C = 2(sum((x - X)(y - Y)))\r\n\r\n  var xDeviationSquaredSum = 0;\r\n  var yDeviationSquaredSum = 0;\r\n  var xyDeviationSum = 0;\r\n\r\n  featureEach(points, function (point) {\r\n    var weight = point.properties[weightTerm] || 1;\r\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\r\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\r\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\r\n    xyDeviationSum += deviation.x * deviation.y * weight;\r\n  });\r\n\r\n  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;\r\n  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\r\n  var bigC = 2 * xyDeviationSum;\r\n  var theta = Math.atan((bigA + bigB) / bigC);\r\n  var thetaDeg = (theta * 180) / Math.PI;\r\n\r\n  // Calculate axes:\r\n  // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))\r\n  // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))\r\n  var sigmaXsum = 0;\r\n  var sigmaYsum = 0;\r\n  var weightsum = 0;\r\n  featureEach(points, function (point) {\r\n    var weight = point.properties[weightTerm] || 1;\r\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\r\n    sigmaXsum +=\r\n      Math.pow(\r\n        deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),\r\n        2\r\n      ) * weight;\r\n    sigmaYsum +=\r\n      Math.pow(\r\n        deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),\r\n        2\r\n      ) * weight;\r\n    weightsum += weight;\r\n  });\r\n\r\n  var sigmaX = Math.sqrt((2 * sigmaXsum) / weightsum);\r\n  var sigmaY = Math.sqrt((2 * sigmaYsum) / weightsum);\r\n\r\n  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\r\n    units: \"degrees\",\r\n    angle: thetaDeg,\r\n    steps: steps,\r\n    properties: properties,\r\n  });\r\n  var pointsWithinEllipse = pointsWithinPolygon(\r\n    points,\r\n    featureCollection([theEllipse])\r\n  );\r\n  var standardDeviationalEllipseProperties = {\r\n    meanCenterCoordinates: getCoords(meanCenter),\r\n    semiMajorAxis: sigmaX,\r\n    semiMinorAxis: sigmaY,\r\n    numberOfFeatures: numberOfFeatures,\r\n    angle: thetaDeg,\r\n    percentageWithinEllipse:\r\n      (100 * coordAll(pointsWithinEllipse).length) / numberOfFeatures,\r\n  };\r\n  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;\r\n\r\n  return theEllipse;\r\n}\r\n\r\n/**\r\n * Get x_i - X and y_i - Y\r\n *\r\n * @private\r\n * @param {Array} coordinates Array of [x_i, y_i]\r\n * @param {Array} center Array of [X, Y]\r\n * @returns {Object} { x: n, y: m }\r\n */\r\nfunction getDeviations(coordinates, center) {\r\n  return {\r\n    x: coordinates[0] - center[0],\r\n    y: coordinates[1] - center[1],\r\n  };\r\n}\r\n\r\nexport default standardDeviationalEllipse;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}