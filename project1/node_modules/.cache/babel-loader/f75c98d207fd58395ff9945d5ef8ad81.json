{"ast":null,"code":"/**\r\n * @requires ./PriorityQueue.js\r\n */\nif (typeof module !== 'undefined' && module.exports) {\n  var PriorityQueue = require('./PriorityQueue.js');\n}\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\n\n\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\n  /** @type {number} */\n  this.epsilon = 1;\n  /** @type {number} */\n\n  this.minPts = 1;\n  /** @type {function} */\n\n  this.distance = this._euclideanDistance; // temporary variables used during computation\n\n  /** @type {Array} */\n\n  this._reachability = [];\n  /** @type {Array} */\n\n  this._processed = [];\n  /** @type {number} */\n\n  this._coreDistance = 0;\n  /** @type {Array} */\n\n  this._orderedList = [];\n\n  this._init(dataset, epsilon, minPts, distanceFunction);\n}\n/******************************************************************************/\n// pulic functions\n\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\n\n\nOPTICS.prototype.run = function (dataset, epsilon, minPts, distanceFunction) {\n  this._init(dataset, epsilon, minPts, distanceFunction);\n\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\n    if (this._processed[pointId] !== 1) {\n      this._processed[pointId] = 1;\n      this.clusters.push([pointId]);\n      var clusterId = this.clusters.length - 1;\n\n      this._orderedList.push(pointId);\n\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\n\n      var neighbors = this._regionQuery(pointId); // using priority queue assign elements to new cluster\n\n\n      if (this._distanceToCore(pointId) !== undefined) {\n        this._updateQueue(pointId, neighbors, priorityQueue);\n\n        this._expandCluster(clusterId, priorityQueue);\n      }\n    }\n  }\n\n  return this.clusters;\n};\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\n\n\nOPTICS.prototype.getReachabilityPlot = function () {\n  var reachabilityPlot = [];\n\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\n    var pointId = this._orderedList[i];\n    var distance = this._reachability[pointId];\n    reachabilityPlot.push([pointId, distance]);\n  }\n\n  return reachabilityPlot;\n};\n/******************************************************************************/\n// protected functions\n\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._init = function (dataset, epsilon, minPts, distance) {\n  if (dataset) {\n    if (!(dataset instanceof Array)) {\n      throw Error('Dataset must be of type array, ' + typeof dataset + ' given');\n    }\n\n    this.dataset = dataset;\n    this.clusters = [];\n    this._reachability = new Array(this.dataset.length);\n    this._processed = new Array(this.dataset.length);\n    this._coreDistance = 0;\n    this._orderedList = [];\n  }\n\n  if (epsilon) {\n    this.epsilon = epsilon;\n  }\n\n  if (minPts) {\n    this.minPts = minPts;\n  }\n\n  if (distance) {\n    this.distance = distance;\n  }\n};\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._updateQueue = function (pointId, neighbors, queue) {\n  var self = this;\n  this._coreDistance = this._distanceToCore(pointId);\n  neighbors.forEach(function (pointId2) {\n    if (self._processed[pointId2] === undefined) {\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\n      var newReachableDistance = Math.max(self._coreDistance, dist);\n\n      if (self._reachability[pointId2] === undefined) {\n        self._reachability[pointId2] = newReachableDistance;\n        queue.insert(pointId2, newReachableDistance);\n      } else {\n        if (newReachableDistance < self._reachability[pointId2]) {\n          self._reachability[pointId2] = newReachableDistance;\n          queue.remove(pointId2);\n          queue.insert(pointId2, newReachableDistance);\n        }\n      }\n    }\n  });\n};\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._expandCluster = function (clusterId, queue) {\n  var queueElements = queue.getElements();\n\n  for (var p = 0, l = queueElements.length; p < l; p++) {\n    var pointId = queueElements[p];\n\n    if (this._processed[pointId] === undefined) {\n      var neighbors = this._regionQuery(pointId);\n\n      this._processed[pointId] = 1;\n      this.clusters[clusterId].push(pointId);\n\n      this._orderedList.push(pointId);\n\n      if (this._distanceToCore(pointId) !== undefined) {\n        this._updateQueue(pointId, neighbors, queue);\n\n        this._expandCluster(clusterId, queue);\n      }\n    }\n  }\n};\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._distanceToCore = function (pointId) {\n  var l = this.epsilon;\n\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\n    var neighbors = this._regionQuery(pointId, coreDistCand);\n\n    if (neighbors.length >= this.minPts) {\n      return coreDistCand;\n    }\n  }\n\n  return;\n};\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._regionQuery = function (pointId, epsilon) {\n  epsilon = epsilon || this.epsilon;\n  var neighbors = [];\n\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\n      neighbors.push(id);\n    }\n  }\n\n  return neighbors;\n};\n/******************************************************************************/\n// helpers\n\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._euclideanDistance = function (p, q) {\n  var sum = 0;\n  var i = Math.min(p.length, q.length);\n\n  while (i--) {\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n\n  return Math.sqrt(sum);\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = OPTICS;\n}","map":{"version":3,"names":["module","exports","PriorityQueue","require","OPTICS","dataset","epsilon","minPts","distanceFunction","distance","_euclideanDistance","_reachability","_processed","_coreDistance","_orderedList","_init","prototype","run","pointId","l","length","clusters","push","clusterId","priorityQueue","neighbors","_regionQuery","_distanceToCore","undefined","_updateQueue","_expandCluster","getReachabilityPlot","reachabilityPlot","i","Array","Error","queue","self","forEach","pointId2","dist","newReachableDistance","Math","max","insert","remove","queueElements","getElements","p","coreDistCand","id","q","sum","min","sqrt"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/density-clustering/lib/OPTICS.js"],"sourcesContent":["\r\n/**\r\n * @requires ./PriorityQueue.js\r\n */\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n      var PriorityQueue = require('./PriorityQueue.js');\r\n}\r\n\r\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\r\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 1;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._reachability = [];\r\n  /** @type {Array} */\r\n  this._processed = [];\r\n  /** @type {number} */\r\n  this._coreDistance = 0;\r\n  /** @type {Array} */\r\n  this._orderedList = [];\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n}\r\n\r\n/******************************************************************************/\r\n// pulic functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nOPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\r\n    if (this._processed[pointId] !== 1) {\r\n      this._processed[pointId] = 1;\r\n      this.clusters.push([pointId]);\r\n      var clusterId = this.clusters.length - 1;\r\n\r\n      this._orderedList.push(pointId);\r\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      // using priority queue assign elements to new cluster\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, priorityQueue);\r\n        this._expandCluster(clusterId, priorityQueue);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\r\nOPTICS.prototype.getReachabilityPlot = function() {\r\n  var reachabilityPlot = [];\r\n\r\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\r\n    var pointId = this._orderedList[i];\r\n    var distance = this._reachability[pointId];\r\n\r\n    reachabilityPlot.push([pointId, distance]);\r\n  }\r\n\r\n  return reachabilityPlot;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this._reachability = new Array(this.dataset.length);\r\n    this._processed = new Array(this.dataset.length);\r\n    this._coreDistance = 0;\r\n    this._orderedList = [];\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {\r\n  var self = this;\r\n\r\n  this._coreDistance = this._distanceToCore(pointId);\r\n  neighbors.forEach(function(pointId2) {\r\n    if (self._processed[pointId2] === undefined) {\r\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\r\n      var newReachableDistance = Math.max(self._coreDistance, dist);\r\n\r\n      if (self._reachability[pointId2] === undefined) {\r\n        self._reachability[pointId2] = newReachableDistance;\r\n        queue.insert(pointId2, newReachableDistance);\r\n      } else {\r\n        if (newReachableDistance < self._reachability[pointId2]) {\r\n          self._reachability[pointId2] = newReachableDistance;\r\n          queue.remove(pointId2);\r\n          queue.insert(pointId2, newReachableDistance);\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._expandCluster = function(clusterId, queue) {\r\n  var queueElements = queue.getElements();\r\n\r\n  for (var p = 0, l = queueElements.length; p < l; p++) {\r\n    var pointId = queueElements[p];\r\n    if (this._processed[pointId] === undefined) {\r\n      var neighbors = this._regionQuery(pointId);\r\n      this._processed[pointId] = 1;\r\n\r\n      this.clusters[clusterId].push(pointId);\r\n      this._orderedList.push(pointId);\r\n\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, queue);\r\n        this._expandCluster(clusterId, queue);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._distanceToCore = function(pointId) {\r\n  var l = this.epsilon;\r\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\r\n    var neighbors = this._regionQuery(pointId, coreDistCand);\r\n    if (neighbors.length >= this.minPts) {\r\n      return coreDistCand;\r\n    }\r\n  }\r\n\r\n  return;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nOPTICS.prototype._regionQuery = function(pointId, epsilon) {\r\n  epsilon = epsilon || this.epsilon;\r\n  var neighbors = [];\r\n\r\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\r\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = OPTICS;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}