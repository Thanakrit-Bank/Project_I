{"ast":null,"code":"import clone from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n/**\r\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\r\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\r\n *\r\n * @name clustersKmeans\r\n * @param {FeatureCollection<Point>} points to be clustered\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\r\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\r\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\r\n * - {number} cluster - the associated clusterId\r\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\r\n * @example\r\n * // create random points with random z-values in their properties\r\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\r\n * var options = {numberOfClusters: 7};\r\n * var clustered = turf.clustersKmeans(points, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [clustered];\r\n */\n\nfunction clustersKmeans(points, options) {\n  if (options === void 0) {\n    options = {};\n  } // Default Params\n\n\n  var count = points.features.length;\n  options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2)); // numberOfClusters can't be greater than the number of points\n  // fallbacks to count\n\n  if (options.numberOfClusters > count) options.numberOfClusters = count; // Clone points to prevent any mutations (enabled by default)\n\n  if (options.mutate !== true) points = clone(points); // collect points coordinates\n\n  var data = coordAll(points); // create seed to avoid skmeans to drift\n\n  var initialCentroids = data.slice(0, options.numberOfClusters); // create skmeans clusters\n\n  var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids); // store centroids {clusterId: [number, number]}\n\n  var centroids = {};\n  skmeansResult.centroids.forEach(function (coord, idx) {\n    centroids[idx] = coord;\n  }); // add associated cluster number\n\n  featureEach(points, function (point, index) {\n    var clusterId = skmeansResult.idxs[index];\n    point.properties.cluster = clusterId;\n    point.properties.centroid = centroids[clusterId];\n  });\n  return points;\n}\n\nexport default clustersKmeans;","map":{"version":3,"names":["clone","coordAll","featureEach","skmeans","clustersKmeans","points","options","count","features","length","numberOfClusters","Math","round","sqrt","mutate","data","initialCentroids","slice","skmeansResult","centroids","forEach","coord","idx","point","index","clusterId","idxs","properties","cluster","centroid"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/clusters-kmeans/dist/es/index.js"],"sourcesContent":["import clone from \"@turf/clone\";\r\nimport { coordAll, featureEach } from \"@turf/meta\";\r\nimport skmeans from \"skmeans\";\r\n/**\r\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\r\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\r\n *\r\n * @name clustersKmeans\r\n * @param {FeatureCollection<Point>} points to be clustered\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\r\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\r\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\r\n * - {number} cluster - the associated clusterId\r\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\r\n * @example\r\n * // create random points with random z-values in their properties\r\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\r\n * var options = {numberOfClusters: 7};\r\n * var clustered = turf.clustersKmeans(points, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [clustered];\r\n */\r\nfunction clustersKmeans(points, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Default Params\r\n    var count = points.features.length;\r\n    options.numberOfClusters =\r\n        options.numberOfClusters || Math.round(Math.sqrt(count / 2));\r\n    // numberOfClusters can't be greater than the number of points\r\n    // fallbacks to count\r\n    if (options.numberOfClusters > count)\r\n        options.numberOfClusters = count;\r\n    // Clone points to prevent any mutations (enabled by default)\r\n    if (options.mutate !== true)\r\n        points = clone(points);\r\n    // collect points coordinates\r\n    var data = coordAll(points);\r\n    // create seed to avoid skmeans to drift\r\n    var initialCentroids = data.slice(0, options.numberOfClusters);\r\n    // create skmeans clusters\r\n    var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\r\n    // store centroids {clusterId: [number, number]}\r\n    var centroids = {};\r\n    skmeansResult.centroids.forEach(function (coord, idx) {\r\n        centroids[idx] = coord;\r\n    });\r\n    // add associated cluster number\r\n    featureEach(points, function (point, index) {\r\n        var clusterId = skmeansResult.idxs[index];\r\n        point.properties.cluster = clusterId;\r\n        point.properties.centroid = centroids[clusterId];\r\n    });\r\n    return points;\r\n}\r\nexport default clustersKmeans;\r\n"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,aAAlB;AACA,SAASC,QAAT,EAAmBC,WAAnB,QAAsC,YAAtC;AACA,OAAOC,OAAP,MAAoB,SAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,MAAxB,EAAgCC,OAAhC,EAAyC;EACrC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe,CADJ,CAErC;;;EACA,IAAIC,KAAK,GAAGF,MAAM,CAACG,QAAP,CAAgBC,MAA5B;EACAH,OAAO,CAACI,gBAAR,GACIJ,OAAO,CAACI,gBAAR,IAA4BC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,IAAL,CAAUN,KAAK,GAAG,CAAlB,CAAX,CADhC,CAJqC,CAMrC;EACA;;EACA,IAAID,OAAO,CAACI,gBAAR,GAA2BH,KAA/B,EACID,OAAO,CAACI,gBAAR,GAA2BH,KAA3B,CATiC,CAUrC;;EACA,IAAID,OAAO,CAACQ,MAAR,KAAmB,IAAvB,EACIT,MAAM,GAAGL,KAAK,CAACK,MAAD,CAAd,CAZiC,CAarC;;EACA,IAAIU,IAAI,GAAGd,QAAQ,CAACI,MAAD,CAAnB,CAdqC,CAerC;;EACA,IAAIW,gBAAgB,GAAGD,IAAI,CAACE,KAAL,CAAW,CAAX,EAAcX,OAAO,CAACI,gBAAtB,CAAvB,CAhBqC,CAiBrC;;EACA,IAAIQ,aAAa,GAAGf,OAAO,CAACY,IAAD,EAAOT,OAAO,CAACI,gBAAf,EAAiCM,gBAAjC,CAA3B,CAlBqC,CAmBrC;;EACA,IAAIG,SAAS,GAAG,EAAhB;EACAD,aAAa,CAACC,SAAd,CAAwBC,OAAxB,CAAgC,UAAUC,KAAV,EAAiBC,GAAjB,EAAsB;IAClDH,SAAS,CAACG,GAAD,CAAT,GAAiBD,KAAjB;EACH,CAFD,EArBqC,CAwBrC;;EACAnB,WAAW,CAACG,MAAD,EAAS,UAAUkB,KAAV,EAAiBC,KAAjB,EAAwB;IACxC,IAAIC,SAAS,GAAGP,aAAa,CAACQ,IAAd,CAAmBF,KAAnB,CAAhB;IACAD,KAAK,CAACI,UAAN,CAAiBC,OAAjB,GAA2BH,SAA3B;IACAF,KAAK,CAACI,UAAN,CAAiBE,QAAjB,GAA4BV,SAAS,CAACM,SAAD,CAArC;EACH,CAJU,CAAX;EAKA,OAAOpB,MAAP;AACH;;AACD,eAAeD,cAAf"},"metadata":{},"sourceType":"module"}