{"ast":null,"code":"import bearing from \"@turf/bearing\";\nimport distance from \"@turf/distance\";\nimport destination from \"@turf/destination\";\nimport lineIntersects from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n/**\r\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\r\n *\r\n * @name nearestPointOnLine\r\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\r\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\r\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\r\n * @example\r\n * var line = turf.lineString([\r\n *     [-77.031669, 38.878605],\r\n *     [-77.029609, 38.881946],\r\n *     [-77.020339, 38.884084],\r\n *     [-77.025661, 38.885821],\r\n *     [-77.021884, 38.889563],\r\n *     [-77.019824, 38.892368]\r\n * ]);\r\n * var pt = turf.point([-77.037076, 38.884017]);\r\n *\r\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\r\n *\r\n * //addToMap\r\n * var addToMap = [line, pt, snapped];\r\n * snapped.properties['marker-color'] = '#00f';\r\n */\n\nfunction nearestPointOnLine(lines, pt, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var closestPt = point([Infinity, Infinity], {\n    dist: Infinity\n  });\n  var length = 0.0;\n  flattenEach(lines, function (line) {\n    var coords = getCoords(line);\n\n    for (var i = 0; i < coords.length - 1; i++) {\n      //start\n      var start = point(coords[i]);\n      start.properties.dist = distance(pt, start, options); //stop\n\n      var stop_1 = point(coords[i + 1]);\n      stop_1.properties.dist = distance(pt, stop_1, options); // sectionLength\n\n      var sectionLength = distance(start, stop_1, options); //perpendicular\n\n      var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n      var direction = bearing(start, stop_1);\n      var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n      var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n      var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n      var intersectPt = null;\n\n      if (intersect.features.length > 0) {\n        intersectPt = intersect.features[0];\n        intersectPt.properties.dist = distance(pt, intersectPt, options);\n        intersectPt.properties.location = length + distance(start, intersectPt, options);\n      }\n\n      if (start.properties.dist < closestPt.properties.dist) {\n        closestPt = start;\n        closestPt.properties.index = i;\n        closestPt.properties.location = length;\n      }\n\n      if (stop_1.properties.dist < closestPt.properties.dist) {\n        closestPt = stop_1;\n        closestPt.properties.index = i + 1;\n        closestPt.properties.location = length + sectionLength;\n      }\n\n      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = intersectPt;\n        closestPt.properties.index = i;\n      } // update length\n\n\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\n\nexport default nearestPointOnLine;","map":{"version":3,"names":["bearing","distance","destination","lineIntersects","flattenEach","point","lineString","getCoords","nearestPointOnLine","lines","pt","options","closestPt","Infinity","dist","length","line","coords","i","start","properties","stop_1","sectionLength","heightDistance","Math","max","direction","perpendicularPt1","perpendicularPt2","intersect","geometry","coordinates","intersectPt","features","location","index"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/nearest-point-on-line/dist/es/index.js"],"sourcesContent":["import bearing from \"@turf/bearing\";\r\nimport distance from \"@turf/distance\";\r\nimport destination from \"@turf/destination\";\r\nimport lineIntersects from \"@turf/line-intersect\";\r\nimport { flattenEach } from \"@turf/meta\";\r\nimport { point, lineString, } from \"@turf/helpers\";\r\nimport { getCoords } from \"@turf/invariant\";\r\n/**\r\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\r\n *\r\n * @name nearestPointOnLine\r\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\r\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\r\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\r\n * @example\r\n * var line = turf.lineString([\r\n *     [-77.031669, 38.878605],\r\n *     [-77.029609, 38.881946],\r\n *     [-77.020339, 38.884084],\r\n *     [-77.025661, 38.885821],\r\n *     [-77.021884, 38.889563],\r\n *     [-77.019824, 38.892368]\r\n * ]);\r\n * var pt = turf.point([-77.037076, 38.884017]);\r\n *\r\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\r\n *\r\n * //addToMap\r\n * var addToMap = [line, pt, snapped];\r\n * snapped.properties['marker-color'] = '#00f';\r\n */\r\nfunction nearestPointOnLine(lines, pt, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var closestPt = point([Infinity, Infinity], {\r\n        dist: Infinity,\r\n    });\r\n    var length = 0.0;\r\n    flattenEach(lines, function (line) {\r\n        var coords = getCoords(line);\r\n        for (var i = 0; i < coords.length - 1; i++) {\r\n            //start\r\n            var start = point(coords[i]);\r\n            start.properties.dist = distance(pt, start, options);\r\n            //stop\r\n            var stop_1 = point(coords[i + 1]);\r\n            stop_1.properties.dist = distance(pt, stop_1, options);\r\n            // sectionLength\r\n            var sectionLength = distance(start, stop_1, options);\r\n            //perpendicular\r\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\r\n            var direction = bearing(start, stop_1);\r\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\r\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\r\n            var intersect = lineIntersects(lineString([\r\n                perpendicularPt1.geometry.coordinates,\r\n                perpendicularPt2.geometry.coordinates,\r\n            ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\r\n            var intersectPt = null;\r\n            if (intersect.features.length > 0) {\r\n                intersectPt = intersect.features[0];\r\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\r\n                intersectPt.properties.location =\r\n                    length + distance(start, intersectPt, options);\r\n            }\r\n            if (start.properties.dist < closestPt.properties.dist) {\r\n                closestPt = start;\r\n                closestPt.properties.index = i;\r\n                closestPt.properties.location = length;\r\n            }\r\n            if (stop_1.properties.dist < closestPt.properties.dist) {\r\n                closestPt = stop_1;\r\n                closestPt.properties.index = i + 1;\r\n                closestPt.properties.location = length + sectionLength;\r\n            }\r\n            if (intersectPt &&\r\n                intersectPt.properties.dist < closestPt.properties.dist) {\r\n                closestPt = intersectPt;\r\n                closestPt.properties.index = i;\r\n            }\r\n            // update length\r\n            length += sectionLength;\r\n        }\r\n    });\r\n    return closestPt;\r\n}\r\nexport default nearestPointOnLine;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}