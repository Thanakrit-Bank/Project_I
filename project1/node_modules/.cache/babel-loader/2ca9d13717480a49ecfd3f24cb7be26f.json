{"ast":null,"code":"import { feature, lineString, isObject, point } from '@turf/helpers';\n/**\r\n * Callback for coordEach\r\n *\r\n * @callback coordEachCallback\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\n\n/**\r\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name coordEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\n\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n      k,\n      l,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      coordIndex = 0,\n      isGeometryCollection,\n      type = geojson.type,\n      isFeatureCollection = type === \"FeatureCollection\",\n      isFeature = type === \"Feature\",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry\n\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n\n        case \"Point\":\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n\n              geometryIndex++;\n            }\n\n            multiFeatureIndex++;\n          }\n\n          break;\n\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n/**\r\n * Callback for coordReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback coordReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\n\n/**\r\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\r\n *\r\n * @name coordReduce\r\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentCoord;\r\n * });\r\n */\n\n\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n/**\r\n * Callback for propEach\r\n *\r\n * @callback propEachCallback\r\n * @param {Object} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\n\n/**\r\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name propEach\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propEach(features, function (currentProperties, featureIndex) {\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n * });\r\n */\n\n\nfunction propEach(geojson, callback) {\n  var i;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n\n      break;\n\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n/**\r\n * Callback for propReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback propReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {*} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\n\n/**\r\n * Reduce properties in any GeoJSON object into a single value,\r\n * similar to how Array.reduce works. However, in this case we lazily run\r\n * the reduction, so an array of all properties is unnecessary.\r\n *\r\n * @name propReduce\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n *   return currentProperties\r\n * });\r\n */\n\n\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n/**\r\n * Callback for featureEach\r\n *\r\n * @callback featureEachCallback\r\n * @param {Feature<any>} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\n\n/**\r\n * Iterate over features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name featureEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.featureEach(features, function (currentFeature, featureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n * });\r\n */\n\n\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n/**\r\n * Callback for featureReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback featureReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\n\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name featureReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   return currentFeature\r\n * });\r\n */\n\n\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n/**\r\n * Get all coordinates from any GeoJSON object.\r\n *\r\n * @name coordAll\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @returns {Array<Array<number>>} coordinate position array\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * var coords = turf.coordAll(features);\r\n * //= [[26, 37], [36, 53]]\r\n */\n\n\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n/**\r\n * Callback for geomEach\r\n *\r\n * @callback geomEachCallback\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\n\n/**\r\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name geomEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n * });\r\n */\n\n\nfunction geomEach(geojson, callback) {\n  var i,\n      j,\n      g,\n      geometry,\n      stopG,\n      geometryMaybeCollection,\n      isGeometryCollection,\n      featureProperties,\n      featureBBox,\n      featureId,\n      featureIndex = 0,\n      isFeatureCollection = geojson.type === \"FeatureCollection\",\n      isFeature = geojson.type === \"Feature\",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry\n\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n\n        case \"GeometryCollection\":\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    } // Only increase `featureIndex` per each feature\n\n\n    featureIndex++;\n  }\n}\n/**\r\n * Callback for geomReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback geomReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\n\n/**\r\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name geomReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=previousValue\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n *   return currentGeometry\r\n * });\r\n */\n\n\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n/**\r\n * Callback for flattenEach\r\n *\r\n * @callback flattenEachCallback\r\n * @param {Feature} currentFeature The current flattened feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\n\n/**\r\n * Iterate over flattened features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name flattenEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n * });\r\n */\n\n\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n\n    var geomType; // Callback for multi-geometry\n\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n/**\r\n * Callback for flattenReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback flattenReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\n\n/**\r\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name flattenReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   return currentFeature\r\n * });\r\n */\n\n\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n/**\r\n * Callback for segmentEach\r\n *\r\n * @callback segmentEachCallback\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n * @returns {void}\r\n */\n\n/**\r\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //=currentSegment\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   //=segmentIndex\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var total = 0;\r\n * turf.segmentEach(polygon, function () {\r\n *     total++;\r\n * });\r\n */\n\n\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0; // Exclude null Geometries\n\n    if (!feature.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return; // Generate 2-vertex line segments\n\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n        previousCoords = currentCoord;\n        previousFeatureIndex = featureIndex;\n        previousMultiIndex = multiPartIndexCoord;\n        prevGeomIndex = geometryIndex;\n        segmentIndex = 0;\n        return;\n      }\n\n      var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n/**\r\n * Callback for segmentReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback segmentReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n */\n\n/**\r\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //= previousSegment\r\n *   //= currentSegment\r\n *   //= featureIndex\r\n *   //= multiFeatureIndex\r\n *   //= geometryIndex\r\n *   //= segmentIndex\r\n *   return currentSegment\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var initialValue = 0\r\n * var total = turf.segmentReduce(polygon, function (previousValue) {\r\n *     previousValue++;\r\n *     return previousValue;\r\n * }, initialValue);\r\n */\n\n\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n/**\r\n * Callback for lineEach\r\n *\r\n * @callback lineEachCallback\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\n\n/**\r\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\r\n * similar to Array.forEach.\r\n *\r\n * @name lineEach\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *   [[26, 37], [35, 45]],\r\n *   [[36, 53], [38, 50], [41, 55]]\r\n * ]);\r\n *\r\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\n\n\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n\n        break;\n    }\n  });\n}\n/**\r\n * Callback for lineReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback lineReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\n\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name lineReduce\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var multiPoly = turf.multiPolygon([\r\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\r\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\r\n * ]);\r\n *\r\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentLine\r\n * });\r\n */\n\n\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n/**\r\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n * Point & MultiPoint will always return null.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.segmentIndex=0] Segment Index\r\n * @param {Object} [options.properties={}] Translate Properties to output LineString\r\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\r\n * @param {number|string} [options.id={}] Translate Id to output LineString\r\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findSegment(multiLine);\r\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\r\n *\r\n * // First Segment of 2nd Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\r\n *\r\n * // Last Segment of Last Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\r\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\r\n */\n\n\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error(\"geojson is invalid\");\n  } // Find SegmentIndex\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n\n  throw new Error(\"geojson is invalid\");\n}\n/**\r\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.coordIndex=0] Coord Index\r\n * @param {Object} [options.properties={}] Translate Properties to output Point\r\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\r\n * @param {number|string} [options.id={}] Translate Id to output Point\r\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findPoint(multiLine);\r\n * // => Feature<Point<[10, 10]>>\r\n *\r\n * // First Segment of the 2nd Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<Point<[-10, -10]>>\r\n *\r\n * // Last Segment of last Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\r\n * // => Feature<Point<[-30, -40]>>\r\n */\n\n\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error(\"geojson is invalid\");\n  } // Find Coord Index\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };","map":{"version":3,"names":["feature","lineString","isObject","point","coordEach","geojson","callback","excludeWrapCoord","j","k","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","features","length","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","coordinates","geomType","Error","coordReduce","initialValue","previousValue","currentCoord","undefined","propEach","i","properties","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","coord","push","geomEach","g","featureProperties","featureBBox","featureId","bbox","id","geomReduce","currentGeometry","flattenEach","coordinate","geom","flattenReduce","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","options","findPoint"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/meta/dist/es/index.js"],"sourcesContent":["import { feature, lineString, isObject, point } from '@turf/helpers';\r\n\r\n/**\r\n * Callback for coordEach\r\n *\r\n * @callback coordEachCallback\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name coordEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nfunction coordEach(geojson, callback, excludeWrapCoord) {\r\n  // Handles null Geometry -- Skips this GeoJSON\r\n  if (geojson === null) return;\r\n  var j,\r\n    k,\r\n    l,\r\n    geometry,\r\n    stopG,\r\n    coords,\r\n    geometryMaybeCollection,\r\n    wrapShrink = 0,\r\n    coordIndex = 0,\r\n    isGeometryCollection,\r\n    type = geojson.type,\r\n    isFeatureCollection = type === \"FeatureCollection\",\r\n    isFeature = type === \"Feature\",\r\n    stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n  // This logic may look a little weird. The reason why it is that way\r\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n  // of objects at its root: FeatureCollection, Features, Geometries.\r\n  // This function has the responsibility of handling all of them, and that\r\n  // means that some of the `for` loops you see below actually just don't apply\r\n  // to certain inputs. For instance, if you give this just a\r\n  // Point geometry, then both loops are short-circuited and all we do\r\n  // is gradually rename the input until it's called 'geometry'.\r\n  //\r\n  // This also aims to allocate as few resources as possible: just a\r\n  // few numbers and booleans, rather than any temporary arrays as would\r\n  // be required with the normalization approach.\r\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\r\n    geometryMaybeCollection = isFeatureCollection\r\n      ? geojson.features[featureIndex].geometry\r\n      : isFeature\r\n      ? geojson.geometry\r\n      : geojson;\r\n    isGeometryCollection = geometryMaybeCollection\r\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\r\n      : false;\r\n    stopG = isGeometryCollection\r\n      ? geometryMaybeCollection.geometries.length\r\n      : 1;\r\n\r\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\r\n      var multiFeatureIndex = 0;\r\n      var geometryIndex = 0;\r\n      geometry = isGeometryCollection\r\n        ? geometryMaybeCollection.geometries[geomIndex]\r\n        : geometryMaybeCollection;\r\n\r\n      // Handles null Geometry -- Skips this geometry\r\n      if (geometry === null) continue;\r\n      coords = geometry.coordinates;\r\n      var geomType = geometry.type;\r\n\r\n      wrapShrink =\r\n        excludeWrapCoord &&\r\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\r\n          ? 1\r\n          : 0;\r\n\r\n      switch (geomType) {\r\n        case null:\r\n          break;\r\n        case \"Point\":\r\n          if (\r\n            callback(\r\n              coords,\r\n              coordIndex,\r\n              featureIndex,\r\n              multiFeatureIndex,\r\n              geometryIndex\r\n            ) === false\r\n          )\r\n            return false;\r\n          coordIndex++;\r\n          multiFeatureIndex++;\r\n          break;\r\n        case \"LineString\":\r\n        case \"MultiPoint\":\r\n          for (j = 0; j < coords.length; j++) {\r\n            if (\r\n              callback(\r\n                coords[j],\r\n                coordIndex,\r\n                featureIndex,\r\n                multiFeatureIndex,\r\n                geometryIndex\r\n              ) === false\r\n            )\r\n              return false;\r\n            coordIndex++;\r\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\r\n          }\r\n          if (geomType === \"LineString\") multiFeatureIndex++;\r\n          break;\r\n        case \"Polygon\":\r\n        case \"MultiLineString\":\r\n          for (j = 0; j < coords.length; j++) {\r\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\r\n              if (\r\n                callback(\r\n                  coords[j][k],\r\n                  coordIndex,\r\n                  featureIndex,\r\n                  multiFeatureIndex,\r\n                  geometryIndex\r\n                ) === false\r\n              )\r\n                return false;\r\n              coordIndex++;\r\n            }\r\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\r\n            if (geomType === \"Polygon\") geometryIndex++;\r\n          }\r\n          if (geomType === \"Polygon\") multiFeatureIndex++;\r\n          break;\r\n        case \"MultiPolygon\":\r\n          for (j = 0; j < coords.length; j++) {\r\n            geometryIndex = 0;\r\n            for (k = 0; k < coords[j].length; k++) {\r\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\r\n                if (\r\n                  callback(\r\n                    coords[j][k][l],\r\n                    coordIndex,\r\n                    featureIndex,\r\n                    multiFeatureIndex,\r\n                    geometryIndex\r\n                  ) === false\r\n                )\r\n                  return false;\r\n                coordIndex++;\r\n              }\r\n              geometryIndex++;\r\n            }\r\n            multiFeatureIndex++;\r\n          }\r\n          break;\r\n        case \"GeometryCollection\":\r\n          for (j = 0; j < geometry.geometries.length; j++)\r\n            if (\r\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\r\n              false\r\n            )\r\n              return false;\r\n          break;\r\n        default:\r\n          throw new Error(\"Unknown Geometry Type\");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for coordReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback coordReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\r\n *\r\n * @name coordReduce\r\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentCoord;\r\n * });\r\n */\r\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\r\n  var previousValue = initialValue;\r\n  coordEach(\r\n    geojson,\r\n    function (\r\n      currentCoord,\r\n      coordIndex,\r\n      featureIndex,\r\n      multiFeatureIndex,\r\n      geometryIndex\r\n    ) {\r\n      if (coordIndex === 0 && initialValue === undefined)\r\n        previousValue = currentCoord;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentCoord,\r\n          coordIndex,\r\n          featureIndex,\r\n          multiFeatureIndex,\r\n          geometryIndex\r\n        );\r\n    },\r\n    excludeWrapCoord\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for propEach\r\n *\r\n * @callback propEachCallback\r\n * @param {Object} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name propEach\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propEach(features, function (currentProperties, featureIndex) {\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n * });\r\n */\r\nfunction propEach(geojson, callback) {\r\n  var i;\r\n  switch (geojson.type) {\r\n    case \"FeatureCollection\":\r\n      for (i = 0; i < geojson.features.length; i++) {\r\n        if (callback(geojson.features[i].properties, i) === false) break;\r\n      }\r\n      break;\r\n    case \"Feature\":\r\n      callback(geojson.properties, 0);\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for propReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback propReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {*} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce properties in any GeoJSON object into a single value,\r\n * similar to how Array.reduce works. However, in this case we lazily run\r\n * the reduction, so an array of all properties is unnecessary.\r\n *\r\n * @name propReduce\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n *   return currentProperties\r\n * });\r\n */\r\nfunction propReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  propEach(geojson, function (currentProperties, featureIndex) {\r\n    if (featureIndex === 0 && initialValue === undefined)\r\n      previousValue = currentProperties;\r\n    else\r\n      previousValue = callback(previousValue, currentProperties, featureIndex);\r\n  });\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for featureEach\r\n *\r\n * @callback featureEachCallback\r\n * @param {Feature<any>} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name featureEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.featureEach(features, function (currentFeature, featureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n * });\r\n */\r\nfunction featureEach(geojson, callback) {\r\n  if (geojson.type === \"Feature\") {\r\n    callback(geojson, 0);\r\n  } else if (geojson.type === \"FeatureCollection\") {\r\n    for (var i = 0; i < geojson.features.length; i++) {\r\n      if (callback(geojson.features[i], i) === false) break;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for featureReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback featureReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name featureReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nfunction featureReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  featureEach(geojson, function (currentFeature, featureIndex) {\r\n    if (featureIndex === 0 && initialValue === undefined)\r\n      previousValue = currentFeature;\r\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\r\n  });\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Get all coordinates from any GeoJSON object.\r\n *\r\n * @name coordAll\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @returns {Array<Array<number>>} coordinate position array\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * var coords = turf.coordAll(features);\r\n * //= [[26, 37], [36, 53]]\r\n */\r\nfunction coordAll(geojson) {\r\n  var coords = [];\r\n  coordEach(geojson, function (coord) {\r\n    coords.push(coord);\r\n  });\r\n  return coords;\r\n}\r\n\r\n/**\r\n * Callback for geomEach\r\n *\r\n * @callback geomEachCallback\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name geomEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n * });\r\n */\r\nfunction geomEach(geojson, callback) {\r\n  var i,\r\n    j,\r\n    g,\r\n    geometry,\r\n    stopG,\r\n    geometryMaybeCollection,\r\n    isGeometryCollection,\r\n    featureProperties,\r\n    featureBBox,\r\n    featureId,\r\n    featureIndex = 0,\r\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\r\n    isFeature = geojson.type === \"Feature\",\r\n    stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n  // This logic may look a little weird. The reason why it is that way\r\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n  // of objects at its root: FeatureCollection, Features, Geometries.\r\n  // This function has the responsibility of handling all of them, and that\r\n  // means that some of the `for` loops you see below actually just don't apply\r\n  // to certain inputs. For instance, if you give this just a\r\n  // Point geometry, then both loops are short-circuited and all we do\r\n  // is gradually rename the input until it's called 'geometry'.\r\n  //\r\n  // This also aims to allocate as few resources as possible: just a\r\n  // few numbers and booleans, rather than any temporary arrays as would\r\n  // be required with the normalization approach.\r\n  for (i = 0; i < stop; i++) {\r\n    geometryMaybeCollection = isFeatureCollection\r\n      ? geojson.features[i].geometry\r\n      : isFeature\r\n      ? geojson.geometry\r\n      : geojson;\r\n    featureProperties = isFeatureCollection\r\n      ? geojson.features[i].properties\r\n      : isFeature\r\n      ? geojson.properties\r\n      : {};\r\n    featureBBox = isFeatureCollection\r\n      ? geojson.features[i].bbox\r\n      : isFeature\r\n      ? geojson.bbox\r\n      : undefined;\r\n    featureId = isFeatureCollection\r\n      ? geojson.features[i].id\r\n      : isFeature\r\n      ? geojson.id\r\n      : undefined;\r\n    isGeometryCollection = geometryMaybeCollection\r\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\r\n      : false;\r\n    stopG = isGeometryCollection\r\n      ? geometryMaybeCollection.geometries.length\r\n      : 1;\r\n\r\n    for (g = 0; g < stopG; g++) {\r\n      geometry = isGeometryCollection\r\n        ? geometryMaybeCollection.geometries[g]\r\n        : geometryMaybeCollection;\r\n\r\n      // Handle null Geometry\r\n      if (geometry === null) {\r\n        if (\r\n          callback(\r\n            null,\r\n            featureIndex,\r\n            featureProperties,\r\n            featureBBox,\r\n            featureId\r\n          ) === false\r\n        )\r\n          return false;\r\n        continue;\r\n      }\r\n      switch (geometry.type) {\r\n        case \"Point\":\r\n        case \"LineString\":\r\n        case \"MultiPoint\":\r\n        case \"Polygon\":\r\n        case \"MultiLineString\":\r\n        case \"MultiPolygon\": {\r\n          if (\r\n            callback(\r\n              geometry,\r\n              featureIndex,\r\n              featureProperties,\r\n              featureBBox,\r\n              featureId\r\n            ) === false\r\n          )\r\n            return false;\r\n          break;\r\n        }\r\n        case \"GeometryCollection\": {\r\n          for (j = 0; j < geometry.geometries.length; j++) {\r\n            if (\r\n              callback(\r\n                geometry.geometries[j],\r\n                featureIndex,\r\n                featureProperties,\r\n                featureBBox,\r\n                featureId\r\n              ) === false\r\n            )\r\n              return false;\r\n          }\r\n          break;\r\n        }\r\n        default:\r\n          throw new Error(\"Unknown Geometry Type\");\r\n      }\r\n    }\r\n    // Only increase `featureIndex` per each feature\r\n    featureIndex++;\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for geomReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback geomReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name geomReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=previousValue\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n *   return currentGeometry\r\n * });\r\n */\r\nfunction geomReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  geomEach(\r\n    geojson,\r\n    function (\r\n      currentGeometry,\r\n      featureIndex,\r\n      featureProperties,\r\n      featureBBox,\r\n      featureId\r\n    ) {\r\n      if (featureIndex === 0 && initialValue === undefined)\r\n        previousValue = currentGeometry;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentGeometry,\r\n          featureIndex,\r\n          featureProperties,\r\n          featureBBox,\r\n          featureId\r\n        );\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for flattenEach\r\n *\r\n * @callback flattenEachCallback\r\n * @param {Feature} currentFeature The current flattened feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over flattened features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name flattenEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n * });\r\n */\r\nfunction flattenEach(geojson, callback) {\r\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\r\n    // Callback for single geometry\r\n    var type = geometry === null ? null : geometry.type;\r\n    switch (type) {\r\n      case null:\r\n      case \"Point\":\r\n      case \"LineString\":\r\n      case \"Polygon\":\r\n        if (\r\n          callback(\r\n            feature(geometry, properties, { bbox: bbox, id: id }),\r\n            featureIndex,\r\n            0\r\n          ) === false\r\n        )\r\n          return false;\r\n        return;\r\n    }\r\n\r\n    var geomType;\r\n\r\n    // Callback for multi-geometry\r\n    switch (type) {\r\n      case \"MultiPoint\":\r\n        geomType = \"Point\";\r\n        break;\r\n      case \"MultiLineString\":\r\n        geomType = \"LineString\";\r\n        break;\r\n      case \"MultiPolygon\":\r\n        geomType = \"Polygon\";\r\n        break;\r\n    }\r\n\r\n    for (\r\n      var multiFeatureIndex = 0;\r\n      multiFeatureIndex < geometry.coordinates.length;\r\n      multiFeatureIndex++\r\n    ) {\r\n      var coordinate = geometry.coordinates[multiFeatureIndex];\r\n      var geom = {\r\n        type: geomType,\r\n        coordinates: coordinate,\r\n      };\r\n      if (\r\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\r\n        false\r\n      )\r\n        return false;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Callback for flattenReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback flattenReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name flattenReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nfunction flattenReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  flattenEach(\r\n    geojson,\r\n    function (currentFeature, featureIndex, multiFeatureIndex) {\r\n      if (\r\n        featureIndex === 0 &&\r\n        multiFeatureIndex === 0 &&\r\n        initialValue === undefined\r\n      )\r\n        previousValue = currentFeature;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentFeature,\r\n          featureIndex,\r\n          multiFeatureIndex\r\n        );\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for segmentEach\r\n *\r\n * @callback segmentEachCallback\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //=currentSegment\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   //=segmentIndex\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var total = 0;\r\n * turf.segmentEach(polygon, function () {\r\n *     total++;\r\n * });\r\n */\r\nfunction segmentEach(geojson, callback) {\r\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n    var segmentIndex = 0;\r\n\r\n    // Exclude null Geometries\r\n    if (!feature.geometry) return;\r\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n    var type = feature.geometry.type;\r\n    if (type === \"Point\" || type === \"MultiPoint\") return;\r\n\r\n    // Generate 2-vertex line segments\r\n    var previousCoords;\r\n    var previousFeatureIndex = 0;\r\n    var previousMultiIndex = 0;\r\n    var prevGeomIndex = 0;\r\n    if (\r\n      coordEach(\r\n        feature,\r\n        function (\r\n          currentCoord,\r\n          coordIndex,\r\n          featureIndexCoord,\r\n          multiPartIndexCoord,\r\n          geometryIndex\r\n        ) {\r\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\r\n          if (\r\n            previousCoords === undefined ||\r\n            featureIndex > previousFeatureIndex ||\r\n            multiPartIndexCoord > previousMultiIndex ||\r\n            geometryIndex > prevGeomIndex\r\n          ) {\r\n            previousCoords = currentCoord;\r\n            previousFeatureIndex = featureIndex;\r\n            previousMultiIndex = multiPartIndexCoord;\r\n            prevGeomIndex = geometryIndex;\r\n            segmentIndex = 0;\r\n            return;\r\n          }\r\n          var currentSegment = lineString(\r\n            [previousCoords, currentCoord],\r\n            feature.properties\r\n          );\r\n          if (\r\n            callback(\r\n              currentSegment,\r\n              featureIndex,\r\n              multiFeatureIndex,\r\n              geometryIndex,\r\n              segmentIndex\r\n            ) === false\r\n          )\r\n            return false;\r\n          segmentIndex++;\r\n          previousCoords = currentCoord;\r\n        }\r\n      ) === false\r\n    )\r\n      return false;\r\n  });\r\n}\r\n\r\n/**\r\n * Callback for segmentReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback segmentReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n */\r\n\r\n/**\r\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //= previousSegment\r\n *   //= currentSegment\r\n *   //= featureIndex\r\n *   //= multiFeatureIndex\r\n *   //= geometryIndex\r\n *   //= segmentIndex\r\n *   return currentSegment\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var initialValue = 0\r\n * var total = turf.segmentReduce(polygon, function (previousValue) {\r\n *     previousValue++;\r\n *     return previousValue;\r\n * }, initialValue);\r\n */\r\nfunction segmentReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  var started = false;\r\n  segmentEach(\r\n    geojson,\r\n    function (\r\n      currentSegment,\r\n      featureIndex,\r\n      multiFeatureIndex,\r\n      geometryIndex,\r\n      segmentIndex\r\n    ) {\r\n      if (started === false && initialValue === undefined)\r\n        previousValue = currentSegment;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentSegment,\r\n          featureIndex,\r\n          multiFeatureIndex,\r\n          geometryIndex,\r\n          segmentIndex\r\n        );\r\n      started = true;\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for lineEach\r\n *\r\n * @callback lineEachCallback\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\r\n * similar to Array.forEach.\r\n *\r\n * @name lineEach\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *   [[26, 37], [35, 45]],\r\n *   [[36, 53], [38, 50], [41, 55]]\r\n * ]);\r\n *\r\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nfunction lineEach(geojson, callback) {\r\n  // validation\r\n  if (!geojson) throw new Error(\"geojson is required\");\r\n\r\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n    if (feature.geometry === null) return;\r\n    var type = feature.geometry.type;\r\n    var coords = feature.geometry.coordinates;\r\n    switch (type) {\r\n      case \"LineString\":\r\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\r\n          return false;\r\n        break;\r\n      case \"Polygon\":\r\n        for (\r\n          var geometryIndex = 0;\r\n          geometryIndex < coords.length;\r\n          geometryIndex++\r\n        ) {\r\n          if (\r\n            callback(\r\n              lineString(coords[geometryIndex], feature.properties),\r\n              featureIndex,\r\n              multiFeatureIndex,\r\n              geometryIndex\r\n            ) === false\r\n          )\r\n            return false;\r\n        }\r\n        break;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Callback for lineReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback lineReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name lineReduce\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var multiPoly = turf.multiPolygon([\r\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\r\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\r\n * ]);\r\n *\r\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentLine\r\n * });\r\n */\r\nfunction lineReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  lineEach(\r\n    geojson,\r\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n      if (featureIndex === 0 && initialValue === undefined)\r\n        previousValue = currentLine;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentLine,\r\n          featureIndex,\r\n          multiFeatureIndex,\r\n          geometryIndex\r\n        );\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n * Point & MultiPoint will always return null.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.segmentIndex=0] Segment Index\r\n * @param {Object} [options.properties={}] Translate Properties to output LineString\r\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\r\n * @param {number|string} [options.id={}] Translate Id to output LineString\r\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findSegment(multiLine);\r\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\r\n *\r\n * // First Segment of 2nd Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\r\n *\r\n * // Last Segment of Last Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\r\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\r\n */\r\nfunction findSegment(geojson, options) {\r\n  // Optional Parameters\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var featureIndex = options.featureIndex || 0;\r\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n  var geometryIndex = options.geometryIndex || 0;\r\n  var segmentIndex = options.segmentIndex || 0;\r\n\r\n  // Find FeatureIndex\r\n  var properties = options.properties;\r\n  var geometry;\r\n\r\n  switch (geojson.type) {\r\n    case \"FeatureCollection\":\r\n      if (featureIndex < 0)\r\n        featureIndex = geojson.features.length + featureIndex;\r\n      properties = properties || geojson.features[featureIndex].properties;\r\n      geometry = geojson.features[featureIndex].geometry;\r\n      break;\r\n    case \"Feature\":\r\n      properties = properties || geojson.properties;\r\n      geometry = geojson.geometry;\r\n      break;\r\n    case \"Point\":\r\n    case \"MultiPoint\":\r\n      return null;\r\n    case \"LineString\":\r\n    case \"Polygon\":\r\n    case \"MultiLineString\":\r\n    case \"MultiPolygon\":\r\n      geometry = geojson;\r\n      break;\r\n    default:\r\n      throw new Error(\"geojson is invalid\");\r\n  }\r\n\r\n  // Find SegmentIndex\r\n  if (geometry === null) return null;\r\n  var coords = geometry.coordinates;\r\n  switch (geometry.type) {\r\n    case \"Point\":\r\n    case \"MultiPoint\":\r\n      return null;\r\n    case \"LineString\":\r\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\r\n      return lineString(\r\n        [coords[segmentIndex], coords[segmentIndex + 1]],\r\n        properties,\r\n        options\r\n      );\r\n    case \"Polygon\":\r\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n      if (segmentIndex < 0)\r\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\r\n      return lineString(\r\n        [\r\n          coords[geometryIndex][segmentIndex],\r\n          coords[geometryIndex][segmentIndex + 1],\r\n        ],\r\n        properties,\r\n        options\r\n      );\r\n    case \"MultiLineString\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (segmentIndex < 0)\r\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\r\n      return lineString(\r\n        [\r\n          coords[multiFeatureIndex][segmentIndex],\r\n          coords[multiFeatureIndex][segmentIndex + 1],\r\n        ],\r\n        properties,\r\n        options\r\n      );\r\n    case \"MultiPolygon\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (geometryIndex < 0)\r\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n      if (segmentIndex < 0)\r\n        segmentIndex =\r\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\r\n      return lineString(\r\n        [\r\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\r\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\r\n        ],\r\n        properties,\r\n        options\r\n      );\r\n  }\r\n  throw new Error(\"geojson is invalid\");\r\n}\r\n\r\n/**\r\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.coordIndex=0] Coord Index\r\n * @param {Object} [options.properties={}] Translate Properties to output Point\r\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\r\n * @param {number|string} [options.id={}] Translate Id to output Point\r\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findPoint(multiLine);\r\n * // => Feature<Point<[10, 10]>>\r\n *\r\n * // First Segment of the 2nd Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<Point<[-10, -10]>>\r\n *\r\n * // Last Segment of last Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\r\n * // => Feature<Point<[-30, -40]>>\r\n */\r\nfunction findPoint(geojson, options) {\r\n  // Optional Parameters\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var featureIndex = options.featureIndex || 0;\r\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n  var geometryIndex = options.geometryIndex || 0;\r\n  var coordIndex = options.coordIndex || 0;\r\n\r\n  // Find FeatureIndex\r\n  var properties = options.properties;\r\n  var geometry;\r\n\r\n  switch (geojson.type) {\r\n    case \"FeatureCollection\":\r\n      if (featureIndex < 0)\r\n        featureIndex = geojson.features.length + featureIndex;\r\n      properties = properties || geojson.features[featureIndex].properties;\r\n      geometry = geojson.features[featureIndex].geometry;\r\n      break;\r\n    case \"Feature\":\r\n      properties = properties || geojson.properties;\r\n      geometry = geojson.geometry;\r\n      break;\r\n    case \"Point\":\r\n    case \"MultiPoint\":\r\n      return null;\r\n    case \"LineString\":\r\n    case \"Polygon\":\r\n    case \"MultiLineString\":\r\n    case \"MultiPolygon\":\r\n      geometry = geojson;\r\n      break;\r\n    default:\r\n      throw new Error(\"geojson is invalid\");\r\n  }\r\n\r\n  // Find Coord Index\r\n  if (geometry === null) return null;\r\n  var coords = geometry.coordinates;\r\n  switch (geometry.type) {\r\n    case \"Point\":\r\n      return point(coords, properties, options);\r\n    case \"MultiPoint\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      return point(coords[multiFeatureIndex], properties, options);\r\n    case \"LineString\":\r\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\r\n      return point(coords[coordIndex], properties, options);\r\n    case \"Polygon\":\r\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n      if (coordIndex < 0)\r\n        coordIndex = coords[geometryIndex].length + coordIndex;\r\n      return point(coords[geometryIndex][coordIndex], properties, options);\r\n    case \"MultiLineString\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (coordIndex < 0)\r\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\r\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\r\n    case \"MultiPolygon\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (geometryIndex < 0)\r\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n      if (coordIndex < 0)\r\n        coordIndex =\r\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\r\n      return point(\r\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\r\n        properties,\r\n        options\r\n      );\r\n  }\r\n  throw new Error(\"geojson is invalid\");\r\n}\r\n\r\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\r\n"],"mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBnC,OAApB,EAA6BC,QAA7B,EAAuC2B,YAAvC,EAAqD;EACnD,IAAIC,aAAa,GAAGD,YAApB;EACAI,QAAQ,CAAChC,OAAD,EAAU,UAAUoC,iBAAV,EAA6BjB,YAA7B,EAA2C;IAC3D,IAAIA,YAAY,KAAK,CAAjB,IAAsBS,YAAY,KAAKG,SAA3C,EACEF,aAAa,GAAGO,iBAAhB,CADF,KAGEP,aAAa,GAAG5B,QAAQ,CAAC4B,aAAD,EAAgBO,iBAAhB,EAAmCjB,YAAnC,CAAxB;EACH,CALO,CAAR;EAMA,OAAOU,aAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,WAAT,CAAqBrC,OAArB,EAA8BC,QAA9B,EAAwC;EACtC,IAAID,OAAO,CAACa,IAAR,KAAiB,SAArB,EAAgC;IAC9BZ,QAAQ,CAACD,OAAD,EAAU,CAAV,CAAR;EACD,CAFD,MAEO,IAAIA,OAAO,CAACa,IAAR,KAAiB,mBAArB,EAA0C;IAC/C,KAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,OAAO,CAACiB,QAAR,CAAiBC,MAArC,EAA6Ce,CAAC,EAA9C,EAAkD;MAChD,IAAIhC,QAAQ,CAACD,OAAO,CAACiB,QAAR,CAAiBgB,CAAjB,CAAD,EAAsBA,CAAtB,CAAR,KAAqC,KAAzC,EAAgD;IACjD;EACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;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"},"metadata":{},"sourceType":"module"}