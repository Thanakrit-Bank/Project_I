{"ast":null,"code":"// Taken from http://geomalgorithms.com/a02-_lines.html\nimport getDistance from \"@turf/distance\";\nimport { convertLength, feature, lineString, point } from \"@turf/helpers\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport getPlanarDistance from \"@turf/rhumb-distance\";\n/**\r\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\r\n * minimum distance between the point and any segment of the `LineString`.\r\n *\r\n * @name pointToLineDistance\r\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\r\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\r\n * (ex: degrees, radians, miles, or kilometers)\r\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\r\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\r\n * @returns {number} distance between point and line\r\n * @example\r\n * var pt = turf.point([0, 0]);\r\n * var line = turf.lineString([[1, 1],[-1, 1]]);\r\n *\r\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\r\n * //=69.11854715938406\r\n */\n\nfunction pointToLineDistance(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  } // Optional parameters\n\n\n  if (!options.method) {\n    options.method = \"geodesic\";\n  }\n\n  if (!options.units) {\n    options.units = \"kilometers\";\n  } // validation\n\n\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n\n  if (Array.isArray(pt)) {\n    pt = point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = feature(pt);\n  } else {\n    featureOf(pt, \"Point\", \"point\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n\n  if (Array.isArray(line)) {\n    line = lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = feature(line);\n  } else {\n    featureOf(line, \"LineString\", \"line\");\n  }\n\n  var distance = Infinity;\n  var p = pt.geometry.coordinates;\n  segmentEach(line, function (segment) {\n    var a = segment.geometry.coordinates[0];\n    var b = segment.geometry.coordinates[1];\n    var d = distanceToSegment(p, a, b, options);\n\n    if (d < distance) {\n      distance = d;\n    }\n  });\n  return convertLength(distance, \"degrees\", options.units);\n}\n/**\r\n * Returns the distance between a point P on a segment AB.\r\n *\r\n * @private\r\n * @param {Array<number>} p external point\r\n * @param {Array<number>} a first segment point\r\n * @param {Array<number>} b second segment point\r\n * @param {Object} [options={}] Optional parameters\r\n * @returns {number} distance\r\n */\n\n\nfunction distanceToSegment(p, a, b, options) {\n  var v = [b[0] - a[0], b[1] - a[1]];\n  var w = [p[0] - a[0], p[1] - a[1]];\n  var c1 = dot(w, v);\n\n  if (c1 <= 0) {\n    return calcDistance(p, a, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n\n  var c2 = dot(v, v);\n\n  if (c2 <= c1) {\n    return calcDistance(p, b, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n\n  var b2 = c1 / c2;\n  var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n  return calcDistance(p, Pb, {\n    method: options.method,\n    units: \"degrees\"\n  });\n}\n\nfunction dot(u, v) {\n  return u[0] * v[0] + u[1] * v[1];\n}\n\nfunction calcDistance(a, b, options) {\n  return options.method === \"planar\" ? getPlanarDistance(a, b, options) : getDistance(a, b, options);\n}\n\nexport default pointToLineDistance;","map":{"version":3,"names":["getDistance","convertLength","feature","lineString","point","featureOf","segmentEach","getPlanarDistance","pointToLineDistance","pt","line","options","method","units","Error","Array","isArray","type","distance","Infinity","p","geometry","coordinates","segment","a","b","d","distanceToSegment","v","w","c1","dot","calcDistance","c2","b2","Pb","u"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/point-to-line-distance/dist/es/index.js"],"sourcesContent":["// Taken from http://geomalgorithms.com/a02-_lines.html\r\nimport getDistance from \"@turf/distance\";\r\nimport { convertLength, feature, lineString, point, } from \"@turf/helpers\";\r\nimport { featureOf } from \"@turf/invariant\";\r\nimport { segmentEach } from \"@turf/meta\";\r\nimport getPlanarDistance from \"@turf/rhumb-distance\";\r\n/**\r\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\r\n * minimum distance between the point and any segment of the `LineString`.\r\n *\r\n * @name pointToLineDistance\r\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\r\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\r\n * (ex: degrees, radians, miles, or kilometers)\r\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\r\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\r\n * @returns {number} distance between point and line\r\n * @example\r\n * var pt = turf.point([0, 0]);\r\n * var line = turf.lineString([[1, 1],[-1, 1]]);\r\n *\r\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\r\n * //=69.11854715938406\r\n */\r\nfunction pointToLineDistance(pt, line, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Optional parameters\r\n    if (!options.method) {\r\n        options.method = \"geodesic\";\r\n    }\r\n    if (!options.units) {\r\n        options.units = \"kilometers\";\r\n    }\r\n    // validation\r\n    if (!pt) {\r\n        throw new Error(\"pt is required\");\r\n    }\r\n    if (Array.isArray(pt)) {\r\n        pt = point(pt);\r\n    }\r\n    else if (pt.type === \"Point\") {\r\n        pt = feature(pt);\r\n    }\r\n    else {\r\n        featureOf(pt, \"Point\", \"point\");\r\n    }\r\n    if (!line) {\r\n        throw new Error(\"line is required\");\r\n    }\r\n    if (Array.isArray(line)) {\r\n        line = lineString(line);\r\n    }\r\n    else if (line.type === \"LineString\") {\r\n        line = feature(line);\r\n    }\r\n    else {\r\n        featureOf(line, \"LineString\", \"line\");\r\n    }\r\n    var distance = Infinity;\r\n    var p = pt.geometry.coordinates;\r\n    segmentEach(line, function (segment) {\r\n        var a = segment.geometry.coordinates[0];\r\n        var b = segment.geometry.coordinates[1];\r\n        var d = distanceToSegment(p, a, b, options);\r\n        if (d < distance) {\r\n            distance = d;\r\n        }\r\n    });\r\n    return convertLength(distance, \"degrees\", options.units);\r\n}\r\n/**\r\n * Returns the distance between a point P on a segment AB.\r\n *\r\n * @private\r\n * @param {Array<number>} p external point\r\n * @param {Array<number>} a first segment point\r\n * @param {Array<number>} b second segment point\r\n * @param {Object} [options={}] Optional parameters\r\n * @returns {number} distance\r\n */\r\nfunction distanceToSegment(p, a, b, options) {\r\n    var v = [b[0] - a[0], b[1] - a[1]];\r\n    var w = [p[0] - a[0], p[1] - a[1]];\r\n    var c1 = dot(w, v);\r\n    if (c1 <= 0) {\r\n        return calcDistance(p, a, { method: options.method, units: \"degrees\" });\r\n    }\r\n    var c2 = dot(v, v);\r\n    if (c2 <= c1) {\r\n        return calcDistance(p, b, { method: options.method, units: \"degrees\" });\r\n    }\r\n    var b2 = c1 / c2;\r\n    var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\r\n    return calcDistance(p, Pb, { method: options.method, units: \"degrees\" });\r\n}\r\nfunction dot(u, v) {\r\n    return u[0] * v[0] + u[1] * v[1];\r\n}\r\nfunction calcDistance(a, b, options) {\r\n    return options.method === \"planar\"\r\n        ? getPlanarDistance(a, b, options)\r\n        : getDistance(a, b, options);\r\n}\r\nexport default pointToLineDistance;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}