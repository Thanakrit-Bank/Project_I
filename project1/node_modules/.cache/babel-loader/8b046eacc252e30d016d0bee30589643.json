{"ast":null,"code":"import bbox from '@turf/bbox';\nimport hexGrid from '@turf/hex-grid';\nimport pointGrid from '@turf/point-grid';\nimport distance from '@turf/distance';\nimport centroid from '@turf/centroid';\nimport squareGrid from '@turf/square-grid';\nimport triangleGrid from '@turf/triangle-grid';\nimport clone from '@turf/clone';\nimport { featureCollection } from '@turf/helpers';\nimport { featureEach } from '@turf/meta';\nimport { collectionOf } from '@turf/invariant';\n/**\r\n * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).\r\n *\r\n * @name interpolate\r\n * @param {FeatureCollection<Point>} points with known value\r\n * @param {number} cellSize the distance across each grid point\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')\r\n * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.\r\n * @param {string} [options.units='kilometers'] used in calculating cellSize, can be degrees, radians, miles, or kilometers\r\n * @param {number} [options.weight=1] exponent regulating the distance-decay weighting\r\n * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'\r\n * @example\r\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\r\n *\r\n * // add a random property to each point\r\n * turf.featureEach(points, function(point) {\r\n *     point.properties.solRad = Math.random() * 50;\r\n * });\r\n * var options = {gridType: 'points', property: 'solRad', units: 'miles'};\r\n * var grid = turf.interpolate(points, 100, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [grid];\r\n */\n\nfunction interpolate(points, cellSize, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var gridType = options.gridType;\n  var property = options.property;\n  var weight = options.weight; // validation\n\n  if (!points) throw new Error(\"points is required\");\n  collectionOf(points, \"Point\", \"input must contain Points\");\n  if (!cellSize) throw new Error(\"cellSize is required\");\n  if (weight !== undefined && typeof weight !== \"number\") throw new Error(\"weight must be a number\"); // default values\n\n  property = property || \"elevation\";\n  gridType = gridType || \"square\";\n  weight = weight || 1;\n  var box = bbox(points);\n  var grid;\n\n  switch (gridType) {\n    case \"point\":\n    case \"points\":\n      grid = pointGrid(box, cellSize, options);\n      break;\n\n    case \"square\":\n    case \"squares\":\n      grid = squareGrid(box, cellSize, options);\n      break;\n\n    case \"hex\":\n    case \"hexes\":\n      grid = hexGrid(box, cellSize, options);\n      break;\n\n    case \"triangle\":\n    case \"triangles\":\n      grid = triangleGrid(box, cellSize, options);\n      break;\n\n    default:\n      throw new Error(\"invalid gridType\");\n  }\n\n  var results = [];\n  featureEach(grid, function (gridFeature) {\n    var zw = 0;\n    var sw = 0; // calculate the distance from each input point to the grid points\n\n    featureEach(points, function (point) {\n      var gridPoint = gridType === \"point\" ? gridFeature : centroid(gridFeature);\n      var d = distance(gridPoint, point, options);\n      var zValue; // property has priority for zValue, fallbacks to 3rd coordinate from geometry\n\n      if (property !== undefined) zValue = point.properties[property];\n      if (zValue === undefined) zValue = point.geometry.coordinates[2];\n      if (zValue === undefined) throw new Error(\"zValue is missing\");\n      if (d === 0) zw = zValue;\n      var w = 1.0 / Math.pow(d, weight);\n      sw += w;\n      zw += w * zValue;\n    }); // write interpolated value for each grid point\n\n    var newFeature = clone(gridFeature);\n    newFeature.properties[property] = zw / sw;\n    results.push(newFeature);\n  });\n  return featureCollection(results);\n}\n\nexport default interpolate;","map":{"version":3,"names":["bbox","hexGrid","pointGrid","distance","centroid","squareGrid","triangleGrid","clone","featureCollection","featureEach","collectionOf","interpolate","points","cellSize","options","Error","gridType","property","weight","undefined","box","grid","results","gridFeature","zw","sw","point","gridPoint","d","zValue","properties","geometry","coordinates","w","Math","pow","newFeature","push"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/interpolate/dist/es/index.js"],"sourcesContent":["import bbox from '@turf/bbox';\r\nimport hexGrid from '@turf/hex-grid';\r\nimport pointGrid from '@turf/point-grid';\r\nimport distance from '@turf/distance';\r\nimport centroid from '@turf/centroid';\r\nimport squareGrid from '@turf/square-grid';\r\nimport triangleGrid from '@turf/triangle-grid';\r\nimport clone from '@turf/clone';\r\nimport { featureCollection } from '@turf/helpers';\r\nimport { featureEach } from '@turf/meta';\r\nimport { collectionOf } from '@turf/invariant';\r\n\r\n/**\r\n * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).\r\n *\r\n * @name interpolate\r\n * @param {FeatureCollection<Point>} points with known value\r\n * @param {number} cellSize the distance across each grid point\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')\r\n * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.\r\n * @param {string} [options.units='kilometers'] used in calculating cellSize, can be degrees, radians, miles, or kilometers\r\n * @param {number} [options.weight=1] exponent regulating the distance-decay weighting\r\n * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'\r\n * @example\r\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\r\n *\r\n * // add a random property to each point\r\n * turf.featureEach(points, function(point) {\r\n *     point.properties.solRad = Math.random() * 50;\r\n * });\r\n * var options = {gridType: 'points', property: 'solRad', units: 'miles'};\r\n * var grid = turf.interpolate(points, 100, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [grid];\r\n */\r\nfunction interpolate(points, cellSize, options) {\r\n  // Optional parameters\r\n  options = options || {};\r\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\r\n  var gridType = options.gridType;\r\n  var property = options.property;\r\n  var weight = options.weight;\r\n\r\n  // validation\r\n  if (!points) throw new Error(\"points is required\");\r\n  collectionOf(points, \"Point\", \"input must contain Points\");\r\n  if (!cellSize) throw new Error(\"cellSize is required\");\r\n  if (weight !== undefined && typeof weight !== \"number\")\r\n    throw new Error(\"weight must be a number\");\r\n\r\n  // default values\r\n  property = property || \"elevation\";\r\n  gridType = gridType || \"square\";\r\n  weight = weight || 1;\r\n\r\n  var box = bbox(points);\r\n  var grid;\r\n  switch (gridType) {\r\n    case \"point\":\r\n    case \"points\":\r\n      grid = pointGrid(box, cellSize, options);\r\n      break;\r\n    case \"square\":\r\n    case \"squares\":\r\n      grid = squareGrid(box, cellSize, options);\r\n      break;\r\n    case \"hex\":\r\n    case \"hexes\":\r\n      grid = hexGrid(box, cellSize, options);\r\n      break;\r\n    case \"triangle\":\r\n    case \"triangles\":\r\n      grid = triangleGrid(box, cellSize, options);\r\n      break;\r\n    default:\r\n      throw new Error(\"invalid gridType\");\r\n  }\r\n  var results = [];\r\n  featureEach(grid, function (gridFeature) {\r\n    var zw = 0;\r\n    var sw = 0;\r\n    // calculate the distance from each input point to the grid points\r\n    featureEach(points, function (point) {\r\n      var gridPoint =\r\n        gridType === \"point\" ? gridFeature : centroid(gridFeature);\r\n      var d = distance(gridPoint, point, options);\r\n      var zValue;\r\n      // property has priority for zValue, fallbacks to 3rd coordinate from geometry\r\n      if (property !== undefined) zValue = point.properties[property];\r\n      if (zValue === undefined) zValue = point.geometry.coordinates[2];\r\n      if (zValue === undefined) throw new Error(\"zValue is missing\");\r\n      if (d === 0) zw = zValue;\r\n      var w = 1.0 / Math.pow(d, weight);\r\n      sw += w;\r\n      zw += w * zValue;\r\n    });\r\n    // write interpolated value for each grid point\r\n    var newFeature = clone(gridFeature);\r\n    newFeature.properties[property] = zw / sw;\r\n    results.push(newFeature);\r\n  });\r\n  return featureCollection(results);\r\n}\r\n\r\nexport default interpolate;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}