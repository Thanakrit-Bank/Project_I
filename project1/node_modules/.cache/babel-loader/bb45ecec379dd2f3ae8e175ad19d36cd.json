{"ast":null,"code":"import intersect from \"@turf/boolean-intersects\";\nimport distance from \"@turf/distance\";\nimport { featureCollection, polygon } from \"@turf/helpers\";\n/**\r\n * Creates a grid of rectangles from a bounding box, {@link Feature} or {@link FeatureCollection}.\r\n *\r\n * @name rectangleGrid\r\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\r\n * @param {number} cellWidth of each cell, in units\r\n * @param {number} cellHeight of each cell, in units\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] units (\"degrees\", \"radians\", \"miles\", \"kilometers\") that the given cellWidth\r\n * and cellHeight are expressed in. Converted at the southern border.\r\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,\r\n * the grid Points will be created only inside it\r\n * @param {Object} [options.properties={}] passed to each point of the grid\r\n * @returns {FeatureCollection<Polygon>} a grid of polygons\r\n * @example\r\n * var bbox = [-95, 30 ,-85, 40];\r\n * var cellWidth = 50;\r\n * var cellHeight = 20;\r\n * var options = {units: 'miles'};\r\n *\r\n * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [rectangleGrid]\r\n */\n\nfunction rectangleGrid(bbox, cellWidth, cellHeight, options) {\n  if (options === void 0) {\n    options = {};\n  } // Containers\n\n\n  var results = [];\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var xFraction = cellWidth / distance([west, south], [east, south], options);\n  var cellWidthDeg = xFraction * (east - west);\n  var yFraction = cellHeight / distance([west, south], [west, north], options);\n  var cellHeightDeg = yFraction * (north - south); // rows & columns\n\n  var bboxWidth = east - west;\n  var bboxHeight = north - south;\n  var columns = Math.floor(bboxWidth / cellWidthDeg);\n  var rows = Math.floor(bboxHeight / cellHeightDeg); // if the grid does not fill the bbox perfectly, center it.\n\n  var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\n  var deltaY = (bboxHeight - rows * cellHeightDeg) / 2; // iterate over columns & rows\n\n  var currentX = west + deltaX;\n\n  for (var column = 0; column < columns; column++) {\n    var currentY = south + deltaY;\n\n    for (var row = 0; row < rows; row++) {\n      var cellPoly = polygon([[[currentX, currentY], [currentX, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY], [currentX, currentY]]], options.properties);\n\n      if (options.mask) {\n        if (intersect(options.mask, cellPoly)) {\n          results.push(cellPoly);\n        }\n      } else {\n        results.push(cellPoly);\n      }\n\n      currentY += cellHeightDeg;\n    }\n\n    currentX += cellWidthDeg;\n  }\n\n  return featureCollection(results);\n}\n\nexport default rectangleGrid;","map":{"version":3,"names":["intersect","distance","featureCollection","polygon","rectangleGrid","bbox","cellWidth","cellHeight","options","results","west","south","east","north","xFraction","cellWidthDeg","yFraction","cellHeightDeg","bboxWidth","bboxHeight","columns","Math","floor","rows","deltaX","deltaY","currentX","column","currentY","row","cellPoly","properties","mask","push"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/rectangle-grid/dist/es/index.js"],"sourcesContent":["import intersect from \"@turf/boolean-intersects\";\r\nimport distance from \"@turf/distance\";\r\nimport { featureCollection, polygon, } from \"@turf/helpers\";\r\n/**\r\n * Creates a grid of rectangles from a bounding box, {@link Feature} or {@link FeatureCollection}.\r\n *\r\n * @name rectangleGrid\r\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\r\n * @param {number} cellWidth of each cell, in units\r\n * @param {number} cellHeight of each cell, in units\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] units (\"degrees\", \"radians\", \"miles\", \"kilometers\") that the given cellWidth\r\n * and cellHeight are expressed in. Converted at the southern border.\r\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,\r\n * the grid Points will be created only inside it\r\n * @param {Object} [options.properties={}] passed to each point of the grid\r\n * @returns {FeatureCollection<Polygon>} a grid of polygons\r\n * @example\r\n * var bbox = [-95, 30 ,-85, 40];\r\n * var cellWidth = 50;\r\n * var cellHeight = 20;\r\n * var options = {units: 'miles'};\r\n *\r\n * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [rectangleGrid]\r\n */\r\nfunction rectangleGrid(bbox, cellWidth, cellHeight, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Containers\r\n    var results = [];\r\n    var west = bbox[0];\r\n    var south = bbox[1];\r\n    var east = bbox[2];\r\n    var north = bbox[3];\r\n    var xFraction = cellWidth / distance([west, south], [east, south], options);\r\n    var cellWidthDeg = xFraction * (east - west);\r\n    var yFraction = cellHeight / distance([west, south], [west, north], options);\r\n    var cellHeightDeg = yFraction * (north - south);\r\n    // rows & columns\r\n    var bboxWidth = east - west;\r\n    var bboxHeight = north - south;\r\n    var columns = Math.floor(bboxWidth / cellWidthDeg);\r\n    var rows = Math.floor(bboxHeight / cellHeightDeg);\r\n    // if the grid does not fill the bbox perfectly, center it.\r\n    var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\r\n    var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;\r\n    // iterate over columns & rows\r\n    var currentX = west + deltaX;\r\n    for (var column = 0; column < columns; column++) {\r\n        var currentY = south + deltaY;\r\n        for (var row = 0; row < rows; row++) {\r\n            var cellPoly = polygon([\r\n                [\r\n                    [currentX, currentY],\r\n                    [currentX, currentY + cellHeightDeg],\r\n                    [currentX + cellWidthDeg, currentY + cellHeightDeg],\r\n                    [currentX + cellWidthDeg, currentY],\r\n                    [currentX, currentY],\r\n                ],\r\n            ], options.properties);\r\n            if (options.mask) {\r\n                if (intersect(options.mask, cellPoly)) {\r\n                    results.push(cellPoly);\r\n                }\r\n            }\r\n            else {\r\n                results.push(cellPoly);\r\n            }\r\n            currentY += cellHeightDeg;\r\n        }\r\n        currentX += cellWidthDeg;\r\n    }\r\n    return featureCollection(results);\r\n}\r\nexport default rectangleGrid;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}