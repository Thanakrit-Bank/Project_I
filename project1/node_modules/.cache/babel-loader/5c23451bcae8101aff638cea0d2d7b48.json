{"ast":null,"code":"import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\"; // http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\r\n * Takes two {@link Point|points} and finds the geographic bearing between them,\r\n * i.e. the angle measured in degrees from the north line (0 degrees)\r\n *\r\n * @name bearing\r\n * @param {Coord} start starting Point\r\n * @param {Coord} end ending Point\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.final=false] calculates the final bearing if true\r\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\r\n * @example\r\n * var point1 = turf.point([-75.343, 39.984]);\r\n * var point2 = turf.point([-75.534, 39.123]);\r\n *\r\n * var bearing = turf.bearing(point1, point2);\r\n *\r\n * //addToMap\r\n * var addToMap = [point1, point2]\r\n * point1.properties['marker-color'] = '#f00'\r\n * point2.properties['marker-color'] = '#0f0'\r\n * point1.properties.bearing = bearing\r\n */\n\nexport default function bearing(start, end, options) {\n  if (options === void 0) {\n    options = {};\n  } // Reverse calculation\n\n\n  if (options.final === true) {\n    return calculateFinalBearing(start, end);\n  }\n\n  var coordinates1 = getCoord(start);\n  var coordinates2 = getCoord(end);\n  var lon1 = degreesToRadians(coordinates1[0]);\n  var lon2 = degreesToRadians(coordinates2[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return radiansToDegrees(Math.atan2(a, b));\n}\n/**\r\n * Calculates Final Bearing\r\n *\r\n * @private\r\n * @param {Coord} start starting Point\r\n * @param {Coord} end ending Point\r\n * @returns {number} bearing\r\n */\n\nfunction calculateFinalBearing(start, end) {\n  // Swap start & end\n  var bear = bearing(end, start);\n  bear = (bear + 180) % 360;\n  return bear;\n}","map":{"version":3,"names":["degreesToRadians","radiansToDegrees","getCoord","bearing","start","end","options","final","calculateFinalBearing","coordinates1","coordinates2","lon1","lon2","lat1","lat2","a","Math","sin","cos","b","atan2","bear"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/bearing/dist/es/index.js"],"sourcesContent":["import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\r\nimport { getCoord } from \"@turf/invariant\";\r\n// http://en.wikipedia.org/wiki/Haversine_formula\r\n// http://www.movable-type.co.uk/scripts/latlong.html\r\n/**\r\n * Takes two {@link Point|points} and finds the geographic bearing between them,\r\n * i.e. the angle measured in degrees from the north line (0 degrees)\r\n *\r\n * @name bearing\r\n * @param {Coord} start starting Point\r\n * @param {Coord} end ending Point\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.final=false] calculates the final bearing if true\r\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\r\n * @example\r\n * var point1 = turf.point([-75.343, 39.984]);\r\n * var point2 = turf.point([-75.534, 39.123]);\r\n *\r\n * var bearing = turf.bearing(point1, point2);\r\n *\r\n * //addToMap\r\n * var addToMap = [point1, point2]\r\n * point1.properties['marker-color'] = '#f00'\r\n * point2.properties['marker-color'] = '#0f0'\r\n * point1.properties.bearing = bearing\r\n */\r\nexport default function bearing(start, end, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Reverse calculation\r\n    if (options.final === true) {\r\n        return calculateFinalBearing(start, end);\r\n    }\r\n    var coordinates1 = getCoord(start);\r\n    var coordinates2 = getCoord(end);\r\n    var lon1 = degreesToRadians(coordinates1[0]);\r\n    var lon2 = degreesToRadians(coordinates2[0]);\r\n    var lat1 = degreesToRadians(coordinates1[1]);\r\n    var lat2 = degreesToRadians(coordinates2[1]);\r\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\r\n    var b = Math.cos(lat1) * Math.sin(lat2) -\r\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\r\n    return radiansToDegrees(Math.atan2(a, b));\r\n}\r\n/**\r\n * Calculates Final Bearing\r\n *\r\n * @private\r\n * @param {Coord} start starting Point\r\n * @param {Coord} end ending Point\r\n * @returns {number} bearing\r\n */\r\nfunction calculateFinalBearing(start, end) {\r\n    // Swap start & end\r\n    var bear = bearing(end, start);\r\n    bear = (bear + 180) % 360;\r\n    return bear;\r\n}\r\n"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,gBAA3B,QAAmD,eAAnD;AACA,SAASC,QAAT,QAAyB,iBAAzB,C,CACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,OAAT,CAAiBC,KAAjB,EAAwBC,GAAxB,EAA6BC,OAA7B,EAAsC;EACjD,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe,CADQ,CAEjD;;;EACA,IAAIA,OAAO,CAACC,KAAR,KAAkB,IAAtB,EAA4B;IACxB,OAAOC,qBAAqB,CAACJ,KAAD,EAAQC,GAAR,CAA5B;EACH;;EACD,IAAII,YAAY,GAAGP,QAAQ,CAACE,KAAD,CAA3B;EACA,IAAIM,YAAY,GAAGR,QAAQ,CAACG,GAAD,CAA3B;EACA,IAAIM,IAAI,GAAGX,gBAAgB,CAACS,YAAY,CAAC,CAAD,CAAb,CAA3B;EACA,IAAIG,IAAI,GAAGZ,gBAAgB,CAACU,YAAY,CAAC,CAAD,CAAb,CAA3B;EACA,IAAIG,IAAI,GAAGb,gBAAgB,CAACS,YAAY,CAAC,CAAD,CAAb,CAA3B;EACA,IAAIK,IAAI,GAAGd,gBAAgB,CAACU,YAAY,CAAC,CAAD,CAAb,CAA3B;EACA,IAAIK,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASL,IAAI,GAAGD,IAAhB,IAAwBK,IAAI,CAACE,GAAL,CAASJ,IAAT,CAAhC;EACA,IAAIK,CAAC,GAAGH,IAAI,CAACE,GAAL,CAASL,IAAT,IAAiBG,IAAI,CAACC,GAAL,CAASH,IAAT,CAAjB,GACJE,IAAI,CAACC,GAAL,CAASJ,IAAT,IAAiBG,IAAI,CAACE,GAAL,CAASJ,IAAT,CAAjB,GAAkCE,IAAI,CAACE,GAAL,CAASN,IAAI,GAAGD,IAAhB,CADtC;EAEA,OAAOV,gBAAgB,CAACe,IAAI,CAACI,KAAL,CAAWL,CAAX,EAAcI,CAAd,CAAD,CAAvB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASX,qBAAT,CAA+BJ,KAA/B,EAAsCC,GAAtC,EAA2C;EACvC;EACA,IAAIgB,IAAI,GAAGlB,OAAO,CAACE,GAAD,EAAMD,KAAN,CAAlB;EACAiB,IAAI,GAAG,CAACA,IAAI,GAAG,GAAR,IAAe,GAAtB;EACA,OAAOA,IAAP;AACH"},"metadata":{},"sourceType":"module"}