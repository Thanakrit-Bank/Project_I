{"ast":null,"code":"import { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\"; // To-Do => Improve Typescript GeoJSON handling\n\n/**\r\n * Removes redundant coordinates from any GeoJSON Geometry.\r\n *\r\n * @name cleanCoords\r\n * @param {Geometry|Feature} geojson Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\r\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\r\n * @example\r\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\r\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\r\n *\r\n * turf.cleanCoords(line).geometry.coordinates;\r\n * //= [[0, 0], [0, 10]]\r\n *\r\n * turf.cleanCoords(multiPoint).geometry.coordinates;\r\n * //= [[0, 0], [2, 2]]\r\n */\n\nfunction cleanCoords(geojson, options) {\n  if (options === void 0) {\n    options = {};\n  } // Backwards compatible with v4.0\n\n\n  var mutate = typeof options === \"object\" ? options.mutate : options;\n  if (!geojson) throw new Error(\"geojson is required\");\n  var type = getType(geojson); // Store new \"clean\" points in this Array\n\n  var newCoords = [];\n\n  switch (type) {\n    case \"LineString\":\n      newCoords = cleanLine(geojson);\n      break;\n\n    case \"MultiLineString\":\n    case \"Polygon\":\n      getCoords(geojson).forEach(function (line) {\n        newCoords.push(cleanLine(line));\n      });\n      break;\n\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (polygons) {\n        var polyPoints = [];\n        polygons.forEach(function (ring) {\n          polyPoints.push(cleanLine(ring));\n        });\n        newCoords.push(polyPoints);\n      });\n      break;\n\n    case \"Point\":\n      return geojson;\n\n    case \"MultiPoint\":\n      var existing = {};\n      getCoords(geojson).forEach(function (coord) {\n        var key = coord.join(\"-\");\n\n        if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n          newCoords.push(coord);\n          existing[key] = true;\n        }\n      });\n      break;\n\n    default:\n      throw new Error(type + \" geometry not supported\");\n  } // Support input mutation\n\n\n  if (geojson.coordinates) {\n    if (mutate === true) {\n      geojson.coordinates = newCoords;\n      return geojson;\n    }\n\n    return {\n      type: type,\n      coordinates: newCoords\n    };\n  } else {\n    if (mutate === true) {\n      geojson.geometry.coordinates = newCoords;\n      return geojson;\n    }\n\n    return feature({\n      type: type,\n      coordinates: newCoords\n    }, geojson.properties, {\n      bbox: geojson.bbox,\n      id: geojson.id\n    });\n  }\n}\n/**\r\n * Clean Coords\r\n *\r\n * @private\r\n * @param {Array<number>|LineString} line Line\r\n * @returns {Array<number>} Cleaned coordinates\r\n */\n\n\nfunction cleanLine(line) {\n  var points = getCoords(line); // handle \"clean\" segment\n\n  if (points.length === 2 && !equals(points[0], points[1])) return points;\n  var newPoints = [];\n  var secondToLast = points.length - 1;\n  var newPointsLength = newPoints.length;\n  newPoints.push(points[0]);\n\n  for (var i = 1; i < secondToLast; i++) {\n    var prevAddedPoint = newPoints[newPoints.length - 1];\n    if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;else {\n      newPoints.push(points[i]);\n      newPointsLength = newPoints.length;\n\n      if (newPointsLength > 2) {\n        if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n      }\n    }\n  }\n\n  newPoints.push(points[points.length - 1]);\n  newPointsLength = newPoints.length;\n  if (equals(points[0], points[points.length - 1]) && newPointsLength < 4) throw new Error(\"invalid polygon\");\n  if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n  return newPoints;\n}\n/**\r\n * Compares two points and returns if they are equals\r\n *\r\n * @private\r\n * @param {Position} pt1 point\r\n * @param {Position} pt2 point\r\n * @returns {boolean} true if they are equals\r\n */\n\n\nfunction equals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n/**\r\n * Returns if `point` is on the segment between `start` and `end`.\r\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\r\n *\r\n * @private\r\n * @param {Position} start coord pair of start of line\r\n * @param {Position} end coord pair of end of line\r\n * @param {Position} point coord pair of point to check\r\n * @returns {boolean} true/false\r\n */\n\n\nfunction isPointOnLineSegment(start, end, point) {\n  var x = point[0],\n      y = point[1];\n  var startX = start[0],\n      startY = start[1];\n  var endX = end[0],\n      endY = end[1];\n  var dxc = x - startX;\n  var dyc = y - startY;\n  var dxl = endX - startX;\n  var dyl = endY - startY;\n  var cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\n\nexport default cleanCoords;","map":{"version":3,"names":["feature","getCoords","getType","cleanCoords","geojson","options","mutate","Error","type","newCoords","cleanLine","forEach","line","push","polygons","polyPoints","ring","existing","coord","key","join","Object","prototype","hasOwnProperty","call","coordinates","geometry","properties","bbox","id","points","length","equals","newPoints","secondToLast","newPointsLength","i","prevAddedPoint","isPointOnLineSegment","splice","pt1","pt2","start","end","point","x","y","startX","startY","endX","endY","dxc","dyc","dxl","dyl","cross","Math","abs"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/clean-coords/dist/es/index.js"],"sourcesContent":["import { feature } from \"@turf/helpers\";\r\nimport { getCoords, getType } from \"@turf/invariant\";\r\n// To-Do => Improve Typescript GeoJSON handling\r\n/**\r\n * Removes redundant coordinates from any GeoJSON Geometry.\r\n *\r\n * @name cleanCoords\r\n * @param {Geometry|Feature} geojson Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\r\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\r\n * @example\r\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\r\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\r\n *\r\n * turf.cleanCoords(line).geometry.coordinates;\r\n * //= [[0, 0], [0, 10]]\r\n *\r\n * turf.cleanCoords(multiPoint).geometry.coordinates;\r\n * //= [[0, 0], [2, 2]]\r\n */\r\nfunction cleanCoords(geojson, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Backwards compatible with v4.0\r\n    var mutate = typeof options === \"object\" ? options.mutate : options;\r\n    if (!geojson)\r\n        throw new Error(\"geojson is required\");\r\n    var type = getType(geojson);\r\n    // Store new \"clean\" points in this Array\r\n    var newCoords = [];\r\n    switch (type) {\r\n        case \"LineString\":\r\n            newCoords = cleanLine(geojson);\r\n            break;\r\n        case \"MultiLineString\":\r\n        case \"Polygon\":\r\n            getCoords(geojson).forEach(function (line) {\r\n                newCoords.push(cleanLine(line));\r\n            });\r\n            break;\r\n        case \"MultiPolygon\":\r\n            getCoords(geojson).forEach(function (polygons) {\r\n                var polyPoints = [];\r\n                polygons.forEach(function (ring) {\r\n                    polyPoints.push(cleanLine(ring));\r\n                });\r\n                newCoords.push(polyPoints);\r\n            });\r\n            break;\r\n        case \"Point\":\r\n            return geojson;\r\n        case \"MultiPoint\":\r\n            var existing = {};\r\n            getCoords(geojson).forEach(function (coord) {\r\n                var key = coord.join(\"-\");\r\n                if (!Object.prototype.hasOwnProperty.call(existing, key)) {\r\n                    newCoords.push(coord);\r\n                    existing[key] = true;\r\n                }\r\n            });\r\n            break;\r\n        default:\r\n            throw new Error(type + \" geometry not supported\");\r\n    }\r\n    // Support input mutation\r\n    if (geojson.coordinates) {\r\n        if (mutate === true) {\r\n            geojson.coordinates = newCoords;\r\n            return geojson;\r\n        }\r\n        return { type: type, coordinates: newCoords };\r\n    }\r\n    else {\r\n        if (mutate === true) {\r\n            geojson.geometry.coordinates = newCoords;\r\n            return geojson;\r\n        }\r\n        return feature({ type: type, coordinates: newCoords }, geojson.properties, {\r\n            bbox: geojson.bbox,\r\n            id: geojson.id,\r\n        });\r\n    }\r\n}\r\n/**\r\n * Clean Coords\r\n *\r\n * @private\r\n * @param {Array<number>|LineString} line Line\r\n * @returns {Array<number>} Cleaned coordinates\r\n */\r\nfunction cleanLine(line) {\r\n    var points = getCoords(line);\r\n    // handle \"clean\" segment\r\n    if (points.length === 2 && !equals(points[0], points[1]))\r\n        return points;\r\n    var newPoints = [];\r\n    var secondToLast = points.length - 1;\r\n    var newPointsLength = newPoints.length;\r\n    newPoints.push(points[0]);\r\n    for (var i = 1; i < secondToLast; i++) {\r\n        var prevAddedPoint = newPoints[newPoints.length - 1];\r\n        if (points[i][0] === prevAddedPoint[0] &&\r\n            points[i][1] === prevAddedPoint[1])\r\n            continue;\r\n        else {\r\n            newPoints.push(points[i]);\r\n            newPointsLength = newPoints.length;\r\n            if (newPointsLength > 2) {\r\n                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\r\n                    newPoints.splice(newPoints.length - 2, 1);\r\n            }\r\n        }\r\n    }\r\n    newPoints.push(points[points.length - 1]);\r\n    newPointsLength = newPoints.length;\r\n    if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)\r\n        throw new Error(\"invalid polygon\");\r\n    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\r\n        newPoints.splice(newPoints.length - 2, 1);\r\n    return newPoints;\r\n}\r\n/**\r\n * Compares two points and returns if they are equals\r\n *\r\n * @private\r\n * @param {Position} pt1 point\r\n * @param {Position} pt2 point\r\n * @returns {boolean} true if they are equals\r\n */\r\nfunction equals(pt1, pt2) {\r\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\r\n}\r\n/**\r\n * Returns if `point` is on the segment between `start` and `end`.\r\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\r\n *\r\n * @private\r\n * @param {Position} start coord pair of start of line\r\n * @param {Position} end coord pair of end of line\r\n * @param {Position} point coord pair of point to check\r\n * @returns {boolean} true/false\r\n */\r\nfunction isPointOnLineSegment(start, end, point) {\r\n    var x = point[0], y = point[1];\r\n    var startX = start[0], startY = start[1];\r\n    var endX = end[0], endY = end[1];\r\n    var dxc = x - startX;\r\n    var dyc = y - startY;\r\n    var dxl = endX - startX;\r\n    var dyl = endY - startY;\r\n    var cross = dxc * dyl - dyc * dxl;\r\n    if (cross !== 0)\r\n        return false;\r\n    else if (Math.abs(dxl) >= Math.abs(dyl))\r\n        return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;\r\n    else\r\n        return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\r\n}\r\nexport default cleanCoords;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}