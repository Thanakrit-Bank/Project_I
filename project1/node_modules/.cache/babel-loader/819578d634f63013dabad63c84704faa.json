{"ast":null,"code":"import centerMean from \"@turf/center-mean\";\nimport distance from \"@turf/distance\";\nimport centroid from \"@turf/centroid\";\nimport { isNumber, point, isObject, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\n/**\r\n * Takes a {@link FeatureCollection} of points and calculates the median center,\r\n * algorithimically. The median center is understood as the point that is\r\n * requires the least total travel from all other points.\r\n *\r\n * Turfjs has four different functions for calculating the center of a set of\r\n * data. Each is useful depending on circumstance.\r\n *\r\n * `@turf/center` finds the simple center of a dataset, by finding the\r\n * midpoint between the extents of the data. That is, it divides in half the\r\n * farthest east and farthest west point as well as the farthest north and\r\n * farthest south.\r\n *\r\n * `@turf/center-of-mass` imagines that the dataset is a sheet of paper.\r\n * The center of mass is where the sheet would balance on a fingertip.\r\n *\r\n * `@turf/center-mean` takes the averages of all the coordinates and\r\n * produces a value that respects that. Unlike `@turf/center`, it is\r\n * sensitive to clusters and outliers. It lands in the statistical middle of a\r\n * dataset, not the geographical. It can also be weighted, meaning certain\r\n * points are more important than others.\r\n *\r\n * `@turf/center-median` takes the mean center and tries to find, iteratively,\r\n * a new point that requires the least amount of travel from all the points in\r\n * the dataset. It is not as sensitive to outliers as `@turf/center-mean`, but it is\r\n * attracted to clustered data. It, too, can be weighted.\r\n *\r\n * **Bibliography**\r\n *\r\n * Harold W. Kuhn and Robert E. Kuenne, “An Efficient Algorithm for the\r\n * Numerical Solution of the Generalized Weber Problem in Spatial\r\n * Economics,” _Journal of Regional Science_ 4, no. 2 (1962): 21–33,\r\n * doi:{@link https://doi.org/10.1111/j.1467-9787.1962.tb00902.x}.\r\n *\r\n * James E. Burt, Gerald M. Barber, and David L. Rigby, _Elementary\r\n * Statistics for Geographers_, 3rd ed., New York: The Guilford\r\n * Press, 2009, 150–151.\r\n *\r\n * @name centerMedian\r\n * @param {FeatureCollection<any>} features Any GeoJSON Feature Collection\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.weight] the property name used to weight the center\r\n * @param {number} [options.tolerance=0.001] the difference in distance between candidate medians at which point the algorighim stops iterating.\r\n * @param {number} [options.counter=10] how many attempts to find the median, should the tolerance be insufficient.\r\n * @returns {Feature<Point>} The median center of the collection\r\n * @example\r\n * var points = turf.points([[0, 0], [1, 0], [0, 1], [5, 8]]);\r\n * var medianCenter = turf.centerMedian(points);\r\n *\r\n * //addToMap\r\n * var addToMap = [points, medianCenter]\r\n */\n\nfunction centerMedian(features, options) {\n  if (options === void 0) {\n    options = {};\n  } // Optional params\n\n\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var counter = options.counter || 10;\n  if (!isNumber(counter)) throw new Error(\"counter must be a number\");\n  var weightTerm = options.weight; // Calculate mean center:\n\n  var meanCenter = centerMean(features, {\n    weight: options.weight\n  }); // Calculate center of every feature:\n\n  var centroids = featureCollection([]);\n  featureEach(features, function (feature) {\n    var _a;\n\n    centroids.features.push(centroid(feature, {\n      properties: {\n        weight: (_a = feature.properties) === null || _a === void 0 ? void 0 : _a[weightTerm]\n      }\n    }));\n  });\n  var properties = {\n    tolerance: options.tolerance,\n    medianCandidates: []\n  };\n  return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);\n}\n/**\r\n * Recursive function to find new candidate medians.\r\n *\r\n * @private\r\n * @param {Position} candidateMedian current candidate median\r\n * @param {Position} previousCandidate the previous candidate median\r\n * @param {FeatureCollection<Point>} centroids the collection of centroids whose median we are determining\r\n * @param {number} counter how many attempts to try before quitting.\r\n * @returns {Feature<Point>} the median center of the dataset.\r\n */\n\n\nfunction findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {\n  var tolerance = properties.tolerance || 0.001;\n  var candidateXsum = 0;\n  var candidateYsum = 0;\n  var kSum = 0;\n  var centroidCount = 0;\n  featureEach(centroids, function (theCentroid) {\n    var _a;\n\n    var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;\n    var weight = weightValue === undefined || weightValue === null ? 1 : weightValue;\n    weight = Number(weight);\n    if (!isNumber(weight)) throw new Error(\"weight value must be a number\");\n\n    if (weight > 0) {\n      centroidCount += 1;\n      var distanceFromCandidate = weight * distance(theCentroid, candidateMedian);\n      if (distanceFromCandidate === 0) distanceFromCandidate = 1;\n      var k = weight / distanceFromCandidate;\n      candidateXsum += theCentroid.geometry.coordinates[0] * k;\n      candidateYsum += theCentroid.geometry.coordinates[1] * k;\n      kSum += k;\n    }\n  });\n  if (centroidCount < 1) throw new Error(\"no features to measure\");\n  var candidateX = candidateXsum / kSum;\n  var candidateY = candidateYsum / kSum;\n\n  if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {\n    return point([candidateX, candidateY], {\n      medianCandidates: properties.medianCandidates\n    });\n  } else {\n    properties.medianCandidates.push([candidateX, candidateY]);\n    return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);\n  }\n}\n\nexport default centerMedian;","map":{"version":3,"names":["centerMean","distance","centroid","isNumber","point","isObject","featureCollection","featureEach","centerMedian","features","options","Error","counter","weightTerm","weight","meanCenter","centroids","feature","_a","push","properties","tolerance","medianCandidates","findMedian","geometry","coordinates","candidateMedian","previousCandidate","candidateXsum","candidateYsum","kSum","centroidCount","theCentroid","weightValue","undefined","Number","distanceFromCandidate","k","candidateX","candidateY","Math","abs"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/center-median/dist/es/index.js"],"sourcesContent":["import centerMean from \"@turf/center-mean\";\r\nimport distance from \"@turf/distance\";\r\nimport centroid from \"@turf/centroid\";\r\nimport { isNumber, point, isObject, featureCollection, } from \"@turf/helpers\";\r\nimport { featureEach } from \"@turf/meta\";\r\n/**\r\n * Takes a {@link FeatureCollection} of points and calculates the median center,\r\n * algorithimically. The median center is understood as the point that is\r\n * requires the least total travel from all other points.\r\n *\r\n * Turfjs has four different functions for calculating the center of a set of\r\n * data. Each is useful depending on circumstance.\r\n *\r\n * `@turf/center` finds the simple center of a dataset, by finding the\r\n * midpoint between the extents of the data. That is, it divides in half the\r\n * farthest east and farthest west point as well as the farthest north and\r\n * farthest south.\r\n *\r\n * `@turf/center-of-mass` imagines that the dataset is a sheet of paper.\r\n * The center of mass is where the sheet would balance on a fingertip.\r\n *\r\n * `@turf/center-mean` takes the averages of all the coordinates and\r\n * produces a value that respects that. Unlike `@turf/center`, it is\r\n * sensitive to clusters and outliers. It lands in the statistical middle of a\r\n * dataset, not the geographical. It can also be weighted, meaning certain\r\n * points are more important than others.\r\n *\r\n * `@turf/center-median` takes the mean center and tries to find, iteratively,\r\n * a new point that requires the least amount of travel from all the points in\r\n * the dataset. It is not as sensitive to outliers as `@turf/center-mean`, but it is\r\n * attracted to clustered data. It, too, can be weighted.\r\n *\r\n * **Bibliography**\r\n *\r\n * Harold W. Kuhn and Robert E. Kuenne, “An Efficient Algorithm for the\r\n * Numerical Solution of the Generalized Weber Problem in Spatial\r\n * Economics,” _Journal of Regional Science_ 4, no. 2 (1962): 21–33,\r\n * doi:{@link https://doi.org/10.1111/j.1467-9787.1962.tb00902.x}.\r\n *\r\n * James E. Burt, Gerald M. Barber, and David L. Rigby, _Elementary\r\n * Statistics for Geographers_, 3rd ed., New York: The Guilford\r\n * Press, 2009, 150–151.\r\n *\r\n * @name centerMedian\r\n * @param {FeatureCollection<any>} features Any GeoJSON Feature Collection\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.weight] the property name used to weight the center\r\n * @param {number} [options.tolerance=0.001] the difference in distance between candidate medians at which point the algorighim stops iterating.\r\n * @param {number} [options.counter=10] how many attempts to find the median, should the tolerance be insufficient.\r\n * @returns {Feature<Point>} The median center of the collection\r\n * @example\r\n * var points = turf.points([[0, 0], [1, 0], [0, 1], [5, 8]]);\r\n * var medianCenter = turf.centerMedian(points);\r\n *\r\n * //addToMap\r\n * var addToMap = [points, medianCenter]\r\n */\r\nfunction centerMedian(features, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Optional params\r\n    options = options || {};\r\n    if (!isObject(options))\r\n        throw new Error(\"options is invalid\");\r\n    var counter = options.counter || 10;\r\n    if (!isNumber(counter))\r\n        throw new Error(\"counter must be a number\");\r\n    var weightTerm = options.weight;\r\n    // Calculate mean center:\r\n    var meanCenter = centerMean(features, { weight: options.weight });\r\n    // Calculate center of every feature:\r\n    var centroids = featureCollection([]);\r\n    featureEach(features, function (feature) {\r\n        var _a;\r\n        centroids.features.push(centroid(feature, {\r\n            properties: { weight: (_a = feature.properties) === null || _a === void 0 ? void 0 : _a[weightTerm] },\r\n        }));\r\n    });\r\n    var properties = {\r\n        tolerance: options.tolerance,\r\n        medianCandidates: [],\r\n    };\r\n    return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);\r\n}\r\n/**\r\n * Recursive function to find new candidate medians.\r\n *\r\n * @private\r\n * @param {Position} candidateMedian current candidate median\r\n * @param {Position} previousCandidate the previous candidate median\r\n * @param {FeatureCollection<Point>} centroids the collection of centroids whose median we are determining\r\n * @param {number} counter how many attempts to try before quitting.\r\n * @returns {Feature<Point>} the median center of the dataset.\r\n */\r\nfunction findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {\r\n    var tolerance = properties.tolerance || 0.001;\r\n    var candidateXsum = 0;\r\n    var candidateYsum = 0;\r\n    var kSum = 0;\r\n    var centroidCount = 0;\r\n    featureEach(centroids, function (theCentroid) {\r\n        var _a;\r\n        var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;\r\n        var weight = weightValue === undefined || weightValue === null ? 1 : weightValue;\r\n        weight = Number(weight);\r\n        if (!isNumber(weight))\r\n            throw new Error(\"weight value must be a number\");\r\n        if (weight > 0) {\r\n            centroidCount += 1;\r\n            var distanceFromCandidate = weight * distance(theCentroid, candidateMedian);\r\n            if (distanceFromCandidate === 0)\r\n                distanceFromCandidate = 1;\r\n            var k = weight / distanceFromCandidate;\r\n            candidateXsum += theCentroid.geometry.coordinates[0] * k;\r\n            candidateYsum += theCentroid.geometry.coordinates[1] * k;\r\n            kSum += k;\r\n        }\r\n    });\r\n    if (centroidCount < 1)\r\n        throw new Error(\"no features to measure\");\r\n    var candidateX = candidateXsum / kSum;\r\n    var candidateY = candidateYsum / kSum;\r\n    if (centroidCount === 1 ||\r\n        counter === 0 ||\r\n        (Math.abs(candidateX - previousCandidate[0]) < tolerance &&\r\n            Math.abs(candidateY - previousCandidate[1]) < tolerance)) {\r\n        return point([candidateX, candidateY], {\r\n            medianCandidates: properties.medianCandidates,\r\n        });\r\n    }\r\n    else {\r\n        properties.medianCandidates.push([candidateX, candidateY]);\r\n        return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);\r\n    }\r\n}\r\nexport default centerMedian;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}