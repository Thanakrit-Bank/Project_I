{"ast":null,"code":"import center from '@turf/center';\nimport { GeoJSONReader, BufferOp, GeoJSONWriter } from 'turf-jsts';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { geoAzimuthalEquidistant } from 'd3-geo';\nimport { featureCollection, earthRadius, radiansToLength, lengthToRadians, feature } from '@turf/helpers';\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=8] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\n\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {}; // use user supplied options or default values\n\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8; // validation\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\"); // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n\n  if (radius === undefined) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n  var results = [];\n\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        var multiBuffered = bufferFeature(feature, radius, units, steps);\n\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n\n  return bufferFeature(geojson, radius, units, steps);\n}\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=8] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\n\n\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson; // Geometry Types faster than jsts\n\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  } // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)\n\n\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection)\n  }; // JSTS buffer operation\n\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered); // Detect if empty geometries\n\n  if (coordsIsNaN(buffered.coordinates)) return undefined; // Unproject coordinates (convert to Degrees)\n\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection)\n  };\n  return feature(result, properties);\n}\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\n\n\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\n\n\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\n\n\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n/**\n * Define Azimuthal Equidistant projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection\n */\n\n\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\n\nexport default buffer;","map":{"version":3,"names":["center","GeoJSONReader","BufferOp","GeoJSONWriter","featureEach","geomEach","geoAzimuthalEquidistant","featureCollection","earthRadius","radiansToLength","lengthToRadians","feature","buffer","geojson","radius","options","units","steps","Error","undefined","results","type","geometry","buffered","bufferFeature","push","multiBuffered","properties","projection","defineProjection","projected","coordinates","projectCoords","reader","geom","read","distance","bufferOp","writer","write","coordsIsNaN","result","unprojectCoords","coords","Array","isArray","isNaN","proj","map","coord","invert","rotation","rotate","scale"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/buffer/dist/es/index.js"],"sourcesContent":["import center from '@turf/center';\nimport { GeoJSONReader, BufferOp, GeoJSONWriter } from 'turf-jsts';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { geoAzimuthalEquidistant } from 'd3-geo';\nimport { featureCollection, earthRadius, radiansToLength, lengthToRadians, feature } from '@turf/helpers';\n\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=8] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {};\n\n  // use user supplied options or default values\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8;\n\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\");\n\n  // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n  if (radius === undefined) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        var multiBuffered = bufferFeature(feature, radius, units, steps);\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n  return bufferFeature(geojson, radius, units, steps);\n}\n\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=8] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson;\n\n  // Geometry Types faster than jsts\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  }\n\n  // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection),\n  };\n\n  // JSTS buffer operation\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered);\n\n  // Detect if empty geometries\n  if (coordsIsNaN(buffered.coordinates)) return undefined;\n\n  // Unproject coordinates (convert to Degrees)\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection),\n  };\n\n  return feature(result, properties);\n}\n\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n\n/**\n * Define Azimuthal Equidistant projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection\n */\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\n\nexport default buffer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}