{"ast":null,"code":"import Node from \"./Node.js\";\nimport Edge from \"./Edge.js\";\nimport EdgeRing from \"./EdgeRing.js\";\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\n/**\n * Validates the geoJson.\n *\n * @param {GeoJSON} geoJson - input geoJson.\n * @throws {Error} if geoJson is invalid.\n */\n\nfunction validateGeoJson(geoJson) {\n  if (!geoJson) throw new Error(\"No geojson passed\");\n  if (geoJson.type !== \"FeatureCollection\" && geoJson.type !== \"GeometryCollection\" && geoJson.type !== \"MultiLineString\" && geoJson.type !== \"LineString\" && geoJson.type !== \"Feature\") throw new Error(\"Invalid input type '\" + geoJson.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\n}\n/**\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\n *\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\n * isn't a javascript transcription of the C++ source.\n *\n * This graph is directed (both directions are created)\n */\n\n\nvar Graph =\n/** @class */\nfunction () {\n  function Graph() {\n    this.edges = []; //< {Edge[]} dirEdges\n    // The key is the `id` of the Node (ie: coordinates.join(','))\n\n    this.nodes = {};\n  }\n  /**\n   * Creates a graph from a GeoJSON.\n   *\n   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n   * @returns {Graph} - The newly created graph\n   * @throws {Error} if geoJson is invalid.\n   */\n\n\n  Graph.fromGeoJson = function (geoJson) {\n    validateGeoJson(geoJson);\n    var graph = new Graph();\n    flattenEach(geoJson, function (feature) {\n      featureOf(feature, \"LineString\", \"Graph::fromGeoJson\"); // When a LineString if formed by many segments, split them\n\n      coordReduce(feature, function (prev, cur) {\n        if (prev) {\n          var start = graph.getNode(prev),\n              end = graph.getNode(cur);\n          graph.addEdge(start, end);\n        }\n\n        return cur;\n      });\n    });\n    return graph;\n  };\n  /**\n   * Creates or get a Node.\n   *\n   * @param {number[]} coordinates - Coordinates of the node\n   * @returns {Node} - The created or stored node\n   */\n\n\n  Graph.prototype.getNode = function (coordinates) {\n    var id = Node.buildId(coordinates);\n    var node = this.nodes[id];\n    if (!node) node = this.nodes[id] = new Node(coordinates);\n    return node;\n  };\n  /**\n   * Adds an Edge and its symetricall.\n   *\n   * Edges are added symetrically, i.e.: we also add its symetric\n   *\n   * @param {Node} from - Node which starts the Edge\n   * @param {Node} to - Node which ends the Edge\n   */\n\n\n  Graph.prototype.addEdge = function (from, to) {\n    var edge = new Edge(from, to),\n        symetricEdge = edge.getSymetric();\n    this.edges.push(edge);\n    this.edges.push(symetricEdge);\n  };\n  /**\n   * Removes Dangle Nodes (nodes with grade 1).\n   */\n\n\n  Graph.prototype.deleteDangles = function () {\n    var _this = this;\n\n    Object.keys(this.nodes).map(function (id) {\n      return _this.nodes[id];\n    }).forEach(function (node) {\n      return _this._removeIfDangle(node);\n    });\n  };\n  /**\n   * Check if node is dangle, if so, remove it.\n   *\n   * It calls itself recursively, removing a dangling node might cause another dangling node\n   *\n   * @param {Node} node - Node to check if it's a dangle\n   */\n\n\n  Graph.prototype._removeIfDangle = function (node) {\n    var _this = this; // As edges are directed and symetrical, we count only innerEdges\n\n\n    if (node.innerEdges.length <= 1) {\n      var outerNodes = node.getOuterEdges().map(function (e) {\n        return e.to;\n      });\n      this.removeNode(node);\n      outerNodes.forEach(function (n) {\n        return _this._removeIfDangle(n);\n      });\n    }\n  };\n  /**\n   * Delete cut-edges (bridge edges).\n   *\n   * The graph will be traversed, all the edges will be labeled according the ring\n   * in which they are. (The label is a number incremented by 1). Edges with the same\n   * label are cut-edges.\n   */\n\n\n  Graph.prototype.deleteCutEdges = function () {\n    var _this = this;\n\n    this._computeNextCWEdges();\n\n    this._findLabeledEdgeRings(); // Cut-edges (bridges) are edges where both edges have the same label\n\n\n    this.edges.forEach(function (edge) {\n      if (edge.label === edge.symetric.label) {\n        _this.removeEdge(edge.symetric);\n\n        _this.removeEdge(edge);\n      }\n    });\n  };\n  /**\n   * Set the `next` property of each Edge.\n   *\n   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n   * OuterEdges are sorted CCW.\n   *\n   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n   */\n\n\n  Graph.prototype._computeNextCWEdges = function (node) {\n    var _this = this;\n\n    if (typeof node === \"undefined\") {\n      Object.keys(this.nodes).forEach(function (id) {\n        return _this._computeNextCWEdges(_this.nodes[id]);\n      });\n    } else {\n      node.getOuterEdges().forEach(function (edge, i) {\n        node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n      });\n    }\n  };\n  /**\n   * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n   *\n   * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n   *\n   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n   * could be written in a more javascript way.\n   *\n   * @param {Node} node - Node\n   * @param {number} label - Ring's label\n   */\n\n\n  Graph.prototype._computeNextCCWEdges = function (node, label) {\n    var edges = node.getOuterEdges();\n    var firstOutDE, prevInDE;\n\n    for (var i = edges.length - 1; i >= 0; --i) {\n      var de = edges[i],\n          sym = de.symetric,\n          outDE = void 0,\n          inDE = void 0;\n      if (de.label === label) outDE = de;\n      if (sym.label === label) inDE = sym;\n      if (!outDE || !inDE) // This edge is not in edgering\n        continue;\n      if (inDE) prevInDE = inDE;\n\n      if (outDE) {\n        if (prevInDE) {\n          prevInDE.next = outDE;\n          prevInDE = undefined;\n        }\n\n        if (!firstOutDE) firstOutDE = outDE;\n      }\n    }\n\n    if (prevInDE) prevInDE.next = firstOutDE;\n  };\n  /**\n   * Finds rings and labels edges according to which rings are.\n   *\n   * The label is a number which is increased for each ring.\n   *\n   * @returns {Edge[]} edges that start rings\n   */\n\n\n  Graph.prototype._findLabeledEdgeRings = function () {\n    var edgeRingStarts = [];\n    var label = 0;\n    this.edges.forEach(function (edge) {\n      if (edge.label >= 0) return;\n      edgeRingStarts.push(edge);\n      var e = edge;\n\n      do {\n        e.label = label;\n        e = e.next;\n      } while (!edge.isEqual(e));\n\n      label++;\n    });\n    return edgeRingStarts;\n  };\n  /**\n   * Computes the EdgeRings formed by the edges in this graph.\n   *\n   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n   */\n\n\n  Graph.prototype.getEdgeRings = function () {\n    var _this = this;\n\n    this._computeNextCWEdges(); // Clear labels\n\n\n    this.edges.forEach(function (edge) {\n      edge.label = undefined;\n    });\n\n    this._findLabeledEdgeRings().forEach(function (edge) {\n      // convertMaximalToMinimalEdgeRings\n      _this._findIntersectionNodes(edge).forEach(function (node) {\n        _this._computeNextCCWEdges(node, edge.label);\n      });\n    });\n\n    var edgeRingList = []; // find all edgerings\n\n    this.edges.forEach(function (edge) {\n      if (edge.ring) return;\n      edgeRingList.push(_this._findEdgeRing(edge));\n    });\n    return edgeRingList;\n  };\n  /**\n   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n   *\n   * @param {Node} startEdge - Start Edge of the Ring\n   * @returns {Node[]} - intersection nodes\n   */\n\n\n  Graph.prototype._findIntersectionNodes = function (startEdge) {\n    var intersectionNodes = [];\n    var edge = startEdge;\n\n    var _loop_1 = function _loop_1() {\n      // getDegree\n      var degree = 0;\n      edge.from.getOuterEdges().forEach(function (e) {\n        if (e.label === startEdge.label) ++degree;\n      });\n      if (degree > 1) intersectionNodes.push(edge.from);\n      edge = edge.next;\n    };\n\n    do {\n      _loop_1();\n    } while (!startEdge.isEqual(edge));\n\n    return intersectionNodes;\n  };\n  /**\n   * Get the edge-ring which starts from the provided Edge.\n   *\n   * @param {Edge} startEdge - starting edge of the edge ring\n   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n   */\n\n\n  Graph.prototype._findEdgeRing = function (startEdge) {\n    var edge = startEdge;\n    var edgeRing = new EdgeRing();\n\n    do {\n      edgeRing.push(edge);\n      edge.ring = edgeRing;\n      edge = edge.next;\n    } while (!startEdge.isEqual(edge));\n\n    return edgeRing;\n  };\n  /**\n   * Removes a node from the Graph.\n   *\n   * It also removes edges asociated to that node\n   * @param {Node} node - Node to be removed\n   */\n\n\n  Graph.prototype.removeNode = function (node) {\n    var _this = this;\n\n    node.getOuterEdges().forEach(function (edge) {\n      return _this.removeEdge(edge);\n    });\n    node.innerEdges.forEach(function (edge) {\n      return _this.removeEdge(edge);\n    });\n    delete this.nodes[node.id];\n  };\n  /**\n   * Remove edge from the graph and deletes the edge.\n   *\n   * @param {Edge} edge - Edge to be removed\n   */\n\n\n  Graph.prototype.removeEdge = function (edge) {\n    this.edges = this.edges.filter(function (e) {\n      return !e.isEqual(edge);\n    });\n    edge.deleteEdge();\n  };\n\n  return Graph;\n}();\n\nexport default Graph;","map":{"version":3,"names":["Node","Edge","EdgeRing","flattenEach","coordReduce","featureOf","validateGeoJson","geoJson","Error","type","Graph","edges","nodes","fromGeoJson","graph","feature","prev","cur","start","getNode","end","addEdge","prototype","coordinates","id","buildId","node","from","to","edge","symetricEdge","getSymetric","push","deleteDangles","_this","Object","keys","map","forEach","_removeIfDangle","innerEdges","length","outerNodes","getOuterEdges","e","removeNode","n","deleteCutEdges","_computeNextCWEdges","_findLabeledEdgeRings","label","symetric","removeEdge","i","getOuterEdge","next","_computeNextCCWEdges","firstOutDE","prevInDE","de","sym","outDE","inDE","undefined","edgeRingStarts","isEqual","getEdgeRings","_findIntersectionNodes","edgeRingList","ring","_findEdgeRing","startEdge","intersectionNodes","_loop_1","degree","edgeRing","filter","deleteEdge"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/polygonize/dist/es/lib/Graph.js"],"sourcesContent":["import Node from \"./Node.js\";\nimport Edge from \"./Edge.js\";\nimport EdgeRing from \"./EdgeRing.js\";\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\n/**\n * Validates the geoJson.\n *\n * @param {GeoJSON} geoJson - input geoJson.\n * @throws {Error} if geoJson is invalid.\n */\nfunction validateGeoJson(geoJson) {\n    if (!geoJson)\n        throw new Error(\"No geojson passed\");\n    if (geoJson.type !== \"FeatureCollection\" &&\n        geoJson.type !== \"GeometryCollection\" &&\n        geoJson.type !== \"MultiLineString\" &&\n        geoJson.type !== \"LineString\" &&\n        geoJson.type !== \"Feature\")\n        throw new Error(\"Invalid input type '\" + geoJson.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\n}\n/**\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\n *\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\n * isn't a javascript transcription of the C++ source.\n *\n * This graph is directed (both directions are created)\n */\nvar Graph = /** @class */ (function () {\n    function Graph() {\n        this.edges = []; //< {Edge[]} dirEdges\n        // The key is the `id` of the Node (ie: coordinates.join(','))\n        this.nodes = {};\n    }\n    /**\n     * Creates a graph from a GeoJSON.\n     *\n     * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n     * @returns {Graph} - The newly created graph\n     * @throws {Error} if geoJson is invalid.\n     */\n    Graph.fromGeoJson = function (geoJson) {\n        validateGeoJson(geoJson);\n        var graph = new Graph();\n        flattenEach(geoJson, function (feature) {\n            featureOf(feature, \"LineString\", \"Graph::fromGeoJson\");\n            // When a LineString if formed by many segments, split them\n            coordReduce(feature, function (prev, cur) {\n                if (prev) {\n                    var start = graph.getNode(prev), end = graph.getNode(cur);\n                    graph.addEdge(start, end);\n                }\n                return cur;\n            });\n        });\n        return graph;\n    };\n    /**\n     * Creates or get a Node.\n     *\n     * @param {number[]} coordinates - Coordinates of the node\n     * @returns {Node} - The created or stored node\n     */\n    Graph.prototype.getNode = function (coordinates) {\n        var id = Node.buildId(coordinates);\n        var node = this.nodes[id];\n        if (!node)\n            node = this.nodes[id] = new Node(coordinates);\n        return node;\n    };\n    /**\n     * Adds an Edge and its symetricall.\n     *\n     * Edges are added symetrically, i.e.: we also add its symetric\n     *\n     * @param {Node} from - Node which starts the Edge\n     * @param {Node} to - Node which ends the Edge\n     */\n    Graph.prototype.addEdge = function (from, to) {\n        var edge = new Edge(from, to), symetricEdge = edge.getSymetric();\n        this.edges.push(edge);\n        this.edges.push(symetricEdge);\n    };\n    /**\n     * Removes Dangle Nodes (nodes with grade 1).\n     */\n    Graph.prototype.deleteDangles = function () {\n        var _this = this;\n        Object.keys(this.nodes)\n            .map(function (id) { return _this.nodes[id]; })\n            .forEach(function (node) { return _this._removeIfDangle(node); });\n    };\n    /**\n     * Check if node is dangle, if so, remove it.\n     *\n     * It calls itself recursively, removing a dangling node might cause another dangling node\n     *\n     * @param {Node} node - Node to check if it's a dangle\n     */\n    Graph.prototype._removeIfDangle = function (node) {\n        var _this = this;\n        // As edges are directed and symetrical, we count only innerEdges\n        if (node.innerEdges.length <= 1) {\n            var outerNodes = node.getOuterEdges().map(function (e) { return e.to; });\n            this.removeNode(node);\n            outerNodes.forEach(function (n) { return _this._removeIfDangle(n); });\n        }\n    };\n    /**\n     * Delete cut-edges (bridge edges).\n     *\n     * The graph will be traversed, all the edges will be labeled according the ring\n     * in which they are. (The label is a number incremented by 1). Edges with the same\n     * label are cut-edges.\n     */\n    Graph.prototype.deleteCutEdges = function () {\n        var _this = this;\n        this._computeNextCWEdges();\n        this._findLabeledEdgeRings();\n        // Cut-edges (bridges) are edges where both edges have the same label\n        this.edges.forEach(function (edge) {\n            if (edge.label === edge.symetric.label) {\n                _this.removeEdge(edge.symetric);\n                _this.removeEdge(edge);\n            }\n        });\n    };\n    /**\n     * Set the `next` property of each Edge.\n     *\n     * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n     * OuterEdges are sorted CCW.\n     *\n     * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n     */\n    Graph.prototype._computeNextCWEdges = function (node) {\n        var _this = this;\n        if (typeof node === \"undefined\") {\n            Object.keys(this.nodes).forEach(function (id) {\n                return _this._computeNextCWEdges(_this.nodes[id]);\n            });\n        }\n        else {\n            node.getOuterEdges().forEach(function (edge, i) {\n                node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n            });\n        }\n    };\n    /**\n     * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n     *\n     * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n     *\n     * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n     * could be written in a more javascript way.\n     *\n     * @param {Node} node - Node\n     * @param {number} label - Ring's label\n     */\n    Graph.prototype._computeNextCCWEdges = function (node, label) {\n        var edges = node.getOuterEdges();\n        var firstOutDE, prevInDE;\n        for (var i = edges.length - 1; i >= 0; --i) {\n            var de = edges[i], sym = de.symetric, outDE = void 0, inDE = void 0;\n            if (de.label === label)\n                outDE = de;\n            if (sym.label === label)\n                inDE = sym;\n            if (!outDE || !inDE)\n                // This edge is not in edgering\n                continue;\n            if (inDE)\n                prevInDE = inDE;\n            if (outDE) {\n                if (prevInDE) {\n                    prevInDE.next = outDE;\n                    prevInDE = undefined;\n                }\n                if (!firstOutDE)\n                    firstOutDE = outDE;\n            }\n        }\n        if (prevInDE)\n            prevInDE.next = firstOutDE;\n    };\n    /**\n     * Finds rings and labels edges according to which rings are.\n     *\n     * The label is a number which is increased for each ring.\n     *\n     * @returns {Edge[]} edges that start rings\n     */\n    Graph.prototype._findLabeledEdgeRings = function () {\n        var edgeRingStarts = [];\n        var label = 0;\n        this.edges.forEach(function (edge) {\n            if (edge.label >= 0)\n                return;\n            edgeRingStarts.push(edge);\n            var e = edge;\n            do {\n                e.label = label;\n                e = e.next;\n            } while (!edge.isEqual(e));\n            label++;\n        });\n        return edgeRingStarts;\n    };\n    /**\n     * Computes the EdgeRings formed by the edges in this graph.\n     *\n     * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n     */\n    Graph.prototype.getEdgeRings = function () {\n        var _this = this;\n        this._computeNextCWEdges();\n        // Clear labels\n        this.edges.forEach(function (edge) {\n            edge.label = undefined;\n        });\n        this._findLabeledEdgeRings().forEach(function (edge) {\n            // convertMaximalToMinimalEdgeRings\n            _this._findIntersectionNodes(edge).forEach(function (node) {\n                _this._computeNextCCWEdges(node, edge.label);\n            });\n        });\n        var edgeRingList = [];\n        // find all edgerings\n        this.edges.forEach(function (edge) {\n            if (edge.ring)\n                return;\n            edgeRingList.push(_this._findEdgeRing(edge));\n        });\n        return edgeRingList;\n    };\n    /**\n     * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n     *\n     * @param {Node} startEdge - Start Edge of the Ring\n     * @returns {Node[]} - intersection nodes\n     */\n    Graph.prototype._findIntersectionNodes = function (startEdge) {\n        var intersectionNodes = [];\n        var edge = startEdge;\n        var _loop_1 = function () {\n            // getDegree\n            var degree = 0;\n            edge.from.getOuterEdges().forEach(function (e) {\n                if (e.label === startEdge.label)\n                    ++degree;\n            });\n            if (degree > 1)\n                intersectionNodes.push(edge.from);\n            edge = edge.next;\n        };\n        do {\n            _loop_1();\n        } while (!startEdge.isEqual(edge));\n        return intersectionNodes;\n    };\n    /**\n     * Get the edge-ring which starts from the provided Edge.\n     *\n     * @param {Edge} startEdge - starting edge of the edge ring\n     * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n     */\n    Graph.prototype._findEdgeRing = function (startEdge) {\n        var edge = startEdge;\n        var edgeRing = new EdgeRing();\n        do {\n            edgeRing.push(edge);\n            edge.ring = edgeRing;\n            edge = edge.next;\n        } while (!startEdge.isEqual(edge));\n        return edgeRing;\n    };\n    /**\n     * Removes a node from the Graph.\n     *\n     * It also removes edges asociated to that node\n     * @param {Node} node - Node to be removed\n     */\n    Graph.prototype.removeNode = function (node) {\n        var _this = this;\n        node.getOuterEdges().forEach(function (edge) { return _this.removeEdge(edge); });\n        node.innerEdges.forEach(function (edge) { return _this.removeEdge(edge); });\n        delete this.nodes[node.id];\n    };\n    /**\n     * Remove edge from the graph and deletes the edge.\n     *\n     * @param {Edge} edge - Edge to be removed\n     */\n    Graph.prototype.removeEdge = function (edge) {\n        this.edges = this.edges.filter(function (e) { return !e.isEqual(edge); });\n        edge.deleteEdge();\n    };\n    return Graph;\n}());\nexport default Graph;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}