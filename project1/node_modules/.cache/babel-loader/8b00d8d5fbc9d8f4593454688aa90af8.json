{"ast":null,"code":"import bearing from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\n/**\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\n *\n * @name angle\n * @param {Coord} startPoint Start Point Coordinates\n * @param {Coord} midPoint Mid Point Coordinates\n * @param {Coord} endPoint End Point Coordinates\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\n * @returns {number} Angle between the provided points, or its explementary.\n * @example\n * turf.angle([5, 5], [5, 6], [3, 4]);\n * //=45\n */\n\nfunction angle(startPoint, midPoint, endPoint, options) {\n  if (options === void 0) {\n    options = {};\n  } // Optional Parameters\n\n\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  } // Validation\n\n\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  } // Rename to shorter variables\n\n\n  var A = startPoint;\n  var O = midPoint;\n  var B = endPoint; // Main\n\n  var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));\n  var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));\n  var angleAO = Math.abs(azimuthAO - azimuthBO); // Explementary angle\n\n  if (options.explementary === true) {\n    return 360 - angleAO;\n  }\n\n  return angleAO;\n}\n\nexport default angle;","map":{"version":3,"names":["bearing","bearingToAzimuth","isObject","rhumbBearing","angle","startPoint","midPoint","endPoint","options","Error","A","O","B","azimuthAO","mercator","azimuthBO","angleAO","Math","abs","explementary"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/angle/dist/es/index.js"],"sourcesContent":["import bearing from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\n/**\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\n *\n * @name angle\n * @param {Coord} startPoint Start Point Coordinates\n * @param {Coord} midPoint Mid Point Coordinates\n * @param {Coord} endPoint End Point Coordinates\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\n * @returns {number} Angle between the provided points, or its explementary.\n * @example\n * turf.angle([5, 5], [5, 6], [3, 4]);\n * //=45\n */\nfunction angle(startPoint, midPoint, endPoint, options) {\n    if (options === void 0) { options = {}; }\n    // Optional Parameters\n    if (!isObject(options)) {\n        throw new Error(\"options is invalid\");\n    }\n    // Validation\n    if (!startPoint) {\n        throw new Error(\"startPoint is required\");\n    }\n    if (!midPoint) {\n        throw new Error(\"midPoint is required\");\n    }\n    if (!endPoint) {\n        throw new Error(\"endPoint is required\");\n    }\n    // Rename to shorter variables\n    var A = startPoint;\n    var O = midPoint;\n    var B = endPoint;\n    // Main\n    var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));\n    var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));\n    var angleAO = Math.abs(azimuthAO - azimuthBO);\n    // Explementary angle\n    if (options.explementary === true) {\n        return 360 - angleAO;\n    }\n    return angleAO;\n}\nexport default angle;\n"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,eAApB;AACA,SAASC,gBAAT,EAA2BC,QAA3B,QAA2C,eAA3C;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,KAAT,CAAeC,UAAf,EAA2BC,QAA3B,EAAqCC,QAArC,EAA+CC,OAA/C,EAAwD;EACpD,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe,CADW,CAEpD;;;EACA,IAAI,CAACN,QAAQ,CAACM,OAAD,CAAb,EAAwB;IACpB,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;EACH,CALmD,CAMpD;;;EACA,IAAI,CAACJ,UAAL,EAAiB;IACb,MAAM,IAAII,KAAJ,CAAU,wBAAV,CAAN;EACH;;EACD,IAAI,CAACH,QAAL,EAAe;IACX,MAAM,IAAIG,KAAJ,CAAU,sBAAV,CAAN;EACH;;EACD,IAAI,CAACF,QAAL,EAAe;IACX,MAAM,IAAIE,KAAJ,CAAU,sBAAV,CAAN;EACH,CAfmD,CAgBpD;;;EACA,IAAIC,CAAC,GAAGL,UAAR;EACA,IAAIM,CAAC,GAAGL,QAAR;EACA,IAAIM,CAAC,GAAGL,QAAR,CAnBoD,CAoBpD;;EACA,IAAIM,SAAS,GAAGZ,gBAAgB,CAACO,OAAO,CAACM,QAAR,KAAqB,IAArB,GAA4Bd,OAAO,CAACU,CAAD,EAAIC,CAAJ,CAAnC,GAA4CR,YAAY,CAACO,CAAD,EAAIC,CAAJ,CAAzD,CAAhC;EACA,IAAII,SAAS,GAAGd,gBAAgB,CAACO,OAAO,CAACM,QAAR,KAAqB,IAArB,GAA4Bd,OAAO,CAACY,CAAD,EAAID,CAAJ,CAAnC,GAA4CR,YAAY,CAACS,CAAD,EAAID,CAAJ,CAAzD,CAAhC;EACA,IAAIK,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASL,SAAS,GAAGE,SAArB,CAAd,CAvBoD,CAwBpD;;EACA,IAAIP,OAAO,CAACW,YAAR,KAAyB,IAA7B,EAAmC;IAC/B,OAAO,MAAMH,OAAb;EACH;;EACD,OAAOA,OAAP;AACH;;AACD,eAAeZ,KAAf"},"metadata":{},"sourceType":"module"}