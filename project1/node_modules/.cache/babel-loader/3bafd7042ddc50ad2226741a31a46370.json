{"ast":null,"code":"import lineIntersect from \"@turf/line-intersect\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\nimport { point } from \"@turf/helpers\";\n/**\r\n * Boolean-Crosses returns True if the intersection results in a geometry whose dimension is one less than\r\n * the maximum dimension of the two source geometries and the intersection set is interior to\r\n * both source geometries.\r\n *\r\n * Boolean-Crosses returns t (TRUE) for only multipoint/polygon, multipoint/linestring, linestring/linestring, linestring/polygon, and linestring/multipolygon comparisons.\r\n *\r\n * @name booleanCrosses\r\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\r\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\r\n * @returns {boolean} true/false\r\n * @example\r\n * var line1 = turf.lineString([[-2, 2], [4, 2]]);\r\n * var line2 = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\r\n *\r\n * var cross = turf.booleanCrosses(line1, line2);\r\n * //=true\r\n */\n\nfunction booleanCrosses(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n\n  switch (type1) {\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"LineString\":\n          return doMultiPointAndLineStringCross(geom1, geom2);\n\n        case \"Polygon\":\n          return doesMultiPointCrossPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"LineString\":\n      switch (type2) {\n        case \"MultiPoint\":\n          // An inverse operation\n          return doMultiPointAndLineStringCross(geom2, geom1);\n\n        case \"LineString\":\n          return doLineStringsCross(geom1, geom2);\n\n        case \"Polygon\":\n          return doLineStringAndPolygonCross(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"Polygon\":\n      switch (type2) {\n        case \"MultiPoint\":\n          // An inverse operation\n          return doesMultiPointCrossPoly(geom2, geom1);\n\n        case \"LineString\":\n          // An inverse operation\n          return doLineStringAndPolygonCross(geom2, geom1);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\n\nfunction doMultiPointAndLineStringCross(multiPoint, lineString) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n  var i = 0;\n\n  while (i < pointLength && !foundIntPoint && !foundExtPoint) {\n    for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {\n      var incEndVertices = true;\n\n      if (i2 === 0 || i2 === lineString.coordinates.length - 2) {\n        incEndVertices = false;\n      }\n\n      if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {\n        foundIntPoint = true;\n      } else {\n        foundExtPoint = true;\n      }\n    }\n\n    i++;\n  }\n\n  return foundIntPoint && foundExtPoint;\n}\n\nfunction doLineStringsCross(lineString1, lineString2) {\n  var doLinesIntersect = lineIntersect(lineString1, lineString2);\n\n  if (doLinesIntersect.features.length > 0) {\n    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {\n      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {\n        var incEndVertices = true;\n\n        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {\n          incEndVertices = false;\n        }\n\n        if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction doLineStringAndPolygonCross(lineString, polygon) {\n  var line = polygonToLine(polygon);\n  var doLinesIntersect = lineIntersect(lineString, line);\n\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction doesMultiPointCrossPoly(multiPoint, polygon) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n\n  for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {\n    if (booleanPointInPolygon(point(multiPoint.coordinates[i]), polygon)) {\n      foundIntPoint = true;\n    } else {\n      foundExtPoint = true;\n    }\n  }\n\n  return foundExtPoint && foundIntPoint;\n}\n/**\r\n * Is a point on a line segment\r\n * Only takes into account outer rings\r\n * See http://stackoverflow.com/a/4833823/1979085\r\n *\r\n * @private\r\n * @param {number[]} lineSegmentStart coord pair of start of line\r\n * @param {number[]} lineSegmentEnd coord pair of end of line\r\n * @param {number[]} pt coord pair of point to check\r\n * @param {boolean} incEnd whether the point is allowed to fall on the line ends\r\n * @returns {boolean} true/false\r\n */\n\n\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {\n  var dxc = pt[0] - lineSegmentStart[0];\n  var dyc = pt[1] - lineSegmentStart[1];\n  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  var cross = dxc * dyl - dyc * dxl;\n\n  if (cross !== 0) {\n    return false;\n  }\n\n  if (incEnd) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n\n    return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  } else {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];\n    }\n\n    return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];\n  }\n}\n\nexport default booleanCrosses;","map":{"version":3,"names":["lineIntersect","polygonToLine","booleanPointInPolygon","getGeom","point","booleanCrosses","feature1","feature2","geom1","geom2","type1","type","type2","doMultiPointAndLineStringCross","doesMultiPointCrossPoly","Error","doLineStringsCross","doLineStringAndPolygonCross","multiPoint","lineString","foundIntPoint","foundExtPoint","pointLength","coordinates","length","i","i2","incEndVertices","isPointOnLineSegment","lineString1","lineString2","doLinesIntersect","features","polygon","line","lineSegmentStart","lineSegmentEnd","pt","incEnd","dxc","dyc","dxl","dyl","cross","Math","abs"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/boolean-crosses/dist/es/index.js"],"sourcesContent":["import lineIntersect from \"@turf/line-intersect\";\r\nimport { polygonToLine } from \"@turf/polygon-to-line\";\r\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\r\nimport { getGeom } from \"@turf/invariant\";\r\nimport { point, } from \"@turf/helpers\";\r\n/**\r\n * Boolean-Crosses returns True if the intersection results in a geometry whose dimension is one less than\r\n * the maximum dimension of the two source geometries and the intersection set is interior to\r\n * both source geometries.\r\n *\r\n * Boolean-Crosses returns t (TRUE) for only multipoint/polygon, multipoint/linestring, linestring/linestring, linestring/polygon, and linestring/multipolygon comparisons.\r\n *\r\n * @name booleanCrosses\r\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\r\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\r\n * @returns {boolean} true/false\r\n * @example\r\n * var line1 = turf.lineString([[-2, 2], [4, 2]]);\r\n * var line2 = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\r\n *\r\n * var cross = turf.booleanCrosses(line1, line2);\r\n * //=true\r\n */\r\nfunction booleanCrosses(feature1, feature2) {\r\n    var geom1 = getGeom(feature1);\r\n    var geom2 = getGeom(feature2);\r\n    var type1 = geom1.type;\r\n    var type2 = geom2.type;\r\n    switch (type1) {\r\n        case \"MultiPoint\":\r\n            switch (type2) {\r\n                case \"LineString\":\r\n                    return doMultiPointAndLineStringCross(geom1, geom2);\r\n                case \"Polygon\":\r\n                    return doesMultiPointCrossPoly(geom1, geom2);\r\n                default:\r\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\r\n            }\r\n        case \"LineString\":\r\n            switch (type2) {\r\n                case \"MultiPoint\": // An inverse operation\r\n                    return doMultiPointAndLineStringCross(geom2, geom1);\r\n                case \"LineString\":\r\n                    return doLineStringsCross(geom1, geom2);\r\n                case \"Polygon\":\r\n                    return doLineStringAndPolygonCross(geom1, geom2);\r\n                default:\r\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\r\n            }\r\n        case \"Polygon\":\r\n            switch (type2) {\r\n                case \"MultiPoint\": // An inverse operation\r\n                    return doesMultiPointCrossPoly(geom2, geom1);\r\n                case \"LineString\": // An inverse operation\r\n                    return doLineStringAndPolygonCross(geom2, geom1);\r\n                default:\r\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\r\n            }\r\n        default:\r\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\r\n    }\r\n}\r\nfunction doMultiPointAndLineStringCross(multiPoint, lineString) {\r\n    var foundIntPoint = false;\r\n    var foundExtPoint = false;\r\n    var pointLength = multiPoint.coordinates.length;\r\n    var i = 0;\r\n    while (i < pointLength && !foundIntPoint && !foundExtPoint) {\r\n        for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {\r\n            var incEndVertices = true;\r\n            if (i2 === 0 || i2 === lineString.coordinates.length - 2) {\r\n                incEndVertices = false;\r\n            }\r\n            if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {\r\n                foundIntPoint = true;\r\n            }\r\n            else {\r\n                foundExtPoint = true;\r\n            }\r\n        }\r\n        i++;\r\n    }\r\n    return foundIntPoint && foundExtPoint;\r\n}\r\nfunction doLineStringsCross(lineString1, lineString2) {\r\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\r\n    if (doLinesIntersect.features.length > 0) {\r\n        for (var i = 0; i < lineString1.coordinates.length - 1; i++) {\r\n            for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {\r\n                var incEndVertices = true;\r\n                if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {\r\n                    incEndVertices = false;\r\n                }\r\n                if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction doLineStringAndPolygonCross(lineString, polygon) {\r\n    var line = polygonToLine(polygon);\r\n    var doLinesIntersect = lineIntersect(lineString, line);\r\n    if (doLinesIntersect.features.length > 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction doesMultiPointCrossPoly(multiPoint, polygon) {\r\n    var foundIntPoint = false;\r\n    var foundExtPoint = false;\r\n    var pointLength = multiPoint.coordinates.length;\r\n    for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {\r\n        if (booleanPointInPolygon(point(multiPoint.coordinates[i]), polygon)) {\r\n            foundIntPoint = true;\r\n        }\r\n        else {\r\n            foundExtPoint = true;\r\n        }\r\n    }\r\n    return foundExtPoint && foundIntPoint;\r\n}\r\n/**\r\n * Is a point on a line segment\r\n * Only takes into account outer rings\r\n * See http://stackoverflow.com/a/4833823/1979085\r\n *\r\n * @private\r\n * @param {number[]} lineSegmentStart coord pair of start of line\r\n * @param {number[]} lineSegmentEnd coord pair of end of line\r\n * @param {number[]} pt coord pair of point to check\r\n * @param {boolean} incEnd whether the point is allowed to fall on the line ends\r\n * @returns {boolean} true/false\r\n */\r\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {\r\n    var dxc = pt[0] - lineSegmentStart[0];\r\n    var dyc = pt[1] - lineSegmentStart[1];\r\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\r\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\r\n    var cross = dxc * dyl - dyc * dxl;\r\n    if (cross !== 0) {\r\n        return false;\r\n    }\r\n    if (incEnd) {\r\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\r\n            return dxl > 0\r\n                ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0]\r\n                : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\r\n        }\r\n        return dyl > 0\r\n            ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1]\r\n            : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\r\n    }\r\n    else {\r\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\r\n            return dxl > 0\r\n                ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0]\r\n                : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];\r\n        }\r\n        return dyl > 0\r\n            ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1]\r\n            : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];\r\n    }\r\n}\r\nexport default booleanCrosses;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}