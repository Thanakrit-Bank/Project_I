{"ast":null,"code":"import { featureCollection } from \"@turf/helpers\";\nimport Graph from \"./lib/Graph.js\";\nimport EdgeRing from \"./lib/EdgeRing.js\";\n/**\r\n * Polygonizes {@link LineString|(Multi)LineString(s)} into {@link Polygons}.\r\n *\r\n * Implementation of GEOSPolygonize function (`geos::operation::polygonize::Polygonizer`).\r\n *\r\n * Polygonizes a set of lines that represents edges in a planar graph. Edges must be correctly\r\n * noded, i.e., they must only meet at their endpoints.\r\n *\r\n * The implementation correctly handles:\r\n *\r\n * - Dangles: edges which have one or both ends which are not incident on another edge endpoint.\r\n * - Cut Edges (bridges): edges that are connected at both ends but which do not form part of a polygon.\r\n *\r\n * @name polygonize\r\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geoJson Lines in order to polygonize\r\n * @returns {FeatureCollection<Polygon>} Polygons created\r\n * @throws {Error} if geoJson is invalid.\r\n */\n\nexport default function polygonize(geoJson) {\n  var graph = Graph.fromGeoJson(geoJson); // 1. Remove dangle node\n\n  graph.deleteDangles(); // 2. Remove cut-edges (bridge edges)\n\n  graph.deleteCutEdges(); // 3. Get all holes and shells\n\n  var holes = [],\n      shells = [];\n  graph.getEdgeRings().filter(function (edgeRing) {\n    return edgeRing.isValid();\n  }).forEach(function (edgeRing) {\n    if (edgeRing.isHole()) holes.push(edgeRing);else shells.push(edgeRing);\n  }); // 4. Assign Holes to Shells\n\n  holes.forEach(function (hole) {\n    if (EdgeRing.findEdgeRingContaining(hole, shells)) shells.push(hole);\n  }); // 5. EdgeRings to Polygons\n\n  return featureCollection(shells.map(function (shell) {\n    return shell.toPolygon();\n  }));\n}","map":{"version":3,"names":["featureCollection","Graph","EdgeRing","polygonize","geoJson","graph","fromGeoJson","deleteDangles","deleteCutEdges","holes","shells","getEdgeRings","filter","edgeRing","isValid","forEach","isHole","push","hole","findEdgeRingContaining","map","shell","toPolygon"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/polygonize/dist/es/index.js"],"sourcesContent":["import { featureCollection } from \"@turf/helpers\";\r\nimport Graph from \"./lib/Graph.js\";\r\nimport EdgeRing from \"./lib/EdgeRing.js\";\r\n/**\r\n * Polygonizes {@link LineString|(Multi)LineString(s)} into {@link Polygons}.\r\n *\r\n * Implementation of GEOSPolygonize function (`geos::operation::polygonize::Polygonizer`).\r\n *\r\n * Polygonizes a set of lines that represents edges in a planar graph. Edges must be correctly\r\n * noded, i.e., they must only meet at their endpoints.\r\n *\r\n * The implementation correctly handles:\r\n *\r\n * - Dangles: edges which have one or both ends which are not incident on another edge endpoint.\r\n * - Cut Edges (bridges): edges that are connected at both ends but which do not form part of a polygon.\r\n *\r\n * @name polygonize\r\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geoJson Lines in order to polygonize\r\n * @returns {FeatureCollection<Polygon>} Polygons created\r\n * @throws {Error} if geoJson is invalid.\r\n */\r\nexport default function polygonize(geoJson) {\r\n    var graph = Graph.fromGeoJson(geoJson);\r\n    // 1. Remove dangle node\r\n    graph.deleteDangles();\r\n    // 2. Remove cut-edges (bridge edges)\r\n    graph.deleteCutEdges();\r\n    // 3. Get all holes and shells\r\n    var holes = [], shells = [];\r\n    graph\r\n        .getEdgeRings()\r\n        .filter(function (edgeRing) { return edgeRing.isValid(); })\r\n        .forEach(function (edgeRing) {\r\n        if (edgeRing.isHole())\r\n            holes.push(edgeRing);\r\n        else\r\n            shells.push(edgeRing);\r\n    });\r\n    // 4. Assign Holes to Shells\r\n    holes.forEach(function (hole) {\r\n        if (EdgeRing.findEdgeRingContaining(hole, shells))\r\n            shells.push(hole);\r\n    });\r\n    // 5. EdgeRings to Polygons\r\n    return featureCollection(shells.map(function (shell) { return shell.toPolygon(); }));\r\n}\r\n"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,eAAlC;AACA,OAAOC,KAAP,MAAkB,gBAAlB;AACA,OAAOC,QAAP,MAAqB,mBAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,UAAT,CAAoBC,OAApB,EAA6B;EACxC,IAAIC,KAAK,GAAGJ,KAAK,CAACK,WAAN,CAAkBF,OAAlB,CAAZ,CADwC,CAExC;;EACAC,KAAK,CAACE,aAAN,GAHwC,CAIxC;;EACAF,KAAK,CAACG,cAAN,GALwC,CAMxC;;EACA,IAAIC,KAAK,GAAG,EAAZ;EAAA,IAAgBC,MAAM,GAAG,EAAzB;EACAL,KAAK,CACAM,YADL,GAEKC,MAFL,CAEY,UAAUC,QAAV,EAAoB;IAAE,OAAOA,QAAQ,CAACC,OAAT,EAAP;EAA4B,CAF9D,EAGKC,OAHL,CAGa,UAAUF,QAAV,EAAoB;IAC7B,IAAIA,QAAQ,CAACG,MAAT,EAAJ,EACIP,KAAK,CAACQ,IAAN,CAAWJ,QAAX,EADJ,KAGIH,MAAM,CAACO,IAAP,CAAYJ,QAAZ;EACP,CARD,EARwC,CAiBxC;;EACAJ,KAAK,CAACM,OAAN,CAAc,UAAUG,IAAV,EAAgB;IAC1B,IAAIhB,QAAQ,CAACiB,sBAAT,CAAgCD,IAAhC,EAAsCR,MAAtC,CAAJ,EACIA,MAAM,CAACO,IAAP,CAAYC,IAAZ;EACP,CAHD,EAlBwC,CAsBxC;;EACA,OAAOlB,iBAAiB,CAACU,MAAM,CAACU,GAAP,CAAW,UAAUC,KAAV,EAAiB;IAAE,OAAOA,KAAK,CAACC,SAAN,EAAP;EAA2B,CAAzD,CAAD,CAAxB;AACH"},"metadata":{},"sourceType":"module"}