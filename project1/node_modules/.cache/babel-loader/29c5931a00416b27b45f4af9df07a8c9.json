{"ast":null,"code":"\"use strict\";\n/*jshint esversion: 6 */\n\nvar Distance = require(\"./distance.js\"),\n    ClusterInit = require(\"./kinit.js\"),\n    eudist = Distance.eudist,\n    mandist = Distance.mandist,\n    dist = Distance.dist,\n    kmrand = ClusterInit.kmrand,\n    kmpp = ClusterInit.kmpp;\n\nvar MAX = 10000;\n/**\n * Inits an array with values\n */\n\nfunction init(len, val, v) {\n  v = v || [];\n\n  for (var i = 0; i < len; i++) {\n    v[i] = val;\n  }\n\n  return v;\n}\n\nfunction skmeans(data, k, initial, maxit) {\n  var ks = [],\n      old = [],\n      idxs = [],\n      dist = [];\n  var conv = false,\n      it = maxit || MAX;\n  var len = data.length,\n      vlen = data[0].length,\n      multi = vlen > 0;\n  var count = [];\n\n  if (!initial) {\n    var _idxs = {};\n\n    while (ks.length < k) {\n      var idx = Math.floor(Math.random() * len);\n\n      if (!_idxs[idx]) {\n        _idxs[idx] = true;\n        ks.push(data[idx]);\n      }\n    }\n  } else if (initial == \"kmrand\") {\n    ks = kmrand(data, k);\n  } else if (initial == \"kmpp\") {\n    ks = kmpp(data, k);\n  } else {\n    ks = initial;\n  }\n\n  do {\n    // Reset k count\n    init(k, 0, count); // For each value in data, find the nearest centroid\n\n    for (var i = 0; i < len; i++) {\n      var min = Infinity,\n          _idx = 0;\n\n      for (var j = 0; j < k; j++) {\n        // Multidimensional or unidimensional\n        var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n\n        if (dist <= min) {\n          min = dist;\n          _idx = j;\n        }\n      }\n\n      idxs[i] = _idx; // Index of the selected centroid for that value\n\n      count[_idx]++; // Number of values for this centroid\n    } // Recalculate centroids\n\n\n    var sum = [],\n        old = [],\n        dif = 0;\n\n    for (var _j = 0; _j < k; _j++) {\n      // Multidimensional or unidimensional\n      sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n      old[_j] = ks[_j];\n    } // If multidimensional\n\n\n    if (multi) {\n      for (var _j2 = 0; _j2 < k; _j2++) {\n        ks[_j2] = [];\n      } // Sum values and count for each centroid\n\n\n      for (var _i = 0; _i < len; _i++) {\n        var _idx2 = idxs[_i],\n            // Centroid for that item\n        vsum = sum[_idx2],\n            // Sum values for this centroid\n        vect = data[_i]; // Current vector\n        // Accumulate value on the centroid for current vector\n\n        for (var h = 0; h < vlen; h++) {\n          vsum[h] += vect[h];\n        }\n      } // Calculate the average for each centroid\n\n\n      conv = true;\n\n      for (var _j3 = 0; _j3 < k; _j3++) {\n        var ksj = ks[_j3],\n            // Current centroid\n        sumj = sum[_j3],\n            // Accumulated centroid values\n        oldj = old[_j3],\n            // Old centroid value\n        cj = count[_j3]; // Number of elements for this centroid\n        // New average\n\n        for (var _h = 0; _h < vlen; _h++) {\n          ksj[_h] = sumj[_h] / cj || 0; // New centroid\n        } // Find if centroids have moved\n\n\n        if (conv) {\n          for (var _h2 = 0; _h2 < vlen; _h2++) {\n            if (oldj[_h2] != ksj[_h2]) {\n              conv = false;\n              break;\n            }\n          }\n        }\n      }\n    } // If unidimensional\n    else {\n      // Sum values and count for each centroid\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        var _idx3 = idxs[_i2];\n        sum[_idx3] += data[_i2];\n      } // Calculate the average for each centroid\n\n\n      for (var _j4 = 0; _j4 < k; _j4++) {\n        ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n      } // Find if centroids have moved\n\n\n      conv = true;\n\n      for (var _j5 = 0; _j5 < k; _j5++) {\n        if (old[_j5] != ks[_j5]) {\n          conv = false;\n          break;\n        }\n      }\n    }\n\n    conv = conv || --it <= 0;\n  } while (!conv);\n\n  return {\n    it: MAX - it,\n    k: k,\n    idxs: idxs,\n    centroids: ks\n  };\n}\n\nmodule.exports = skmeans;","map":{"version":3,"mappings":"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","names":["Distance","require","ClusterInit","eudist","mandist","dist","kmrand","kmpp","MAX","init","len","val","v","i","skmeans","data","k","initial","maxit","ks","old","idxs","conv","it","length","vlen","multi","count","idx","Math","floor","random","push","min","Infinity","j","abs","sum","dif","vsum","vect","h","ksj","sumj","oldj","cj","centroids","module","exports"],"sources":["D:\\Project\\Mix_Project\\Project_I\\project1\\node_modules\\skmeans\\main.js"],"sourcesContent":["/*jshint esversion: 6 */\n\nconst\n\tDistance = require(\"./distance.js\"),\n\tClusterInit = require(\"./kinit.js\"),\n\teudist = Distance.eudist,\n\tmandist = Distance.mandist,\n\tdist = Distance.dist,\n\tkmrand = ClusterInit.kmrand,\n\tkmpp = ClusterInit.kmpp;\n\nconst MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len,val,v) {\n\tv = v || [];\n\tfor(let i=0;i<len;i++) v[i] = val;\n\treturn v;\n}\n\nfunction skmeans(data,k,initial,maxit) {\n\tvar ks = [], old = [], idxs = [], dist = [];\n\tvar conv = false, it = maxit || MAX;\n\tvar len = data.length, vlen = data[0].length, multi = vlen>0;\n\tvar count = [];\n\n\tif(!initial) {\n\t\tlet idxs = {};\n\t\twhile(ks.length<k) {\n\t\t\tlet idx = Math.floor(Math.random()*len);\n\t\t\tif(!idxs[idx]) {\n\t\t\t\tidxs[idx] = true;\n\t\t\t\tks.push(data[idx]);\n\t\t\t}\n\t\t}\n\t}\n\telse if(initial==\"kmrand\") {\n\t\tks = kmrand(data,k);\n\t}\n\telse if(initial==\"kmpp\") {\n\t\tks = kmpp(data,k);\n\t}\n\telse {\n\t\tks = initial;\n\t}\n\n\tdo {\n\t\t// Reset k count\n\t\tinit(k,0,count);\n\n\t\t// For each value in data, find the nearest centroid\n\t\tfor(let i=0;i<len;i++) {\n\t\t\tlet min = Infinity, idx = 0;\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\t// Multidimensional or unidimensional\n\t\t\t\tvar dist = multi? eudist(data[i],ks[j]) : Math.abs(data[i]-ks[j]);\n\t\t\t\tif(dist<=min) {\n\t\t\t\t\tmin = dist;\n\t\t\t\t\tidx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidxs[i] = idx;\t// Index of the selected centroid for that value\n\t\t\tcount[idx]++;\t\t// Number of values for this centroid\n\t\t}\n\n\t\t// Recalculate centroids\n\t\tvar sum = [], old = [], dif = 0;\n\t\tfor(let j=0;j<k;j++) {\n\t\t\t// Multidimensional or unidimensional\n\t\t\tsum[j] = multi? init(vlen,0,sum[j]) : 0;\n\t\t\told[j] = ks[j];\n\t\t}\n\n\t\t// If multidimensional\n\t\tif(multi) {\n\t\t\tfor(let j=0;j<k;j++) ks[j] = [];\n\n\t\t\t// Sum values and count for each centroid\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tlet\tidx = idxs[i],\t\t// Centroid for that item\n\t\t\t\t\t\tvsum = sum[idx],\t// Sum values for this centroid\n\t\t\t\t\t\tvect = data[i];\t\t// Current vector\n\n\t\t\t\t// Accumulate value on the centroid for current vector\n\t\t\t\tfor(let h=0;h<vlen;h++) {\n\t\t\t\t\tvsum[h] += vect[h];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tconv = true;\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\tlet ksj = ks[j],\t\t// Current centroid\n\t\t\t\t\t\tsumj = sum[j],\t// Accumulated centroid values\n\t\t\t\t\t\toldj = old[j], \t// Old centroid value\n\t\t\t\t\t\tcj = count[j];\t// Number of elements for this centroid\n\n\t\t\t\t// New average\n\t\t\t\tfor(let h=0;h<vlen;h++) {\n\t\t\t\t\tksj[h] = (sumj[h])/(cj) || 0;\t// New centroid\n\t\t\t\t}\n\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tif(conv) {\n\t\t\t\t\tfor(let h=0;h<vlen;h++) {\n\t\t\t\t\t\tif(oldj[h]!=ksj[h]) {\n\t\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If unidimensional\n\t\telse {\n\t\t\t// Sum values and count for each centroid\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tlet idx = idxs[i];\n\t\t\t\tsum[idx] += data[i];\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\tks[j] = sum[j]/count[j] || 0;\t// New centroid\n\t\t\t}\n\t\t\t// Find if centroids have moved\n\t\t\tconv = true;\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\tif(old[j]!=ks[j]) {\n\t\t\t\t\tconv = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconv = conv || (--it<=0);\n\t}while(!conv);\n\n\treturn {\n\t\tit : MAX-it,\n\t\tk : k,\n\t\tidxs : idxs,\n\t\tcentroids : ks\n\t};\n}\n\nmodule.exports = skmeans;\n"]},"metadata":{},"sourceType":"script"}