{"ast":null,"code":"import hashmap from \"./hash/hashmap.js\";\nimport equalPoint from \"./hash/point-equal.js\";\nimport hashPoint from \"./hash/point-hash.js\"; // Given a cut topology, combines duplicate arcs.\n\nexport default function (topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      line,\n      rings = topology.rings,\n      ring,\n      arcCount = lines.length + rings.length,\n      i,\n      n;\n  delete topology.lines;\n  delete topology.rings; // Count the number of (non-unique) arcs to initialize the hashmap safely.\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n\n    while (line = line.next) {\n      ++arcCount;\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n\n    while (ring = ring.next) {\n      ++arcCount;\n    }\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n\n    if (ring.next) {\n      // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n; // Does this arc match an existing arc in order?\n\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    } // Does this arc match an existing arc in reverse order?\n\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint, endArcs, endArc, i, n; // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    } // Otherwise, does this arc match an existing ring in order, or reverse order?\n\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n\n    for (; ia <= ja; ++ia, ++ib) {\n      if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    }\n\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n\n    for (; ia <= ja; ++ia, --jb) {\n      if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    }\n\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n\n    return true;\n  } // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n\n\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n\n    while (++mid < end) {\n      var point = coordinates[mid];\n\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n\n    return minimum - start;\n  }\n\n  return topology;\n}","map":{"version":3,"names":["hashmap","equalPoint","hashPoint","topology","coordinates","lines","line","rings","ring","arcCount","length","i","n","next","arcsByEnd","arcs","dedupLine","dedupRing","arc","startPoint","endPoint","startArcs","startArc","endArcs","endArc","get","equalLine","reverseEqualLine","push","set","equalRing","reverseEqualRing","findMinimumOffset","arcA","arcB","ia","ib","ja","jb","ka","kb","start","end","mid","minimum","minimumPoint","point"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/topojson-server/src/dedup.js"],"sourcesContent":["import hashmap from \"./hash/hashmap.js\";\nimport equalPoint from \"./hash/point-equal.js\";\nimport hashPoint from \"./hash/point-hash.js\";\n\n// Given a cut topology, combines duplicate arcs.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}