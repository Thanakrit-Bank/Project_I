{"ast":null,"code":"import bbox from \"./bbox.js\";\nimport untransform from \"./untransform.js\";\nexport default function (topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0],\n        y0 = box[1],\n        x1 = box[2],\n        y1 = box[3],\n        n;\n    transform = {\n      scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1],\n      translate: [x0, y0]\n    };\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform),\n      box,\n      key,\n      inputs = topology.objects,\n      outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n\n    switch (input.type) {\n      case \"GeometryCollection\":\n        output = {\n          type: \"GeometryCollection\",\n          geometries: input.geometries.map(quantizeGeometry)\n        };\n        break;\n\n      case \"Point\":\n        output = {\n          type: \"Point\",\n          coordinates: quantizePoint(input.coordinates)\n        };\n        break;\n\n      case \"MultiPoint\":\n        output = {\n          type: \"MultiPoint\",\n          coordinates: input.coordinates.map(quantizePoint)\n        };\n        break;\n\n      default:\n        return input;\n    }\n\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0,\n        j = 1,\n        n = input.length,\n        p,\n        output = new Array(n); // pessimistic\n\n    output[0] = t(input[0], 0);\n\n    while (++i < n) {\n      if ((p = t(input[i], i))[0] || p[1]) output[j++] = p;\n    } // non-coincident points\n\n\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) {\n    outputs[key] = quantizeGeometry(inputs[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}","map":{"version":3,"names":["bbox","untransform","topology","transform","Error","scale","n","Math","floor","box","x0","y0","x1","y1","translate","t","key","inputs","objects","outputs","quantizePoint","point","quantizeGeometry","input","output","type","geometries","map","coordinates","id","properties","quantizeArc","i","j","length","p","Array","arcs"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/topojson-client/src/quantize.js"],"sourcesContent":["import bbox from \"./bbox.js\";\nimport untransform from \"./untransform.js\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}