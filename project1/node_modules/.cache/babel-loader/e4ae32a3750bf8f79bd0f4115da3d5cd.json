{"ast":null,"code":"import cleanCoords from \"@turf/clean-coords\";\nimport lineSegment from \"@turf/line-segment\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\nimport { bearingToAzimuth } from \"@turf/helpers\";\n/**\r\n * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`\r\n *\r\n * @name booleanParallel\r\n * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry\r\n * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry\r\n * @returns {boolean} true/false if the lines are parallel\r\n * @example\r\n * var line1 = turf.lineString([[0, 0], [0, 1]]);\r\n * var line2 = turf.lineString([[1, 0], [1, 1]]);\r\n *\r\n * turf.booleanParallel(line1, line2);\r\n * //=true\r\n */\n\nfunction booleanParallel(line1, line2) {\n  // validation\n  if (!line1) throw new Error(\"line1 is required\");\n  if (!line2) throw new Error(\"line2 is required\");\n  var type1 = getType(line1, \"line1\");\n  if (type1 !== \"LineString\") throw new Error(\"line1 must be a LineString\");\n  var type2 = getType(line2, \"line2\");\n  if (type2 !== \"LineString\") throw new Error(\"line2 must be a LineString\");\n  var segments1 = lineSegment(cleanCoords(line1)).features;\n  var segments2 = lineSegment(cleanCoords(line2)).features;\n\n  for (var i = 0; i < segments1.length; i++) {\n    var segment1 = segments1[i].geometry.coordinates;\n    if (!segments2[i]) break;\n    var segment2 = segments2[i].geometry.coordinates;\n    if (!isParallel(segment1, segment2)) return false;\n  }\n\n  return true;\n}\n/**\r\n * Compares slopes and return result\r\n *\r\n * @private\r\n * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature\r\n * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature\r\n * @returns {boolean} if slopes are equal\r\n */\n\n\nfunction isParallel(segment1, segment2) {\n  var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\n  var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\n  return slope1 === slope2;\n}\n/**\r\n * Returns Feature's type\r\n *\r\n * @private\r\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\r\n * @param {string} name of the variable\r\n * @returns {string} Feature's type\r\n */\n\n\nfunction getType(geojson, name) {\n  if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n  if (geojson.type) return geojson.type; // if GeoJSON geometry\n\n  throw new Error(\"Invalid GeoJSON object for \" + name);\n}\n\nexport default booleanParallel;","map":{"version":3,"names":["cleanCoords","lineSegment","rhumbBearing","bearingToAzimuth","booleanParallel","line1","line2","Error","type1","getType","type2","segments1","features","segments2","i","length","segment1","geometry","coordinates","segment2","isParallel","slope1","slope2","geojson","name","type"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/boolean-parallel/dist/es/index.js"],"sourcesContent":["import cleanCoords from \"@turf/clean-coords\";\r\nimport lineSegment from \"@turf/line-segment\";\r\nimport rhumbBearing from \"@turf/rhumb-bearing\";\r\nimport { bearingToAzimuth, } from \"@turf/helpers\";\r\n/**\r\n * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`\r\n *\r\n * @name booleanParallel\r\n * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry\r\n * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry\r\n * @returns {boolean} true/false if the lines are parallel\r\n * @example\r\n * var line1 = turf.lineString([[0, 0], [0, 1]]);\r\n * var line2 = turf.lineString([[1, 0], [1, 1]]);\r\n *\r\n * turf.booleanParallel(line1, line2);\r\n * //=true\r\n */\r\nfunction booleanParallel(line1, line2) {\r\n    // validation\r\n    if (!line1)\r\n        throw new Error(\"line1 is required\");\r\n    if (!line2)\r\n        throw new Error(\"line2 is required\");\r\n    var type1 = getType(line1, \"line1\");\r\n    if (type1 !== \"LineString\")\r\n        throw new Error(\"line1 must be a LineString\");\r\n    var type2 = getType(line2, \"line2\");\r\n    if (type2 !== \"LineString\")\r\n        throw new Error(\"line2 must be a LineString\");\r\n    var segments1 = lineSegment(cleanCoords(line1)).features;\r\n    var segments2 = lineSegment(cleanCoords(line2)).features;\r\n    for (var i = 0; i < segments1.length; i++) {\r\n        var segment1 = segments1[i].geometry.coordinates;\r\n        if (!segments2[i])\r\n            break;\r\n        var segment2 = segments2[i].geometry.coordinates;\r\n        if (!isParallel(segment1, segment2))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Compares slopes and return result\r\n *\r\n * @private\r\n * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature\r\n * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature\r\n * @returns {boolean} if slopes are equal\r\n */\r\nfunction isParallel(segment1, segment2) {\r\n    var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\r\n    var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\r\n    return slope1 === slope2;\r\n}\r\n/**\r\n * Returns Feature's type\r\n *\r\n * @private\r\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\r\n * @param {string} name of the variable\r\n * @returns {string} Feature's type\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.geometry && geojson.geometry.type)\r\n        return geojson.geometry.type;\r\n    if (geojson.type)\r\n        return geojson.type; // if GeoJSON geometry\r\n    throw new Error(\"Invalid GeoJSON object for \" + name);\r\n}\r\nexport default booleanParallel;\r\n"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,oBAAxB;AACA,OAAOC,WAAP,MAAwB,oBAAxB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SAASC,gBAAT,QAAkC,eAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,KAAzB,EAAgCC,KAAhC,EAAuC;EACnC;EACA,IAAI,CAACD,KAAL,EACI,MAAM,IAAIE,KAAJ,CAAU,mBAAV,CAAN;EACJ,IAAI,CAACD,KAAL,EACI,MAAM,IAAIC,KAAJ,CAAU,mBAAV,CAAN;EACJ,IAAIC,KAAK,GAAGC,OAAO,CAACJ,KAAD,EAAQ,OAAR,CAAnB;EACA,IAAIG,KAAK,KAAK,YAAd,EACI,MAAM,IAAID,KAAJ,CAAU,4BAAV,CAAN;EACJ,IAAIG,KAAK,GAAGD,OAAO,CAACH,KAAD,EAAQ,OAAR,CAAnB;EACA,IAAII,KAAK,KAAK,YAAd,EACI,MAAM,IAAIH,KAAJ,CAAU,4BAAV,CAAN;EACJ,IAAII,SAAS,GAAGV,WAAW,CAACD,WAAW,CAACK,KAAD,CAAZ,CAAX,CAAgCO,QAAhD;EACA,IAAIC,SAAS,GAAGZ,WAAW,CAACD,WAAW,CAACM,KAAD,CAAZ,CAAX,CAAgCM,QAAhD;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACI,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;IACvC,IAAIE,QAAQ,GAAGL,SAAS,CAACG,CAAD,CAAT,CAAaG,QAAb,CAAsBC,WAArC;IACA,IAAI,CAACL,SAAS,CAACC,CAAD,CAAd,EACI;IACJ,IAAIK,QAAQ,GAAGN,SAAS,CAACC,CAAD,CAAT,CAAaG,QAAb,CAAsBC,WAArC;IACA,IAAI,CAACE,UAAU,CAACJ,QAAD,EAAWG,QAAX,CAAf,EACI,OAAO,KAAP;EACP;;EACD,OAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBJ,QAApB,EAA8BG,QAA9B,EAAwC;EACpC,IAAIE,MAAM,GAAGlB,gBAAgB,CAACD,YAAY,CAACc,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAAb,CAA7B;EACA,IAAIM,MAAM,GAAGnB,gBAAgB,CAACD,YAAY,CAACiB,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAAb,CAA7B;EACA,OAAOE,MAAM,KAAKC,MAAlB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASb,OAAT,CAAiBc,OAAjB,EAA0BC,IAA1B,EAAgC;EAC5B,IAAID,OAAO,CAACN,QAAR,IAAoBM,OAAO,CAACN,QAAR,CAAiBQ,IAAzC,EACI,OAAOF,OAAO,CAACN,QAAR,CAAiBQ,IAAxB;EACJ,IAAIF,OAAO,CAACE,IAAZ,EACI,OAAOF,OAAO,CAACE,IAAf,CAJwB,CAIH;;EACzB,MAAM,IAAIlB,KAAJ,CAAU,gCAAgCiB,IAA1C,CAAN;AACH;;AACD,eAAepB,eAAf"},"metadata":{},"sourceType":"module"}