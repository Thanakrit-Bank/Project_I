{"ast":null,"code":"import { point } from \"@turf/helpers\";\n/**\n * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring},\n * {@link MultiPolygon|multi-polygon} or {@link Polygon|polygon} and\n * returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = turf.polygon([[\n *   [-12.034835, 8.901183],\n *   [-12.060413, 8.899826],\n *   [-12.03638, 8.873199],\n *   [-12.059383, 8.871418],\n *   [-12.034835, 8.901183]\n * ]]);\n *\n * var kinks = turf.kinks(poly);\n *\n * //addToMap\n * var addToMap = [poly, kinks]\n */\n\nexport default function kinks(featureIn) {\n  var coordinates;\n  var feature;\n  var results = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n\n  if (featureIn.type === \"Feature\") {\n    feature = featureIn.geometry;\n  } else {\n    feature = featureIn;\n  }\n\n  if (feature.type === \"LineString\") {\n    coordinates = [feature.coordinates];\n  } else if (feature.type === \"MultiLineString\") {\n    coordinates = feature.coordinates;\n  } else if (feature.type === \"MultiPolygon\") {\n    coordinates = [].concat.apply([], feature.coordinates);\n  } else if (feature.type === \"Polygon\") {\n    coordinates = feature.coordinates;\n  } else {\n    throw new Error(\"Input must be a LineString, MultiLineString, \" + \"Polygon, or MultiPolygon Feature or Geometry\");\n  }\n\n  coordinates.forEach(function (line1) {\n    coordinates.forEach(function (line2) {\n      for (var i = 0; i < line1.length - 1; i++) {\n        // start iteration at i, intersections for k < i have already\n        // been checked in previous outer loop iterations\n        for (var k = i; k < line2.length - 1; k++) {\n          if (line1 === line2) {\n            // segments are adjacent and always share a vertex, not a kink\n            if (Math.abs(i - k) === 1) {\n              continue;\n            } // first and last segment in a closed lineString or ring always share a vertex, not a kink\n\n\n            if ( // segments are first and last segment of lineString\n            i === 0 && k === line1.length - 2 && // lineString is closed\n            line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {\n              continue;\n            }\n          }\n\n          var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n\n          if (intersection) {\n            results.features.push(point([intersection[0], intersection[1]]));\n          }\n        }\n      }\n    });\n  });\n  return results;\n} // modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the\n  // intersection (treating the lines as infinite) and booleans for whether\n  // line segment 1 or line segment 2 contain the point\n  var denominator;\n  var a;\n  var b;\n  var numerator1;\n  var numerator2;\n  var result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:\n\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY); // if line1 is a segment and line2 is infinite, they intersect if:\n\n  if (a >= 0 && a <= 1) {\n    result.onLine1 = true;\n  } // if line2 is a segment and line1 is infinite, they intersect if:\n\n\n  if (b >= 0 && b <= 1) {\n    result.onLine2 = true;\n  } // if line1 and line2 are segments, they intersect if both of the above are true\n\n\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}","map":{"version":3,"names":["point","kinks","featureIn","coordinates","feature","results","type","features","geometry","concat","apply","Error","forEach","line1","line2","i","length","k","Math","abs","intersection","lineIntersects","push","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","a","b","numerator1","numerator2","result","x","y","onLine1","onLine2"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/kinks/dist/es/index.js"],"sourcesContent":["import { point } from \"@turf/helpers\";\n/**\n * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring},\n * {@link MultiPolygon|multi-polygon} or {@link Polygon|polygon} and\n * returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = turf.polygon([[\n *   [-12.034835, 8.901183],\n *   [-12.060413, 8.899826],\n *   [-12.03638, 8.873199],\n *   [-12.059383, 8.871418],\n *   [-12.034835, 8.901183]\n * ]]);\n *\n * var kinks = turf.kinks(poly);\n *\n * //addToMap\n * var addToMap = [poly, kinks]\n */\nexport default function kinks(featureIn) {\n    var coordinates;\n    var feature;\n    var results = {\n        type: \"FeatureCollection\",\n        features: [],\n    };\n    if (featureIn.type === \"Feature\") {\n        feature = featureIn.geometry;\n    }\n    else {\n        feature = featureIn;\n    }\n    if (feature.type === \"LineString\") {\n        coordinates = [feature.coordinates];\n    }\n    else if (feature.type === \"MultiLineString\") {\n        coordinates = feature.coordinates;\n    }\n    else if (feature.type === \"MultiPolygon\") {\n        coordinates = [].concat.apply([], feature.coordinates);\n    }\n    else if (feature.type === \"Polygon\") {\n        coordinates = feature.coordinates;\n    }\n    else {\n        throw new Error(\"Input must be a LineString, MultiLineString, \" +\n            \"Polygon, or MultiPolygon Feature or Geometry\");\n    }\n    coordinates.forEach(function (line1) {\n        coordinates.forEach(function (line2) {\n            for (var i = 0; i < line1.length - 1; i++) {\n                // start iteration at i, intersections for k < i have already\n                // been checked in previous outer loop iterations\n                for (var k = i; k < line2.length - 1; k++) {\n                    if (line1 === line2) {\n                        // segments are adjacent and always share a vertex, not a kink\n                        if (Math.abs(i - k) === 1) {\n                            continue;\n                        }\n                        // first and last segment in a closed lineString or ring always share a vertex, not a kink\n                        if (\n                        // segments are first and last segment of lineString\n                        i === 0 &&\n                            k === line1.length - 2 &&\n                            // lineString is closed\n                            line1[i][0] === line1[line1.length - 1][0] &&\n                            line1[i][1] === line1[line1.length - 1][1]) {\n                            continue;\n                        }\n                    }\n                    var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n                    if (intersection) {\n                        results.features.push(point([intersection[0], intersection[1]]));\n                    }\n                }\n            }\n        });\n    });\n    return results;\n}\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n    // if the lines intersect, the result contains the x and y of the\n    // intersection (treating the lines as infinite) and booleans for whether\n    // line segment 1 or line segment 2 contain the point\n    var denominator;\n    var a;\n    var b;\n    var numerator1;\n    var numerator2;\n    var result = {\n        x: null,\n        y: null,\n        onLine1: false,\n        onLine2: false,\n    };\n    denominator =\n        (line2EndY - line2StartY) * (line1EndX - line1StartX) -\n            (line2EndX - line2StartX) * (line1EndY - line1StartY);\n    if (denominator === 0) {\n        if (result.x !== null && result.y !== null) {\n            return result;\n        }\n        else {\n            return false;\n        }\n    }\n    a = line1StartY - line2StartY;\n    b = line1StartX - line2StartX;\n    numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n    numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n    // if we cast these lines infinitely in both directions, they intersect here:\n    result.x = line1StartX + a * (line1EndX - line1StartX);\n    result.y = line1StartY + a * (line1EndY - line1StartY);\n    // if line1 is a segment and line2 is infinite, they intersect if:\n    if (a >= 0 && a <= 1) {\n        result.onLine1 = true;\n    }\n    // if line2 is a segment and line1 is infinite, they intersect if:\n    if (b >= 0 && b <= 1) {\n        result.onLine2 = true;\n    }\n    // if line1 and line2 are segments, they intersect if both of the above are true\n    if (result.onLine1 && result.onLine2) {\n        return [result.x, result.y];\n    }\n    else {\n        return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}