{"ast":null,"code":"// http://en.wikipedia.org/wiki/Delaunay_triangulation\n// https://github.com/ironwallaby/delaunay\nimport { featureCollection, polygon } from \"@turf/helpers\";\n/**\r\n * Takes a set of {@link Point|points} and creates a\r\n * [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),\r\n * or a TIN for short, returned as a collection of Polygons. These are often used\r\n * for developing elevation contour maps or stepped heat visualizations.\r\n *\r\n * If an optional z-value property is provided then it is added as properties called `a`, `b`,\r\n * and `c` representing its value at each of the points that represent the corners of the\r\n * triangle.\r\n *\r\n * @name tin\r\n * @param {FeatureCollection<Point>} points input points\r\n * @param {String} [z] name of the property from which to pull z values\r\n * This is optional: if not given, then there will be no extra data added to the derived triangles.\r\n * @returns {FeatureCollection<Polygon>} TIN output\r\n * @example\r\n * // generate some random point data\r\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\r\n *\r\n * // add a random property to each point between 0 and 9\r\n * for (var i = 0; i < points.features.length; i++) {\r\n *   points.features[i].properties.z = ~~(Math.random() * 9);\r\n * }\r\n * var tin = turf.tin(points, 'z');\r\n *\r\n * //addToMap\r\n * var addToMap = [tin, points]\r\n * for (var i = 0; i < tin.features.length; i++) {\r\n *   var properties  = tin.features[i].properties;\r\n *   properties.fill = '#' + properties.a + properties.b + properties.c;\r\n * }\r\n */\n\nexport default function tin(points, z) {\n  // break down points\n  var isPointZ = false;\n  return featureCollection(triangulate(points.features.map(function (p) {\n    var point = {\n      x: p.geometry.coordinates[0],\n      y: p.geometry.coordinates[1]\n    };\n\n    if (z) {\n      point.z = p.properties[z];\n    } else if (p.geometry.coordinates.length === 3) {\n      isPointZ = true;\n      point.z = p.geometry.coordinates[2];\n    }\n\n    return point;\n  })).map(function (triangle) {\n    var a = [triangle.a.x, triangle.a.y];\n    var b = [triangle.b.x, triangle.b.y];\n    var c = [triangle.c.x, triangle.c.y];\n    var properties = {}; // Add z coordinates to triangle points if user passed\n    // them in that way otherwise add it as a property.\n\n    if (isPointZ) {\n      a.push(triangle.a.z);\n      b.push(triangle.b.z);\n      c.push(triangle.c.z);\n    } else {\n      properties = {\n        a: triangle.a.z,\n        b: triangle.b.z,\n        c: triangle.c.z\n      };\n    }\n\n    return polygon([[a, b, c, a]], properties);\n  }));\n}\n\nvar Triangle =\n/** @class */\nfunction () {\n  function Triangle(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    var A = b.x - a.x;\n    var B = b.y - a.y;\n    var C = c.x - a.x;\n    var D = c.y - a.y;\n    var E = A * (a.x + b.x) + B * (a.y + b.y);\n    var F = C * (a.x + c.x) + D * (a.y + c.y);\n    var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n    var dx;\n    var dy; // If the points of the triangle are collinear, then just find the\n    // extremes and use the midpoint as the center of the circumcircle.\n\n    this.x = (D * E - B * F) / G;\n    this.y = (A * F - C * E) / G;\n    dx = this.x - a.x;\n    dy = this.y - a.y;\n    this.r = dx * dx + dy * dy;\n  }\n\n  return Triangle;\n}();\n\nfunction byX(a, b) {\n  return b.x - a.x;\n}\n\nfunction dedup(edges) {\n  var j = edges.length;\n  var a;\n  var b;\n  var i;\n  var m;\n  var n;\n\n  outer: while (j) {\n    b = edges[--j];\n    a = edges[--j];\n    i = j;\n\n    while (i) {\n      n = edges[--i];\n      m = edges[--i];\n\n      if (a === m && b === n || a === n && b === m) {\n        edges.splice(j, 2);\n        edges.splice(i, 2);\n        j -= 2;\n        continue outer;\n      }\n    }\n  }\n}\n\nfunction triangulate(vertices) {\n  // Bail if there aren't enough vertices to form any triangles.\n  if (vertices.length < 3) {\n    return [];\n  } // Ensure the vertex array is in order of descending X coordinate\n  // (which is needed to ensure a subquadratic runtime), and then find\n  // the bounding box around the points.\n\n\n  vertices.sort(byX);\n  var i = vertices.length - 1;\n  var xmin = vertices[i].x;\n  var xmax = vertices[0].x;\n  var ymin = vertices[i].y;\n  var ymax = ymin;\n  var epsilon = 1e-12;\n  var a;\n  var b;\n  var c;\n  var A;\n  var B;\n  var G;\n\n  while (i--) {\n    if (vertices[i].y < ymin) {\n      ymin = vertices[i].y;\n    }\n\n    if (vertices[i].y > ymax) {\n      ymax = vertices[i].y;\n    }\n  } // Find a supertriangle, which is a triangle that surrounds all the\n  // vertices. This is used like something of a sentinel value to remove\n  // cases in the main algorithm, and is removed before we return any\n  // results.\n  // Once found, put it in the \"open\" list. (The \"open\" list is for\n  // triangles who may still need to be considered; the \"closed\" list is\n  // for triangles which do not.)\n\n\n  var dx = xmax - xmin;\n  var dy = ymax - ymin;\n  var dmax = dx > dy ? dx : dy;\n  var xmid = (xmax + xmin) * 0.5;\n  var ymid = (ymax + ymin) * 0.5;\n  var open = [new Triangle({\n    __sentinel: true,\n    x: xmid - 20 * dmax,\n    y: ymid - dmax\n  }, {\n    __sentinel: true,\n    x: xmid,\n    y: ymid + 20 * dmax\n  }, {\n    __sentinel: true,\n    x: xmid + 20 * dmax,\n    y: ymid - dmax\n  })];\n  var closed = [];\n  var edges = [];\n  var j; // Incrementally add each vertex to the mesh.\n\n  i = vertices.length;\n\n  while (i--) {\n    // For each open triangle, check to see if the current point is\n    // inside it's circumcircle. If it is, remove the triangle and add\n    // it's edges to an edge list.\n    edges.length = 0;\n    j = open.length;\n\n    while (j--) {\n      // If this point is to the right of this triangle's circumcircle,\n      // then this triangle should never get checked again. Remove it\n      // from the open list, add it to the closed list, and skip.\n      dx = vertices[i].x - open[j].x;\n\n      if (dx > 0 && dx * dx > open[j].r) {\n        closed.push(open[j]);\n        open.splice(j, 1);\n        continue;\n      } // If not, skip this triangle.\n\n\n      dy = vertices[i].y - open[j].y;\n\n      if (dx * dx + dy * dy > open[j].r) {\n        continue;\n      } // Remove the triangle and add it's edges to the edge list.\n\n\n      edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);\n      open.splice(j, 1);\n    } // Remove any doubled edges.\n\n\n    dedup(edges); // Add a new triangle for each edge.\n\n    j = edges.length;\n\n    while (j) {\n      b = edges[--j];\n      a = edges[--j];\n      c = vertices[i]; // Avoid adding colinear triangles (which have error-prone\n      // circumcircles)\n\n      A = b.x - a.x;\n      B = b.y - a.y;\n      G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n\n      if (Math.abs(G) > epsilon) {\n        open.push(new Triangle(a, b, c));\n      }\n    }\n  } // Copy any remaining open triangles to the closed list, and then\n  // remove any triangles that share a vertex with the supertriangle.\n\n\n  Array.prototype.push.apply(closed, open);\n  i = closed.length;\n\n  while (i--) {\n    if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {\n      closed.splice(i, 1);\n    }\n  }\n\n  return closed;\n}","map":{"version":3,"names":["featureCollection","polygon","tin","points","z","isPointZ","triangulate","features","map","p","point","x","geometry","coordinates","y","properties","length","triangle","a","b","c","push","Triangle","A","B","C","D","E","F","G","dx","dy","r","byX","dedup","edges","j","i","m","n","outer","splice","vertices","sort","xmin","xmax","ymin","ymax","epsilon","dmax","xmid","ymid","open","__sentinel","closed","Math","abs","Array","prototype","apply"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/tin/dist/es/index.js"],"sourcesContent":["// http://en.wikipedia.org/wiki/Delaunay_triangulation\r\n// https://github.com/ironwallaby/delaunay\r\nimport { featureCollection, polygon } from \"@turf/helpers\";\r\n/**\r\n * Takes a set of {@link Point|points} and creates a\r\n * [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),\r\n * or a TIN for short, returned as a collection of Polygons. These are often used\r\n * for developing elevation contour maps or stepped heat visualizations.\r\n *\r\n * If an optional z-value property is provided then it is added as properties called `a`, `b`,\r\n * and `c` representing its value at each of the points that represent the corners of the\r\n * triangle.\r\n *\r\n * @name tin\r\n * @param {FeatureCollection<Point>} points input points\r\n * @param {String} [z] name of the property from which to pull z values\r\n * This is optional: if not given, then there will be no extra data added to the derived triangles.\r\n * @returns {FeatureCollection<Polygon>} TIN output\r\n * @example\r\n * // generate some random point data\r\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\r\n *\r\n * // add a random property to each point between 0 and 9\r\n * for (var i = 0; i < points.features.length; i++) {\r\n *   points.features[i].properties.z = ~~(Math.random() * 9);\r\n * }\r\n * var tin = turf.tin(points, 'z');\r\n *\r\n * //addToMap\r\n * var addToMap = [tin, points]\r\n * for (var i = 0; i < tin.features.length; i++) {\r\n *   var properties  = tin.features[i].properties;\r\n *   properties.fill = '#' + properties.a + properties.b + properties.c;\r\n * }\r\n */\r\nexport default function tin(points, z) {\r\n    // break down points\r\n    var isPointZ = false;\r\n    return featureCollection(triangulate(points.features.map(function (p) {\r\n        var point = {\r\n            x: p.geometry.coordinates[0],\r\n            y: p.geometry.coordinates[1],\r\n        };\r\n        if (z) {\r\n            point.z = p.properties[z];\r\n        }\r\n        else if (p.geometry.coordinates.length === 3) {\r\n            isPointZ = true;\r\n            point.z = p.geometry.coordinates[2];\r\n        }\r\n        return point;\r\n    })).map(function (triangle) {\r\n        var a = [triangle.a.x, triangle.a.y];\r\n        var b = [triangle.b.x, triangle.b.y];\r\n        var c = [triangle.c.x, triangle.c.y];\r\n        var properties = {};\r\n        // Add z coordinates to triangle points if user passed\r\n        // them in that way otherwise add it as a property.\r\n        if (isPointZ) {\r\n            a.push(triangle.a.z);\r\n            b.push(triangle.b.z);\r\n            c.push(triangle.c.z);\r\n        }\r\n        else {\r\n            properties = {\r\n                a: triangle.a.z,\r\n                b: triangle.b.z,\r\n                c: triangle.c.z,\r\n            };\r\n        }\r\n        return polygon([[a, b, c, a]], properties);\r\n    }));\r\n}\r\nvar Triangle = /** @class */ (function () {\r\n    function Triangle(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        var A = b.x - a.x;\r\n        var B = b.y - a.y;\r\n        var C = c.x - a.x;\r\n        var D = c.y - a.y;\r\n        var E = A * (a.x + b.x) + B * (a.y + b.y);\r\n        var F = C * (a.x + c.x) + D * (a.y + c.y);\r\n        var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\r\n        var dx;\r\n        var dy;\r\n        // If the points of the triangle are collinear, then just find the\r\n        // extremes and use the midpoint as the center of the circumcircle.\r\n        this.x = (D * E - B * F) / G;\r\n        this.y = (A * F - C * E) / G;\r\n        dx = this.x - a.x;\r\n        dy = this.y - a.y;\r\n        this.r = dx * dx + dy * dy;\r\n    }\r\n    return Triangle;\r\n}());\r\nfunction byX(a, b) {\r\n    return b.x - a.x;\r\n}\r\nfunction dedup(edges) {\r\n    var j = edges.length;\r\n    var a;\r\n    var b;\r\n    var i;\r\n    var m;\r\n    var n;\r\n    outer: while (j) {\r\n        b = edges[--j];\r\n        a = edges[--j];\r\n        i = j;\r\n        while (i) {\r\n            n = edges[--i];\r\n            m = edges[--i];\r\n            if ((a === m && b === n) || (a === n && b === m)) {\r\n                edges.splice(j, 2);\r\n                edges.splice(i, 2);\r\n                j -= 2;\r\n                continue outer;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction triangulate(vertices) {\r\n    // Bail if there aren't enough vertices to form any triangles.\r\n    if (vertices.length < 3) {\r\n        return [];\r\n    }\r\n    // Ensure the vertex array is in order of descending X coordinate\r\n    // (which is needed to ensure a subquadratic runtime), and then find\r\n    // the bounding box around the points.\r\n    vertices.sort(byX);\r\n    var i = vertices.length - 1;\r\n    var xmin = vertices[i].x;\r\n    var xmax = vertices[0].x;\r\n    var ymin = vertices[i].y;\r\n    var ymax = ymin;\r\n    var epsilon = 1e-12;\r\n    var a;\r\n    var b;\r\n    var c;\r\n    var A;\r\n    var B;\r\n    var G;\r\n    while (i--) {\r\n        if (vertices[i].y < ymin) {\r\n            ymin = vertices[i].y;\r\n        }\r\n        if (vertices[i].y > ymax) {\r\n            ymax = vertices[i].y;\r\n        }\r\n    }\r\n    // Find a supertriangle, which is a triangle that surrounds all the\r\n    // vertices. This is used like something of a sentinel value to remove\r\n    // cases in the main algorithm, and is removed before we return any\r\n    // results.\r\n    // Once found, put it in the \"open\" list. (The \"open\" list is for\r\n    // triangles who may still need to be considered; the \"closed\" list is\r\n    // for triangles which do not.)\r\n    var dx = xmax - xmin;\r\n    var dy = ymax - ymin;\r\n    var dmax = dx > dy ? dx : dy;\r\n    var xmid = (xmax + xmin) * 0.5;\r\n    var ymid = (ymax + ymin) * 0.5;\r\n    var open = [\r\n        new Triangle({\r\n            __sentinel: true,\r\n            x: xmid - 20 * dmax,\r\n            y: ymid - dmax,\r\n        }, {\r\n            __sentinel: true,\r\n            x: xmid,\r\n            y: ymid + 20 * dmax,\r\n        }, {\r\n            __sentinel: true,\r\n            x: xmid + 20 * dmax,\r\n            y: ymid - dmax,\r\n        }),\r\n    ];\r\n    var closed = [];\r\n    var edges = [];\r\n    var j;\r\n    // Incrementally add each vertex to the mesh.\r\n    i = vertices.length;\r\n    while (i--) {\r\n        // For each open triangle, check to see if the current point is\r\n        // inside it's circumcircle. If it is, remove the triangle and add\r\n        // it's edges to an edge list.\r\n        edges.length = 0;\r\n        j = open.length;\r\n        while (j--) {\r\n            // If this point is to the right of this triangle's circumcircle,\r\n            // then this triangle should never get checked again. Remove it\r\n            // from the open list, add it to the closed list, and skip.\r\n            dx = vertices[i].x - open[j].x;\r\n            if (dx > 0 && dx * dx > open[j].r) {\r\n                closed.push(open[j]);\r\n                open.splice(j, 1);\r\n                continue;\r\n            }\r\n            // If not, skip this triangle.\r\n            dy = vertices[i].y - open[j].y;\r\n            if (dx * dx + dy * dy > open[j].r) {\r\n                continue;\r\n            }\r\n            // Remove the triangle and add it's edges to the edge list.\r\n            edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);\r\n            open.splice(j, 1);\r\n        }\r\n        // Remove any doubled edges.\r\n        dedup(edges);\r\n        // Add a new triangle for each edge.\r\n        j = edges.length;\r\n        while (j) {\r\n            b = edges[--j];\r\n            a = edges[--j];\r\n            c = vertices[i];\r\n            // Avoid adding colinear triangles (which have error-prone\r\n            // circumcircles)\r\n            A = b.x - a.x;\r\n            B = b.y - a.y;\r\n            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\r\n            if (Math.abs(G) > epsilon) {\r\n                open.push(new Triangle(a, b, c));\r\n            }\r\n        }\r\n    }\r\n    // Copy any remaining open triangles to the closed list, and then\r\n    // remove any triangles that share a vertex with the supertriangle.\r\n    Array.prototype.push.apply(closed, open);\r\n    i = closed.length;\r\n    while (i--) {\r\n        if (closed[i].a.__sentinel ||\r\n            closed[i].b.__sentinel ||\r\n            closed[i].c.__sentinel) {\r\n            closed.splice(i, 1);\r\n        }\r\n    }\r\n    return closed;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}