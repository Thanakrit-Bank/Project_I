{"ast":null,"code":"import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { point } from \"@turf/helpers\"; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n\nfunction mathSign(x) {\n  return (x > 0) - (x < 0) || +x;\n}\n/**\n * Returns the direction of the point q relative to the vector p1 -> p2.\n *\n * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()\n * (same as geos::algorithm::CGAlgorithm::computeOrientation())\n *\n * @param {number[]} p1 - the origin point of the vector\n * @param {number[]} p2 - the final point of the vector\n * @param {number[]} q - the point to compute the direction to\n *\n * @returns {number} - 1 if q is ccw (left) from p1->p2,\n *    -1 if q is cw (right) from p1->p2,\n *     0 if q is colinear with p1->p2\n */\n\n\nexport function orientationIndex(p1, p2, q) {\n  var dx1 = p2[0] - p1[0],\n      dy1 = p2[1] - p1[1],\n      dx2 = q[0] - p2[0],\n      dy2 = q[1] - p2[1];\n  return mathSign(dx1 * dy2 - dx2 * dy1);\n}\n/**\n * Checks if two envelopes are equal.\n *\n * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon\n *\n * @param {Feature<Polygon>} env1 - Envelope\n * @param {Feature<Polygon>} env2 - Envelope\n * @returns {boolean} - True if the envelopes are equal\n */\n\nexport function envelopeIsEqual(env1, env2) {\n  var envX1 = env1.geometry.coordinates[0].map(function (c) {\n    return c[0];\n  }),\n      envY1 = env1.geometry.coordinates[0].map(function (c) {\n    return c[1];\n  }),\n      envX2 = env2.geometry.coordinates[0].map(function (c) {\n    return c[0];\n  }),\n      envY2 = env2.geometry.coordinates[0].map(function (c) {\n    return c[1];\n  });\n  return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);\n}\n/**\n * Check if a envelope is contained in other one.\n *\n * The function assumes that the arguments are envelopes, i.e.: Convex polygon\n * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,\n * this could be further improved.\n *\n * @param {Feature<Polygon>} self - Envelope\n * @param {Feature<Polygon>} env - Envelope\n * @returns {boolean} - True if env is contained in self\n */\n\nexport function envelopeContains(self, env) {\n  return env.geometry.coordinates[0].every(function (c) {\n    return booleanPointInPolygon(point(c), self);\n  });\n}\n/**\n * Checks if two coordinates are equal.\n *\n * @param {number[]} coord1 - First coordinate\n * @param {number[]} coord2 - Second coordinate\n * @returns {boolean} - True if coordinates are equal\n */\n\nexport function coordinatesEqual(coord1, coord2) {\n  return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}","map":{"version":3,"names":["booleanPointInPolygon","point","mathSign","x","orientationIndex","p1","p2","q","dx1","dy1","dx2","dy2","envelopeIsEqual","env1","env2","envX1","geometry","coordinates","map","c","envY1","envX2","envY2","Math","max","apply","min","envelopeContains","self","env","every","coordinatesEqual","coord1","coord2"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/polygonize/dist/es/lib/util.js"],"sourcesContent":["import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { point } from \"@turf/helpers\";\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\nfunction mathSign(x) {\n    return ((x > 0) - (x < 0) || +x);\n}\n/**\n * Returns the direction of the point q relative to the vector p1 -> p2.\n *\n * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()\n * (same as geos::algorithm::CGAlgorithm::computeOrientation())\n *\n * @param {number[]} p1 - the origin point of the vector\n * @param {number[]} p2 - the final point of the vector\n * @param {number[]} q - the point to compute the direction to\n *\n * @returns {number} - 1 if q is ccw (left) from p1->p2,\n *    -1 if q is cw (right) from p1->p2,\n *     0 if q is colinear with p1->p2\n */\nexport function orientationIndex(p1, p2, q) {\n    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];\n    return mathSign(dx1 * dy2 - dx2 * dy1);\n}\n/**\n * Checks if two envelopes are equal.\n *\n * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon\n *\n * @param {Feature<Polygon>} env1 - Envelope\n * @param {Feature<Polygon>} env2 - Envelope\n * @returns {boolean} - True if the envelopes are equal\n */\nexport function envelopeIsEqual(env1, env2) {\n    var envX1 = env1.geometry.coordinates[0].map(function (c) { return c[0]; }), envY1 = env1.geometry.coordinates[0].map(function (c) { return c[1]; }), envX2 = env2.geometry.coordinates[0].map(function (c) { return c[0]; }), envY2 = env2.geometry.coordinates[0].map(function (c) { return c[1]; });\n    return (Math.max.apply(null, envX1) === Math.max.apply(null, envX2) &&\n        Math.max.apply(null, envY1) === Math.max.apply(null, envY2) &&\n        Math.min.apply(null, envX1) === Math.min.apply(null, envX2) &&\n        Math.min.apply(null, envY1) === Math.min.apply(null, envY2));\n}\n/**\n * Check if a envelope is contained in other one.\n *\n * The function assumes that the arguments are envelopes, i.e.: Convex polygon\n * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,\n * this could be further improved.\n *\n * @param {Feature<Polygon>} self - Envelope\n * @param {Feature<Polygon>} env - Envelope\n * @returns {boolean} - True if env is contained in self\n */\nexport function envelopeContains(self, env) {\n    return env.geometry.coordinates[0].every(function (c) {\n        return booleanPointInPolygon(point(c), self);\n    });\n}\n/**\n * Checks if two coordinates are equal.\n *\n * @param {number[]} coord1 - First coordinate\n * @param {number[]} coord2 - Second coordinate\n * @returns {boolean} - True if coordinates are equal\n */\nexport function coordinatesEqual(coord1, coord2) {\n    return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}