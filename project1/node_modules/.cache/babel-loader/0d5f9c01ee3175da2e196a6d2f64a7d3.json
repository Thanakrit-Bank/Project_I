{"ast":null,"code":"import explode from '@turf/explode';\nimport centroid from '@turf/center';\nimport nearestPoint from '@turf/nearest-point';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { featureCollection, point, feature } from '@turf/helpers';\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @name pointOnFeature\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\n\nfunction pointOnFeature(geojson) {\n  // normalize\n  var fc = normalize(geojson); // get centroid\n\n  var cent = centroid(fc); // check to see if centroid is on surface\n\n  var onSurface = false;\n  var i = 0;\n\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n\n    if (geom.type === \"Point\") {\n      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      var onMultiPoint = false;\n      k = 0;\n\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      k = 0;\n\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      var j = 0;\n\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n\n          k++;\n        }\n\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n\n    i++;\n  }\n\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(explode(fc.features[i]).features);\n    } // Remove distanceToPoint properties from nearestPoint()\n\n\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\n\n\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n\n    return featureCollection([geojson]);\n  }\n\n  return geojson;\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\n\nexport default pointOnFeature;","map":{"version":3,"names":["explode","centroid","nearestPoint","booleanPointInPolygon","featureCollection","point","feature","pointOnFeature","geojson","fc","normalize","cent","onSurface","i","features","length","geom","geometry","x","y","x1","y1","x2","y2","k","onLine","type","coordinates","onMultiPoint","pointOnSegment","j","line","vertices","concat","ab","Math","sqrt","ap","pb"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/point-on-feature/dist/es/index.js"],"sourcesContent":["import explode from '@turf/explode';\nimport centroid from '@turf/center';\nimport nearestPoint from '@turf/nearest-point';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { featureCollection, point, feature } from '@turf/helpers';\n\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @name pointOnFeature\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\nfunction pointOnFeature(geojson) {\n  // normalize\n  var fc = normalize(geojson);\n\n  // get centroid\n  var cent = centroid(fc);\n\n  // check to see if centroid is on surface\n  var onSurface = false;\n  var i = 0;\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n    if (geom.type === \"Point\") {\n      if (\n        cent.geometry.coordinates[0] === geom.coordinates[0] &&\n        cent.geometry.coordinates[1] === geom.coordinates[1]\n      ) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      var onMultiPoint = false;\n      k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (\n          cent.geometry.coordinates[0] === geom.coordinates[k][0] &&\n          cent.geometry.coordinates[1] === geom.coordinates[k][1]\n        ) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      var j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(\n        explode(fc.features[i]).features\n      );\n    }\n    // Remove distanceToPoint properties from nearestPoint()\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\n\nexport default pointOnFeature;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}