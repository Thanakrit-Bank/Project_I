{"ast":null,"code":"import { cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical } from \"../cartesian\";\nimport { circleStream } from \"../circle\";\nimport { abs, cos, epsilon, pi, sqrt } from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\nexport default function (radius, delta) {\n  var cr = cos(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  } // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n\n\n  function clipLine(stream) {\n    var point0, // previous point\n    c0, // code for previous point\n    v0, // visibility of previous point\n    v00, // visibility of first point\n    _clean; // no intersections\n\n\n    return {\n      lineStart: function lineStart() {\n        v00 = v0 = false;\n        _clean = 1;\n      },\n      point: function point(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n\n        if (v !== v0) {\n          _clean = 0;\n\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t; // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            _clean = 0;\n\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function lineEnd() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function clean() {\n        return _clean | (v00 && v0) << 1;\n      }\n    };\n  } // Intersects the great circle between a and b with the clip circle.\n\n\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b); // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n\n    var n1 = [1, 0, 0],\n        // normal\n    n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0],\n        // cartesianDot(n1, n2),\n    determinant = n2n2 - n1n2 * n1n2; // Two polar points.\n\n    if (!determinant) return !two && a;\n    var c1 = cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B); // Solve |p(t)|^2 = 1.\n\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n    if (t2 < 0) return;\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n    if (!two) return q; // Two intersection points.\n\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.\n\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  } // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n\n\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}","map":{"version":3,"names":["cartesian","cartesianAddInPlace","cartesianCross","cartesianDot","cartesianScale","spherical","circleStream","abs","cos","epsilon","pi","sqrt","pointEqual","clip","radius","delta","cr","smallRadius","notHemisphere","interpolate","from","to","direction","stream","visible","lambda","phi","clipLine","point0","c0","v0","v00","clean","lineStart","point","point1","point2","v","c","code","intersect","lineEnd","t","a","b","two","pa","pb","n1","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","A","B","u","w","uu","t2","q","lambda0","lambda1","phi0","phi1","z","polar","meridian","q1","r"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/d3-geo/src/clip/circle.js"],"sourcesContent":["import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian\";\r\nimport {circleStream} from \"../circle\";\r\nimport {abs, cos, epsilon, pi, sqrt} from \"../math\";\r\nimport pointEqual from \"../pointEqual\";\r\nimport clip from \"./index\";\r\n\r\nexport default function(radius, delta) {\r\n  var cr = cos(radius),\r\n      smallRadius = cr > 0,\r\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\r\n\r\n  function interpolate(from, to, direction, stream) {\r\n    circleStream(stream, radius, delta, direction, from, to);\r\n  }\r\n\r\n  function visible(lambda, phi) {\r\n    return cos(lambda) * cos(phi) > cr;\r\n  }\r\n\r\n  // Takes a line and cuts into visible segments. Return values used for polygon\r\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\r\n  // intersections 2 - there were intersections, and the first and last segments\r\n  // should be rejoined.\r\n  function clipLine(stream) {\r\n    var point0, // previous point\r\n        c0, // code for previous point\r\n        v0, // visibility of previous point\r\n        v00, // visibility of first point\r\n        clean; // no intersections\r\n    return {\r\n      lineStart: function() {\r\n        v00 = v0 = false;\r\n        clean = 1;\r\n      },\r\n      point: function(lambda, phi) {\r\n        var point1 = [lambda, phi],\r\n            point2,\r\n            v = visible(lambda, phi),\r\n            c = smallRadius\r\n              ? v ? 0 : code(lambda, phi)\r\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\r\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\r\n        // Handle degeneracies.\r\n        // TODO ignore if not clipping polygons.\r\n        if (v !== v0) {\r\n          point2 = intersect(point0, point1);\r\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\r\n            point1[0] += epsilon;\r\n            point1[1] += epsilon;\r\n            v = visible(point1[0], point1[1]);\r\n          }\r\n        }\r\n        if (v !== v0) {\r\n          clean = 0;\r\n          if (v) {\r\n            // outside going in\r\n            stream.lineStart();\r\n            point2 = intersect(point1, point0);\r\n            stream.point(point2[0], point2[1]);\r\n          } else {\r\n            // inside going out\r\n            point2 = intersect(point0, point1);\r\n            stream.point(point2[0], point2[1]);\r\n            stream.lineEnd();\r\n          }\r\n          point0 = point2;\r\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\r\n          var t;\r\n          // If the codes for two points are different, or are both zero,\r\n          // and there this segment intersects with the small circle.\r\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\r\n            clean = 0;\r\n            if (smallRadius) {\r\n              stream.lineStart();\r\n              stream.point(t[0][0], t[0][1]);\r\n              stream.point(t[1][0], t[1][1]);\r\n              stream.lineEnd();\r\n            } else {\r\n              stream.point(t[1][0], t[1][1]);\r\n              stream.lineEnd();\r\n              stream.lineStart();\r\n              stream.point(t[0][0], t[0][1]);\r\n            }\r\n          }\r\n        }\r\n        if (v && (!point0 || !pointEqual(point0, point1))) {\r\n          stream.point(point1[0], point1[1]);\r\n        }\r\n        point0 = point1, v0 = v, c0 = c;\r\n      },\r\n      lineEnd: function() {\r\n        if (v0) stream.lineEnd();\r\n        point0 = null;\r\n      },\r\n      // Rejoin first and last segments if there were intersections and the first\r\n      // and last points were visible.\r\n      clean: function() {\r\n        return clean | ((v00 && v0) << 1);\r\n      }\r\n    };\r\n  }\r\n\r\n  // Intersects the great circle between a and b with the clip circle.\r\n  function intersect(a, b, two) {\r\n    var pa = cartesian(a),\r\n        pb = cartesian(b);\r\n\r\n    // We have two planes, n1.p = d1 and n2.p = d2.\r\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\r\n    var n1 = [1, 0, 0], // normal\r\n        n2 = cartesianCross(pa, pb),\r\n        n2n2 = cartesianDot(n2, n2),\r\n        n1n2 = n2[0], // cartesianDot(n1, n2),\r\n        determinant = n2n2 - n1n2 * n1n2;\r\n\r\n    // Two polar points.\r\n    if (!determinant) return !two && a;\r\n\r\n    var c1 =  cr * n2n2 / determinant,\r\n        c2 = -cr * n1n2 / determinant,\r\n        n1xn2 = cartesianCross(n1, n2),\r\n        A = cartesianScale(n1, c1),\r\n        B = cartesianScale(n2, c2);\r\n    cartesianAddInPlace(A, B);\r\n\r\n    // Solve |p(t)|^2 = 1.\r\n    var u = n1xn2,\r\n        w = cartesianDot(A, u),\r\n        uu = cartesianDot(u, u),\r\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\r\n\r\n    if (t2 < 0) return;\r\n\r\n    var t = sqrt(t2),\r\n        q = cartesianScale(u, (-w - t) / uu);\r\n    cartesianAddInPlace(q, A);\r\n    q = spherical(q);\r\n\r\n    if (!two) return q;\r\n\r\n    // Two intersection points.\r\n    var lambda0 = a[0],\r\n        lambda1 = b[0],\r\n        phi0 = a[1],\r\n        phi1 = b[1],\r\n        z;\r\n\r\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\r\n\r\n    var delta = lambda1 - lambda0,\r\n        polar = abs(delta - pi) < epsilon,\r\n        meridian = polar || delta < epsilon;\r\n\r\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\r\n\r\n    // Check that the first point is between a and b.\r\n    if (meridian\r\n        ? polar\r\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\r\n          : phi0 <= q[1] && q[1] <= phi1\r\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\r\n      var q1 = cartesianScale(u, (-w + t) / uu);\r\n      cartesianAddInPlace(q1, A);\r\n      return [q, spherical(q1)];\r\n    }\r\n  }\r\n\r\n  // Generates a 4-bit vector representing the location of a point relative to\r\n  // the small circle's bounding box.\r\n  function code(lambda, phi) {\r\n    var r = smallRadius ? radius : pi - radius,\r\n        code = 0;\r\n    if (lambda < -r) code |= 1; // left\r\n    else if (lambda > r) code |= 2; // right\r\n    if (phi < -r) code |= 4; // below\r\n    else if (phi > r) code |= 8; // above\r\n    return code;\r\n  }\r\n\r\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}