{"ast":null,"code":"import length from '@turf/length';\nimport lineSliceAlong from '@turf/line-slice-along';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, featureCollection } from '@turf/helpers';\n/**\n * Divides a {@link LineString} into chunks of a specified length.\n * If the line is shorter than the segment length then the original line is returned.\n *\n * @name lineChunk\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\n * @param {number} segmentLength how long to make each segment\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\n * @returns {FeatureCollection<LineString>} collection of line segments\n * @example\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\n *\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [chunk];\n */\n\nfunction lineChunk(geojson, segmentLength, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var reverse = options.reverse; // Validation\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0) throw new Error(\"segmentLength must be greater than 0\"); // Container\n\n  var results = []; // Flatten each feature to simple LineString\n\n  flattenEach(geojson, function (feature) {\n    // reverses coordinates to start the first chunked segment at the end\n    if (reverse) feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\n      results.push(segment);\n    });\n  });\n  return featureCollection(results);\n}\n/**\n * Slice Line Segments\n *\n * @private\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {number} segmentLength how long to make each segment\n * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {Function} callback iterate over sliced line segments\n * @returns {void}\n */\n\n\nfunction sliceLineSegments(line, segmentLength, units, callback) {\n  var lineLength = length(line, {\n    units: units\n  }); // If the line is shorter than the segment length then the orginal line is returned.\n\n  if (lineLength <= segmentLength) return callback(line);\n  var numberOfSegments = lineLength / segmentLength; // If numberOfSegments is integer, no need to plus 1\n\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(line, segmentLength * i, segmentLength * (i + 1), {\n      units: units\n    });\n    callback(outline, i);\n  }\n}\n\nexport default lineChunk;","map":{"version":3,"names":["length","lineSliceAlong","flattenEach","isObject","featureCollection","lineChunk","geojson","segmentLength","options","Error","units","reverse","results","feature","geometry","coordinates","sliceLineSegments","segment","push","line","callback","lineLength","numberOfSegments","Number","isInteger","Math","floor","i","outline"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/line-chunk/dist/es/index.js"],"sourcesContent":["import length from '@turf/length';\nimport lineSliceAlong from '@turf/line-slice-along';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Divides a {@link LineString} into chunks of a specified length.\n * If the line is shorter than the segment length then the original line is returned.\n *\n * @name lineChunk\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\n * @param {number} segmentLength how long to make each segment\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\n * @returns {FeatureCollection<LineString>} collection of line segments\n * @example\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\n *\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [chunk];\n */\nfunction lineChunk(geojson, segmentLength, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var reverse = options.reverse;\n\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0)\n    throw new Error(\"segmentLength must be greater than 0\");\n\n  // Container\n  var results = [];\n\n  // Flatten each feature to simple LineString\n  flattenEach(geojson, function (feature) {\n    // reverses coordinates to start the first chunked segment at the end\n    if (reverse)\n      feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\n      results.push(segment);\n    });\n  });\n  return featureCollection(results);\n}\n\n/**\n * Slice Line Segments\n *\n * @private\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {number} segmentLength how long to make each segment\n * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {Function} callback iterate over sliced line segments\n * @returns {void}\n */\nfunction sliceLineSegments(line, segmentLength, units, callback) {\n  var lineLength = length(line, { units: units });\n\n  // If the line is shorter than the segment length then the orginal line is returned.\n  if (lineLength <= segmentLength) return callback(line);\n\n  var numberOfSegments = lineLength / segmentLength;\n\n  // If numberOfSegments is integer, no need to plus 1\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(\n      line,\n      segmentLength * i,\n      segmentLength * (i + 1),\n      { units: units }\n    );\n    callback(outline, i);\n  }\n}\n\nexport default lineChunk;\n"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,cAAnB;AACA,OAAOC,cAAP,MAA2B,wBAA3B;AACA,SAASC,WAAT,QAA4B,YAA5B;AACA,SAASC,QAAT,EAAmBC,iBAAnB,QAA4C,eAA5C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,aAA5B,EAA2CC,OAA3C,EAAoD;EAClD;EACAA,OAAO,GAAGA,OAAO,IAAI,EAArB;EACA,IAAI,CAACL,QAAQ,CAACK,OAAD,CAAb,EAAwB,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;EACxB,IAAIC,KAAK,GAAGF,OAAO,CAACE,KAApB;EACA,IAAIC,OAAO,GAAGH,OAAO,CAACG,OAAtB,CALkD,CAOlD;;EACA,IAAI,CAACL,OAAL,EAAc,MAAM,IAAIG,KAAJ,CAAU,qBAAV,CAAN;EACd,IAAIF,aAAa,IAAI,CAArB,EACE,MAAM,IAAIE,KAAJ,CAAU,sCAAV,CAAN,CAVgD,CAYlD;;EACA,IAAIG,OAAO,GAAG,EAAd,CAbkD,CAelD;;EACAV,WAAW,CAACI,OAAD,EAAU,UAAUO,OAAV,EAAmB;IACtC;IACA,IAAIF,OAAJ,EACEE,OAAO,CAACC,QAAR,CAAiBC,WAAjB,GAA+BF,OAAO,CAACC,QAAR,CAAiBC,WAAjB,CAA6BJ,OAA7B,EAA/B;IAEFK,iBAAiB,CAACH,OAAD,EAAUN,aAAV,EAAyBG,KAAzB,EAAgC,UAAUO,OAAV,EAAmB;MAClEL,OAAO,CAACM,IAAR,CAAaD,OAAb;IACD,CAFgB,CAAjB;EAGD,CARU,CAAX;EASA,OAAOb,iBAAiB,CAACQ,OAAD,CAAxB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,iBAAT,CAA2BG,IAA3B,EAAiCZ,aAAjC,EAAgDG,KAAhD,EAAuDU,QAAvD,EAAiE;EAC/D,IAAIC,UAAU,GAAGrB,MAAM,CAACmB,IAAD,EAAO;IAAET,KAAK,EAAEA;EAAT,CAAP,CAAvB,CAD+D,CAG/D;;EACA,IAAIW,UAAU,IAAId,aAAlB,EAAiC,OAAOa,QAAQ,CAACD,IAAD,CAAf;EAEjC,IAAIG,gBAAgB,GAAGD,UAAU,GAAGd,aAApC,CAN+D,CAQ/D;;EACA,IAAI,CAACgB,MAAM,CAACC,SAAP,CAAiBF,gBAAjB,CAAL,EAAyC;IACvCA,gBAAgB,GAAGG,IAAI,CAACC,KAAL,CAAWJ,gBAAX,IAA+B,CAAlD;EACD;;EAED,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,gBAApB,EAAsCK,CAAC,EAAvC,EAA2C;IACzC,IAAIC,OAAO,GAAG3B,cAAc,CAC1BkB,IAD0B,EAE1BZ,aAAa,GAAGoB,CAFU,EAG1BpB,aAAa,IAAIoB,CAAC,GAAG,CAAR,CAHa,EAI1B;MAAEjB,KAAK,EAAEA;IAAT,CAJ0B,CAA5B;IAMAU,QAAQ,CAACQ,OAAD,EAAUD,CAAV,CAAR;EACD;AACF;;AAED,eAAetB,SAAf"},"metadata":{},"sourceType":"module"}