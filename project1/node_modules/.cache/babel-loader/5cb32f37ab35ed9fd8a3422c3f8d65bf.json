{"ast":null,"code":"import bearing from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\n/**\r\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\r\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\r\n *\r\n * @name angle\r\n * @param {Coord} startPoint Start Point Coordinates\r\n * @param {Coord} midPoint Mid Point Coordinates\r\n * @param {Coord} endPoint End Point Coordinates\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\r\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\r\n * @returns {number} Angle between the provided points, or its explementary.\r\n * @example\r\n * turf.angle([5, 5], [5, 6], [3, 4]);\r\n * //=45\r\n */\n\nfunction angle(startPoint, midPoint, endPoint, options) {\n  if (options === void 0) {\n    options = {};\n  } // Optional Parameters\n\n\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  } // Validation\n\n\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  } // Rename to shorter variables\n\n\n  var A = startPoint;\n  var O = midPoint;\n  var B = endPoint; // Main\n\n  var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));\n  var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));\n  var angleAO = Math.abs(azimuthAO - azimuthBO); // Explementary angle\n\n  if (options.explementary === true) {\n    return 360 - angleAO;\n  }\n\n  return angleAO;\n}\n\nexport default angle;","map":{"version":3,"names":["bearing","bearingToAzimuth","isObject","rhumbBearing","angle","startPoint","midPoint","endPoint","options","Error","A","O","B","azimuthAO","mercator","azimuthBO","angleAO","Math","abs","explementary"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/angle/dist/es/index.js"],"sourcesContent":["import bearing from \"@turf/bearing\";\r\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\r\nimport rhumbBearing from \"@turf/rhumb-bearing\";\r\n/**\r\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\r\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\r\n *\r\n * @name angle\r\n * @param {Coord} startPoint Start Point Coordinates\r\n * @param {Coord} midPoint Mid Point Coordinates\r\n * @param {Coord} endPoint End Point Coordinates\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\r\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\r\n * @returns {number} Angle between the provided points, or its explementary.\r\n * @example\r\n * turf.angle([5, 5], [5, 6], [3, 4]);\r\n * //=45\r\n */\r\nfunction angle(startPoint, midPoint, endPoint, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Optional Parameters\r\n    if (!isObject(options)) {\r\n        throw new Error(\"options is invalid\");\r\n    }\r\n    // Validation\r\n    if (!startPoint) {\r\n        throw new Error(\"startPoint is required\");\r\n    }\r\n    if (!midPoint) {\r\n        throw new Error(\"midPoint is required\");\r\n    }\r\n    if (!endPoint) {\r\n        throw new Error(\"endPoint is required\");\r\n    }\r\n    // Rename to shorter variables\r\n    var A = startPoint;\r\n    var O = midPoint;\r\n    var B = endPoint;\r\n    // Main\r\n    var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));\r\n    var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));\r\n    var angleAO = Math.abs(azimuthAO - azimuthBO);\r\n    // Explementary angle\r\n    if (options.explementary === true) {\r\n        return 360 - angleAO;\r\n    }\r\n    return angleAO;\r\n}\r\nexport default angle;\r\n"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,eAApB;AACA,SAASC,gBAAT,EAA2BC,QAA3B,QAA2C,eAA3C;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,KAAT,CAAeC,UAAf,EAA2BC,QAA3B,EAAqCC,QAArC,EAA+CC,OAA/C,EAAwD;EACpD,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe,CADW,CAEpD;;;EACA,IAAI,CAACN,QAAQ,CAACM,OAAD,CAAb,EAAwB;IACpB,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;EACH,CALmD,CAMpD;;;EACA,IAAI,CAACJ,UAAL,EAAiB;IACb,MAAM,IAAII,KAAJ,CAAU,wBAAV,CAAN;EACH;;EACD,IAAI,CAACH,QAAL,EAAe;IACX,MAAM,IAAIG,KAAJ,CAAU,sBAAV,CAAN;EACH;;EACD,IAAI,CAACF,QAAL,EAAe;IACX,MAAM,IAAIE,KAAJ,CAAU,sBAAV,CAAN;EACH,CAfmD,CAgBpD;;;EACA,IAAIC,CAAC,GAAGL,UAAR;EACA,IAAIM,CAAC,GAAGL,QAAR;EACA,IAAIM,CAAC,GAAGL,QAAR,CAnBoD,CAoBpD;;EACA,IAAIM,SAAS,GAAGZ,gBAAgB,CAACO,OAAO,CAACM,QAAR,KAAqB,IAArB,GAA4Bd,OAAO,CAACU,CAAD,EAAIC,CAAJ,CAAnC,GAA4CR,YAAY,CAACO,CAAD,EAAIC,CAAJ,CAAzD,CAAhC;EACA,IAAII,SAAS,GAAGd,gBAAgB,CAACO,OAAO,CAACM,QAAR,KAAqB,IAArB,GAA4Bd,OAAO,CAACY,CAAD,EAAID,CAAJ,CAAnC,GAA4CR,YAAY,CAACS,CAAD,EAAID,CAAJ,CAAzD,CAAhC;EACA,IAAIK,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASL,SAAS,GAAGE,SAArB,CAAd,CAvBoD,CAwBpD;;EACA,IAAIP,OAAO,CAACW,YAAR,KAAyB,IAA7B,EAAmC;IAC/B,OAAO,MAAMH,OAAb;EACH;;EACD,OAAOA,OAAP;AACH;;AACD,eAAeZ,KAAf"},"metadata":{},"sourceType":"module"}