{"ast":null,"code":"import { isObject, featureCollection, polygon } from '@turf/helpers';\nimport { collectionOf } from '@turf/invariant';\nimport { voronoi as voronoi$1 } from 'd3-voronoi';\n/**\r\n * @private\r\n * @param {Array<Array<number>>} coords representing a polygon\r\n * @returns {Feature<Polygon>} polygon\r\n */\n\nfunction coordsToPolygon(coords) {\n  coords = coords.slice();\n  coords.push(coords[0]);\n  return polygon([coords]);\n}\n/**\r\n * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection\r\n * of Voronoi polygons.\r\n *\r\n * The Voronoi algorithim used comes from the d3-voronoi package.\r\n *\r\n * @name voronoi\r\n * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.\r\n * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.\r\n * @example\r\n * var options = {\r\n *   bbox: [-70, 40, -60, 60]\r\n * };\r\n * var points = turf.randomPoint(100, options);\r\n * var voronoiPolygons = turf.voronoi(points, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [voronoiPolygons, points];\r\n */\n\n\nfunction voronoi(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var bbox = options.bbox || [-180, -85, 180, 85]; // Input Validation\n\n  if (!points) throw new Error(\"points is required\");\n  if (!Array.isArray(bbox)) throw new Error(\"bbox is invalid\");\n  collectionOf(points, \"Point\", \"points\"); // Main\n\n  return featureCollection(voronoi$1().x(function (feature) {\n    return feature.geometry.coordinates[0];\n  }).y(function (feature) {\n    return feature.geometry.coordinates[1];\n  }).extent([[bbox[0], bbox[1]], [bbox[2], bbox[3]]]).polygons(points.features).map(coordsToPolygon));\n}\n\nexport default voronoi;","map":{"version":3,"names":["isObject","featureCollection","polygon","collectionOf","voronoi","voronoi$1","coordsToPolygon","coords","slice","push","points","options","Error","bbox","Array","isArray","x","feature","geometry","coordinates","y","extent","polygons","features","map"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/voronoi/dist/es/index.js"],"sourcesContent":["import { isObject, featureCollection, polygon } from '@turf/helpers';\r\nimport { collectionOf } from '@turf/invariant';\r\nimport { voronoi as voronoi$1 } from 'd3-voronoi';\r\n\r\n/**\r\n * @private\r\n * @param {Array<Array<number>>} coords representing a polygon\r\n * @returns {Feature<Polygon>} polygon\r\n */\r\nfunction coordsToPolygon(coords) {\r\n  coords = coords.slice();\r\n  coords.push(coords[0]);\r\n  return polygon([coords]);\r\n}\r\n\r\n/**\r\n * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection\r\n * of Voronoi polygons.\r\n *\r\n * The Voronoi algorithim used comes from the d3-voronoi package.\r\n *\r\n * @name voronoi\r\n * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.\r\n * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.\r\n * @example\r\n * var options = {\r\n *   bbox: [-70, 40, -60, 60]\r\n * };\r\n * var points = turf.randomPoint(100, options);\r\n * var voronoiPolygons = turf.voronoi(points, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [voronoiPolygons, points];\r\n */\r\nfunction voronoi(points, options) {\r\n  // Optional params\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var bbox = options.bbox || [-180, -85, 180, 85];\r\n\r\n  // Input Validation\r\n  if (!points) throw new Error(\"points is required\");\r\n  if (!Array.isArray(bbox)) throw new Error(\"bbox is invalid\");\r\n  collectionOf(points, \"Point\", \"points\");\r\n\r\n  // Main\r\n  return featureCollection(\r\n    voronoi$1()\r\n      .x(function (feature) {\r\n        return feature.geometry.coordinates[0];\r\n      })\r\n      .y(function (feature) {\r\n        return feature.geometry.coordinates[1];\r\n      })\r\n      .extent([\r\n        [bbox[0], bbox[1]],\r\n        [bbox[2], bbox[3]],\r\n      ])\r\n      .polygons(points.features)\r\n      .map(coordsToPolygon)\r\n  );\r\n}\r\n\r\nexport default voronoi;\r\n"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,iBAAnB,EAAsCC,OAAtC,QAAqD,eAArD;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,SAASC,OAAO,IAAIC,SAApB,QAAqC,YAArC;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;EAC/BA,MAAM,GAAGA,MAAM,CAACC,KAAP,EAAT;EACAD,MAAM,CAACE,IAAP,CAAYF,MAAM,CAAC,CAAD,CAAlB;EACA,OAAOL,OAAO,CAAC,CAACK,MAAD,CAAD,CAAd;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASH,OAAT,CAAiBM,MAAjB,EAAyBC,OAAzB,EAAkC;EAChC;EACAA,OAAO,GAAGA,OAAO,IAAI,EAArB;EACA,IAAI,CAACX,QAAQ,CAACW,OAAD,CAAb,EAAwB,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;EACxB,IAAIC,IAAI,GAAGF,OAAO,CAACE,IAAR,IAAgB,CAAC,CAAC,GAAF,EAAO,CAAC,EAAR,EAAY,GAAZ,EAAiB,EAAjB,CAA3B,CAJgC,CAMhC;;EACA,IAAI,CAACH,MAAL,EAAa,MAAM,IAAIE,KAAJ,CAAU,oBAAV,CAAN;EACb,IAAI,CAACE,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B,MAAM,IAAID,KAAJ,CAAU,iBAAV,CAAN;EAC1BT,YAAY,CAACO,MAAD,EAAS,OAAT,EAAkB,QAAlB,CAAZ,CATgC,CAWhC;;EACA,OAAOT,iBAAiB,CACtBI,SAAS,GACNW,CADH,CACK,UAAUC,OAAV,EAAmB;IACpB,OAAOA,OAAO,CAACC,QAAR,CAAiBC,WAAjB,CAA6B,CAA7B,CAAP;EACD,CAHH,EAIGC,CAJH,CAIK,UAAUH,OAAV,EAAmB;IACpB,OAAOA,OAAO,CAACC,QAAR,CAAiBC,WAAjB,CAA6B,CAA7B,CAAP;EACD,CANH,EAOGE,MAPH,CAOU,CACN,CAACR,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CADM,EAEN,CAACA,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAFM,CAPV,EAWGS,QAXH,CAWYZ,MAAM,CAACa,QAXnB,EAYGC,GAZH,CAYOlB,eAZP,CADsB,CAAxB;AAeD;;AAED,eAAeF,OAAf"},"metadata":{},"sourceType":"module"}