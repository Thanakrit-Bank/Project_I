{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n})(this, function () {\n  'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n   * splaytree v3.1.0\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n\n\n  var Node =\n  /** @class */\n  function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n\n    return Node;\n  }();\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n\n\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n\n    while (true) {\n      var cmp = comparator(i, t.key); //if (i < t.key) {\n\n      if (cmp < 0) {\n        if (t.left === null) break; //if (i < t.left.key) {\n\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left;\n          /* rotate right */\n\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n\n        r.left = t;\n        /* link right */\n\n        r = t;\n        t = t.left; //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break; //if (i > t.right.key) {\n\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right;\n          /* rotate left */\n\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n\n        l.right = t;\n        /* link left */\n\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n\n\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n\n    return node;\n  }\n\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n\n    return {\n      left: left,\n      right: right\n    };\n  }\n\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n\n\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n\n  var Tree =\n  /** @class */\n  function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n\n\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n\n\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n\n\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n\n\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n\n        this._size--;\n        return x;\n      }\n\n      return t;\n      /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n\n\n    Tree.prototype.pop = function () {\n      var node = this._root;\n\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }\n\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n\n\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return null;\n    };\n\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n\n      return this._root;\n    };\n\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return false;\n    };\n\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = [];\n      /* Initialize stack s */\n\n      var done = false;\n\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n\n          node = node.right;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n\n\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n\n\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.left) {\n        t = t.left;\n      }\n      return t;\n    };\n\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.right) {\n        t = t.right;\n      }\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n\n\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return null;\n    };\n\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n\n      if (d.right) {\n        successor = d.right;\n\n        while (successor.left) {\n          successor = successor.left;\n        }\n\n        return successor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n\n      return successor;\n    };\n\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n\n      if (d.left !== null) {\n        predecessor = d.left;\n\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }\n\n        return predecessor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n\n      return predecessor;\n    };\n\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n\n\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n\n      if (presort === void 0) {\n        presort = false;\n      }\n\n      var size = keys.length;\n      var comparator = this._comparator; // sort if needed\n\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n\n      return this;\n    };\n\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function printNode(n) {\n          return String(n.key);\n        };\n      }\n\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n\n      var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n\n      this._root = merge(left, right, comparator);\n    };\n\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n\n    return Tree;\n  }();\n\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n\n    p.next = null;\n    return head.next;\n  }\n\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n\n    p.next = null; // that'll work even if the tree was empty\n\n    return head.next;\n  }\n\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n\n    return null;\n  }\n\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n\n      p = p.next;\n    }\n\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n\n    return head.next;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n\n\n  var isInBbox = function isInBbox(bbox, point) {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n\n\n  var getBboxOverlap = function getBboxOverlap(b1, b2) {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n\n\n  var epsilon = Number.EPSILON; // IE Polyfill\n\n  if (epsilon === undefined) epsilon = Math.pow(2, -52);\n  var EPSILON_SQ = epsilon * epsilon;\n  /* FLP comparator */\n\n  var cmp = function cmp(a, b) {\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n      if (-epsilon < b && b < epsilon) {\n        return 0;\n      }\n    } // check if they're flp equal\n\n\n    var ab = a - b;\n\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    } // normal comparison\n\n\n    return a < b ? -1 : 1;\n  };\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n\n  var PtRounder = /*#__PURE__*/function () {\n    function PtRounder() {\n      _classCallCheck(this, PtRounder);\n\n      this.reset();\n    }\n\n    _createClass(PtRounder, [{\n      key: \"reset\",\n      value: function reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n    }, {\n      key: \"round\",\n      value: function round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }]);\n\n    return PtRounder;\n  }();\n\n  var CoordRounder = /*#__PURE__*/function () {\n    function CoordRounder() {\n      _classCallCheck(this, CoordRounder);\n\n      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n      this.round(0);\n    } // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n\n\n    _createClass(CoordRounder, [{\n      key: \"round\",\n      value: function round(coord) {\n        var node = this.tree.add(coord);\n        var prevNode = this.tree.prev(node);\n\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n\n        var nextNode = this.tree.next(node);\n\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n\n        return coord;\n      }\n    }]);\n\n    return CoordRounder;\n  }(); // singleton available by import\n\n\n  var rounder = new PtRounder();\n  /* Cross Product of two vectors with first point at origin */\n\n  var crossProduct = function crossProduct(a, b) {\n    return a.x * b.y - a.y * b.x;\n  };\n  /* Dot Product of two vectors with first point at origin */\n\n\n  var dotProduct = function dotProduct(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n  /* Comparator for two vectors with same starting point */\n\n\n  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n    var v1 = {\n      x: endPt1.x - basePt.x,\n      y: endPt1.y - basePt.y\n    };\n    var v2 = {\n      x: endPt2.x - basePt.x,\n      y: endPt2.y - basePt.y\n    };\n    var kross = crossProduct(v1, v2);\n    return cmp(kross, 0);\n  };\n\n  var length = function length(v) {\n    return Math.sqrt(dotProduct(v, v));\n  };\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n\n  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n\n  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n\n  var horizontalIntersection = function horizontalIntersection(pt, v, y) {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n\n  var verticalIntersection = function verticalIntersection(pt, v, x) {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n\n  var intersection = function intersection(pt1, v1, pt2, v2) {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    var kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    var ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    var d1 = crossProduct(ve, v1) / kross;\n    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n    var x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n    var y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n    var x = (x1 + x2) / 2;\n    var y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  var SweepEvent = /*#__PURE__*/function () {\n    _createClass(SweepEvent, null, [{\n      key: \"compare\",\n      // for ordering sweep events in the sweep event queue\n      value: function compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n        if (a.point !== b.point) a.link(b); // favor right events over left\n\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n\n        return Segment.compare(a.segment, b.segment);\n      } // for ordering points in sweep line order\n\n    }, {\n      key: \"comparePoints\",\n      value: function comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      } // Warning: 'point' input will be modified and re-used (for performance)\n\n    }]);\n\n    function SweepEvent(point, isLeft) {\n      _classCallCheck(this, SweepEvent);\n\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n    }\n\n    _createClass(SweepEvent, [{\n      key: \"link\",\n      value: function link(other) {\n        if (other.point === this.point) {\n          throw new Error('Tried to link already linked events');\n        }\n\n        var otherEvents = other.point.events;\n\n        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          var evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n\n        this.checkForConsuming();\n      }\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n\n    }, {\n      key: \"checkForConsuming\",\n      value: function checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        var numEvents = this.point.events.length;\n\n        for (var i = 0; i < numEvents; i++) {\n          var evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n\n          for (var j = i + 1; j < numEvents; j++) {\n            var evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        var events = [];\n\n        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          var evt = this.point.events[i];\n\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n\n        return events;\n      }\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function getLeftmostComparator(baseEvent) {\n        var _this = this;\n\n        var cache = new Map();\n\n        var fillCache = function fillCache(linkedEvent) {\n          var nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n\n        return function (a, b) {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n\n          var _cache$get = cache.get(a),\n              asine = _cache$get.sine,\n              acosine = _cache$get.cosine;\n\n          var _cache$get2 = cache.get(b),\n              bsine = _cache$get2.sine,\n              bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          } // both below x-axis\n\n\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          } // one above x-axis, one below\n\n\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }]);\n\n    return SweepEvent;\n  }(); // segments and sweep events when all else is identical\n\n\n  var segmentId = 0;\n\n  var Segment = /*#__PURE__*/function () {\n    _createClass(Segment, null, [{\n      key: \"compare\",\n\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      value: function compare(a, b) {\n        var alx = a.leftSE.point.x;\n        var blx = b.leftSE.point.x;\n        var arx = a.rightSE.point.x;\n        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        var aly = a.leftSE.point.y;\n        var bly = b.leftSE.point.y;\n        var ary = a.rightSE.point.y;\n        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n          var aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n          var bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return -1;\n        } // is left endpoint of segment A the right-more?\n\n\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n          var bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n          var aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return 1;\n        } // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n\n\n        if (aly < bly) return -1;\n        if (aly > bly) return 1; // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n\n        if (arx < brx) {\n          var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n          if (_bCmpARight !== 0) return _bCmpARight;\n        } // is the B right endpoint more left-more?\n\n\n        if (arx > brx) {\n          var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n          if (_aCmpBRight < 0) return 1;\n          if (_aCmpBRight > 0) return -1;\n        }\n\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          var ay = ary - aly;\n          var ax = arx - alx;\n          var by = bry - bly;\n          var bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        } // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n\n\n        if (arx > brx) return 1;\n        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n\n        if (ary < bry) return -1;\n        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1; // identical segment, ie a === b\n\n        return 0;\n      }\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n\n    }]);\n\n    function Segment(leftSE, rightSE, rings, windings) {\n      _classCallCheck(this, Segment);\n\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings; // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n\n    _createClass(Segment, [{\n      key: \"replaceRightSE\",\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      value: function replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function bbox() {\n        var y1 = this.leftSE.point.y;\n        var y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n      /* A vector from the left point to the right */\n\n    }, {\n      key: \"vector\",\n      value: function vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n\n    }, {\n      key: \"comparePoint\",\n      value: function comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        var lPt = this.leftSE.point;\n        var rPt = this.rightSE.point;\n        var v = this.vector(); // Exactly vertical segments.\n\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        } // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n\n\n        var yDist = (point.y - lPt.y) / v.y;\n        var xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0; // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n\n        var xDist = (point.x - lPt.x) / v.x;\n        var yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n\n    }, {\n      key: \"getIntersection\",\n      value: function getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        var tBbox = this.bbox();\n        var oBbox = other.bbox();\n        var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        var tlp = this.leftSE.point;\n        var trp = this.rightSE.point;\n        var olp = other.leftSE.point;\n        var orp = other.rightSE.point; // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n\n        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n\n          return null;\n        } // does this left endpoint matches (other doesn't)\n\n\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return tlp;\n        } // does other left endpoint matches (this doesn't)\n\n\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return olp;\n        } // trivial intersection on right endpoints\n\n\n        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n\n        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n\n        if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n        return rounder.round(pt.x, pt.y);\n      }\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n\n    }, {\n      key: \"split\",\n      value: function split(point) {\n        var newEvents = [];\n        var alreadyLinked = point.events !== undefined;\n        var newLeftSE = new SweepEvent(point, true);\n        var newRightSE = new SweepEvent(point, false);\n        var oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        } // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n\n\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n\n        return newEvents;\n      }\n      /* Swap which event is left and right */\n\n    }, {\n      key: \"swapEvents\",\n      value: function swapEvents() {\n        var tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n\n        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n\n    }, {\n      key: \"consume\",\n      value: function consume(other) {\n        var consumer = this;\n        var consumee = other;\n\n        while (consumer.consumedBy) {\n          consumer = consumer.consumedBy;\n        }\n\n        while (consumee.consumedBy) {\n          consumee = consumee.consumedBy;\n        }\n\n        var cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n\n        if (cmp > 0) {\n          var tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        } // make sure a segment doesn't consume it's prev\n\n\n        if (consumer.prev === consumee) {\n          var _tmp = consumer;\n          consumer = consumee;\n          consumee = _tmp;\n        }\n\n        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          var ring = consumee.rings[i];\n          var winding = consumee.windings[i];\n          var index = consumer.rings.indexOf(ring);\n\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n      /* The first segment previous segment chain that is in the result */\n\n    }, {\n      key: \"prevInResult\",\n      value: function prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n    }, {\n      key: \"beforeState\",\n      value: function beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        var beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        var ringsAfter = this._afterState.rings;\n        var windingsAfter = this._afterState.windings;\n        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n          var ring = this.rings[i];\n          var winding = this.windings[i];\n          var index = ringsAfter.indexOf(ring);\n\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        } // calcualte polysAfter\n\n\n        var polysAfter = [];\n        var polysExclude = [];\n\n        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n          if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n          var _ring = ringsAfter[_i];\n          var poly = _ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (_ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n            var _index = polysAfter.indexOf(_ring.poly);\n\n            if (_index !== -1) polysAfter.splice(_index, 1);\n          }\n        } // calculate multiPolysAfter\n\n\n        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n          var mp = polysAfter[_i2].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n\n        return this._afterState;\n      }\n      /* Is this segment part of the final result? */\n\n    }, {\n      key: \"isInResult\",\n      value: function isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        var mpsBefore = this.beforeState().multiPolys;\n        var mpsAfter = this.afterState().multiPolys;\n\n        switch (operation.type) {\n          case 'union':\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              var noBefores = mpsBefore.length === 0;\n              var noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n\n          case 'intersection':\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              var least;\n              var most;\n\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n\n          case 'xor':\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n\n          case 'difference':\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              var isJustSubject = function isJustSubject(mps) {\n                return mps.length === 1 && mps[0].isSubject;\n              };\n\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n        }\n\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function fromRing(pt1, pt2, ring) {\n        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n        var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n        var leftSE = new SweepEvent(leftPt, true);\n        var rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n    }]);\n\n    return Segment;\n  }();\n\n  var RingIn = /*#__PURE__*/function () {\n    function RingIn(geomRing, poly, isExterior) {\n      _classCallCheck(this, RingIn);\n\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n\n      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      var prevPoint = firstPoint;\n\n      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n        }\n\n        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      } // add segment from last to first if last is not the same as first\n\n\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n\n    _createClass(RingIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n          var segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return RingIn;\n  }();\n\n  var PolyIn = /*#__PURE__*/function () {\n    function PolyIn(geomPoly, multiPoly) {\n      _classCallCheck(this, PolyIn);\n\n      if (!Array.isArray(geomPoly)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n\n      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        var ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n\n      this.multiPoly = multiPoly;\n    }\n\n    _createClass(PolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = this.exteriorRing.getSweepEvents();\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return PolyIn;\n  }();\n\n  var MultiPolyIn = /*#__PURE__*/function () {\n    function MultiPolyIn(geom, isSubject) {\n      _classCallCheck(this, MultiPolyIn);\n\n      if (!Array.isArray(geom)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === 'number') geom = [geom];\n      } catch (ex) {// The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n\n      for (var i = 0, iMax = geom.length; i < iMax; i++) {\n        var poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n\n      this.isSubject = isSubject;\n    }\n\n    _createClass(MultiPolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polySweepEvents = this.polys[i].getSweepEvents();\n\n          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return MultiPolyIn;\n  }();\n\n  var RingOut = /*#__PURE__*/function () {\n    _createClass(RingOut, null, [{\n      key: \"factory\",\n\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      value: function factory(allSegments) {\n        var ringsOut = [];\n\n        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n          var segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          var prevEvent = null;\n          var event = segment.leftSE;\n          var nextEvent = segment.rightSE;\n          var events = [event];\n          var startingPoint = event.point;\n          var intersectionLEs = [];\n          /* Walk the chain of linked events to form a closed ring */\n\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n            /* Is the ring complete? */\n\n            if (event.point === startingPoint) break;\n\n            while (true) {\n              var availableLEs = event.getAvailableLinkedEvents();\n              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n               * part of the algorithm malfunctioned... please file a bug report. */\n\n              if (availableLEs.length === 0) {\n                var firstPt = events[0].point;\n                var lastPt = events[events.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n              }\n              /* Only one way to go, so cotinue on the path */\n\n\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n              /* We must have an intersection. Check for a completed loop */\n\n\n              var indexLE = null;\n\n              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n\n\n              if (indexLE !== null) {\n                var intersectionLE = intersectionLEs.splice(indexLE)[0];\n                var ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n\n\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n\n              var comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n\n          ringsOut.push(new RingOut(events));\n        }\n\n        return ringsOut;\n      }\n    }]);\n\n    function RingOut(events) {\n      _classCallCheck(this, RingOut);\n\n      this.events = events;\n\n      for (var i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n\n      this.poly = null;\n    }\n\n    _createClass(RingOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        var prevPt = this.events[0].point;\n        var points = [prevPt];\n\n        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          var _pt = this.events[i].point;\n          var _nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n          points.push(_pt);\n          prevPt = _pt;\n        } // ring was all (within rounding error of angle calc) colinear points\n\n\n        if (points.length === 1) return null; // check if the starting point is necessary\n\n        var pt = points[0];\n        var nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        var step = this.isExteriorRing() ? 1 : -1;\n        var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        var iEnd = this.isExteriorRing() ? points.length : -1;\n        var orderedPoints = [];\n\n        for (var _i = iStart; _i != iEnd; _i += step) {\n          orderedPoints.push([points[_i].x, points[_i].y]);\n        }\n\n        return orderedPoints;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          var enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n\n        return this._enclosingRing;\n      }\n      /* Returns the ring that encloses this one, if any */\n\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        var leftMostEvt = this.events[0];\n\n        for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n          var evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n\n        var prevSeg = leftMostEvt.segment.prevInResult();\n        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n\n          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          } // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n\n\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }]);\n\n    return RingOut;\n  }();\n\n  var PolyOut = /*#__PURE__*/function () {\n    function PolyOut(exteriorRing) {\n      _classCallCheck(this, PolyOut);\n\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n\n    _createClass(PolyOut, [{\n      key: \"addInterior\",\n      value: function addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (geom[0] === null) return null;\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n\n        return geom;\n      }\n    }]);\n\n    return PolyOut;\n  }();\n\n  var MultiPolyOut = /*#__PURE__*/function () {\n    function MultiPolyOut(rings) {\n      _classCallCheck(this, MultiPolyOut);\n\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n\n    _createClass(MultiPolyOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n\n        return geom;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function _composePolys(rings) {\n        var polys = [];\n\n        for (var i = 0, iMax = rings.length; i < iMax; i++) {\n          var ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            var enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n\n        return polys;\n      }\n    }]);\n\n    return MultiPolyOut;\n  }();\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n\n  var SweepLine = /*#__PURE__*/function () {\n    function SweepLine(queue) {\n      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n      _classCallCheck(this, SweepLine);\n\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n\n    _createClass(SweepLine, [{\n      key: \"process\",\n      value: function process(event) {\n        var segment = event.segment;\n        var newEvents = []; // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n\n        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n        if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n        var prevNode = node;\n        var nextNode = node;\n        var prevSeg = undefined;\n        var nextSeg = undefined; // skip consumed segments still in tree\n\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        } // skip consumed segments still in tree\n\n\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          var prevMySplitter = null;\n\n          if (prevSeg) {\n            var prevInter = prevSeg.getIntersection(segment);\n\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          } // Check for intersections against the next segment in the sweep line\n\n\n          var nextMySplitter = null;\n\n          if (nextSeg) {\n            var nextInter = nextSeg.getIntersection(segment);\n\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                  newEvents.push(_newEventsFromSplit[_i]);\n                }\n              }\n            }\n          } // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n\n\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            var mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            } // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n\n            var _newEventsFromSplit2 = segment.split(mySplitter);\n\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit2[_i2]);\n            }\n          }\n\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            var inter = prevSeg.getIntersection(nextSeg);\n\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                  newEvents.push(_newEventsFromSplit3[_i3]);\n                }\n              }\n\n              if (!nextSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                  newEvents.push(_newEventsFromSplit4[_i4]);\n                }\n              }\n            }\n          }\n\n          this.tree.remove(segment);\n        }\n\n        return newEvents;\n      }\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n\n    }, {\n      key: \"_splitSafely\",\n      value: function _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        var rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        var newEvents = seg.split(pt);\n        newEvents.push(rightSE); // splitting can trigger consumption\n\n        if (seg.consumedBy === undefined) this.tree.insert(seg);\n        return newEvents;\n      }\n    }]);\n\n    return SweepLine;\n  }();\n\n  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n\n  var Operation = /*#__PURE__*/function () {\n    function Operation() {\n      _classCallCheck(this, Operation);\n    }\n\n    _createClass(Operation, [{\n      key: \"run\",\n      value: function run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */\n\n        var multipolys = [new MultiPolyIn(geom, true)];\n\n        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n\n        if (operation.type === 'difference') {\n          // in place removal\n          var subject = multipolys[0];\n          var _i = 1;\n\n          while (_i < multipolys.length) {\n            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n          }\n        }\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n\n\n        if (operation.type === 'intersection') {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n            var mpA = multipolys[_i2];\n\n            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n        /* Put segment endpoints in a priority queue */\n\n\n        var queue = new Tree(SweepEvent.compare);\n\n        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n          var sweepEvents = multipolys[_i3].getSweepEvents();\n\n          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n            queue.insert(sweepEvents[_j]);\n\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n            }\n          }\n        }\n        /* Pass the sweep line over those endpoints */\n\n\n        var sweepLine = new SweepLine(queue);\n        var prevQueueSize = queue.size;\n        var node = queue.pop();\n\n        while (node) {\n          var evt = node.key;\n\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            var seg = evt.segment;\n            throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n          }\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n          }\n\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n          }\n\n          var newEvents = sweepLine.process(evt);\n\n          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n            var _evt = newEvents[_i4];\n            if (_evt.consumedBy === undefined) queue.insert(_evt);\n          }\n\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        } // free some memory we don't need anymore\n\n\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */\n\n        var ringsOut = RingOut.factory(sweepLine.segments);\n        var result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }]);\n\n    return Operation;\n  }(); // singleton available by import\n\n\n  var operation = new Operation();\n\n  var union = function union(geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n\n    return operation.run('union', geom, moreGeoms);\n  };\n\n  var intersection$1 = function intersection(geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n\n    return operation.run('intersection', geom, moreGeoms);\n  };\n\n  var xor = function xor(geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n\n    return operation.run('xor', geom, moreGeoms);\n  };\n\n  var difference = function difference(subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n\n    return operation.run('difference', subjectGeom, clippingGeoms);\n  };\n\n  var index = {\n    union: union,\n    intersection: intersection$1,\n    xor: xor,\n    difference: difference\n  };\n  return index;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","polygonClipping","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Node","data","next","left","right","DEFAULT_COMPARE","a","b","splay","t","comparator","N","l","r","cmp","y","insert","node","split","v","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","add","remove","_remove","x","pop","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","done","push","call","range","low","high","fn","keys","_a","values","min","minNode","max","maxNode","at","index","d","successor","prev","predecessor","clear","toList","load","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","head","isEmpty","get","toString","n","String","join","update","newKey","newData","start","end","middle","Math","floor","p","list","l1","l2","p1","p2","pivot","j","tmp","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","lowerY","upperY","epsilon","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","reset","value","xRounder","CoordRounder","yRounder","round","tree","coord","prevNode","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection","pt1","pt2","ve","d1","d2","x1","x2","y1","y2","SweepEvent","ptCmp","comparePoints","link","isLeft","Segment","segment","aPt","bPt","events","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","asine","acosine","_cache$get2","bsine","bcosine","segmentId","alx","leftSE","blx","arx","rightSE","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","_bCmpARight","_aCmpBRight","ay","ax","by","bx","id","rings","windings","replaceRightSE","newRightSE","vector","isAnEndpoint","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","getIntersection","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","_tmp","ring","winding","indexOf","prevInResult","_prevInResult","beforeState","_beforeState","multiPolys","seg","afterState","_afterState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","_i","_iMax","_ring","poly","isExterior","_index","splice","_i2","_iMax2","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","abs","isJustSubject","mps","isSubject","concat","fromRing","leftPt","rightPt","cmpPts","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","getSweepEvents","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","unshift","reverse","getGeom","prevPt","points","_pt","_nextPt","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","addInterior","ringGeom","MultiPolyOut","_composePolys","polyGeom","SweepLine","queue","arguments","process","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","_newEventsFromSplit","mySplitter","cmpSplitters","_newEventsFromSplit2","inter","_newEventsFromSplit3","_i3","_iMax3","_newEventsFromSplit4","_i4","_iMax4","POLYGON_CLIPPING_MAX_QUEUE_SIZE","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","run","moreGeoms","multipolys","subject","mpA","_j","_jMax","sweepLine","prevQueueSize","_evt","result","union","_len","_key","intersection$1","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/polygon-clipping/dist/polygon-clipping.umd.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n}(this, (function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /**\n   * splaytree v3.1.0\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n  var Node =\n  /** @class */\n  function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n\n    return Node;\n  }();\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n\n\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n\n    while (true) {\n      var cmp = comparator(i, t.key); //if (i < t.key) {\n\n      if (cmp < 0) {\n        if (t.left === null) break; //if (i < t.left.key) {\n\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left;\n          /* rotate right */\n\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n\n        r.left = t;\n        /* link right */\n\n        r = t;\n        t = t.left; //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break; //if (i > t.right.key) {\n\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right;\n          /* rotate left */\n\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n\n        l.right = t;\n        /* link left */\n\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n\n\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n\n    return node;\n  }\n\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n\n    return {\n      left: left,\n      right: right\n    };\n  }\n\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n\n\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n\n  var Tree =\n  /** @class */\n  function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n\n\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n\n\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n\n\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n\n\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n\n        this._size--;\n        return x;\n      }\n\n      return t;\n      /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n\n\n    Tree.prototype.pop = function () {\n      var node = this._root;\n\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }\n\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n\n\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return null;\n    };\n\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n\n      return this._root;\n    };\n\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return false;\n    };\n\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = [];\n      /* Initialize stack s */\n\n      var done = false;\n\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n\n          node = node.right;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n\n\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n\n\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.left) {\n        t = t.left;\n      }\n      return t;\n    };\n\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.right) {\n        t = t.right;\n      }\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n\n\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return null;\n    };\n\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n\n      if (d.right) {\n        successor = d.right;\n\n        while (successor.left) {\n          successor = successor.left;\n        }\n\n        return successor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n\n      return successor;\n    };\n\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n\n      if (d.left !== null) {\n        predecessor = d.left;\n\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }\n\n        return predecessor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n\n      return predecessor;\n    };\n\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n\n\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n\n      if (presort === void 0) {\n        presort = false;\n      }\n\n      var size = keys.length;\n      var comparator = this._comparator; // sort if needed\n\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n\n      return this;\n    };\n\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function printNode(n) {\n          return String(n.key);\n        };\n      }\n\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n\n      var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n\n      this._root = merge(left, right, comparator);\n    };\n\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n\n    return Tree;\n  }();\n\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n\n    p.next = null;\n    return head.next;\n  }\n\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n\n    p.next = null; // that'll work even if the tree was empty\n\n    return head.next;\n  }\n\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n\n    return null;\n  }\n\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n\n      p = p.next;\n    }\n\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n\n    return head.next;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n  var isInBbox = function isInBbox(bbox, point) {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n\n  var getBboxOverlap = function getBboxOverlap(b1, b2) {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n  var epsilon = Number.EPSILON; // IE Polyfill\n\n  if (epsilon === undefined) epsilon = Math.pow(2, -52);\n  var EPSILON_SQ = epsilon * epsilon;\n  /* FLP comparator */\n\n  var cmp = function cmp(a, b) {\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n      if (-epsilon < b && b < epsilon) {\n        return 0;\n      }\n    } // check if they're flp equal\n\n\n    var ab = a - b;\n\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    } // normal comparison\n\n\n    return a < b ? -1 : 1;\n  };\n\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n  var PtRounder = /*#__PURE__*/function () {\n    function PtRounder() {\n      _classCallCheck(this, PtRounder);\n\n      this.reset();\n    }\n\n    _createClass(PtRounder, [{\n      key: \"reset\",\n      value: function reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n    }, {\n      key: \"round\",\n      value: function round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }]);\n\n    return PtRounder;\n  }();\n\n  var CoordRounder = /*#__PURE__*/function () {\n    function CoordRounder() {\n      _classCallCheck(this, CoordRounder);\n\n      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n      this.round(0);\n    } // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n\n\n    _createClass(CoordRounder, [{\n      key: \"round\",\n      value: function round(coord) {\n        var node = this.tree.add(coord);\n        var prevNode = this.tree.prev(node);\n\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n\n        var nextNode = this.tree.next(node);\n\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n\n        return coord;\n      }\n    }]);\n\n    return CoordRounder;\n  }(); // singleton available by import\n\n\n  var rounder = new PtRounder();\n\n  /* Cross Product of two vectors with first point at origin */\n\n  var crossProduct = function crossProduct(a, b) {\n    return a.x * b.y - a.y * b.x;\n  };\n  /* Dot Product of two vectors with first point at origin */\n\n  var dotProduct = function dotProduct(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n  /* Comparator for two vectors with same starting point */\n\n  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n    var v1 = {\n      x: endPt1.x - basePt.x,\n      y: endPt1.y - basePt.y\n    };\n    var v2 = {\n      x: endPt2.x - basePt.x,\n      y: endPt2.y - basePt.y\n    };\n    var kross = crossProduct(v1, v2);\n    return cmp(kross, 0);\n  };\n  var length = function length(v) {\n    return Math.sqrt(dotProduct(v, v));\n  };\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var horizontalIntersection = function horizontalIntersection(pt, v, y) {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var verticalIntersection = function verticalIntersection(pt, v, x) {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var intersection = function intersection(pt1, v1, pt2, v2) {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    var kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    var ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    var d1 = crossProduct(ve, v1) / kross;\n    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n    var x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n    var y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n    var x = (x1 + x2) / 2;\n    var y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  var SweepEvent = /*#__PURE__*/function () {\n    _createClass(SweepEvent, null, [{\n      key: \"compare\",\n      // for ordering sweep events in the sweep event queue\n      value: function compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n        if (a.point !== b.point) a.link(b); // favor right events over left\n\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n\n        return Segment.compare(a.segment, b.segment);\n      } // for ordering points in sweep line order\n\n    }, {\n      key: \"comparePoints\",\n      value: function comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      } // Warning: 'point' input will be modified and re-used (for performance)\n\n    }]);\n\n    function SweepEvent(point, isLeft) {\n      _classCallCheck(this, SweepEvent);\n\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n    }\n\n    _createClass(SweepEvent, [{\n      key: \"link\",\n      value: function link(other) {\n        if (other.point === this.point) {\n          throw new Error('Tried to link already linked events');\n        }\n\n        var otherEvents = other.point.events;\n\n        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          var evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n\n        this.checkForConsuming();\n      }\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n\n    }, {\n      key: \"checkForConsuming\",\n      value: function checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        var numEvents = this.point.events.length;\n\n        for (var i = 0; i < numEvents; i++) {\n          var evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n\n          for (var j = i + 1; j < numEvents; j++) {\n            var evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        var events = [];\n\n        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          var evt = this.point.events[i];\n\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n\n        return events;\n      }\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function getLeftmostComparator(baseEvent) {\n        var _this = this;\n\n        var cache = new Map();\n\n        var fillCache = function fillCache(linkedEvent) {\n          var nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n\n        return function (a, b) {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n\n          var _cache$get = cache.get(a),\n              asine = _cache$get.sine,\n              acosine = _cache$get.cosine;\n\n          var _cache$get2 = cache.get(b),\n              bsine = _cache$get2.sine,\n              bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          } // both below x-axis\n\n\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          } // one above x-axis, one below\n\n\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }]);\n\n    return SweepEvent;\n  }();\n\n  // segments and sweep events when all else is identical\n\n  var segmentId = 0;\n\n  var Segment = /*#__PURE__*/function () {\n    _createClass(Segment, null, [{\n      key: \"compare\",\n\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      value: function compare(a, b) {\n        var alx = a.leftSE.point.x;\n        var blx = b.leftSE.point.x;\n        var arx = a.rightSE.point.x;\n        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        var aly = a.leftSE.point.y;\n        var bly = b.leftSE.point.y;\n        var ary = a.rightSE.point.y;\n        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n          var aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n          var bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return -1;\n        } // is left endpoint of segment A the right-more?\n\n\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n          var bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n          var aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return 1;\n        } // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n\n\n        if (aly < bly) return -1;\n        if (aly > bly) return 1; // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n\n        if (arx < brx) {\n          var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n          if (_bCmpARight !== 0) return _bCmpARight;\n        } // is the B right endpoint more left-more?\n\n\n        if (arx > brx) {\n          var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n          if (_aCmpBRight < 0) return 1;\n          if (_aCmpBRight > 0) return -1;\n        }\n\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          var ay = ary - aly;\n          var ax = arx - alx;\n          var by = bry - bly;\n          var bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        } // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n\n\n        if (arx > brx) return 1;\n        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n\n        if (ary < bry) return -1;\n        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1; // identical segment, ie a === b\n\n        return 0;\n      }\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n\n    }]);\n\n    function Segment(leftSE, rightSE, rings, windings) {\n      _classCallCheck(this, Segment);\n\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings; // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n\n    _createClass(Segment, [{\n      key: \"replaceRightSE\",\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      value: function replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function bbox() {\n        var y1 = this.leftSE.point.y;\n        var y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n      /* A vector from the left point to the right */\n\n    }, {\n      key: \"vector\",\n      value: function vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n\n    }, {\n      key: \"comparePoint\",\n      value: function comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        var lPt = this.leftSE.point;\n        var rPt = this.rightSE.point;\n        var v = this.vector(); // Exactly vertical segments.\n\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        } // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n\n\n        var yDist = (point.y - lPt.y) / v.y;\n        var xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0; // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n\n        var xDist = (point.x - lPt.x) / v.x;\n        var yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n\n    }, {\n      key: \"getIntersection\",\n      value: function getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        var tBbox = this.bbox();\n        var oBbox = other.bbox();\n        var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        var tlp = this.leftSE.point;\n        var trp = this.rightSE.point;\n        var olp = other.leftSE.point;\n        var orp = other.rightSE.point; // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n\n        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n\n          return null;\n        } // does this left endpoint matches (other doesn't)\n\n\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return tlp;\n        } // does other left endpoint matches (this doesn't)\n\n\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return olp;\n        } // trivial intersection on right endpoints\n\n\n        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n\n        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n\n        if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n        return rounder.round(pt.x, pt.y);\n      }\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n\n    }, {\n      key: \"split\",\n      value: function split(point) {\n        var newEvents = [];\n        var alreadyLinked = point.events !== undefined;\n        var newLeftSE = new SweepEvent(point, true);\n        var newRightSE = new SweepEvent(point, false);\n        var oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        } // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n\n\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n\n        return newEvents;\n      }\n      /* Swap which event is left and right */\n\n    }, {\n      key: \"swapEvents\",\n      value: function swapEvents() {\n        var tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n\n        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n\n    }, {\n      key: \"consume\",\n      value: function consume(other) {\n        var consumer = this;\n        var consumee = other;\n\n        while (consumer.consumedBy) {\n          consumer = consumer.consumedBy;\n        }\n\n        while (consumee.consumedBy) {\n          consumee = consumee.consumedBy;\n        }\n\n        var cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n\n        if (cmp > 0) {\n          var tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        } // make sure a segment doesn't consume it's prev\n\n\n        if (consumer.prev === consumee) {\n          var _tmp = consumer;\n          consumer = consumee;\n          consumee = _tmp;\n        }\n\n        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          var ring = consumee.rings[i];\n          var winding = consumee.windings[i];\n          var index = consumer.rings.indexOf(ring);\n\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n      /* The first segment previous segment chain that is in the result */\n\n    }, {\n      key: \"prevInResult\",\n      value: function prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n    }, {\n      key: \"beforeState\",\n      value: function beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        var beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        var ringsAfter = this._afterState.rings;\n        var windingsAfter = this._afterState.windings;\n        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n          var ring = this.rings[i];\n          var winding = this.windings[i];\n          var index = ringsAfter.indexOf(ring);\n\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        } // calcualte polysAfter\n\n\n        var polysAfter = [];\n        var polysExclude = [];\n\n        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n          if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n          var _ring = ringsAfter[_i];\n          var poly = _ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (_ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n            var _index = polysAfter.indexOf(_ring.poly);\n\n            if (_index !== -1) polysAfter.splice(_index, 1);\n          }\n        } // calculate multiPolysAfter\n\n\n        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n          var mp = polysAfter[_i2].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n\n        return this._afterState;\n      }\n      /* Is this segment part of the final result? */\n\n    }, {\n      key: \"isInResult\",\n      value: function isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        var mpsBefore = this.beforeState().multiPolys;\n        var mpsAfter = this.afterState().multiPolys;\n\n        switch (operation.type) {\n          case 'union':\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              var noBefores = mpsBefore.length === 0;\n              var noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n\n          case 'intersection':\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              var least;\n              var most;\n\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n\n          case 'xor':\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n\n          case 'difference':\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              var isJustSubject = function isJustSubject(mps) {\n                return mps.length === 1 && mps[0].isSubject;\n              };\n\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n        }\n\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function fromRing(pt1, pt2, ring) {\n        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n        var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n        var leftSE = new SweepEvent(leftPt, true);\n        var rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n    }]);\n\n    return Segment;\n  }();\n\n  var RingIn = /*#__PURE__*/function () {\n    function RingIn(geomRing, poly, isExterior) {\n      _classCallCheck(this, RingIn);\n\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n\n      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      var prevPoint = firstPoint;\n\n      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n        }\n\n        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      } // add segment from last to first if last is not the same as first\n\n\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n\n    _createClass(RingIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n          var segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return RingIn;\n  }();\n  var PolyIn = /*#__PURE__*/function () {\n    function PolyIn(geomPoly, multiPoly) {\n      _classCallCheck(this, PolyIn);\n\n      if (!Array.isArray(geomPoly)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n\n      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        var ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n\n      this.multiPoly = multiPoly;\n    }\n\n    _createClass(PolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = this.exteriorRing.getSweepEvents();\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return PolyIn;\n  }();\n  var MultiPolyIn = /*#__PURE__*/function () {\n    function MultiPolyIn(geom, isSubject) {\n      _classCallCheck(this, MultiPolyIn);\n\n      if (!Array.isArray(geom)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === 'number') geom = [geom];\n      } catch (ex) {// The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n\n      for (var i = 0, iMax = geom.length; i < iMax; i++) {\n        var poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n\n      this.isSubject = isSubject;\n    }\n\n    _createClass(MultiPolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polySweepEvents = this.polys[i].getSweepEvents();\n\n          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return MultiPolyIn;\n  }();\n\n  var RingOut = /*#__PURE__*/function () {\n    _createClass(RingOut, null, [{\n      key: \"factory\",\n\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      value: function factory(allSegments) {\n        var ringsOut = [];\n\n        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n          var segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          var prevEvent = null;\n          var event = segment.leftSE;\n          var nextEvent = segment.rightSE;\n          var events = [event];\n          var startingPoint = event.point;\n          var intersectionLEs = [];\n          /* Walk the chain of linked events to form a closed ring */\n\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n            /* Is the ring complete? */\n\n            if (event.point === startingPoint) break;\n\n            while (true) {\n              var availableLEs = event.getAvailableLinkedEvents();\n              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n               * part of the algorithm malfunctioned... please file a bug report. */\n\n              if (availableLEs.length === 0) {\n                var firstPt = events[0].point;\n                var lastPt = events[events.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n              }\n              /* Only one way to go, so cotinue on the path */\n\n\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n              /* We must have an intersection. Check for a completed loop */\n\n\n              var indexLE = null;\n\n              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n\n\n              if (indexLE !== null) {\n                var intersectionLE = intersectionLEs.splice(indexLE)[0];\n                var ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n\n\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n\n              var comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n\n          ringsOut.push(new RingOut(events));\n        }\n\n        return ringsOut;\n      }\n    }]);\n\n    function RingOut(events) {\n      _classCallCheck(this, RingOut);\n\n      this.events = events;\n\n      for (var i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n\n      this.poly = null;\n    }\n\n    _createClass(RingOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        var prevPt = this.events[0].point;\n        var points = [prevPt];\n\n        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          var _pt = this.events[i].point;\n          var _nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n          points.push(_pt);\n          prevPt = _pt;\n        } // ring was all (within rounding error of angle calc) colinear points\n\n\n        if (points.length === 1) return null; // check if the starting point is necessary\n\n        var pt = points[0];\n        var nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        var step = this.isExteriorRing() ? 1 : -1;\n        var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        var iEnd = this.isExteriorRing() ? points.length : -1;\n        var orderedPoints = [];\n\n        for (var _i = iStart; _i != iEnd; _i += step) {\n          orderedPoints.push([points[_i].x, points[_i].y]);\n        }\n\n        return orderedPoints;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          var enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n\n        return this._enclosingRing;\n      }\n      /* Returns the ring that encloses this one, if any */\n\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        var leftMostEvt = this.events[0];\n\n        for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n          var evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n\n        var prevSeg = leftMostEvt.segment.prevInResult();\n        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n\n          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          } // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n\n\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }]);\n\n    return RingOut;\n  }();\n  var PolyOut = /*#__PURE__*/function () {\n    function PolyOut(exteriorRing) {\n      _classCallCheck(this, PolyOut);\n\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n\n    _createClass(PolyOut, [{\n      key: \"addInterior\",\n      value: function addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (geom[0] === null) return null;\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n\n        return geom;\n      }\n    }]);\n\n    return PolyOut;\n  }();\n  var MultiPolyOut = /*#__PURE__*/function () {\n    function MultiPolyOut(rings) {\n      _classCallCheck(this, MultiPolyOut);\n\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n\n    _createClass(MultiPolyOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n\n        return geom;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function _composePolys(rings) {\n        var polys = [];\n\n        for (var i = 0, iMax = rings.length; i < iMax; i++) {\n          var ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            var enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n\n        return polys;\n      }\n    }]);\n\n    return MultiPolyOut;\n  }();\n\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n  var SweepLine = /*#__PURE__*/function () {\n    function SweepLine(queue) {\n      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n      _classCallCheck(this, SweepLine);\n\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n\n    _createClass(SweepLine, [{\n      key: \"process\",\n      value: function process(event) {\n        var segment = event.segment;\n        var newEvents = []; // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n\n        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n        if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n        var prevNode = node;\n        var nextNode = node;\n        var prevSeg = undefined;\n        var nextSeg = undefined; // skip consumed segments still in tree\n\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        } // skip consumed segments still in tree\n\n\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          var prevMySplitter = null;\n\n          if (prevSeg) {\n            var prevInter = prevSeg.getIntersection(segment);\n\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          } // Check for intersections against the next segment in the sweep line\n\n\n          var nextMySplitter = null;\n\n          if (nextSeg) {\n            var nextInter = nextSeg.getIntersection(segment);\n\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                  newEvents.push(_newEventsFromSplit[_i]);\n                }\n              }\n            }\n          } // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n\n\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            var mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            } // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n\n            var _newEventsFromSplit2 = segment.split(mySplitter);\n\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit2[_i2]);\n            }\n          }\n\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            var inter = prevSeg.getIntersection(nextSeg);\n\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                  newEvents.push(_newEventsFromSplit3[_i3]);\n                }\n              }\n\n              if (!nextSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                  newEvents.push(_newEventsFromSplit4[_i4]);\n                }\n              }\n            }\n          }\n\n          this.tree.remove(segment);\n        }\n\n        return newEvents;\n      }\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n\n    }, {\n      key: \"_splitSafely\",\n      value: function _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        var rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        var newEvents = seg.split(pt);\n        newEvents.push(rightSE); // splitting can trigger consumption\n\n        if (seg.consumedBy === undefined) this.tree.insert(seg);\n        return newEvents;\n      }\n    }]);\n\n    return SweepLine;\n  }();\n\n  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n  var Operation = /*#__PURE__*/function () {\n    function Operation() {\n      _classCallCheck(this, Operation);\n    }\n\n    _createClass(Operation, [{\n      key: \"run\",\n      value: function run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */\n\n        var multipolys = [new MultiPolyIn(geom, true)];\n\n        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n\n        if (operation.type === 'difference') {\n          // in place removal\n          var subject = multipolys[0];\n          var _i = 1;\n\n          while (_i < multipolys.length) {\n            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n          }\n        }\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n\n\n        if (operation.type === 'intersection') {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n            var mpA = multipolys[_i2];\n\n            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n        /* Put segment endpoints in a priority queue */\n\n\n        var queue = new Tree(SweepEvent.compare);\n\n        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n          var sweepEvents = multipolys[_i3].getSweepEvents();\n\n          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n            queue.insert(sweepEvents[_j]);\n\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n            }\n          }\n        }\n        /* Pass the sweep line over those endpoints */\n\n\n        var sweepLine = new SweepLine(queue);\n        var prevQueueSize = queue.size;\n        var node = queue.pop();\n\n        while (node) {\n          var evt = node.key;\n\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            var seg = evt.segment;\n            throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n          }\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n          }\n\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n          }\n\n          var newEvents = sweepLine.process(evt);\n\n          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n            var _evt = newEvents[_i4];\n            if (_evt.consumedBy === undefined) queue.insert(_evt);\n          }\n\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        } // free some memory we don't need anymore\n\n\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */\n\n        var ringsOut = RingOut.factory(sweepLine.segments);\n        var result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }]);\n\n    return Operation;\n  }(); // singleton available by import\n\n  var operation = new Operation();\n\n  var union = function union(geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n\n    return operation.run('union', geom, moreGeoms);\n  };\n\n  var intersection$1 = function intersection(geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n\n    return operation.run('intersection', geom, moreGeoms);\n  };\n\n  var xor = function xor(geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n\n    return operation.run('xor', geom, moreGeoms);\n  };\n\n  var difference = function difference(subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n\n    return operation.run('difference', subjectGeom, clippingGeoms);\n  };\n\n  var index = {\n    union: union,\n    intersection: intersection$1,\n    xor: xor,\n    difference: difference\n  };\n\n  return index;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}