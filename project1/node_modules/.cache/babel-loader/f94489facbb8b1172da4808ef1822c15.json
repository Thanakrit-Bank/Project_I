{"ast":null,"code":"import rbush from 'geojson-rbush';\nimport square from '@turf/square';\nimport bbox from '@turf/bbox';\nimport truncate from '@turf/truncate';\nimport lineSegment from '@turf/line-segment';\nimport lineIntersect from '@turf/line-intersect';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { getType, getCoords, getCoord } from '@turf/invariant';\nimport { flattenEach, featureEach, featureReduce } from '@turf/meta';\nimport { featureCollection, lineString } from '@turf/helpers';\n/**\r\n * Split a LineString by another GeoJSON Feature.\r\n *\r\n * @name lineSplit\r\n * @param {Feature<LineString>} line LineString Feature to split\r\n * @param {Feature<any>} splitter Feature used to split line\r\n * @returns {FeatureCollection<LineString>} Split LineStrings\r\n * @example\r\n * var line = turf.lineString([[120, -25], [145, -25]]);\r\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\r\n *\r\n * var split = turf.lineSplit(line, splitter);\r\n *\r\n * //addToMap\r\n * var addToMap = [line, splitter]\r\n */\n\nfunction lineSplit(line, splitter) {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n  var lineType = getType(line);\n  var splitterType = getType(splitter);\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\") throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\") throw new Error(\"splitter cannot be a GeometryCollection\"); // remove excessive decimals from splitter\n  // to avoid possible approximation issues in rbush\n\n  var truncatedSplitter = truncate(splitter, {\n    precision: 7\n  });\n\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(line, truncatedSplitter);\n\n    case \"MultiPoint\":\n      return splitLineWithPoints(line, truncatedSplitter);\n\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter));\n  }\n}\n/**\r\n * Split LineString with MultiPoint\r\n *\r\n * @private\r\n * @param {Feature<LineString>} line LineString\r\n * @param {FeatureCollection<Point>} splitter Point\r\n * @returns {FeatureCollection<LineString>} split LineStrings\r\n */\n\n\nfunction splitLineWithPoints(line, splitter) {\n  var results = [];\n  var tree = rbush();\n  flattenEach(splitter, function (point) {\n    // Add index/id to features (needed for filter)\n    results.forEach(function (feature, index) {\n      feature.id = index;\n    }); // First Point - doesn't need to handle any previous line results\n\n    if (!results.length) {\n      results = splitLineWithPoint(line, point).features; // Add Square BBox to each feature for GeoJSON-RBush\n\n      results.forEach(function (feature) {\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\n      });\n      tree.load(featureCollection(results)); // Split with remaining points - lines might needed to be split multiple times\n    } else {\n      // Find all lines that are within the splitter's bbox\n      var search = tree.search(point);\n\n      if (search.features.length) {\n        // RBush might return multiple lines - only process the closest line to splitter\n        var closestLine = findClosestFeature(point, search); // Remove closest line from results since this will be split into two lines\n        // This removes any duplicates inside the results & index\n\n        results = results.filter(function (feature) {\n          return feature.id !== closestLine.id;\n        });\n        tree.remove(closestLine); // Append the two newly split lines into the results\n\n        featureEach(splitLineWithPoint(closestLine, point), function (line) {\n          results.push(line);\n          tree.insert(line);\n        });\n      }\n    }\n  });\n  return featureCollection(results);\n}\n/**\r\n * Split LineString with Point\r\n *\r\n * @private\r\n * @param {Feature<LineString>} line LineString\r\n * @param {Feature<Point>} splitter Point\r\n * @returns {FeatureCollection<LineString>} split LineStrings\r\n */\n\n\nfunction splitLineWithPoint(line, splitter) {\n  var results = []; // handle endpoints\n\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (pointsEquals(startPoint, getCoord(splitter)) || pointsEquals(endPoint, getCoord(splitter))) return featureCollection([line]); // Create spatial index\n\n  var tree = rbush();\n  var segments = lineSegment(line);\n  tree.load(segments); // Find all segments that are within bbox of splitter\n\n  var search = tree.search(splitter); // Return itself if point is not within spatial index\n\n  if (!search.features.length) return featureCollection([line]); // RBush might return multiple lines - only process the closest line to splitter\n\n  var closestSegment = findClosestFeature(splitter, search); // Initial value is the first point of the first segments (beginning of line)\n\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(segments, function (previous, current, index) {\n    var currentCoords = getCoords(current)[1];\n    var splitterCoords = getCoord(splitter); // Location where segment intersects with line\n\n    if (index === closestSegment.id) {\n      previous.push(splitterCoords);\n      results.push(lineString(previous)); // Don't duplicate splitter coordinate (Issue #688)\n\n      if (pointsEquals(splitterCoords, currentCoords)) return [splitterCoords];\n      return [splitterCoords, currentCoords]; // Keep iterating over coords until finished or intersection is found\n    } else {\n      previous.push(currentCoords);\n      return previous;\n    }\n  }, initialValue); // Append last line to final split results\n\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n\n  return featureCollection(results);\n}\n/**\r\n * Find Closest Feature\r\n *\r\n * @private\r\n * @param {Feature<Point>} point Feature must be closest to this point\r\n * @param {FeatureCollection<LineString>} lines Collection of Features\r\n * @returns {Feature<LineString>} closest LineString\r\n */\n\n\nfunction findClosestFeature(point, lines) {\n  if (!lines.features.length) throw new Error(\"lines must contain features\"); // Filter to one segment that is the closest to the line\n\n  if (lines.features.length === 1) return lines.features[0];\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature;\n}\n/**\r\n * Compares two points and returns if they are equals\r\n *\r\n * @private\r\n * @param {Array<number>} pt1 point\r\n * @param {Array<number>} pt2 point\r\n * @returns {boolean} true if they are equals\r\n */\n\n\nfunction pointsEquals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\nexport default lineSplit;","map":{"version":3,"names":["rbush","square","bbox","truncate","lineSegment","lineIntersect","nearestPointOnLine","getType","getCoords","getCoord","flattenEach","featureEach","featureReduce","featureCollection","lineString","lineSplit","line","splitter","Error","lineType","splitterType","truncatedSplitter","precision","splitLineWithPoint","splitLineWithPoints","results","tree","point","forEach","feature","index","id","length","features","load","search","closestLine","findClosestFeature","filter","remove","push","insert","startPoint","endPoint","geometry","coordinates","pointsEquals","segments","closestSegment","initialValue","lastCoords","previous","current","currentCoords","splitterCoords","lines","closestFeature","closestDistance","Infinity","segment","pt","dist","properties","pt1","pt2"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/line-split/dist/es/index.js"],"sourcesContent":["import rbush from 'geojson-rbush';\r\nimport square from '@turf/square';\r\nimport bbox from '@turf/bbox';\r\nimport truncate from '@turf/truncate';\r\nimport lineSegment from '@turf/line-segment';\r\nimport lineIntersect from '@turf/line-intersect';\r\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\r\nimport { getType, getCoords, getCoord } from '@turf/invariant';\r\nimport { flattenEach, featureEach, featureReduce } from '@turf/meta';\r\nimport { featureCollection, lineString } from '@turf/helpers';\r\n\r\n/**\r\n * Split a LineString by another GeoJSON Feature.\r\n *\r\n * @name lineSplit\r\n * @param {Feature<LineString>} line LineString Feature to split\r\n * @param {Feature<any>} splitter Feature used to split line\r\n * @returns {FeatureCollection<LineString>} Split LineStrings\r\n * @example\r\n * var line = turf.lineString([[120, -25], [145, -25]]);\r\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\r\n *\r\n * var split = turf.lineSplit(line, splitter);\r\n *\r\n * //addToMap\r\n * var addToMap = [line, splitter]\r\n */\r\nfunction lineSplit(line, splitter) {\r\n  if (!line) throw new Error(\"line is required\");\r\n  if (!splitter) throw new Error(\"splitter is required\");\r\n\r\n  var lineType = getType(line);\r\n  var splitterType = getType(splitter);\r\n\r\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\r\n  if (splitterType === \"FeatureCollection\")\r\n    throw new Error(\"splitter cannot be a FeatureCollection\");\r\n  if (splitterType === \"GeometryCollection\")\r\n    throw new Error(\"splitter cannot be a GeometryCollection\");\r\n\r\n  // remove excessive decimals from splitter\r\n  // to avoid possible approximation issues in rbush\r\n  var truncatedSplitter = truncate(splitter, { precision: 7 });\r\n\r\n  switch (splitterType) {\r\n    case \"Point\":\r\n      return splitLineWithPoint(line, truncatedSplitter);\r\n    case \"MultiPoint\":\r\n      return splitLineWithPoints(line, truncatedSplitter);\r\n    case \"LineString\":\r\n    case \"MultiLineString\":\r\n    case \"Polygon\":\r\n    case \"MultiPolygon\":\r\n      return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter));\r\n  }\r\n}\r\n\r\n/**\r\n * Split LineString with MultiPoint\r\n *\r\n * @private\r\n * @param {Feature<LineString>} line LineString\r\n * @param {FeatureCollection<Point>} splitter Point\r\n * @returns {FeatureCollection<LineString>} split LineStrings\r\n */\r\nfunction splitLineWithPoints(line, splitter) {\r\n  var results = [];\r\n  var tree = rbush();\r\n\r\n  flattenEach(splitter, function (point) {\r\n    // Add index/id to features (needed for filter)\r\n    results.forEach(function (feature, index) {\r\n      feature.id = index;\r\n    });\r\n    // First Point - doesn't need to handle any previous line results\r\n    if (!results.length) {\r\n      results = splitLineWithPoint(line, point).features;\r\n\r\n      // Add Square BBox to each feature for GeoJSON-RBush\r\n      results.forEach(function (feature) {\r\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\r\n      });\r\n      tree.load(featureCollection(results));\r\n      // Split with remaining points - lines might needed to be split multiple times\r\n    } else {\r\n      // Find all lines that are within the splitter's bbox\r\n      var search = tree.search(point);\r\n\r\n      if (search.features.length) {\r\n        // RBush might return multiple lines - only process the closest line to splitter\r\n        var closestLine = findClosestFeature(point, search);\r\n\r\n        // Remove closest line from results since this will be split into two lines\r\n        // This removes any duplicates inside the results & index\r\n        results = results.filter(function (feature) {\r\n          return feature.id !== closestLine.id;\r\n        });\r\n        tree.remove(closestLine);\r\n\r\n        // Append the two newly split lines into the results\r\n        featureEach(splitLineWithPoint(closestLine, point), function (line) {\r\n          results.push(line);\r\n          tree.insert(line);\r\n        });\r\n      }\r\n    }\r\n  });\r\n  return featureCollection(results);\r\n}\r\n\r\n/**\r\n * Split LineString with Point\r\n *\r\n * @private\r\n * @param {Feature<LineString>} line LineString\r\n * @param {Feature<Point>} splitter Point\r\n * @returns {FeatureCollection<LineString>} split LineStrings\r\n */\r\nfunction splitLineWithPoint(line, splitter) {\r\n  var results = [];\r\n\r\n  // handle endpoints\r\n  var startPoint = getCoords(line)[0];\r\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\r\n  if (\r\n    pointsEquals(startPoint, getCoord(splitter)) ||\r\n    pointsEquals(endPoint, getCoord(splitter))\r\n  )\r\n    return featureCollection([line]);\r\n\r\n  // Create spatial index\r\n  var tree = rbush();\r\n  var segments = lineSegment(line);\r\n  tree.load(segments);\r\n\r\n  // Find all segments that are within bbox of splitter\r\n  var search = tree.search(splitter);\r\n\r\n  // Return itself if point is not within spatial index\r\n  if (!search.features.length) return featureCollection([line]);\r\n\r\n  // RBush might return multiple lines - only process the closest line to splitter\r\n  var closestSegment = findClosestFeature(splitter, search);\r\n\r\n  // Initial value is the first point of the first segments (beginning of line)\r\n  var initialValue = [startPoint];\r\n  var lastCoords = featureReduce(\r\n    segments,\r\n    function (previous, current, index) {\r\n      var currentCoords = getCoords(current)[1];\r\n      var splitterCoords = getCoord(splitter);\r\n\r\n      // Location where segment intersects with line\r\n      if (index === closestSegment.id) {\r\n        previous.push(splitterCoords);\r\n        results.push(lineString(previous));\r\n        // Don't duplicate splitter coordinate (Issue #688)\r\n        if (pointsEquals(splitterCoords, currentCoords))\r\n          return [splitterCoords];\r\n        return [splitterCoords, currentCoords];\r\n\r\n        // Keep iterating over coords until finished or intersection is found\r\n      } else {\r\n        previous.push(currentCoords);\r\n        return previous;\r\n      }\r\n    },\r\n    initialValue\r\n  );\r\n  // Append last line to final split results\r\n  if (lastCoords.length > 1) {\r\n    results.push(lineString(lastCoords));\r\n  }\r\n  return featureCollection(results);\r\n}\r\n\r\n/**\r\n * Find Closest Feature\r\n *\r\n * @private\r\n * @param {Feature<Point>} point Feature must be closest to this point\r\n * @param {FeatureCollection<LineString>} lines Collection of Features\r\n * @returns {Feature<LineString>} closest LineString\r\n */\r\nfunction findClosestFeature(point, lines) {\r\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\r\n  // Filter to one segment that is the closest to the line\r\n  if (lines.features.length === 1) return lines.features[0];\r\n\r\n  var closestFeature;\r\n  var closestDistance = Infinity;\r\n  featureEach(lines, function (segment) {\r\n    var pt = nearestPointOnLine(segment, point);\r\n    var dist = pt.properties.dist;\r\n    if (dist < closestDistance) {\r\n      closestFeature = segment;\r\n      closestDistance = dist;\r\n    }\r\n  });\r\n  return closestFeature;\r\n}\r\n\r\n/**\r\n * Compares two points and returns if they are equals\r\n *\r\n * @private\r\n * @param {Array<number>} pt1 point\r\n * @param {Array<number>} pt2 point\r\n * @returns {boolean} true if they are equals\r\n */\r\nfunction pointsEquals(pt1, pt2) {\r\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\r\n}\r\n\r\nexport default lineSplit;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}