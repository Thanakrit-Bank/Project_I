{"ast":null,"code":"import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { coordAll } from \"@turf/meta\";\nimport { convertLength } from \"@turf/helpers\";\nimport clustering from \"density-clustering\";\n/**\r\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\r\n *\r\n * @name clustersDbscan\r\n * @param {FeatureCollection<Point>} points to be clustered\r\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\r\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\r\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\r\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\r\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\r\n * - {number} cluster - the associated clusterId\r\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\r\n * @example\r\n * // create random points with random z-values in their properties\r\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\r\n * var maxDistance = 100;\r\n * var clustered = turf.clustersDbscan(points, maxDistance);\r\n *\r\n * //addToMap\r\n * var addToMap = [clustered];\r\n */\n\nfunction clustersDbscan(points, maxDistance, options) {\n  // Input validation being handled by Typescript\n  // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n  // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n  // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n  // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n  if (options === void 0) {\n    options = {};\n  } // Clone points to prevent any mutations\n\n\n  if (options.mutate !== true) points = clone(points); // Defaults\n\n  options.minPoints = options.minPoints || 3; // create clustered ids\n\n  var dbscan = new clustering.DBSCAN();\n  var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance); // Tag points to Clusters ID\n\n  var clusterId = -1;\n  clusteredIds.forEach(function (clusterIds) {\n    clusterId++; // assign cluster ids to input points\n\n    clusterIds.forEach(function (idx) {\n      var clusterPoint = points.features[idx];\n      if (!clusterPoint.properties) clusterPoint.properties = {};\n      clusterPoint.properties.cluster = clusterId;\n      clusterPoint.properties.dbscan = \"core\";\n    });\n  }); // handle noise points, if any\n  // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\n\n  dbscan.noise.forEach(function (noiseId) {\n    var noisePoint = points.features[noiseId];\n    if (!noisePoint.properties) noisePoint.properties = {};\n    if (noisePoint.properties.cluster) noisePoint.properties.dbscan = \"edge\";else noisePoint.properties.dbscan = \"noise\";\n  });\n  return points;\n}\n\nexport default clustersDbscan;","map":{"version":3,"names":["clone","distance","coordAll","convertLength","clustering","clustersDbscan","points","maxDistance","options","mutate","minPoints","dbscan","DBSCAN","clusteredIds","run","units","clusterId","forEach","clusterIds","idx","clusterPoint","features","properties","cluster","noise","noiseId","noisePoint"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/clusters-dbscan/dist/es/index.js"],"sourcesContent":["import clone from \"@turf/clone\";\r\nimport distance from \"@turf/distance\";\r\nimport { coordAll } from \"@turf/meta\";\r\nimport { convertLength, } from \"@turf/helpers\";\r\nimport clustering from \"density-clustering\";\r\n/**\r\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\r\n *\r\n * @name clustersDbscan\r\n * @param {FeatureCollection<Point>} points to be clustered\r\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\r\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\r\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\r\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\r\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\r\n * - {number} cluster - the associated clusterId\r\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\r\n * @example\r\n * // create random points with random z-values in their properties\r\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\r\n * var maxDistance = 100;\r\n * var clustered = turf.clustersDbscan(points, maxDistance);\r\n *\r\n * //addToMap\r\n * var addToMap = [clustered];\r\n */\r\nfunction clustersDbscan(points, maxDistance, options) {\r\n    // Input validation being handled by Typescript\r\n    // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\r\n    // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\r\n    // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\r\n    // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\r\n    if (options === void 0) { options = {}; }\r\n    // Clone points to prevent any mutations\r\n    if (options.mutate !== true)\r\n        points = clone(points);\r\n    // Defaults\r\n    options.minPoints = options.minPoints || 3;\r\n    // create clustered ids\r\n    var dbscan = new clustering.DBSCAN();\r\n    var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance);\r\n    // Tag points to Clusters ID\r\n    var clusterId = -1;\r\n    clusteredIds.forEach(function (clusterIds) {\r\n        clusterId++;\r\n        // assign cluster ids to input points\r\n        clusterIds.forEach(function (idx) {\r\n            var clusterPoint = points.features[idx];\r\n            if (!clusterPoint.properties)\r\n                clusterPoint.properties = {};\r\n            clusterPoint.properties.cluster = clusterId;\r\n            clusterPoint.properties.dbscan = \"core\";\r\n        });\r\n    });\r\n    // handle noise points, if any\r\n    // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\r\n    dbscan.noise.forEach(function (noiseId) {\r\n        var noisePoint = points.features[noiseId];\r\n        if (!noisePoint.properties)\r\n            noisePoint.properties = {};\r\n        if (noisePoint.properties.cluster)\r\n            noisePoint.properties.dbscan = \"edge\";\r\n        else\r\n            noisePoint.properties.dbscan = \"noise\";\r\n    });\r\n    return points;\r\n}\r\nexport default clustersDbscan;\r\n"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,aAAlB;AACA,OAAOC,QAAP,MAAqB,gBAArB;AACA,SAASC,QAAT,QAAyB,YAAzB;AACA,SAASC,aAAT,QAA+B,eAA/B;AACA,OAAOC,UAAP,MAAuB,oBAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,MAAxB,EAAgCC,WAAhC,EAA6CC,OAA7C,EAAsD;EAClD;EACA;EACA;EACA;EACA;EACA,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe,CANS,CAOlD;;;EACA,IAAIA,OAAO,CAACC,MAAR,KAAmB,IAAvB,EACIH,MAAM,GAAGN,KAAK,CAACM,MAAD,CAAd,CAT8C,CAUlD;;EACAE,OAAO,CAACE,SAAR,GAAoBF,OAAO,CAACE,SAAR,IAAqB,CAAzC,CAXkD,CAYlD;;EACA,IAAIC,MAAM,GAAG,IAAIP,UAAU,CAACQ,MAAf,EAAb;EACA,IAAIC,YAAY,GAAGF,MAAM,CAACG,GAAP,CAAWZ,QAAQ,CAACI,MAAD,CAAnB,EAA6BH,aAAa,CAACI,WAAD,EAAcC,OAAO,CAACO,KAAtB,CAA1C,EAAwEP,OAAO,CAACE,SAAhF,EAA2FT,QAA3F,CAAnB,CAdkD,CAelD;;EACA,IAAIe,SAAS,GAAG,CAAC,CAAjB;EACAH,YAAY,CAACI,OAAb,CAAqB,UAAUC,UAAV,EAAsB;IACvCF,SAAS,GAD8B,CAEvC;;IACAE,UAAU,CAACD,OAAX,CAAmB,UAAUE,GAAV,EAAe;MAC9B,IAAIC,YAAY,GAAGd,MAAM,CAACe,QAAP,CAAgBF,GAAhB,CAAnB;MACA,IAAI,CAACC,YAAY,CAACE,UAAlB,EACIF,YAAY,CAACE,UAAb,GAA0B,EAA1B;MACJF,YAAY,CAACE,UAAb,CAAwBC,OAAxB,GAAkCP,SAAlC;MACAI,YAAY,CAACE,UAAb,CAAwBX,MAAxB,GAAiC,MAAjC;IACH,CAND;EAOH,CAVD,EAjBkD,CA4BlD;EACA;;EACAA,MAAM,CAACa,KAAP,CAAaP,OAAb,CAAqB,UAAUQ,OAAV,EAAmB;IACpC,IAAIC,UAAU,GAAGpB,MAAM,CAACe,QAAP,CAAgBI,OAAhB,CAAjB;IACA,IAAI,CAACC,UAAU,CAACJ,UAAhB,EACII,UAAU,CAACJ,UAAX,GAAwB,EAAxB;IACJ,IAAII,UAAU,CAACJ,UAAX,CAAsBC,OAA1B,EACIG,UAAU,CAACJ,UAAX,CAAsBX,MAAtB,GAA+B,MAA/B,CADJ,KAGIe,UAAU,CAACJ,UAAX,CAAsBX,MAAtB,GAA+B,OAA/B;EACP,CARD;EASA,OAAOL,MAAP;AACH;;AACD,eAAeD,cAAf"},"metadata":{},"sourceType":"module"}