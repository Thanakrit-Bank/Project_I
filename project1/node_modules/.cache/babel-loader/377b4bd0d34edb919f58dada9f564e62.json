{"ast":null,"code":"import { featureEach } from \"@turf/meta\";\nimport { featureCollection } from \"@turf/helpers\";\n/**\r\n * Get Cluster\r\n *\r\n * @name getCluster\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {*} filter Filter used on GeoJSON properties to get Cluster\r\n * @returns {FeatureCollection} Single Cluster filtered by GeoJSON Properties\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0], {'marker-symbol': 'circle'}),\r\n *     turf.point([2, 4], {'marker-symbol': 'star'}),\r\n *     turf.point([3, 6], {'marker-symbol': 'star'}),\r\n *     turf.point([5, 1], {'marker-symbol': 'square'}),\r\n *     turf.point([4, 2], {'marker-symbol': 'circle'})\r\n * ]);\r\n *\r\n * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)\r\n * var clustered = turf.clustersKmeans(geojson);\r\n *\r\n * // Retrieve first cluster (0)\r\n * var cluster = turf.getCluster(clustered, {cluster: 0});\r\n * //= cluster\r\n *\r\n * // Retrieve cluster based on custom properties\r\n * turf.getCluster(clustered, {'marker-symbol': 'circle'}).length;\r\n * //= 2\r\n * turf.getCluster(clustered, {'marker-symbol': 'square'}).length;\r\n * //= 1\r\n */\n\nexport function getCluster(geojson, filter) {\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (geojson.type !== \"FeatureCollection\") throw new Error(\"geojson must be a FeatureCollection\");\n  if (filter === undefined || filter === null) throw new Error(\"filter is required\"); // Filter Features\n\n  var features = [];\n  featureEach(geojson, function (feature) {\n    if (applyFilter(feature.properties, filter)) features.push(feature);\n  });\n  return featureCollection(features);\n}\n/**\r\n * Callback for clusterEach\r\n *\r\n * @callback clusterEachCallback\r\n * @param {FeatureCollection} [cluster] The current cluster being processed.\r\n * @param {*} [clusterValue] Value used to create cluster being processed.\r\n * @param {number} [currentIndex] The index of the current element being processed in the array.Starts at index 0\r\n * @returns {void}\r\n */\n\n/**\r\n * clusterEach\r\n *\r\n * @name clusterEach\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {string|number} property GeoJSON property key/value used to create clusters\r\n * @param {Function} callback a method that takes (cluster, clusterValue, currentIndex)\r\n * @returns {void}\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0]),\r\n *     turf.point([2, 4]),\r\n *     turf.point([3, 6]),\r\n *     turf.point([5, 1]),\r\n *     turf.point([4, 2])\r\n * ]);\r\n *\r\n * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)\r\n * var clustered = turf.clustersKmeans(geojson);\r\n *\r\n * // Iterate over each cluster\r\n * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue, currentIndex) {\r\n *     //= cluster\r\n *     //= clusterValue\r\n *     //= currentIndex\r\n * })\r\n *\r\n * // Calculate the total number of clusters\r\n * var total = 0\r\n * turf.clusterEach(clustered, 'cluster', function () {\r\n *     total++;\r\n * });\r\n *\r\n * // Create an Array of all the values retrieved from the 'cluster' property\r\n * var values = []\r\n * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue) {\r\n *     values.push(clusterValue);\r\n * });\r\n */\n\nexport function clusterEach(geojson, property, callback) {\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (geojson.type !== \"FeatureCollection\") throw new Error(\"geojson must be a FeatureCollection\");\n  if (property === undefined || property === null) throw new Error(\"property is required\"); // Create clusters based on property values\n\n  var bins = createBins(geojson, property);\n  var values = Object.keys(bins);\n\n  for (var index = 0; index < values.length; index++) {\n    var value = values[index];\n    var bin = bins[value];\n    var features = [];\n\n    for (var i = 0; i < bin.length; i++) {\n      features.push(geojson.features[bin[i]]);\n    }\n\n    callback(featureCollection(features), value, index);\n  }\n}\n/**\r\n * Callback for clusterReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback clusterReduceCallback\r\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {FeatureCollection} [cluster] The current cluster being processed.\r\n * @param {*} [clusterValue] Value used to create cluster being processed.\r\n * @param {number} [currentIndex] The index of the current element being processed in the\r\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\r\n */\n\n/**\r\n * Reduce clusters in GeoJSON Features, similar to Array.reduce()\r\n *\r\n * @name clusterReduce\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {string|number} property GeoJSON property key/value used to create clusters\r\n * @param {Function} callback a method that takes (previousValue, cluster, clusterValue, currentIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0]),\r\n *     turf.point([2, 4]),\r\n *     turf.point([3, 6]),\r\n *     turf.point([5, 1]),\r\n *     turf.point([4, 2])\r\n * ]);\r\n *\r\n * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)\r\n * var clustered = turf.clustersKmeans(geojson);\r\n *\r\n * // Iterate over each cluster and perform a calculation\r\n * var initialValue = 0\r\n * turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue, currentIndex) {\r\n *     //=previousValue\r\n *     //=cluster\r\n *     //=clusterValue\r\n *     //=currentIndex\r\n *     return previousValue++;\r\n * }, initialValue);\r\n *\r\n * // Calculate the total number of clusters\r\n * var total = turf.clusterReduce(clustered, 'cluster', function (previousValue) {\r\n *     return previousValue++;\r\n * }, 0);\r\n *\r\n * // Create an Array of all the values retrieved from the 'cluster' property\r\n * var values = turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue) {\r\n *     return previousValue.concat(clusterValue);\r\n * }, []);\r\n */\n\nexport function clusterReduce(geojson, property, callback, initialValue) {\n  var previousValue = initialValue;\n  clusterEach(geojson, property, function (cluster, clusterValue, currentIndex) {\n    if (currentIndex === 0 && initialValue === undefined) previousValue = cluster;else previousValue = callback(previousValue, cluster, clusterValue, currentIndex);\n  });\n  return previousValue;\n}\n/**\r\n * Create Bins\r\n *\r\n * @private\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {string|number} property Property values are used to create bins\r\n * @returns {Object} bins with Feature IDs\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0], {cluster: 0, foo: 'null'}),\r\n *     turf.point([2, 4], {cluster: 1, foo: 'bar'}),\r\n *     turf.point([5, 1], {0: 'foo'}),\r\n *     turf.point([3, 6], {cluster: 1}),\r\n * ]);\r\n * createBins(geojson, 'cluster');\r\n * //= { '0': [ 0 ], '1': [ 1, 3 ] }\r\n */\n\nexport function createBins(geojson, property) {\n  var bins = {};\n  featureEach(geojson, function (feature, i) {\n    var properties = feature.properties || {};\n\n    if (Object.prototype.hasOwnProperty.call(properties, String(property))) {\n      var value = properties[property];\n      if (Object.prototype.hasOwnProperty.call(bins, value)) bins[value].push(i);else bins[value] = [i];\n    }\n  });\n  return bins;\n}\n/**\r\n * Apply Filter\r\n *\r\n * @private\r\n * @param {*} properties Properties\r\n * @param {*} filter Filter\r\n * @returns {boolean} applied Filter to properties\r\n */\n\nexport function applyFilter(properties, filter) {\n  if (properties === undefined) return false;\n  var filterType = typeof filter; // String & Number\n\n  if (filterType === \"number\" || filterType === \"string\") return Object.prototype.hasOwnProperty.call(properties, filter); // Array\n  else if (Array.isArray(filter)) {\n    for (var i = 0; i < filter.length; i++) {\n      if (!applyFilter(properties, filter[i])) return false;\n    }\n\n    return true; // Object\n  } else {\n    return propertiesContainsFilter(properties, filter);\n  }\n}\n/**\r\n * Properties contains filter (does not apply deepEqual operations)\r\n *\r\n * @private\r\n * @param {*} properties Properties\r\n * @param {Object} filter Filter\r\n * @returns {boolean} does filter equal Properties\r\n * @example\r\n * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 0})\r\n * //= true\r\n * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 1})\r\n * //= false\r\n */\n\nexport function propertiesContainsFilter(properties, filter) {\n  var keys = Object.keys(filter);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (properties[key] !== filter[key]) return false;\n  }\n\n  return true;\n}\n/**\r\n * Filter Properties\r\n *\r\n * @private\r\n * @param {*} properties Properties\r\n * @param {Array<string>} keys Used to filter Properties\r\n * @returns {*} filtered Properties\r\n * @example\r\n * filterProperties({foo: 'bar', cluster: 0}, ['cluster'])\r\n * //= {cluster: 0}\r\n */\n\nexport function filterProperties(properties, keys) {\n  if (!keys) return {};\n  if (!keys.length) return {};\n  var newProperties = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (Object.prototype.hasOwnProperty.call(properties, key)) newProperties[key] = properties[key];\n  }\n\n  return newProperties;\n}","map":{"version":3,"names":["featureEach","featureCollection","getCluster","geojson","filter","Error","type","undefined","features","feature","applyFilter","properties","push","clusterEach","property","callback","bins","createBins","values","Object","keys","index","length","value","bin","i","clusterReduce","initialValue","previousValue","cluster","clusterValue","currentIndex","prototype","hasOwnProperty","call","String","filterType","Array","isArray","propertiesContainsFilter","key","filterProperties","newProperties"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/clusters/dist/es/index.js"],"sourcesContent":["import { featureEach } from \"@turf/meta\";\r\nimport { featureCollection } from \"@turf/helpers\";\r\n/**\r\n * Get Cluster\r\n *\r\n * @name getCluster\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {*} filter Filter used on GeoJSON properties to get Cluster\r\n * @returns {FeatureCollection} Single Cluster filtered by GeoJSON Properties\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0], {'marker-symbol': 'circle'}),\r\n *     turf.point([2, 4], {'marker-symbol': 'star'}),\r\n *     turf.point([3, 6], {'marker-symbol': 'star'}),\r\n *     turf.point([5, 1], {'marker-symbol': 'square'}),\r\n *     turf.point([4, 2], {'marker-symbol': 'circle'})\r\n * ]);\r\n *\r\n * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)\r\n * var clustered = turf.clustersKmeans(geojson);\r\n *\r\n * // Retrieve first cluster (0)\r\n * var cluster = turf.getCluster(clustered, {cluster: 0});\r\n * //= cluster\r\n *\r\n * // Retrieve cluster based on custom properties\r\n * turf.getCluster(clustered, {'marker-symbol': 'circle'}).length;\r\n * //= 2\r\n * turf.getCluster(clustered, {'marker-symbol': 'square'}).length;\r\n * //= 1\r\n */\r\nexport function getCluster(geojson, filter) {\r\n    // Validation\r\n    if (!geojson)\r\n        throw new Error(\"geojson is required\");\r\n    if (geojson.type !== \"FeatureCollection\")\r\n        throw new Error(\"geojson must be a FeatureCollection\");\r\n    if (filter === undefined || filter === null)\r\n        throw new Error(\"filter is required\");\r\n    // Filter Features\r\n    var features = [];\r\n    featureEach(geojson, function (feature) {\r\n        if (applyFilter(feature.properties, filter))\r\n            features.push(feature);\r\n    });\r\n    return featureCollection(features);\r\n}\r\n/**\r\n * Callback for clusterEach\r\n *\r\n * @callback clusterEachCallback\r\n * @param {FeatureCollection} [cluster] The current cluster being processed.\r\n * @param {*} [clusterValue] Value used to create cluster being processed.\r\n * @param {number} [currentIndex] The index of the current element being processed in the array.Starts at index 0\r\n * @returns {void}\r\n */\r\n/**\r\n * clusterEach\r\n *\r\n * @name clusterEach\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {string|number} property GeoJSON property key/value used to create clusters\r\n * @param {Function} callback a method that takes (cluster, clusterValue, currentIndex)\r\n * @returns {void}\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0]),\r\n *     turf.point([2, 4]),\r\n *     turf.point([3, 6]),\r\n *     turf.point([5, 1]),\r\n *     turf.point([4, 2])\r\n * ]);\r\n *\r\n * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)\r\n * var clustered = turf.clustersKmeans(geojson);\r\n *\r\n * // Iterate over each cluster\r\n * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue, currentIndex) {\r\n *     //= cluster\r\n *     //= clusterValue\r\n *     //= currentIndex\r\n * })\r\n *\r\n * // Calculate the total number of clusters\r\n * var total = 0\r\n * turf.clusterEach(clustered, 'cluster', function () {\r\n *     total++;\r\n * });\r\n *\r\n * // Create an Array of all the values retrieved from the 'cluster' property\r\n * var values = []\r\n * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue) {\r\n *     values.push(clusterValue);\r\n * });\r\n */\r\nexport function clusterEach(geojson, property, callback) {\r\n    // Validation\r\n    if (!geojson)\r\n        throw new Error(\"geojson is required\");\r\n    if (geojson.type !== \"FeatureCollection\")\r\n        throw new Error(\"geojson must be a FeatureCollection\");\r\n    if (property === undefined || property === null)\r\n        throw new Error(\"property is required\");\r\n    // Create clusters based on property values\r\n    var bins = createBins(geojson, property);\r\n    var values = Object.keys(bins);\r\n    for (var index = 0; index < values.length; index++) {\r\n        var value = values[index];\r\n        var bin = bins[value];\r\n        var features = [];\r\n        for (var i = 0; i < bin.length; i++) {\r\n            features.push(geojson.features[bin[i]]);\r\n        }\r\n        callback(featureCollection(features), value, index);\r\n    }\r\n}\r\n/**\r\n * Callback for clusterReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback clusterReduceCallback\r\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {FeatureCollection} [cluster] The current cluster being processed.\r\n * @param {*} [clusterValue] Value used to create cluster being processed.\r\n * @param {number} [currentIndex] The index of the current element being processed in the\r\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\r\n */\r\n/**\r\n * Reduce clusters in GeoJSON Features, similar to Array.reduce()\r\n *\r\n * @name clusterReduce\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {string|number} property GeoJSON property key/value used to create clusters\r\n * @param {Function} callback a method that takes (previousValue, cluster, clusterValue, currentIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0]),\r\n *     turf.point([2, 4]),\r\n *     turf.point([3, 6]),\r\n *     turf.point([5, 1]),\r\n *     turf.point([4, 2])\r\n * ]);\r\n *\r\n * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)\r\n * var clustered = turf.clustersKmeans(geojson);\r\n *\r\n * // Iterate over each cluster and perform a calculation\r\n * var initialValue = 0\r\n * turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue, currentIndex) {\r\n *     //=previousValue\r\n *     //=cluster\r\n *     //=clusterValue\r\n *     //=currentIndex\r\n *     return previousValue++;\r\n * }, initialValue);\r\n *\r\n * // Calculate the total number of clusters\r\n * var total = turf.clusterReduce(clustered, 'cluster', function (previousValue) {\r\n *     return previousValue++;\r\n * }, 0);\r\n *\r\n * // Create an Array of all the values retrieved from the 'cluster' property\r\n * var values = turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue) {\r\n *     return previousValue.concat(clusterValue);\r\n * }, []);\r\n */\r\nexport function clusterReduce(geojson, property, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    clusterEach(geojson, property, function (cluster, clusterValue, currentIndex) {\r\n        if (currentIndex === 0 && initialValue === undefined)\r\n            previousValue = cluster;\r\n        else\r\n            previousValue = callback(previousValue, cluster, clusterValue, currentIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n/**\r\n * Create Bins\r\n *\r\n * @private\r\n * @param {FeatureCollection} geojson GeoJSON Features\r\n * @param {string|number} property Property values are used to create bins\r\n * @returns {Object} bins with Feature IDs\r\n * @example\r\n * var geojson = turf.featureCollection([\r\n *     turf.point([0, 0], {cluster: 0, foo: 'null'}),\r\n *     turf.point([2, 4], {cluster: 1, foo: 'bar'}),\r\n *     turf.point([5, 1], {0: 'foo'}),\r\n *     turf.point([3, 6], {cluster: 1}),\r\n * ]);\r\n * createBins(geojson, 'cluster');\r\n * //= { '0': [ 0 ], '1': [ 1, 3 ] }\r\n */\r\nexport function createBins(geojson, property) {\r\n    var bins = {};\r\n    featureEach(geojson, function (feature, i) {\r\n        var properties = feature.properties || {};\r\n        if (Object.prototype.hasOwnProperty.call(properties, String(property))) {\r\n            var value = properties[property];\r\n            if (Object.prototype.hasOwnProperty.call(bins, value))\r\n                bins[value].push(i);\r\n            else\r\n                bins[value] = [i];\r\n        }\r\n    });\r\n    return bins;\r\n}\r\n/**\r\n * Apply Filter\r\n *\r\n * @private\r\n * @param {*} properties Properties\r\n * @param {*} filter Filter\r\n * @returns {boolean} applied Filter to properties\r\n */\r\nexport function applyFilter(properties, filter) {\r\n    if (properties === undefined)\r\n        return false;\r\n    var filterType = typeof filter;\r\n    // String & Number\r\n    if (filterType === \"number\" || filterType === \"string\")\r\n        return Object.prototype.hasOwnProperty.call(properties, filter);\r\n    // Array\r\n    else if (Array.isArray(filter)) {\r\n        for (var i = 0; i < filter.length; i++) {\r\n            if (!applyFilter(properties, filter[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n        // Object\r\n    }\r\n    else {\r\n        return propertiesContainsFilter(properties, filter);\r\n    }\r\n}\r\n/**\r\n * Properties contains filter (does not apply deepEqual operations)\r\n *\r\n * @private\r\n * @param {*} properties Properties\r\n * @param {Object} filter Filter\r\n * @returns {boolean} does filter equal Properties\r\n * @example\r\n * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 0})\r\n * //= true\r\n * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 1})\r\n * //= false\r\n */\r\nexport function propertiesContainsFilter(properties, filter) {\r\n    var keys = Object.keys(filter);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        var key = keys[i];\r\n        if (properties[key] !== filter[key])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Filter Properties\r\n *\r\n * @private\r\n * @param {*} properties Properties\r\n * @param {Array<string>} keys Used to filter Properties\r\n * @returns {*} filtered Properties\r\n * @example\r\n * filterProperties({foo: 'bar', cluster: 0}, ['cluster'])\r\n * //= {cluster: 0}\r\n */\r\nexport function filterProperties(properties, keys) {\r\n    if (!keys)\r\n        return {};\r\n    if (!keys.length)\r\n        return {};\r\n    var newProperties = {};\r\n    for (var i = 0; i < keys.length; i++) {\r\n        var key = keys[i];\r\n        if (Object.prototype.hasOwnProperty.call(properties, key))\r\n            newProperties[key] = properties[key];\r\n    }\r\n    return newProperties;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}