{"ast":null,"code":"// https://en.wikipedia.org/wiki/Rhumb_line\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\r\n * Takes two {@link Point|points} and finds the bearing angle between them along a Rhumb line\r\n * i.e. the angle measured in degrees start the north line (0 degrees)\r\n *\r\n * @name rhumbBearing\r\n * @param {Coord} start starting Point\r\n * @param {Coord} end ending Point\r\n * @param {Object} [options] Optional parameters\r\n * @param {boolean} [options.final=false] calculates the final bearing if true\r\n * @returns {number} bearing from north in decimal degrees, between -180 and 180 degrees (positive clockwise)\r\n * @example\r\n * var point1 = turf.point([-75.343, 39.984], {\"marker-color\": \"#F00\"});\r\n * var point2 = turf.point([-75.534, 39.123], {\"marker-color\": \"#00F\"});\r\n *\r\n * var bearing = turf.rhumbBearing(point1, point2);\r\n *\r\n * //addToMap\r\n * var addToMap = [point1, point2];\r\n * point1.properties.bearing = bearing;\r\n * point2.properties.bearing = bearing;\r\n */\n\nfunction rhumbBearing(start, end, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var bear360;\n\n  if (options.final) {\n    bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));\n  } else {\n    bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));\n  }\n\n  var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;\n  return bear180;\n}\n/**\r\n * Returns the bearing from ‘this’ point to destination point along a rhumb line.\r\n * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js\r\n *\r\n * @private\r\n * @param   {Array<number>} from - origin point.\r\n * @param   {Array<number>} to - destination point.\r\n * @returns {number} Bearing in degrees from north.\r\n * @example\r\n * var p1 = new LatLon(51.127, 1.338);\r\n * var p2 = new LatLon(50.964, 1.853);\r\n * var d = p1.rhumbBearingTo(p2); // 116.7 m\r\n */\n\n\nfunction calculateRhumbBearing(from, to) {\n  // φ => phi\n  // Δλ => deltaLambda\n  // Δψ => deltaPsi\n  // θ => theta\n  var phi1 = degreesToRadians(from[1]);\n  var phi2 = degreesToRadians(to[1]);\n  var deltaLambda = degreesToRadians(to[0] - from[0]); // if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:\n\n  if (deltaLambda > Math.PI) {\n    deltaLambda -= 2 * Math.PI;\n  }\n\n  if (deltaLambda < -Math.PI) {\n    deltaLambda += 2 * Math.PI;\n  }\n\n  var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n  var theta = Math.atan2(deltaLambda, deltaPsi);\n  return (radiansToDegrees(theta) + 360) % 360;\n}\n\nexport default rhumbBearing;","map":{"version":3,"names":["degreesToRadians","radiansToDegrees","getCoord","rhumbBearing","start","end","options","bear360","final","calculateRhumbBearing","bear180","from","to","phi1","phi2","deltaLambda","Math","PI","deltaPsi","log","tan","theta","atan2"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/rhumb-bearing/dist/es/index.js"],"sourcesContent":["// https://en.wikipedia.org/wiki/Rhumb_line\r\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\r\nimport { getCoord } from \"@turf/invariant\";\r\n/**\r\n * Takes two {@link Point|points} and finds the bearing angle between them along a Rhumb line\r\n * i.e. the angle measured in degrees start the north line (0 degrees)\r\n *\r\n * @name rhumbBearing\r\n * @param {Coord} start starting Point\r\n * @param {Coord} end ending Point\r\n * @param {Object} [options] Optional parameters\r\n * @param {boolean} [options.final=false] calculates the final bearing if true\r\n * @returns {number} bearing from north in decimal degrees, between -180 and 180 degrees (positive clockwise)\r\n * @example\r\n * var point1 = turf.point([-75.343, 39.984], {\"marker-color\": \"#F00\"});\r\n * var point2 = turf.point([-75.534, 39.123], {\"marker-color\": \"#00F\"});\r\n *\r\n * var bearing = turf.rhumbBearing(point1, point2);\r\n *\r\n * //addToMap\r\n * var addToMap = [point1, point2];\r\n * point1.properties.bearing = bearing;\r\n * point2.properties.bearing = bearing;\r\n */\r\nfunction rhumbBearing(start, end, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var bear360;\r\n    if (options.final) {\r\n        bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));\r\n    }\r\n    else {\r\n        bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));\r\n    }\r\n    var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;\r\n    return bear180;\r\n}\r\n/**\r\n * Returns the bearing from ‘this’ point to destination point along a rhumb line.\r\n * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js\r\n *\r\n * @private\r\n * @param   {Array<number>} from - origin point.\r\n * @param   {Array<number>} to - destination point.\r\n * @returns {number} Bearing in degrees from north.\r\n * @example\r\n * var p1 = new LatLon(51.127, 1.338);\r\n * var p2 = new LatLon(50.964, 1.853);\r\n * var d = p1.rhumbBearingTo(p2); // 116.7 m\r\n */\r\nfunction calculateRhumbBearing(from, to) {\r\n    // φ => phi\r\n    // Δλ => deltaLambda\r\n    // Δψ => deltaPsi\r\n    // θ => theta\r\n    var phi1 = degreesToRadians(from[1]);\r\n    var phi2 = degreesToRadians(to[1]);\r\n    var deltaLambda = degreesToRadians(to[0] - from[0]);\r\n    // if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:\r\n    if (deltaLambda > Math.PI) {\r\n        deltaLambda -= 2 * Math.PI;\r\n    }\r\n    if (deltaLambda < -Math.PI) {\r\n        deltaLambda += 2 * Math.PI;\r\n    }\r\n    var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\r\n    var theta = Math.atan2(deltaLambda, deltaPsi);\r\n    return (radiansToDegrees(theta) + 360) % 360;\r\n}\r\nexport default rhumbBearing;\r\n"],"mappings":"AAAA;AACA,SAASA,gBAAT,EAA2BC,gBAA3B,QAAmD,eAAnD;AACA,SAASC,QAAT,QAAyB,iBAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,GAA7B,EAAkCC,OAAlC,EAA2C;EACvC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe;;EACzC,IAAIC,OAAJ;;EACA,IAAID,OAAO,CAACE,KAAZ,EAAmB;IACfD,OAAO,GAAGE,qBAAqB,CAACP,QAAQ,CAACG,GAAD,CAAT,EAAgBH,QAAQ,CAACE,KAAD,CAAxB,CAA/B;EACH,CAFD,MAGK;IACDG,OAAO,GAAGE,qBAAqB,CAACP,QAAQ,CAACE,KAAD,CAAT,EAAkBF,QAAQ,CAACG,GAAD,CAA1B,CAA/B;EACH;;EACD,IAAIK,OAAO,GAAGH,OAAO,GAAG,GAAV,GAAgB,EAAE,MAAMA,OAAR,CAAhB,GAAmCA,OAAjD;EACA,OAAOG,OAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASD,qBAAT,CAA+BE,IAA/B,EAAqCC,EAArC,EAAyC;EACrC;EACA;EACA;EACA;EACA,IAAIC,IAAI,GAAGb,gBAAgB,CAACW,IAAI,CAAC,CAAD,CAAL,CAA3B;EACA,IAAIG,IAAI,GAAGd,gBAAgB,CAACY,EAAE,CAAC,CAAD,CAAH,CAA3B;EACA,IAAIG,WAAW,GAAGf,gBAAgB,CAACY,EAAE,CAAC,CAAD,CAAF,GAAQD,IAAI,CAAC,CAAD,CAAb,CAAlC,CAPqC,CAQrC;;EACA,IAAII,WAAW,GAAGC,IAAI,CAACC,EAAvB,EAA2B;IACvBF,WAAW,IAAI,IAAIC,IAAI,CAACC,EAAxB;EACH;;EACD,IAAIF,WAAW,GAAG,CAACC,IAAI,CAACC,EAAxB,EAA4B;IACxBF,WAAW,IAAI,IAAIC,IAAI,CAACC,EAAxB;EACH;;EACD,IAAIC,QAAQ,GAAGF,IAAI,CAACG,GAAL,CAASH,IAAI,CAACI,GAAL,CAASN,IAAI,GAAG,CAAP,GAAWE,IAAI,CAACC,EAAL,GAAU,CAA9B,IAAmCD,IAAI,CAACI,GAAL,CAASP,IAAI,GAAG,CAAP,GAAWG,IAAI,CAACC,EAAL,GAAU,CAA9B,CAA5C,CAAf;EACA,IAAII,KAAK,GAAGL,IAAI,CAACM,KAAL,CAAWP,WAAX,EAAwBG,QAAxB,CAAZ;EACA,OAAO,CAACjB,gBAAgB,CAACoB,KAAD,CAAhB,GAA0B,GAA3B,IAAkC,GAAzC;AACH;;AACD,eAAelB,YAAf"},"metadata":{},"sourceType":"module"}