{"ast":null,"code":"import { segmentEach } from \"@turf/meta\";\nimport { getGeom } from \"@turf/invariant\";\nimport lineOverlap from \"@turf/line-overlap\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport GeojsonEquality from \"geojson-equality\";\n/**\r\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\r\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\r\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\r\n *\r\n * In other words, it returns true if the two geometries overlap, provided that neither completely contains the other.\r\n *\r\n * @name booleanOverlap\r\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\r\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\r\n * @returns {boolean} true/false\r\n * @example\r\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\r\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\r\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\r\n *\r\n * turf.booleanOverlap(poly1, poly2)\r\n * //=true\r\n * turf.booleanOverlap(poly2, poly3)\r\n * //=false\r\n */\n\nexport default function booleanOverlap(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n\n  if (type1 === \"MultiPoint\" && type2 !== \"MultiPoint\" || (type1 === \"LineString\" || type1 === \"MultiLineString\") && type2 !== \"LineString\" && type2 !== \"MultiLineString\" || (type1 === \"Polygon\" || type1 === \"MultiPolygon\") && type2 !== \"Polygon\" && type2 !== \"MultiPolygon\") {\n    throw new Error(\"features must be of the same type\");\n  }\n\n  if (type1 === \"Point\") throw new Error(\"Point geometry not supported\"); // features must be not equal\n\n  var equality = new GeojsonEquality({\n    precision: 6\n  });\n  if (equality.compare(feature1, feature2)) return false;\n  var overlap = 0;\n\n  switch (type1) {\n    case \"MultiPoint\":\n      for (var i = 0; i < geom1.coordinates.length; i++) {\n        for (var j = 0; j < geom2.coordinates.length; j++) {\n          var coord1 = geom1.coordinates[i];\n          var coord2 = geom2.coordinates[j];\n\n          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n\n    case \"LineString\":\n    case \"MultiLineString\":\n      segmentEach(feature1, function (segment1) {\n        segmentEach(feature2, function (segment2) {\n          if (lineOverlap(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      segmentEach(feature1, function (segment1) {\n        segmentEach(feature2, function (segment2) {\n          if (lineIntersect(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n  }\n\n  return overlap > 0;\n}","map":{"version":3,"names":["segmentEach","getGeom","lineOverlap","lineIntersect","GeojsonEquality","booleanOverlap","feature1","feature2","geom1","geom2","type1","type","type2","Error","equality","precision","compare","overlap","i","coordinates","length","j","coord1","coord2","segment1","segment2","features"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/boolean-overlap/dist/es/index.js"],"sourcesContent":["import { segmentEach } from \"@turf/meta\";\r\nimport { getGeom } from \"@turf/invariant\";\r\nimport lineOverlap from \"@turf/line-overlap\";\r\nimport lineIntersect from \"@turf/line-intersect\";\r\nimport GeojsonEquality from \"geojson-equality\";\r\n/**\r\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\r\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\r\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\r\n *\r\n * In other words, it returns true if the two geometries overlap, provided that neither completely contains the other.\r\n *\r\n * @name booleanOverlap\r\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\r\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\r\n * @returns {boolean} true/false\r\n * @example\r\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\r\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\r\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\r\n *\r\n * turf.booleanOverlap(poly1, poly2)\r\n * //=true\r\n * turf.booleanOverlap(poly2, poly3)\r\n * //=false\r\n */\r\nexport default function booleanOverlap(feature1, feature2) {\r\n    var geom1 = getGeom(feature1);\r\n    var geom2 = getGeom(feature2);\r\n    var type1 = geom1.type;\r\n    var type2 = geom2.type;\r\n    if ((type1 === \"MultiPoint\" && type2 !== \"MultiPoint\") ||\r\n        ((type1 === \"LineString\" || type1 === \"MultiLineString\") &&\r\n            type2 !== \"LineString\" &&\r\n            type2 !== \"MultiLineString\") ||\r\n        ((type1 === \"Polygon\" || type1 === \"MultiPolygon\") &&\r\n            type2 !== \"Polygon\" &&\r\n            type2 !== \"MultiPolygon\")) {\r\n        throw new Error(\"features must be of the same type\");\r\n    }\r\n    if (type1 === \"Point\")\r\n        throw new Error(\"Point geometry not supported\");\r\n    // features must be not equal\r\n    var equality = new GeojsonEquality({ precision: 6 });\r\n    if (equality.compare(feature1, feature2))\r\n        return false;\r\n    var overlap = 0;\r\n    switch (type1) {\r\n        case \"MultiPoint\":\r\n            for (var i = 0; i < geom1.coordinates.length; i++) {\r\n                for (var j = 0; j < geom2.coordinates.length; j++) {\r\n                    var coord1 = geom1.coordinates[i];\r\n                    var coord2 = geom2.coordinates[j];\r\n                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        case \"LineString\":\r\n        case \"MultiLineString\":\r\n            segmentEach(feature1, function (segment1) {\r\n                segmentEach(feature2, function (segment2) {\r\n                    if (lineOverlap(segment1, segment2).features.length)\r\n                        overlap++;\r\n                });\r\n            });\r\n            break;\r\n        case \"Polygon\":\r\n        case \"MultiPolygon\":\r\n            segmentEach(feature1, function (segment1) {\r\n                segmentEach(feature2, function (segment2) {\r\n                    if (lineIntersect(segment1, segment2).features.length)\r\n                        overlap++;\r\n                });\r\n            });\r\n            break;\r\n    }\r\n    return overlap > 0;\r\n}\r\n"],"mappings":"AAAA,SAASA,WAAT,QAA4B,YAA5B;AACA,SAASC,OAAT,QAAwB,iBAAxB;AACA,OAAOC,WAAP,MAAwB,oBAAxB;AACA,OAAOC,aAAP,MAA0B,sBAA1B;AACA,OAAOC,eAAP,MAA4B,kBAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,cAAT,CAAwBC,QAAxB,EAAkCC,QAAlC,EAA4C;EACvD,IAAIC,KAAK,GAAGP,OAAO,CAACK,QAAD,CAAnB;EACA,IAAIG,KAAK,GAAGR,OAAO,CAACM,QAAD,CAAnB;EACA,IAAIG,KAAK,GAAGF,KAAK,CAACG,IAAlB;EACA,IAAIC,KAAK,GAAGH,KAAK,CAACE,IAAlB;;EACA,IAAKD,KAAK,KAAK,YAAV,IAA0BE,KAAK,KAAK,YAArC,IACC,CAACF,KAAK,KAAK,YAAV,IAA0BA,KAAK,KAAK,iBAArC,KACGE,KAAK,KAAK,YADb,IAEGA,KAAK,KAAK,iBAHd,IAIC,CAACF,KAAK,KAAK,SAAV,IAAuBA,KAAK,KAAK,cAAlC,KACGE,KAAK,KAAK,SADb,IAEGA,KAAK,KAAK,cANlB,EAMmC;IAC/B,MAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;EACH;;EACD,IAAIH,KAAK,KAAK,OAAd,EACI,MAAM,IAAIG,KAAJ,CAAU,8BAAV,CAAN,CAfmD,CAgBvD;;EACA,IAAIC,QAAQ,GAAG,IAAIV,eAAJ,CAAoB;IAAEW,SAAS,EAAE;EAAb,CAApB,CAAf;EACA,IAAID,QAAQ,CAACE,OAAT,CAAiBV,QAAjB,EAA2BC,QAA3B,CAAJ,EACI,OAAO,KAAP;EACJ,IAAIU,OAAO,GAAG,CAAd;;EACA,QAAQP,KAAR;IACI,KAAK,YAAL;MACI,KAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,KAAK,CAACW,WAAN,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;QAC/C,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,KAAK,CAACU,WAAN,CAAkBC,MAAtC,EAA8CC,CAAC,EAA/C,EAAmD;UAC/C,IAAIC,MAAM,GAAGd,KAAK,CAACW,WAAN,CAAkBD,CAAlB,CAAb;UACA,IAAIK,MAAM,GAAGd,KAAK,CAACU,WAAN,CAAkBE,CAAlB,CAAb;;UACA,IAAIC,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAApB,IAA2BD,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAAnD,EAAwD;YACpD,OAAO,IAAP;UACH;QACJ;MACJ;;MACD,OAAO,KAAP;;IACJ,KAAK,YAAL;IACA,KAAK,iBAAL;MACIvB,WAAW,CAACM,QAAD,EAAW,UAAUkB,QAAV,EAAoB;QACtCxB,WAAW,CAACO,QAAD,EAAW,UAAUkB,QAAV,EAAoB;UACtC,IAAIvB,WAAW,CAACsB,QAAD,EAAWC,QAAX,CAAX,CAAgCC,QAAhC,CAAyCN,MAA7C,EACIH,OAAO;QACd,CAHU,CAAX;MAIH,CALU,CAAX;MAMA;;IACJ,KAAK,SAAL;IACA,KAAK,cAAL;MACIjB,WAAW,CAACM,QAAD,EAAW,UAAUkB,QAAV,EAAoB;QACtCxB,WAAW,CAACO,QAAD,EAAW,UAAUkB,QAAV,EAAoB;UACtC,IAAItB,aAAa,CAACqB,QAAD,EAAWC,QAAX,CAAb,CAAkCC,QAAlC,CAA2CN,MAA/C,EACIH,OAAO;QACd,CAHU,CAAX;MAIH,CALU,CAAX;MAMA;EA7BR;;EA+BA,OAAOA,OAAO,GAAG,CAAjB;AACH"},"metadata":{},"sourceType":"module"}