{"ast":null,"code":"import bbox from '@turf/bbox';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { collectionOf, getCoords } from '@turf/invariant';\nimport { isObject, featureCollection, multiLineString } from '@turf/helpers';\nimport objectAssign from 'object-assign';\n/**\n * @license GNU Affero General Public License.\n * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\n * v. 1.2.0\n * https://github.com/RaumZeit/MarchingSquares.js\n *\n * MarchingSquaresJS is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * MarchingSquaresJS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * As additional permission under GNU Affero General Public License version 3\n * section 7, third-party projects (personal or commercial) may distribute,\n * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\n * requirement that said third-party project for that reason alone becomes\n * subject to any requirement of the GNU Affero General Public License version 3.\n * Any modifications to MarchingSquaresJS, however, must be shared with the public\n * and made available.\n *\n * In summary this:\n * - allows you to use MarchingSquaresJS at no cost\n * - allows you to use MarchingSquaresJS for both personal and commercial purposes\n * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\n *   license as long as this license notice is included\n * - enables you to keep the source code of your program that uses MarchingSquaresJS\n *   undisclosed\n * - forces you to share any modifications you have made to MarchingSquaresJS,\n *   e.g. bug-fixes\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Compute the isocontour(s) of a scalar 2D field given\n * a certain threshold by applying the Marching Squares\n * Algorithm. The function returns a list of path coordinates\n */\n\nvar defaultSettings = {\n  successCallback: null,\n  verbose: false\n};\nvar settings = {};\n\nfunction isoContours(data, threshold, options) {\n  /* process options */\n  options = options ? options : {};\n  var optionKeys = Object.keys(defaultSettings);\n\n  for (var i = 0; i < optionKeys.length; i++) {\n    var key = optionKeys[i];\n    var val = options[key];\n    val = typeof val !== \"undefined\" && val !== null ? val : defaultSettings[key];\n    settings[key] = val;\n  }\n\n  if (settings.verbose) console.log(\"MarchingSquaresJS-isoContours: computing isocontour for \" + threshold);\n  var ret = contourGrid2Paths(computeContourGrid(data, threshold));\n  if (typeof settings.successCallback === \"function\") settings.successCallback(ret);\n  return ret;\n}\n/*\n  Thats all for the public interface, below follows the actual\n  implementation\n*/\n\n/*\n################################\nIsocontour implementation below\n################################\n*/\n\n/* assume that x1 == 1 &&  x0 == 0 */\n\n\nfunction interpolateX(y, y0, y1) {\n  return (y - y0) / (y1 - y0);\n}\n/* compute the isocontour 4-bit grid */\n\n\nfunction computeContourGrid(data, threshold) {\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n  var ContourGrid = {\n    rows: rows,\n    cols: cols,\n    cells: []\n  };\n\n  for (var j = 0; j < rows; ++j) {\n    ContourGrid.cells[j] = [];\n\n    for (var i = 0; i < cols; ++i) {\n      /* compose the 4-bit corner representation */\n      var cval = 0;\n      var tl = data[j + 1][i];\n      var tr = data[j + 1][i + 1];\n      var br = data[j][i + 1];\n      var bl = data[j][i];\n\n      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {\n        continue;\n      }\n\n      cval |= tl >= threshold ? 8 : 0;\n      cval |= tr >= threshold ? 4 : 0;\n      cval |= br >= threshold ? 2 : 0;\n      cval |= bl >= threshold ? 1 : 0;\n      /* resolve ambiguity for cval == 5 || 10 via averaging */\n\n      var flipped = false;\n\n      if (cval === 5 || cval === 10) {\n        var average = (tl + tr + br + bl) / 4;\n\n        if (cval === 5 && average < threshold) {\n          cval = 10;\n          flipped = true;\n        } else if (cval === 10 && average < threshold) {\n          cval = 5;\n          flipped = true;\n        }\n      }\n      /* add cell to ContourGrid if it contains edges */\n\n\n      if (cval !== 0 && cval !== 15) {\n        var top, bottom, left, right;\n        top = bottom = left = right = 0.5;\n        /* interpolate edges of cell */\n\n        if (cval === 1) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          bottom = 1 - interpolateX(threshold, br, bl);\n        } else if (cval === 2) {\n          bottom = interpolateX(threshold, bl, br);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 3) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 4) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 5) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n          bottom = 1 - interpolateX(threshold, br, bl);\n          left = 1 - interpolateX(threshold, tl, bl);\n        } else if (cval === 6) {\n          bottom = interpolateX(threshold, bl, br);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 7) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 8) {\n          left = interpolateX(threshold, bl, tl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 9) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 10) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n          bottom = interpolateX(threshold, bl, br);\n          left = interpolateX(threshold, bl, tl);\n        } else if (cval === 11) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 12) {\n          left = interpolateX(threshold, bl, tl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 13) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 14) {\n          left = interpolateX(threshold, bl, tl);\n          bottom = interpolateX(threshold, bl, br);\n        } else {\n          console.log(\"MarchingSquaresJS-isoContours: Illegal cval detected: \" + cval);\n        }\n\n        ContourGrid.cells[j][i] = {\n          cval: cval,\n          flipped: flipped,\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left\n        };\n      }\n    }\n  }\n\n  return ContourGrid;\n}\n\nfunction isSaddle(cell) {\n  return cell.cval === 5 || cell.cval === 10;\n}\n\nfunction isTrivial(cell) {\n  return cell.cval === 0 || cell.cval === 15;\n}\n\nfunction clearCell(cell) {\n  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {\n    cell.cval = 15;\n  }\n}\n\nfunction getXY(cell, edge) {\n  if (edge === \"top\") {\n    return [cell.top, 1.0];\n  } else if (edge === \"bottom\") {\n    return [cell.bottom, 0.0];\n  } else if (edge === \"right\") {\n    return [1.0, cell.right];\n  } else if (edge === \"left\") {\n    return [0.0, cell.left];\n  }\n}\n\nfunction contourGrid2Paths(grid) {\n  var paths = [];\n  var path_idx = 0;\n  var epsilon = 1e-7;\n  grid.cells.forEach(function (g, j) {\n    g.forEach(function (gg, i) {\n      if (typeof gg !== \"undefined\" && !isSaddle(gg) && !isTrivial(gg)) {\n        var p = tracePath(grid.cells, j, i);\n        var merged = false;\n        /* we may try to merge paths at this point */\n\n        if (p.info === \"mergeable\") {\n          /*\n            search backwards through the path array to find an entry\n            that starts with where the current path ends...\n          */\n          var x = p.path[p.path.length - 1][0],\n              y = p.path[p.path.length - 1][1];\n\n          for (var k = path_idx - 1; k >= 0; k--) {\n            if (Math.abs(paths[k][0][0] - x) <= epsilon && Math.abs(paths[k][0][1] - y) <= epsilon) {\n              for (var l = p.path.length - 2; l >= 0; --l) {\n                paths[k].unshift(p.path[l]);\n              }\n\n              merged = true;\n              break;\n            }\n          }\n        }\n\n        if (!merged) paths[path_idx++] = p.path;\n      }\n    });\n  });\n  return paths;\n}\n/*\n  construct consecutive line segments from starting cell by\n  walking arround the enclosed area clock-wise\n  */\n\n\nfunction tracePath(grid, j, i) {\n  var maxj = grid.length;\n  var p = [];\n  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];\n  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];\n  var dx, dy;\n  var startEdge = [\"none\", \"left\", \"bottom\", \"left\", \"right\", \"none\", \"bottom\", \"left\", \"top\", \"top\", \"none\", \"top\", \"right\", \"right\", \"bottom\", \"none\"];\n  var nextEdge = [\"none\", \"bottom\", \"right\", \"right\", \"top\", \"top\", \"top\", \"top\", \"left\", \"bottom\", \"right\", \"right\", \"left\", \"bottom\", \"left\", \"none\"];\n  var edge;\n  var currentCell = grid[j][i];\n  var cval = currentCell.cval;\n  var edge = startEdge[cval];\n  var pt = getXY(currentCell, edge);\n  /* push initial segment */\n\n  p.push([i + pt[0], j + pt[1]]);\n  edge = nextEdge[cval];\n  pt = getXY(currentCell, edge);\n  p.push([i + pt[0], j + pt[1]]);\n  clearCell(currentCell);\n  /* now walk arround the enclosed area in clockwise-direction */\n\n  var k = i + dxContour[cval];\n  var l = j + dyContour[cval];\n  var prev_cval = cval;\n\n  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {\n    currentCell = grid[l][k];\n\n    if (typeof currentCell === \"undefined\") {\n      /* path ends here */\n      //console.log(k + \" \" + l + \" is undefined, stopping path!\");\n      break;\n    }\n\n    cval = currentCell.cval;\n\n    if (cval === 0 || cval === 15) {\n      return {\n        path: p,\n        info: \"mergeable\"\n      };\n    }\n\n    edge = nextEdge[cval];\n    dx = dxContour[cval];\n    dy = dyContour[cval];\n\n    if (cval === 5 || cval === 10) {\n      /* select upper or lower band, depending on previous cells cval */\n      if (cval === 5) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 10 */\n          if (dyContour[prev_cval] === -1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          } else {\n            edge = \"right\";\n            dx = 1;\n            dy = 0;\n          }\n        } else {\n          /* real case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        }\n      } else if (cval === 10) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"top\";\n            dx = 0;\n            dy = 1;\n          } else {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        } else {\n          /* real case 10 */\n          if (dyContour[prev_cval] === 1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          }\n        }\n      }\n    }\n\n    pt = getXY(currentCell, edge);\n    p.push([k + pt[0], l + pt[1]]);\n    clearCell(currentCell);\n    k += dx;\n    l += dy;\n    prev_cval = cval;\n  }\n\n  return {\n    path: p,\n    info: \"closed\"\n  };\n}\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\n\n\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags; // validation\n\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = []; // create property matrix from sorted points\n  // looping order matters here\n\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c]; // Check if zProperty exist\n\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0); // add flags\n\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\n\n\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {}; // divide points by rows with the same latitude\n\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  }); // sort points (with the same latitude) by longitude\n\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  }); // sort rows (of points with the same latitude) by latitude\n\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n/**\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\n *\n * @name isolines\n * @param {FeatureCollection<Point>} pointGrid input points\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\n * the breaks array will define the order in which the isolines are created\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\n * @example\n * // create a grid of points with random z-values in their properties\n * var extent = [0, 30, 20, 50];\n * var cellWidth = 100;\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\n *\n * for (var i = 0; i < pointGrid.features.length; i++) {\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\n * }\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n *\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\n *\n * //addToMap\n * var addToMap = [lines];\n */\n\n\nfunction isolines(pointGrid, breaks, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var commonProperties = options.commonProperties || {};\n  var breaksProperties = options.breaksProperties || []; // Input validation\n\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject(commonProperties)) throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties must be an Array\"); // Isoline methods\n\n  var matrix = gridToMatrix(pointGrid, {\n    zProperty: zProperty,\n    flip: true\n  });\n  var createdIsoLines = createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties);\n  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n  return featureCollection(scaledIsolines);\n}\n/**\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} zProperty name of the z-values property\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\n * @returns {Array<MultiLineString>} isolines\n */\n\n\nfunction createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {\n  var results = [];\n\n  for (var i = 1; i < breaks.length; i++) {\n    var threshold = +breaks[i]; // make sure it's a number\n\n    var properties = objectAssign({}, commonProperties, breaksProperties[i]);\n    properties[zProperty] = threshold;\n    var isoline = multiLineString(isoContours(matrix, threshold), properties);\n    results.push(isoline);\n  }\n\n  return results;\n}\n/**\n * Translates and scales isolines\n *\n * @private\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<MultiLineString>} isolines\n */\n\n\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  // get dimensions (on the map) of the original grid\n  var gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n\n  var originalWidth = gridBbox[2] - gridBbox[0];\n  var originalHeigth = gridBbox[3] - gridBbox[1]; // get origin, which is the first point of the last row on the rectangular data on the map\n\n  var x0 = gridBbox[0];\n  var y0 = gridBbox[1]; // get number of cells per side\n\n  var matrixWidth = matrix[0].length - 1;\n  var matrixHeight = matrix.length - 1; // calculate the scaling factor between matrix and rectangular grid on the map\n\n  var scaleX = originalWidth / matrixWidth;\n  var scaleY = originalHeigth / matrixHeight;\n\n  var resize = function resize(point) {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  }; // resize and shift each point/line of the createdIsoLines\n\n\n  createdIsoLines.forEach(function (isoline) {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\n\nexport default isolines;","map":{"version":3,"names":["bbox","featureEach","coordEach","collectionOf","getCoords","isObject","featureCollection","multiLineString","objectAssign","defaultSettings","successCallback","verbose","settings","isoContours","data","threshold","options","optionKeys","Object","keys","i","length","key","val","console","log","ret","contourGrid2Paths","computeContourGrid","interpolateX","y","y0","y1","rows","cols","ContourGrid","cells","j","cval","tl","tr","br","bl","isNaN","flipped","average","top","bottom","left","right","isSaddle","cell","isTrivial","clearCell","getXY","edge","grid","paths","path_idx","epsilon","forEach","g","gg","p","tracePath","merged","info","x","path","k","Math","abs","l","unshift","maxj","dxContour","dyContour","dx","dy","startEdge","nextEdge","currentCell","pt","push","prev_cval","gridToMatrix","Error","zProperty","flip","flags","pointsMatrix","sortPointsByLatLng","matrix","r","pointRow","row","c","point","properties","matrixPosition","points","pointsByLatitude","lat","orderedRowsByLatitude","map","rowOrderedByLongitude","sort","a","b","pointMatrix","isolines","pointGrid","breaks","commonProperties","breaksProperties","Array","isArray","createdIsoLines","createIsoLines","scaledIsolines","rescaleIsolines","results","isoline","gridBbox","originalWidth","originalHeigth","x0","matrixWidth","matrixHeight","scaleX","scaleY","resize"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/isolines/dist/es/index.js"],"sourcesContent":["import bbox from '@turf/bbox';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { collectionOf, getCoords } from '@turf/invariant';\nimport { isObject, featureCollection, multiLineString } from '@turf/helpers';\nimport objectAssign from 'object-assign';\n\n/**\n * @license GNU Affero General Public License.\n * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\n * v. 1.2.0\n * https://github.com/RaumZeit/MarchingSquares.js\n *\n * MarchingSquaresJS is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * MarchingSquaresJS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * As additional permission under GNU Affero General Public License version 3\n * section 7, third-party projects (personal or commercial) may distribute,\n * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\n * requirement that said third-party project for that reason alone becomes\n * subject to any requirement of the GNU Affero General Public License version 3.\n * Any modifications to MarchingSquaresJS, however, must be shared with the public\n * and made available.\n *\n * In summary this:\n * - allows you to use MarchingSquaresJS at no cost\n * - allows you to use MarchingSquaresJS for both personal and commercial purposes\n * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\n *   license as long as this license notice is included\n * - enables you to keep the source code of your program that uses MarchingSquaresJS\n *   undisclosed\n * - forces you to share any modifications you have made to MarchingSquaresJS,\n *   e.g. bug-fixes\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Compute the isocontour(s) of a scalar 2D field given\n * a certain threshold by applying the Marching Squares\n * Algorithm. The function returns a list of path coordinates\n */\nvar defaultSettings = {\n  successCallback: null,\n  verbose: false,\n};\n\nvar settings = {};\n\nfunction isoContours(data, threshold, options) {\n  /* process options */\n  options = options ? options : {};\n\n  var optionKeys = Object.keys(defaultSettings);\n\n  for (var i = 0; i < optionKeys.length; i++) {\n    var key = optionKeys[i];\n    var val = options[key];\n    val =\n      typeof val !== \"undefined\" && val !== null ? val : defaultSettings[key];\n\n    settings[key] = val;\n  }\n\n  if (settings.verbose)\n    console.log(\n      \"MarchingSquaresJS-isoContours: computing isocontour for \" + threshold\n    );\n\n  var ret = contourGrid2Paths(computeContourGrid(data, threshold));\n\n  if (typeof settings.successCallback === \"function\")\n    settings.successCallback(ret);\n\n  return ret;\n}\n\n/*\n  Thats all for the public interface, below follows the actual\n  implementation\n*/\n\n/*\n################################\nIsocontour implementation below\n################################\n*/\n\n/* assume that x1 == 1 &&  x0 == 0 */\nfunction interpolateX(y, y0, y1) {\n  return (y - y0) / (y1 - y0);\n}\n\n/* compute the isocontour 4-bit grid */\nfunction computeContourGrid(data, threshold) {\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n  var ContourGrid = { rows: rows, cols: cols, cells: [] };\n\n  for (var j = 0; j < rows; ++j) {\n    ContourGrid.cells[j] = [];\n    for (var i = 0; i < cols; ++i) {\n      /* compose the 4-bit corner representation */\n      var cval = 0;\n\n      var tl = data[j + 1][i];\n      var tr = data[j + 1][i + 1];\n      var br = data[j][i + 1];\n      var bl = data[j][i];\n\n      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {\n        continue;\n      }\n      cval |= tl >= threshold ? 8 : 0;\n      cval |= tr >= threshold ? 4 : 0;\n      cval |= br >= threshold ? 2 : 0;\n      cval |= bl >= threshold ? 1 : 0;\n\n      /* resolve ambiguity for cval == 5 || 10 via averaging */\n      var flipped = false;\n      if (cval === 5 || cval === 10) {\n        var average = (tl + tr + br + bl) / 4;\n        if (cval === 5 && average < threshold) {\n          cval = 10;\n          flipped = true;\n        } else if (cval === 10 && average < threshold) {\n          cval = 5;\n          flipped = true;\n        }\n      }\n\n      /* add cell to ContourGrid if it contains edges */\n      if (cval !== 0 && cval !== 15) {\n        var top, bottom, left, right;\n        top = bottom = left = right = 0.5;\n        /* interpolate edges of cell */\n        if (cval === 1) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          bottom = 1 - interpolateX(threshold, br, bl);\n        } else if (cval === 2) {\n          bottom = interpolateX(threshold, bl, br);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 3) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 4) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 5) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n          bottom = 1 - interpolateX(threshold, br, bl);\n          left = 1 - interpolateX(threshold, tl, bl);\n        } else if (cval === 6) {\n          bottom = interpolateX(threshold, bl, br);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 7) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 8) {\n          left = interpolateX(threshold, bl, tl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 9) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 10) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n          bottom = interpolateX(threshold, bl, br);\n          left = interpolateX(threshold, bl, tl);\n        } else if (cval === 11) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 12) {\n          left = interpolateX(threshold, bl, tl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 13) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 14) {\n          left = interpolateX(threshold, bl, tl);\n          bottom = interpolateX(threshold, bl, br);\n        } else {\n          console.log(\n            \"MarchingSquaresJS-isoContours: Illegal cval detected: \" + cval\n          );\n        }\n        ContourGrid.cells[j][i] = {\n          cval: cval,\n          flipped: flipped,\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left,\n        };\n      }\n    }\n  }\n\n  return ContourGrid;\n}\n\nfunction isSaddle(cell) {\n  return cell.cval === 5 || cell.cval === 10;\n}\n\nfunction isTrivial(cell) {\n  return cell.cval === 0 || cell.cval === 15;\n}\n\nfunction clearCell(cell) {\n  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {\n    cell.cval = 15;\n  }\n}\n\nfunction getXY(cell, edge) {\n  if (edge === \"top\") {\n    return [cell.top, 1.0];\n  } else if (edge === \"bottom\") {\n    return [cell.bottom, 0.0];\n  } else if (edge === \"right\") {\n    return [1.0, cell.right];\n  } else if (edge === \"left\") {\n    return [0.0, cell.left];\n  }\n}\n\nfunction contourGrid2Paths(grid) {\n  var paths = [];\n  var path_idx = 0;\n  var epsilon = 1e-7;\n\n  grid.cells.forEach(function (g, j) {\n    g.forEach(function (gg, i) {\n      if (typeof gg !== \"undefined\" && !isSaddle(gg) && !isTrivial(gg)) {\n        var p = tracePath(grid.cells, j, i);\n        var merged = false;\n        /* we may try to merge paths at this point */\n        if (p.info === \"mergeable\") {\n          /*\n            search backwards through the path array to find an entry\n            that starts with where the current path ends...\n          */\n          var x = p.path[p.path.length - 1][0],\n            y = p.path[p.path.length - 1][1];\n\n          for (var k = path_idx - 1; k >= 0; k--) {\n            if (\n              Math.abs(paths[k][0][0] - x) <= epsilon &&\n              Math.abs(paths[k][0][1] - y) <= epsilon\n            ) {\n              for (var l = p.path.length - 2; l >= 0; --l) {\n                paths[k].unshift(p.path[l]);\n              }\n              merged = true;\n              break;\n            }\n          }\n        }\n        if (!merged) paths[path_idx++] = p.path;\n      }\n    });\n  });\n\n  return paths;\n}\n\n/*\n  construct consecutive line segments from starting cell by\n  walking arround the enclosed area clock-wise\n  */\nfunction tracePath(grid, j, i) {\n  var maxj = grid.length;\n  var p = [];\n  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];\n  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];\n  var dx, dy;\n  var startEdge = [\n    \"none\",\n    \"left\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"none\",\n    \"bottom\",\n    \"left\",\n    \"top\",\n    \"top\",\n    \"none\",\n    \"top\",\n    \"right\",\n    \"right\",\n    \"bottom\",\n    \"none\",\n  ];\n  var nextEdge = [\n    \"none\",\n    \"bottom\",\n    \"right\",\n    \"right\",\n    \"top\",\n    \"top\",\n    \"top\",\n    \"top\",\n    \"left\",\n    \"bottom\",\n    \"right\",\n    \"right\",\n    \"left\",\n    \"bottom\",\n    \"left\",\n    \"none\",\n  ];\n  var edge;\n\n  var currentCell = grid[j][i];\n\n  var cval = currentCell.cval;\n  var edge = startEdge[cval];\n\n  var pt = getXY(currentCell, edge);\n\n  /* push initial segment */\n  p.push([i + pt[0], j + pt[1]]);\n  edge = nextEdge[cval];\n  pt = getXY(currentCell, edge);\n  p.push([i + pt[0], j + pt[1]]);\n  clearCell(currentCell);\n\n  /* now walk arround the enclosed area in clockwise-direction */\n  var k = i + dxContour[cval];\n  var l = j + dyContour[cval];\n  var prev_cval = cval;\n\n  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {\n    currentCell = grid[l][k];\n    if (typeof currentCell === \"undefined\") {\n      /* path ends here */\n      //console.log(k + \" \" + l + \" is undefined, stopping path!\");\n      break;\n    }\n    cval = currentCell.cval;\n    if (cval === 0 || cval === 15) {\n      return { path: p, info: \"mergeable\" };\n    }\n    edge = nextEdge[cval];\n    dx = dxContour[cval];\n    dy = dyContour[cval];\n    if (cval === 5 || cval === 10) {\n      /* select upper or lower band, depending on previous cells cval */\n      if (cval === 5) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 10 */\n          if (dyContour[prev_cval] === -1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          } else {\n            edge = \"right\";\n            dx = 1;\n            dy = 0;\n          }\n        } else {\n          /* real case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        }\n      } else if (cval === 10) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"top\";\n            dx = 0;\n            dy = 1;\n          } else {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        } else {\n          /* real case 10 */\n          if (dyContour[prev_cval] === 1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          }\n        }\n      }\n    }\n    pt = getXY(currentCell, edge);\n    p.push([k + pt[0], l + pt[1]]);\n    clearCell(currentCell);\n    k += dx;\n    l += dy;\n    prev_cval = cval;\n  }\n\n  return { path: p, info: \"closed\" };\n}\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n\n  // sort rows (of points with the same latitude) by latitude\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];\n    else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n\n  return pointMatrix;\n}\n\n/**\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\n *\n * @name isolines\n * @param {FeatureCollection<Point>} pointGrid input points\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\n * the breaks array will define the order in which the isolines are created\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\n * @example\n * // create a grid of points with random z-values in their properties\n * var extent = [0, 30, 20, 50];\n * var cellWidth = 100;\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\n *\n * for (var i = 0; i < pointGrid.features.length; i++) {\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\n * }\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n *\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\n *\n * //addToMap\n * var addToMap = [lines];\n */\nfunction isolines(pointGrid, breaks, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var commonProperties = options.commonProperties || {};\n  var breaksProperties = options.breaksProperties || [];\n\n  // Input validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties must be an Array\");\n\n  // Isoline methods\n  var matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n  var createdIsoLines = createIsoLines(\n    matrix,\n    breaks,\n    zProperty,\n    commonProperties,\n    breaksProperties\n  );\n  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n\n  return featureCollection(scaledIsolines);\n}\n\n/**\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} zProperty name of the z-values property\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\n * @returns {Array<MultiLineString>} isolines\n */\nfunction createIsoLines(\n  matrix,\n  breaks,\n  zProperty,\n  commonProperties,\n  breaksProperties\n) {\n  var results = [];\n  for (var i = 1; i < breaks.length; i++) {\n    var threshold = +breaks[i]; // make sure it's a number\n\n    var properties = objectAssign({}, commonProperties, breaksProperties[i]);\n    properties[zProperty] = threshold;\n    var isoline = multiLineString(isoContours(matrix, threshold), properties);\n\n    results.push(isoline);\n  }\n  return results;\n}\n\n/**\n * Translates and scales isolines\n *\n * @private\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<MultiLineString>} isolines\n */\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  // get dimensions (on the map) of the original grid\n  var gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  var originalWidth = gridBbox[2] - gridBbox[0];\n  var originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  var x0 = gridBbox[0];\n  var y0 = gridBbox[1];\n\n  // get number of cells per side\n  var matrixWidth = matrix[0].length - 1;\n  var matrixHeight = matrix.length - 1;\n\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  var scaleX = originalWidth / matrixWidth;\n  var scaleY = originalHeigth / matrixHeight;\n\n  var resize = function (point) {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n\n  // resize and shift each point/line of the createdIsoLines\n  createdIsoLines.forEach(function (isoline) {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\n\nexport default isolines;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}