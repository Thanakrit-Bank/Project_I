{"ast":null,"code":"import rbush from \"geojson-rbush\";\nimport lineSegment from \"@turf/line-segment\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureEach, segmentEach } from \"@turf/meta\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nimport equal from \"deep-equal\";\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @name lineOverlap\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\n\nfunction lineOverlap(line1, line2, options) {\n  if (options === void 0) {\n    options = {};\n  } // Optional parameters\n\n\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance || 0; // Containers\n\n  var features = []; // Create Spatial Index\n\n  var tree = rbush(); // To-Do -- HACK way to support typescript\n\n  var line = lineSegment(line1);\n  tree.load(line);\n  var overlapSegment; // Line Intersection\n  // Iterate over line segments\n\n  segmentEach(line2, function (segment) {\n    var doesOverlaps = false;\n\n    if (!segment) {\n      return;\n    } // Iterate over each segments which falls within the same bounds\n\n\n    featureEach(tree.search(segment), function (match) {\n      if (doesOverlaps === false) {\n        var coordsSegment = getCoords(segment).sort();\n        var coordsMatch = getCoords(match).sort(); // Segment overlaps feature\n\n        if (equal(coordsSegment, coordsMatch)) {\n          doesOverlaps = true; // Overlaps already exists - only append last coordinate of segment\n\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);else overlapSegment = segment; // Match segments which don't share nodes (Issue #901)\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsSegment[0], match) && booleanPointOnLine(coordsSegment[1], match) : nearestPointOnLine(match, coordsSegment[0]).properties.dist <= tolerance && nearestPointOnLine(match, coordsSegment[1]).properties.dist <= tolerance) {\n          doesOverlaps = true;\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);else overlapSegment = segment;\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsMatch[0], segment) && booleanPointOnLine(coordsMatch[1], segment) : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <= tolerance && nearestPointOnLine(segment, coordsMatch[1]).properties.dist <= tolerance) {\n          // Do not define (doesOverlap = true) since more matches can occur within the same segment\n          // doesOverlaps = true;\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, match);else overlapSegment = match;\n        }\n      }\n    }); // Segment doesn't overlap - add overlaps to results & reset\n\n    if (doesOverlaps === false && overlapSegment) {\n      features.push(overlapSegment);\n      overlapSegment = undefined;\n    }\n  }); // Add last segment if exists\n\n  if (overlapSegment) features.push(overlapSegment);\n  return featureCollection(features);\n}\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\n\n\nfunction concatSegment(line, segment) {\n  var coords = getCoords(segment);\n  var lineCoords = getCoords(line);\n  var start = lineCoords[0];\n  var end = lineCoords[lineCoords.length - 1];\n  var geom = line.geometry.coordinates;\n  if (equal(coords[0], start)) geom.unshift(coords[1]);else if (equal(coords[0], end)) geom.push(coords[1]);else if (equal(coords[1], start)) geom.unshift(coords[0]);else if (equal(coords[1], end)) geom.push(coords[0]);\n  return line;\n}\n\nexport default lineOverlap;","map":{"version":3,"names":["rbush","lineSegment","nearestPointOnLine","booleanPointOnLine","getCoords","featureEach","segmentEach","featureCollection","isObject","equal","lineOverlap","line1","line2","options","Error","tolerance","features","tree","line","load","overlapSegment","segment","doesOverlaps","search","match","coordsSegment","sort","coordsMatch","concatSegment","properties","dist","push","undefined","coords","lineCoords","start","end","length","geom","geometry","coordinates","unshift"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/line-overlap/dist/es/index.js"],"sourcesContent":["import rbush from \"geojson-rbush\";\nimport lineSegment from \"@turf/line-segment\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureEach, segmentEach } from \"@turf/meta\";\nimport { featureCollection, isObject, } from \"@turf/helpers\";\nimport equal from \"deep-equal\";\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @name lineOverlap\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\nfunction lineOverlap(line1, line2, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options))\n        throw new Error(\"options is invalid\");\n    var tolerance = options.tolerance || 0;\n    // Containers\n    var features = [];\n    // Create Spatial Index\n    var tree = rbush();\n    // To-Do -- HACK way to support typescript\n    var line = lineSegment(line1);\n    tree.load(line);\n    var overlapSegment;\n    // Line Intersection\n    // Iterate over line segments\n    segmentEach(line2, function (segment) {\n        var doesOverlaps = false;\n        if (!segment) {\n            return;\n        }\n        // Iterate over each segments which falls within the same bounds\n        featureEach(tree.search(segment), function (match) {\n            if (doesOverlaps === false) {\n                var coordsSegment = getCoords(segment).sort();\n                var coordsMatch = getCoords(match).sort();\n                // Segment overlaps feature\n                if (equal(coordsSegment, coordsMatch)) {\n                    doesOverlaps = true;\n                    // Overlaps already exists - only append last coordinate of segment\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                    // Match segments which don't share nodes (Issue #901)\n                }\n                else if (tolerance === 0\n                    ? booleanPointOnLine(coordsSegment[0], match) &&\n                        booleanPointOnLine(coordsSegment[1], match)\n                    : nearestPointOnLine(match, coordsSegment[0]).properties.dist <=\n                        tolerance &&\n                        nearestPointOnLine(match, coordsSegment[1]).properties.dist <=\n                            tolerance) {\n                    doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                }\n                else if (tolerance === 0\n                    ? booleanPointOnLine(coordsMatch[0], segment) &&\n                        booleanPointOnLine(coordsMatch[1], segment)\n                    : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <=\n                        tolerance &&\n                        nearestPointOnLine(segment, coordsMatch[1]).properties.dist <=\n                            tolerance) {\n                    // Do not define (doesOverlap = true) since more matches can occur within the same segment\n                    // doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, match);\n                    else\n                        overlapSegment = match;\n                }\n            }\n        });\n        // Segment doesn't overlap - add overlaps to results & reset\n        if (doesOverlaps === false && overlapSegment) {\n            features.push(overlapSegment);\n            overlapSegment = undefined;\n        }\n    });\n    // Add last segment if exists\n    if (overlapSegment)\n        features.push(overlapSegment);\n    return featureCollection(features);\n}\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\nfunction concatSegment(line, segment) {\n    var coords = getCoords(segment);\n    var lineCoords = getCoords(line);\n    var start = lineCoords[0];\n    var end = lineCoords[lineCoords.length - 1];\n    var geom = line.geometry.coordinates;\n    if (equal(coords[0], start))\n        geom.unshift(coords[1]);\n    else if (equal(coords[0], end))\n        geom.push(coords[1]);\n    else if (equal(coords[1], start))\n        geom.unshift(coords[0]);\n    else if (equal(coords[1], end))\n        geom.push(coords[0]);\n    return line;\n}\nexport default lineOverlap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}