{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * @module helpers\r\n */\n\n/**\r\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\r\n *\r\n * @memberof helpers\r\n * @type {number}\r\n */\n\nexports.earthRadius = 6371008.8;\n/**\r\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\n\nexports.factors = {\n  centimeters: exports.earthRadius * 100,\n  centimetres: exports.earthRadius * 100,\n  degrees: exports.earthRadius / 111325,\n  feet: exports.earthRadius * 3.28084,\n  inches: exports.earthRadius * 39.37,\n  kilometers: exports.earthRadius / 1000,\n  kilometres: exports.earthRadius / 1000,\n  meters: exports.earthRadius,\n  metres: exports.earthRadius,\n  miles: exports.earthRadius / 1609.344,\n  millimeters: exports.earthRadius * 1000,\n  millimetres: exports.earthRadius * 1000,\n  nauticalmiles: exports.earthRadius / 1852,\n  radians: 1,\n  yards: exports.earthRadius * 1.0936\n};\n/**\r\n * Units of measurement factors based on 1 meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\n\nexports.unitsFactors = {\n  centimeters: 100,\n  centimetres: 100,\n  degrees: 1 / 111325,\n  feet: 3.28084,\n  inches: 39.37,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  meters: 1,\n  metres: 1,\n  miles: 1 / 1609.344,\n  millimeters: 1000,\n  millimetres: 1000,\n  nauticalmiles: 1 / 1852,\n  radians: 1 / exports.earthRadius,\n  yards: 1.0936133\n};\n/**\r\n * Area of measurement factors based on 1 square meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\n\nexports.areaFactors = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046\n};\n/**\r\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\r\n *\r\n * @name feature\r\n * @param {Geometry} geometry input geometry\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature} a GeoJSON Feature\r\n * @example\r\n * var geometry = {\r\n *   \"type\": \"Point\",\r\n *   \"coordinates\": [110, 50]\r\n * };\r\n *\r\n * var feature = turf.feature(geometry);\r\n *\r\n * //=feature\r\n */\n\nfunction feature(geom, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var feat = {\n    type: \"Feature\"\n  };\n\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n\nexports.feature = feature;\n/**\r\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\r\n * For GeometryCollection type use `helpers.geometryCollection`\r\n *\r\n * @name geometry\r\n * @param {string} type Geometry Type\r\n * @param {Array<any>} coordinates Coordinates\r\n * @param {Object} [options={}] Optional Parameters\r\n * @returns {Geometry} a GeoJSON Geometry\r\n * @example\r\n * var type = \"Point\";\r\n * var coordinates = [110, 50];\r\n * var geometry = turf.geometry(type, coordinates);\r\n * // => geometry\r\n */\n\nfunction geometry(type, coordinates, _options) {\n  if (_options === void 0) {\n    _options = {};\n  }\n\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n\nexports.geometry = geometry;\n/**\r\n * Creates a {@link Point} {@link Feature} from a Position.\r\n *\r\n * @name point\r\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Point>} a Point feature\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n *\r\n * //=point\r\n */\n\nfunction point(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n\n  var geom = {\n    type: \"Point\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n\nexports.point = point;\n/**\r\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\r\n *\r\n * @name points\r\n * @param {Array<Array<number>>} coordinates an array of Points\r\n * @param {Object} [properties={}] Translate these properties to each Feature\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Point>} Point Feature\r\n * @example\r\n * var points = turf.points([\r\n *   [-75, 39],\r\n *   [-80, 45],\r\n *   [-78, 50]\r\n * ]);\r\n *\r\n * //=points\r\n */\n\nfunction points(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return point(coords, properties);\n  }), options);\n}\n\nexports.points = points;\n/**\r\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\r\n *\r\n * @name polygon\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Polygon>} Polygon Feature\r\n * @example\r\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\r\n *\r\n * //=polygon\r\n */\n\nfunction polygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n    var ring = coordinates_1[_i];\n\n    if (ring.length < 4) {\n      throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    }\n\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n\n  var geom = {\n    type: \"Polygon\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n\nexports.polygon = polygon;\n/**\r\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\r\n *\r\n * @name polygons\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\r\n * @example\r\n * var polygons = turf.polygons([\r\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\r\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\r\n * ]);\r\n *\r\n * //=polygons\r\n */\n\nfunction polygons(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n\nexports.polygons = polygons;\n/**\r\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\r\n *\r\n * @name lineString\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<LineString>} LineString Feature\r\n * @example\r\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\r\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\r\n *\r\n * //=linestring1\r\n * //=linestring2\r\n */\n\nfunction lineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n\n  var geom = {\n    type: \"LineString\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n\nexports.lineString = lineString;\n/**\r\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\r\n *\r\n * @name lineStrings\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\r\n * @example\r\n * var linestrings = turf.lineStrings([\r\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\r\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\r\n * ]);\r\n *\r\n * //=linestrings\r\n */\n\nfunction lineStrings(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return lineString(coords, properties);\n  }), options);\n}\n\nexports.lineStrings = lineStrings;\n/**\r\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\r\n *\r\n * @name featureCollection\r\n * @param {Feature[]} features input features\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {FeatureCollection} FeatureCollection of Features\r\n * @example\r\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\r\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\r\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\r\n *\r\n * var collection = turf.featureCollection([\r\n *   locationA,\r\n *   locationB,\r\n *   locationC\r\n * ]);\r\n *\r\n * //=collection\r\n */\n\nfunction featureCollection(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var fc = {\n    type: \"FeatureCollection\"\n  };\n\n  if (options.id) {\n    fc.id = options.id;\n  }\n\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n\n  fc.features = features;\n  return fc;\n}\n\nexports.featureCollection = featureCollection;\n/**\r\n * Creates a {@link Feature<MultiLineString>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiLineString\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiLineString>} a MultiLineString feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\r\n *\r\n * //=multiLine\r\n */\n\nfunction multiLineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"MultiLineString\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n\nexports.multiLineString = multiLineString;\n/**\r\n * Creates a {@link Feature<MultiPoint>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPoint\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPoint>} a MultiPoint feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\r\n *\r\n * //=multiPt\r\n */\n\nfunction multiPoint(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"MultiPoint\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n\nexports.multiPoint = multiPoint;\n/**\r\n * Creates a {@link Feature<MultiPolygon>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPolygon\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPolygon>} a multipolygon feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\r\n *\r\n * //=multiPoly\r\n *\r\n */\n\nfunction multiPolygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"MultiPolygon\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n\nexports.multiPolygon = multiPolygon;\n/**\r\n * Creates a {@link Feature<GeometryCollection>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name geometryCollection\r\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\r\n * @example\r\n * var pt = turf.geometry(\"Point\", [100, 0]);\r\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\r\n * var collection = turf.geometryCollection([pt, line]);\r\n *\r\n * // => collection\r\n */\n\nfunction geometryCollection(geometries, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"GeometryCollection\",\n    geometries: geometries\n  };\n  return feature(geom, properties, options);\n}\n\nexports.geometryCollection = geometryCollection;\n/**\r\n * Round number to precision\r\n *\r\n * @param {number} num Number\r\n * @param {number} [precision=0] Precision\r\n * @returns {number} rounded number\r\n * @example\r\n * turf.round(120.4321)\r\n * //=120\r\n *\r\n * turf.round(120.4321, 2)\r\n * //=120.43\r\n */\n\nfunction round(num, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n\nexports.round = round;\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name radiansToLength\r\n * @param {number} radians in radians across the sphere\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} distance\r\n */\n\nfunction radiansToLength(radians, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n\n  var factor = exports.factors[units];\n\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n\n  return radians * factor;\n}\n\nexports.radiansToLength = radiansToLength;\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name lengthToRadians\r\n * @param {number} distance in real units\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} radians\r\n */\n\nfunction lengthToRadians(distance, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n\n  var factor = exports.factors[units];\n\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n\n  return distance / factor;\n}\n\nexports.lengthToRadians = lengthToRadians;\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\r\n *\r\n * @name lengthToDegrees\r\n * @param {number} distance in real units\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} degrees\r\n */\n\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n\nexports.lengthToDegrees = lengthToDegrees;\n/**\r\n * Converts any bearing angle from the north line direction (positive clockwise)\r\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\r\n *\r\n * @name bearingToAzimuth\r\n * @param {number} bearing angle, between -180 and +180 degrees\r\n * @returns {number} angle between 0 and 360 degrees\r\n */\n\nfunction bearingToAzimuth(bearing) {\n  var angle = bearing % 360;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return angle;\n}\n\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\r\n * Converts an angle in radians to degrees\r\n *\r\n * @name radiansToDegrees\r\n * @param {number} radians angle in radians\r\n * @returns {number} degrees between 0 and 360 degrees\r\n */\n\nfunction radiansToDegrees(radians) {\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n\nexports.radiansToDegrees = radiansToDegrees;\n/**\r\n * Converts an angle in degrees to radians\r\n *\r\n * @name degreesToRadians\r\n * @param {number} degrees angle between 0 and 360 degrees\r\n * @returns {number} angle in radians\r\n */\n\nfunction degreesToRadians(degrees) {\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n\nexports.degreesToRadians = degreesToRadians;\n/**\r\n * Converts a length to the requested unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @param {number} length to be converted\r\n * @param {Units} [originalUnit=\"kilometers\"] of the length\r\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\r\n * @returns {number} the converted length\r\n */\n\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"kilometers\";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n\nexports.convertLength = convertLength;\n/**\r\n * Converts a area to the requested unit.\r\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\r\n * @param {number} area to be converted\r\n * @param {Units} [originalUnit=\"meters\"] of the distance\r\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\r\n * @returns {number} the converted area\r\n */\n\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"meters\";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n\n  var startFactor = exports.areaFactors[originalUnit];\n\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n\n  var finalFactor = exports.areaFactors[finalUnit];\n\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n\n  return area / startFactor * finalFactor;\n}\n\nexports.convertArea = convertArea;\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isNumber(123)\r\n * //=true\r\n * turf.isNumber('foo')\r\n * //=false\r\n */\n\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\nexports.isNumber = isNumber;\n/**\r\n * isObject\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isObject({elevation: 10})\r\n * //=true\r\n * turf.isObject('foo')\r\n * //=false\r\n */\n\nfunction isObject(input) {\n  return !!input && input.constructor === Object;\n}\n\nexports.isObject = isObject;\n/**\r\n * Validate BBox\r\n *\r\n * @private\r\n * @param {Array<number>} bbox BBox to validate\r\n * @returns {void}\r\n * @throws Error if BBox is not valid\r\n * @example\r\n * validateBBox([-180, -40, 110, 50])\r\n * //=OK\r\n * validateBBox([-180, -40])\r\n * //=Error\r\n * validateBBox('Foo')\r\n * //=Error\r\n * validateBBox(5)\r\n * //=Error\r\n * validateBBox(null)\r\n * //=Error\r\n * validateBBox(undefined)\r\n * //=Error\r\n */\n\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n\nexports.validateBBox = validateBBox;\n/**\r\n * Validate Id\r\n *\r\n * @private\r\n * @param {string|number} id Id to validate\r\n * @returns {void}\r\n * @throws Error if Id is not valid\r\n * @example\r\n * validateId([-180, -40, 110, 50])\r\n * //=Error\r\n * validateId([-180, -40])\r\n * //=Error\r\n * validateId('Foo')\r\n * //=OK\r\n * validateId(5)\r\n * //=OK\r\n * validateId(null)\r\n * //=Error\r\n * validateId(undefined)\r\n * //=Error\r\n */\n\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n\nexports.validateId = validateId;","map":{"version":3,"names":["Object","defineProperty","exports","value","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","unitsFactors","areaFactors","acres","hectares","feature","geom","properties","options","feat","type","id","bbox","geometry","coordinates","_options","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","Error","Array","isArray","length","isNumber","points","featureCollection","map","coords","_i","coordinates_1","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","multiplier","Math","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isNaN","isObject","input","constructor","validateBBox","forEach","validateId","indexOf"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/helpers/dist/js/index.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @module helpers\r\n */\r\n/**\r\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\r\n *\r\n * @memberof helpers\r\n * @type {number}\r\n */\r\nexports.earthRadius = 6371008.8;\r\n/**\r\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexports.factors = {\r\n    centimeters: exports.earthRadius * 100,\r\n    centimetres: exports.earthRadius * 100,\r\n    degrees: exports.earthRadius / 111325,\r\n    feet: exports.earthRadius * 3.28084,\r\n    inches: exports.earthRadius * 39.37,\r\n    kilometers: exports.earthRadius / 1000,\r\n    kilometres: exports.earthRadius / 1000,\r\n    meters: exports.earthRadius,\r\n    metres: exports.earthRadius,\r\n    miles: exports.earthRadius / 1609.344,\r\n    millimeters: exports.earthRadius * 1000,\r\n    millimetres: exports.earthRadius * 1000,\r\n    nauticalmiles: exports.earthRadius / 1852,\r\n    radians: 1,\r\n    yards: exports.earthRadius * 1.0936,\r\n};\r\n/**\r\n * Units of measurement factors based on 1 meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexports.unitsFactors = {\r\n    centimeters: 100,\r\n    centimetres: 100,\r\n    degrees: 1 / 111325,\r\n    feet: 3.28084,\r\n    inches: 39.37,\r\n    kilometers: 1 / 1000,\r\n    kilometres: 1 / 1000,\r\n    meters: 1,\r\n    metres: 1,\r\n    miles: 1 / 1609.344,\r\n    millimeters: 1000,\r\n    millimetres: 1000,\r\n    nauticalmiles: 1 / 1852,\r\n    radians: 1 / exports.earthRadius,\r\n    yards: 1.0936133,\r\n};\r\n/**\r\n * Area of measurement factors based on 1 square meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexports.areaFactors = {\r\n    acres: 0.000247105,\r\n    centimeters: 10000,\r\n    centimetres: 10000,\r\n    feet: 10.763910417,\r\n    hectares: 0.0001,\r\n    inches: 1550.003100006,\r\n    kilometers: 0.000001,\r\n    kilometres: 0.000001,\r\n    meters: 1,\r\n    metres: 1,\r\n    miles: 3.86e-7,\r\n    millimeters: 1000000,\r\n    millimetres: 1000000,\r\n    yards: 1.195990046,\r\n};\r\n/**\r\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\r\n *\r\n * @name feature\r\n * @param {Geometry} geometry input geometry\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature} a GeoJSON Feature\r\n * @example\r\n * var geometry = {\r\n *   \"type\": \"Point\",\r\n *   \"coordinates\": [110, 50]\r\n * };\r\n *\r\n * var feature = turf.feature(geometry);\r\n *\r\n * //=feature\r\n */\r\nfunction feature(geom, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var feat = { type: \"Feature\" };\r\n    if (options.id === 0 || options.id) {\r\n        feat.id = options.id;\r\n    }\r\n    if (options.bbox) {\r\n        feat.bbox = options.bbox;\r\n    }\r\n    feat.properties = properties || {};\r\n    feat.geometry = geom;\r\n    return feat;\r\n}\r\nexports.feature = feature;\r\n/**\r\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\r\n * For GeometryCollection type use `helpers.geometryCollection`\r\n *\r\n * @name geometry\r\n * @param {string} type Geometry Type\r\n * @param {Array<any>} coordinates Coordinates\r\n * @param {Object} [options={}] Optional Parameters\r\n * @returns {Geometry} a GeoJSON Geometry\r\n * @example\r\n * var type = \"Point\";\r\n * var coordinates = [110, 50];\r\n * var geometry = turf.geometry(type, coordinates);\r\n * // => geometry\r\n */\r\nfunction geometry(type, coordinates, _options) {\r\n    if (_options === void 0) { _options = {}; }\r\n    switch (type) {\r\n        case \"Point\":\r\n            return point(coordinates).geometry;\r\n        case \"LineString\":\r\n            return lineString(coordinates).geometry;\r\n        case \"Polygon\":\r\n            return polygon(coordinates).geometry;\r\n        case \"MultiPoint\":\r\n            return multiPoint(coordinates).geometry;\r\n        case \"MultiLineString\":\r\n            return multiLineString(coordinates).geometry;\r\n        case \"MultiPolygon\":\r\n            return multiPolygon(coordinates).geometry;\r\n        default:\r\n            throw new Error(type + \" is invalid\");\r\n    }\r\n}\r\nexports.geometry = geometry;\r\n/**\r\n * Creates a {@link Point} {@link Feature} from a Position.\r\n *\r\n * @name point\r\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Point>} a Point feature\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n *\r\n * //=point\r\n */\r\nfunction point(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (!coordinates) {\r\n        throw new Error(\"coordinates is required\");\r\n    }\r\n    if (!Array.isArray(coordinates)) {\r\n        throw new Error(\"coordinates must be an Array\");\r\n    }\r\n    if (coordinates.length < 2) {\r\n        throw new Error(\"coordinates must be at least 2 numbers long\");\r\n    }\r\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\r\n        throw new Error(\"coordinates must contain numbers\");\r\n    }\r\n    var geom = {\r\n        type: \"Point\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\nexports.point = point;\r\n/**\r\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\r\n *\r\n * @name points\r\n * @param {Array<Array<number>>} coordinates an array of Points\r\n * @param {Object} [properties={}] Translate these properties to each Feature\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Point>} Point Feature\r\n * @example\r\n * var points = turf.points([\r\n *   [-75, 39],\r\n *   [-80, 45],\r\n *   [-78, 50]\r\n * ]);\r\n *\r\n * //=points\r\n */\r\nfunction points(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return featureCollection(coordinates.map(function (coords) {\r\n        return point(coords, properties);\r\n    }), options);\r\n}\r\nexports.points = points;\r\n/**\r\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\r\n *\r\n * @name polygon\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Polygon>} Polygon Feature\r\n * @example\r\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\r\n *\r\n * //=polygon\r\n */\r\nfunction polygon(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\r\n        var ring = coordinates_1[_i];\r\n        if (ring.length < 4) {\r\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\r\n        }\r\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\r\n            // Check if first point of Polygon contains two numbers\r\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\r\n                throw new Error(\"First and last Position are not equivalent.\");\r\n            }\r\n        }\r\n    }\r\n    var geom = {\r\n        type: \"Polygon\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\nexports.polygon = polygon;\r\n/**\r\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\r\n *\r\n * @name polygons\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\r\n * @example\r\n * var polygons = turf.polygons([\r\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\r\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\r\n * ]);\r\n *\r\n * //=polygons\r\n */\r\nfunction polygons(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return featureCollection(coordinates.map(function (coords) {\r\n        return polygon(coords, properties);\r\n    }), options);\r\n}\r\nexports.polygons = polygons;\r\n/**\r\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\r\n *\r\n * @name lineString\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<LineString>} LineString Feature\r\n * @example\r\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\r\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\r\n *\r\n * //=linestring1\r\n * //=linestring2\r\n */\r\nfunction lineString(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (coordinates.length < 2) {\r\n        throw new Error(\"coordinates must be an array of two or more positions\");\r\n    }\r\n    var geom = {\r\n        type: \"LineString\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\nexports.lineString = lineString;\r\n/**\r\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\r\n *\r\n * @name lineStrings\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\r\n * @example\r\n * var linestrings = turf.lineStrings([\r\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\r\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\r\n * ]);\r\n *\r\n * //=linestrings\r\n */\r\nfunction lineStrings(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return featureCollection(coordinates.map(function (coords) {\r\n        return lineString(coords, properties);\r\n    }), options);\r\n}\r\nexports.lineStrings = lineStrings;\r\n/**\r\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\r\n *\r\n * @name featureCollection\r\n * @param {Feature[]} features input features\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {FeatureCollection} FeatureCollection of Features\r\n * @example\r\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\r\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\r\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\r\n *\r\n * var collection = turf.featureCollection([\r\n *   locationA,\r\n *   locationB,\r\n *   locationC\r\n * ]);\r\n *\r\n * //=collection\r\n */\r\nfunction featureCollection(features, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var fc = { type: \"FeatureCollection\" };\r\n    if (options.id) {\r\n        fc.id = options.id;\r\n    }\r\n    if (options.bbox) {\r\n        fc.bbox = options.bbox;\r\n    }\r\n    fc.features = features;\r\n    return fc;\r\n}\r\nexports.featureCollection = featureCollection;\r\n/**\r\n * Creates a {@link Feature<MultiLineString>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiLineString\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiLineString>} a MultiLineString feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\r\n *\r\n * //=multiLine\r\n */\r\nfunction multiLineString(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"MultiLineString\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\nexports.multiLineString = multiLineString;\r\n/**\r\n * Creates a {@link Feature<MultiPoint>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPoint\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPoint>} a MultiPoint feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\r\n *\r\n * //=multiPt\r\n */\r\nfunction multiPoint(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"MultiPoint\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\nexports.multiPoint = multiPoint;\r\n/**\r\n * Creates a {@link Feature<MultiPolygon>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPolygon\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPolygon>} a multipolygon feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\r\n *\r\n * //=multiPoly\r\n *\r\n */\r\nfunction multiPolygon(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"MultiPolygon\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\nexports.multiPolygon = multiPolygon;\r\n/**\r\n * Creates a {@link Feature<GeometryCollection>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name geometryCollection\r\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\r\n * @example\r\n * var pt = turf.geometry(\"Point\", [100, 0]);\r\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\r\n * var collection = turf.geometryCollection([pt, line]);\r\n *\r\n * // => collection\r\n */\r\nfunction geometryCollection(geometries, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"GeometryCollection\",\r\n        geometries: geometries,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\nexports.geometryCollection = geometryCollection;\r\n/**\r\n * Round number to precision\r\n *\r\n * @param {number} num Number\r\n * @param {number} [precision=0] Precision\r\n * @returns {number} rounded number\r\n * @example\r\n * turf.round(120.4321)\r\n * //=120\r\n *\r\n * turf.round(120.4321, 2)\r\n * //=120.43\r\n */\r\nfunction round(num, precision) {\r\n    if (precision === void 0) { precision = 0; }\r\n    if (precision && !(precision >= 0)) {\r\n        throw new Error(\"precision must be a positive number\");\r\n    }\r\n    var multiplier = Math.pow(10, precision || 0);\r\n    return Math.round(num * multiplier) / multiplier;\r\n}\r\nexports.round = round;\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name radiansToLength\r\n * @param {number} radians in radians across the sphere\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} distance\r\n */\r\nfunction radiansToLength(radians, units) {\r\n    if (units === void 0) { units = \"kilometers\"; }\r\n    var factor = exports.factors[units];\r\n    if (!factor) {\r\n        throw new Error(units + \" units is invalid\");\r\n    }\r\n    return radians * factor;\r\n}\r\nexports.radiansToLength = radiansToLength;\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name lengthToRadians\r\n * @param {number} distance in real units\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} radians\r\n */\r\nfunction lengthToRadians(distance, units) {\r\n    if (units === void 0) { units = \"kilometers\"; }\r\n    var factor = exports.factors[units];\r\n    if (!factor) {\r\n        throw new Error(units + \" units is invalid\");\r\n    }\r\n    return distance / factor;\r\n}\r\nexports.lengthToRadians = lengthToRadians;\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\r\n *\r\n * @name lengthToDegrees\r\n * @param {number} distance in real units\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} degrees\r\n */\r\nfunction lengthToDegrees(distance, units) {\r\n    return radiansToDegrees(lengthToRadians(distance, units));\r\n}\r\nexports.lengthToDegrees = lengthToDegrees;\r\n/**\r\n * Converts any bearing angle from the north line direction (positive clockwise)\r\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\r\n *\r\n * @name bearingToAzimuth\r\n * @param {number} bearing angle, between -180 and +180 degrees\r\n * @returns {number} angle between 0 and 360 degrees\r\n */\r\nfunction bearingToAzimuth(bearing) {\r\n    var angle = bearing % 360;\r\n    if (angle < 0) {\r\n        angle += 360;\r\n    }\r\n    return angle;\r\n}\r\nexports.bearingToAzimuth = bearingToAzimuth;\r\n/**\r\n * Converts an angle in radians to degrees\r\n *\r\n * @name radiansToDegrees\r\n * @param {number} radians angle in radians\r\n * @returns {number} degrees between 0 and 360 degrees\r\n */\r\nfunction radiansToDegrees(radians) {\r\n    var degrees = radians % (2 * Math.PI);\r\n    return (degrees * 180) / Math.PI;\r\n}\r\nexports.radiansToDegrees = radiansToDegrees;\r\n/**\r\n * Converts an angle in degrees to radians\r\n *\r\n * @name degreesToRadians\r\n * @param {number} degrees angle between 0 and 360 degrees\r\n * @returns {number} angle in radians\r\n */\r\nfunction degreesToRadians(degrees) {\r\n    var radians = degrees % 360;\r\n    return (radians * Math.PI) / 180;\r\n}\r\nexports.degreesToRadians = degreesToRadians;\r\n/**\r\n * Converts a length to the requested unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @param {number} length to be converted\r\n * @param {Units} [originalUnit=\"kilometers\"] of the length\r\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\r\n * @returns {number} the converted length\r\n */\r\nfunction convertLength(length, originalUnit, finalUnit) {\r\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\r\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\r\n    if (!(length >= 0)) {\r\n        throw new Error(\"length must be a positive number\");\r\n    }\r\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\r\n}\r\nexports.convertLength = convertLength;\r\n/**\r\n * Converts a area to the requested unit.\r\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\r\n * @param {number} area to be converted\r\n * @param {Units} [originalUnit=\"meters\"] of the distance\r\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\r\n * @returns {number} the converted area\r\n */\r\nfunction convertArea(area, originalUnit, finalUnit) {\r\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\r\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\r\n    if (!(area >= 0)) {\r\n        throw new Error(\"area must be a positive number\");\r\n    }\r\n    var startFactor = exports.areaFactors[originalUnit];\r\n    if (!startFactor) {\r\n        throw new Error(\"invalid original units\");\r\n    }\r\n    var finalFactor = exports.areaFactors[finalUnit];\r\n    if (!finalFactor) {\r\n        throw new Error(\"invalid final units\");\r\n    }\r\n    return (area / startFactor) * finalFactor;\r\n}\r\nexports.convertArea = convertArea;\r\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isNumber(123)\r\n * //=true\r\n * turf.isNumber('foo')\r\n * //=false\r\n */\r\nfunction isNumber(num) {\r\n    return !isNaN(num) && num !== null && !Array.isArray(num);\r\n}\r\nexports.isNumber = isNumber;\r\n/**\r\n * isObject\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isObject({elevation: 10})\r\n * //=true\r\n * turf.isObject('foo')\r\n * //=false\r\n */\r\nfunction isObject(input) {\r\n    return !!input && input.constructor === Object;\r\n}\r\nexports.isObject = isObject;\r\n/**\r\n * Validate BBox\r\n *\r\n * @private\r\n * @param {Array<number>} bbox BBox to validate\r\n * @returns {void}\r\n * @throws Error if BBox is not valid\r\n * @example\r\n * validateBBox([-180, -40, 110, 50])\r\n * //=OK\r\n * validateBBox([-180, -40])\r\n * //=Error\r\n * validateBBox('Foo')\r\n * //=Error\r\n * validateBBox(5)\r\n * //=Error\r\n * validateBBox(null)\r\n * //=Error\r\n * validateBBox(undefined)\r\n * //=Error\r\n */\r\nfunction validateBBox(bbox) {\r\n    if (!bbox) {\r\n        throw new Error(\"bbox is required\");\r\n    }\r\n    if (!Array.isArray(bbox)) {\r\n        throw new Error(\"bbox must be an Array\");\r\n    }\r\n    if (bbox.length !== 4 && bbox.length !== 6) {\r\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\r\n    }\r\n    bbox.forEach(function (num) {\r\n        if (!isNumber(num)) {\r\n            throw new Error(\"bbox must only contain numbers\");\r\n        }\r\n    });\r\n}\r\nexports.validateBBox = validateBBox;\r\n/**\r\n * Validate Id\r\n *\r\n * @private\r\n * @param {string|number} id Id to validate\r\n * @returns {void}\r\n * @throws Error if Id is not valid\r\n * @example\r\n * validateId([-180, -40, 110, 50])\r\n * //=Error\r\n * validateId([-180, -40])\r\n * //=Error\r\n * validateId('Foo')\r\n * //=OK\r\n * validateId(5)\r\n * //=OK\r\n * validateId(null)\r\n * //=Error\r\n * validateId(undefined)\r\n * //=Error\r\n */\r\nfunction validateId(id) {\r\n    if (!id) {\r\n        throw new Error(\"id is required\");\r\n    }\r\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\r\n        throw new Error(\"id must be a number or a string\");\r\n    }\r\n}\r\nexports.validateId = validateId;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}