{"ast":null,"code":"import { geomEach, coordEach } from '@turf/meta';\nimport { multiPolygon, polygon, featureCollection } from '@turf/helpers';\n/**\n * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).\n * Warning: may create degenerate polygons.\n *\n * @name polygonSmooth\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} inputPolys (Multi)Polygon(s) to smooth\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.iterations=1] THe number of times to smooth the polygon. A higher value means a smoother polygon.\n * @returns {FeatureCollection<Polygon>} FeatureCollection containing the smoothed polygon/poylgons\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n *\n * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})\n *\n * //addToMap\n * var addToMap = [smoothed, polygon];\n */\n\nfunction polygonSmooth(inputPolys, options) {\n  var outPolys = []; // Optional parameters\n\n  var iterations = options.iterations || 1;\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    var outCoords;\n    var poly;\n    var tempOutput;\n\n    switch (geom.type) {\n      case \"Polygon\":\n        outCoords = [[]];\n\n        for (var i = 0; i < iterations; i++) {\n          tempOutput = [[]];\n          poly = geom;\n          if (i > 0) poly = polygon(outCoords).geometry;\n          processPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n\n        outPolys.push(polygon(outCoords, properties));\n        break;\n\n      case \"MultiPolygon\":\n        outCoords = [[[]]];\n\n        for (var y = 0; y < iterations; y++) {\n          tempOutput = [[[]]];\n          poly = geom;\n          if (y > 0) poly = multiPolygon(outCoords).geometry;\n          processMultiPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n\n        outPolys.push(multiPolygon(outCoords, properties));\n        break;\n\n      default:\n        throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n  return featureCollection(outPolys);\n}\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\n\n\nfunction processPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (geometryIndex > prevGeomIndex) {\n      prevGeomIndex = geometryIndex;\n      subtractCoordIndex = coordIndex;\n      tempOutput.push([]);\n    }\n\n    var realCoordIndex = coordIndex - subtractCoordIndex;\n    var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];\n    var p0x = currentCoord[0];\n    var p0y = currentCoord[1];\n    var p1x = p1[0];\n    var p1y = p1[1];\n    tempOutput[geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n    tempOutput[geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n  }, true);\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\n\n\nfunction processMultiPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n  var prevMultiIndex = 0;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (multiFeatureIndex > prevMultiIndex) {\n      prevMultiIndex = multiFeatureIndex;\n      subtractCoordIndex = coordIndex;\n      tempOutput.push([[]]);\n    }\n\n    if (geometryIndex > prevGeomIndex) {\n      prevGeomIndex = geometryIndex;\n      subtractCoordIndex = coordIndex;\n      tempOutput[multiFeatureIndex].push([]);\n    }\n\n    var realCoordIndex = coordIndex - subtractCoordIndex;\n    var p1 = poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];\n    var p0x = currentCoord[0];\n    var p0y = currentCoord[1];\n    var p1x = p1[0];\n    var p1y = p1[1];\n    tempOutput[multiFeatureIndex][geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n    tempOutput[multiFeatureIndex][geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n  }, true);\n  tempOutput.forEach(function (poly) {\n    poly.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\n\nexport default polygonSmooth;","map":{"version":3,"names":["geomEach","coordEach","multiPolygon","polygon","featureCollection","polygonSmooth","inputPolys","options","outPolys","iterations","Error","geom","geomIndex","properties","outCoords","poly","tempOutput","type","i","geometry","processPolygon","slice","push","y","processMultiPolygon","prevGeomIndex","subtractCoordIndex","currentCoord","coordIndex","featureIndex","multiFeatureIndex","geometryIndex","realCoordIndex","p1","coordinates","p0x","p0y","p1x","p1y","forEach","ring","prevMultiIndex"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/polygon-smooth/dist/es/index.js"],"sourcesContent":["import { geomEach, coordEach } from '@turf/meta';\nimport { multiPolygon, polygon, featureCollection } from '@turf/helpers';\n\n/**\n * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).\n * Warning: may create degenerate polygons.\n *\n * @name polygonSmooth\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} inputPolys (Multi)Polygon(s) to smooth\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.iterations=1] THe number of times to smooth the polygon. A higher value means a smoother polygon.\n * @returns {FeatureCollection<Polygon>} FeatureCollection containing the smoothed polygon/poylgons\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n *\n * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})\n *\n * //addToMap\n * var addToMap = [smoothed, polygon];\n */\nfunction polygonSmooth(inputPolys, options) {\n  var outPolys = [];\n  // Optional parameters\n  var iterations = options.iterations || 1;\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    var outCoords;\n    var poly;\n    var tempOutput;\n\n    switch (geom.type) {\n      case \"Polygon\":\n        outCoords = [[]];\n        for (var i = 0; i < iterations; i++) {\n          tempOutput = [[]];\n          poly = geom;\n          if (i > 0) poly = polygon(outCoords).geometry;\n          processPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n        outPolys.push(polygon(outCoords, properties));\n        break;\n      case \"MultiPolygon\":\n        outCoords = [[[]]];\n        for (var y = 0; y < iterations; y++) {\n          tempOutput = [[[]]];\n          poly = geom;\n          if (y > 0) poly = multiPolygon(outCoords).geometry;\n          processMultiPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n        outPolys.push(multiPolygon(outCoords, properties));\n        break;\n      default:\n        throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n  return featureCollection(outPolys);\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (geometryIndex > prevGeomIndex) {\n        prevGeomIndex = geometryIndex;\n        subtractCoordIndex = coordIndex;\n        tempOutput.push([]);\n      }\n      var realCoordIndex = coordIndex - subtractCoordIndex;\n      var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];\n      var p0x = currentCoord[0];\n      var p0y = currentCoord[1];\n      var p1x = p1[0];\n      var p1y = p1[1];\n      tempOutput[geometryIndex].push([\n        0.75 * p0x + 0.25 * p1x,\n        0.75 * p0y + 0.25 * p1y,\n      ]);\n      tempOutput[geometryIndex].push([\n        0.25 * p0x + 0.75 * p1x,\n        0.25 * p0y + 0.75 * p1y,\n      ]);\n    },\n    true\n  );\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processMultiPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n  var prevMultiIndex = 0;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (multiFeatureIndex > prevMultiIndex) {\n        prevMultiIndex = multiFeatureIndex;\n        subtractCoordIndex = coordIndex;\n        tempOutput.push([[]]);\n      }\n      if (geometryIndex > prevGeomIndex) {\n        prevGeomIndex = geometryIndex;\n        subtractCoordIndex = coordIndex;\n        tempOutput[multiFeatureIndex].push([]);\n      }\n      var realCoordIndex = coordIndex - subtractCoordIndex;\n      var p1 =\n        poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];\n      var p0x = currentCoord[0];\n      var p0y = currentCoord[1];\n      var p1x = p1[0];\n      var p1y = p1[1];\n      tempOutput[multiFeatureIndex][geometryIndex].push([\n        0.75 * p0x + 0.25 * p1x,\n        0.75 * p0y + 0.25 * p1y,\n      ]);\n      tempOutput[multiFeatureIndex][geometryIndex].push([\n        0.25 * p0x + 0.75 * p1x,\n        0.25 * p0y + 0.75 * p1y,\n      ]);\n    },\n    true\n  );\n\n  tempOutput.forEach(function (poly) {\n    poly.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\n\nexport default polygonSmooth;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}