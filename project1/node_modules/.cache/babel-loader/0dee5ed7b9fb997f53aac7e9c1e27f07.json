{"ast":null,"code":"import cleanCoords from \"@turf/clean-coords\";\nimport lineSegment from \"@turf/line-segment\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\nimport { bearingToAzimuth } from \"@turf/helpers\";\n/**\n * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`\n *\n * @name booleanParallel\n * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false if the lines are parallel\n * @example\n * var line1 = turf.lineString([[0, 0], [0, 1]]);\n * var line2 = turf.lineString([[1, 0], [1, 1]]);\n *\n * turf.booleanParallel(line1, line2);\n * //=true\n */\n\nfunction booleanParallel(line1, line2) {\n  // validation\n  if (!line1) throw new Error(\"line1 is required\");\n  if (!line2) throw new Error(\"line2 is required\");\n  var type1 = getType(line1, \"line1\");\n  if (type1 !== \"LineString\") throw new Error(\"line1 must be a LineString\");\n  var type2 = getType(line2, \"line2\");\n  if (type2 !== \"LineString\") throw new Error(\"line2 must be a LineString\");\n  var segments1 = lineSegment(cleanCoords(line1)).features;\n  var segments2 = lineSegment(cleanCoords(line2)).features;\n\n  for (var i = 0; i < segments1.length; i++) {\n    var segment1 = segments1[i].geometry.coordinates;\n    if (!segments2[i]) break;\n    var segment2 = segments2[i].geometry.coordinates;\n    if (!isParallel(segment1, segment2)) return false;\n  }\n\n  return true;\n}\n/**\n * Compares slopes and return result\n *\n * @private\n * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature\n * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature\n * @returns {boolean} if slopes are equal\n */\n\n\nfunction isParallel(segment1, segment2) {\n  var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\n  var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\n  return slope1 === slope2;\n}\n/**\n * Returns Feature's type\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {string} name of the variable\n * @returns {string} Feature's type\n */\n\n\nfunction getType(geojson, name) {\n  if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n  if (geojson.type) return geojson.type; // if GeoJSON geometry\n\n  throw new Error(\"Invalid GeoJSON object for \" + name);\n}\n\nexport default booleanParallel;","map":{"version":3,"names":["cleanCoords","lineSegment","rhumbBearing","bearingToAzimuth","booleanParallel","line1","line2","Error","type1","getType","type2","segments1","features","segments2","i","length","segment1","geometry","coordinates","segment2","isParallel","slope1","slope2","geojson","name","type"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/boolean-parallel/dist/es/index.js"],"sourcesContent":["import cleanCoords from \"@turf/clean-coords\";\nimport lineSegment from \"@turf/line-segment\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\nimport { bearingToAzimuth, } from \"@turf/helpers\";\n/**\n * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`\n *\n * @name booleanParallel\n * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false if the lines are parallel\n * @example\n * var line1 = turf.lineString([[0, 0], [0, 1]]);\n * var line2 = turf.lineString([[1, 0], [1, 1]]);\n *\n * turf.booleanParallel(line1, line2);\n * //=true\n */\nfunction booleanParallel(line1, line2) {\n    // validation\n    if (!line1)\n        throw new Error(\"line1 is required\");\n    if (!line2)\n        throw new Error(\"line2 is required\");\n    var type1 = getType(line1, \"line1\");\n    if (type1 !== \"LineString\")\n        throw new Error(\"line1 must be a LineString\");\n    var type2 = getType(line2, \"line2\");\n    if (type2 !== \"LineString\")\n        throw new Error(\"line2 must be a LineString\");\n    var segments1 = lineSegment(cleanCoords(line1)).features;\n    var segments2 = lineSegment(cleanCoords(line2)).features;\n    for (var i = 0; i < segments1.length; i++) {\n        var segment1 = segments1[i].geometry.coordinates;\n        if (!segments2[i])\n            break;\n        var segment2 = segments2[i].geometry.coordinates;\n        if (!isParallel(segment1, segment2))\n            return false;\n    }\n    return true;\n}\n/**\n * Compares slopes and return result\n *\n * @private\n * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature\n * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature\n * @returns {boolean} if slopes are equal\n */\nfunction isParallel(segment1, segment2) {\n    var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\n    var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\n    return slope1 === slope2;\n}\n/**\n * Returns Feature's type\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {string} name of the variable\n * @returns {string} Feature's type\n */\nfunction getType(geojson, name) {\n    if (geojson.geometry && geojson.geometry.type)\n        return geojson.geometry.type;\n    if (geojson.type)\n        return geojson.type; // if GeoJSON geometry\n    throw new Error(\"Invalid GeoJSON object for \" + name);\n}\nexport default booleanParallel;\n"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,oBAAxB;AACA,OAAOC,WAAP,MAAwB,oBAAxB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SAASC,gBAAT,QAAkC,eAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,KAAzB,EAAgCC,KAAhC,EAAuC;EACnC;EACA,IAAI,CAACD,KAAL,EACI,MAAM,IAAIE,KAAJ,CAAU,mBAAV,CAAN;EACJ,IAAI,CAACD,KAAL,EACI,MAAM,IAAIC,KAAJ,CAAU,mBAAV,CAAN;EACJ,IAAIC,KAAK,GAAGC,OAAO,CAACJ,KAAD,EAAQ,OAAR,CAAnB;EACA,IAAIG,KAAK,KAAK,YAAd,EACI,MAAM,IAAID,KAAJ,CAAU,4BAAV,CAAN;EACJ,IAAIG,KAAK,GAAGD,OAAO,CAACH,KAAD,EAAQ,OAAR,CAAnB;EACA,IAAII,KAAK,KAAK,YAAd,EACI,MAAM,IAAIH,KAAJ,CAAU,4BAAV,CAAN;EACJ,IAAII,SAAS,GAAGV,WAAW,CAACD,WAAW,CAACK,KAAD,CAAZ,CAAX,CAAgCO,QAAhD;EACA,IAAIC,SAAS,GAAGZ,WAAW,CAACD,WAAW,CAACM,KAAD,CAAZ,CAAX,CAAgCM,QAAhD;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACI,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;IACvC,IAAIE,QAAQ,GAAGL,SAAS,CAACG,CAAD,CAAT,CAAaG,QAAb,CAAsBC,WAArC;IACA,IAAI,CAACL,SAAS,CAACC,CAAD,CAAd,EACI;IACJ,IAAIK,QAAQ,GAAGN,SAAS,CAACC,CAAD,CAAT,CAAaG,QAAb,CAAsBC,WAArC;IACA,IAAI,CAACE,UAAU,CAACJ,QAAD,EAAWG,QAAX,CAAf,EACI,OAAO,KAAP;EACP;;EACD,OAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBJ,QAApB,EAA8BG,QAA9B,EAAwC;EACpC,IAAIE,MAAM,GAAGlB,gBAAgB,CAACD,YAAY,CAACc,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAAb,CAA7B;EACA,IAAIM,MAAM,GAAGnB,gBAAgB,CAACD,YAAY,CAACiB,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAAb,CAA7B;EACA,OAAOE,MAAM,KAAKC,MAAlB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASb,OAAT,CAAiBc,OAAjB,EAA0BC,IAA1B,EAAgC;EAC5B,IAAID,OAAO,CAACN,QAAR,IAAoBM,OAAO,CAACN,QAAR,CAAiBQ,IAAzC,EACI,OAAOF,OAAO,CAACN,QAAR,CAAiBQ,IAAxB;EACJ,IAAIF,OAAO,CAACE,IAAZ,EACI,OAAOF,OAAO,CAACE,IAAf,CAJwB,CAIH;;EACzB,MAAM,IAAIlB,KAAJ,CAAU,gCAAgCiB,IAA1C,CAAN;AACH;;AACD,eAAepB,eAAf"},"metadata":{},"sourceType":"module"}