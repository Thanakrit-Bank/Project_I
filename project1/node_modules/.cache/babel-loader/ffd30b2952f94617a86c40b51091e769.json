{"ast":null,"code":"import { abs, epsilon } from \"../math\";\nimport clipBuffer from \"./buffer\";\nimport clipLine from \"./line\";\nimport clipPolygon from \"./polygon\";\nimport { merge } from \"d3-array\";\nvar clipMax = 1e9,\n    clipMin = -clipMax; // TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport function clipExtent(x0, y0, x1, y1) {\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0,\n        a1 = 0;\n\n    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n      do {\n        stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      } while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n  }\n\n  return function (stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__,\n        y__,\n        v__,\n        // first point\n    x_,\n        y_,\n        v_,\n        // previous point\n    first,\n        clean;\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n\n          if (a1 <= y1) {\n            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;\n          } else {\n            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;\n          }\n        }\n      }\n\n      return winding;\n    } // Buffer geometry within a polygon and then clip it en masse.\n\n\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n\n      if (cleanInside || visible) {\n        stream.polygonStart();\n\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n\n        stream.polygonEnd();\n      }\n\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    } // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n\n\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\nexport default function () {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n  return clip = {\n    stream: function stream(_stream) {\n      return cache && cacheStream === _stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = _stream);\n    },\n    extent: function extent(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n}","map":{"version":3,"names":["abs","epsilon","clipBuffer","clipLine","clipPolygon","merge","clipMax","clipMin","clipExtent","x0","y0","x1","y1","visible","x","y","interpolate","from","to","direction","stream","a","a1","corner","comparePoint","point","p","compareIntersection","b","ca","cb","activeStream","bufferStream","segments","polygon","ring","x__","y__","v__","x_","y_","v_","first","clean","clipStream","lineStart","lineEnd","polygonStart","polygonEnd","polygonInside","winding","i","n","length","j","m","a0","b0","b1","startInside","cleanInside","linePoint","push","NaN","rejoin","result","v","Math","max","min","cache","cacheStream","clip","extent","_","arguments"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/d3-geo/src/clip/extent.js"],"sourcesContent":["import {abs, epsilon} from \"../math\";\nimport clipBuffer from \"./buffer\";\nimport clipLine from \"./line\";\nimport clipPolygon from \"./polygon\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport function clipExtent(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}