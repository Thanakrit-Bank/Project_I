{"ast":null,"code":"import turfbbox from \"@turf/bbox\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport rbush from \"rbush\";\n/**\r\n * Merges a specified property from a FeatureCollection of points into a\r\n * FeatureCollection of polygons. Given an `inProperty` on points and an `outProperty`\r\n * for polygons, this finds every point that lies within each polygon, collects the\r\n * `inProperty` values from those points, and adds them as an array to `outProperty`\r\n * on the polygon.\r\n *\r\n * @name collect\r\n * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate\r\n * @param {FeatureCollection<Point>} points points to be aggregated\r\n * @param {string} inProperty property to be nested from\r\n * @param {string} outProperty property to be nested into\r\n * @returns {FeatureCollection<Polygon>} polygons with properties listed based on `outField`\r\n * @example\r\n * var poly1 = turf.polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);\r\n * var poly2 = turf.polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);\r\n * var polyFC = turf.featureCollection([poly1, poly2]);\r\n * var pt1 = turf.point([5,5], {population: 200});\r\n * var pt2 = turf.point([1,3], {population: 600});\r\n * var pt3 = turf.point([14,2], {population: 100});\r\n * var pt4 = turf.point([13,1], {population: 200});\r\n * var pt5 = turf.point([19,7], {population: 300});\r\n * var pointFC = turf.featureCollection([pt1, pt2, pt3, pt4, pt5]);\r\n * var collected = turf.collect(polyFC, pointFC, 'population', 'values');\r\n * var values = collected.features[0].properties.values\r\n * //=values => [200, 600]\r\n *\r\n * //addToMap\r\n * var addToMap = [pointFC, collected]\r\n */\n\nfunction collect(polygons, points, inProperty, outProperty) {\n  var rtree = rbush(6);\n  var treeItems = points.features.map(function (item) {\n    var _a;\n\n    return {\n      minX: item.geometry.coordinates[0],\n      minY: item.geometry.coordinates[1],\n      maxX: item.geometry.coordinates[0],\n      maxY: item.geometry.coordinates[1],\n      property: (_a = item.properties) === null || _a === void 0 ? void 0 : _a[inProperty]\n    };\n  });\n  rtree.load(treeItems);\n  polygons.features.forEach(function (poly) {\n    if (!poly.properties) {\n      poly.properties = {};\n    }\n\n    var bbox = turfbbox(poly);\n    var potentialPoints = rtree.search({\n      minX: bbox[0],\n      minY: bbox[1],\n      maxX: bbox[2],\n      maxY: bbox[3]\n    });\n    var values = [];\n    potentialPoints.forEach(function (pt) {\n      if (booleanPointInPolygon([pt.minX, pt.minY], poly)) {\n        values.push(pt.property);\n      }\n    });\n    poly.properties[outProperty] = values;\n  });\n  return polygons;\n}\n\nexport default collect;","map":{"version":3,"names":["turfbbox","booleanPointInPolygon","rbush","collect","polygons","points","inProperty","outProperty","rtree","treeItems","features","map","item","_a","minX","geometry","coordinates","minY","maxX","maxY","property","properties","load","forEach","poly","bbox","potentialPoints","search","values","pt","push"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/collect/dist/es/index.js"],"sourcesContent":["import turfbbox from \"@turf/bbox\";\r\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\r\nimport rbush from \"rbush\";\r\n/**\r\n * Merges a specified property from a FeatureCollection of points into a\r\n * FeatureCollection of polygons. Given an `inProperty` on points and an `outProperty`\r\n * for polygons, this finds every point that lies within each polygon, collects the\r\n * `inProperty` values from those points, and adds them as an array to `outProperty`\r\n * on the polygon.\r\n *\r\n * @name collect\r\n * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate\r\n * @param {FeatureCollection<Point>} points points to be aggregated\r\n * @param {string} inProperty property to be nested from\r\n * @param {string} outProperty property to be nested into\r\n * @returns {FeatureCollection<Polygon>} polygons with properties listed based on `outField`\r\n * @example\r\n * var poly1 = turf.polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);\r\n * var poly2 = turf.polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);\r\n * var polyFC = turf.featureCollection([poly1, poly2]);\r\n * var pt1 = turf.point([5,5], {population: 200});\r\n * var pt2 = turf.point([1,3], {population: 600});\r\n * var pt3 = turf.point([14,2], {population: 100});\r\n * var pt4 = turf.point([13,1], {population: 200});\r\n * var pt5 = turf.point([19,7], {population: 300});\r\n * var pointFC = turf.featureCollection([pt1, pt2, pt3, pt4, pt5]);\r\n * var collected = turf.collect(polyFC, pointFC, 'population', 'values');\r\n * var values = collected.features[0].properties.values\r\n * //=values => [200, 600]\r\n *\r\n * //addToMap\r\n * var addToMap = [pointFC, collected]\r\n */\r\nfunction collect(polygons, points, inProperty, outProperty) {\r\n    var rtree = rbush(6);\r\n    var treeItems = points.features.map(function (item) {\r\n        var _a;\r\n        return {\r\n            minX: item.geometry.coordinates[0],\r\n            minY: item.geometry.coordinates[1],\r\n            maxX: item.geometry.coordinates[0],\r\n            maxY: item.geometry.coordinates[1],\r\n            property: (_a = item.properties) === null || _a === void 0 ? void 0 : _a[inProperty],\r\n        };\r\n    });\r\n    rtree.load(treeItems);\r\n    polygons.features.forEach(function (poly) {\r\n        if (!poly.properties) {\r\n            poly.properties = {};\r\n        }\r\n        var bbox = turfbbox(poly);\r\n        var potentialPoints = rtree.search({\r\n            minX: bbox[0],\r\n            minY: bbox[1],\r\n            maxX: bbox[2],\r\n            maxY: bbox[3],\r\n        });\r\n        var values = [];\r\n        potentialPoints.forEach(function (pt) {\r\n            if (booleanPointInPolygon([pt.minX, pt.minY], poly)) {\r\n                values.push(pt.property);\r\n            }\r\n        });\r\n        poly.properties[outProperty] = values;\r\n    });\r\n    return polygons;\r\n}\r\nexport default collect;\r\n"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,qBAAP,MAAkC,gCAAlC;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,OAAT,CAAiBC,QAAjB,EAA2BC,MAA3B,EAAmCC,UAAnC,EAA+CC,WAA/C,EAA4D;EACxD,IAAIC,KAAK,GAAGN,KAAK,CAAC,CAAD,CAAjB;EACA,IAAIO,SAAS,GAAGJ,MAAM,CAACK,QAAP,CAAgBC,GAAhB,CAAoB,UAAUC,IAAV,EAAgB;IAChD,IAAIC,EAAJ;;IACA,OAAO;MACHC,IAAI,EAAEF,IAAI,CAACG,QAAL,CAAcC,WAAd,CAA0B,CAA1B,CADH;MAEHC,IAAI,EAAEL,IAAI,CAACG,QAAL,CAAcC,WAAd,CAA0B,CAA1B,CAFH;MAGHE,IAAI,EAAEN,IAAI,CAACG,QAAL,CAAcC,WAAd,CAA0B,CAA1B,CAHH;MAIHG,IAAI,EAAEP,IAAI,CAACG,QAAL,CAAcC,WAAd,CAA0B,CAA1B,CAJH;MAKHI,QAAQ,EAAE,CAACP,EAAE,GAAGD,IAAI,CAACS,UAAX,MAA2B,IAA3B,IAAmCR,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACP,UAAD;IALrE,CAAP;EAOH,CATe,CAAhB;EAUAE,KAAK,CAACc,IAAN,CAAWb,SAAX;EACAL,QAAQ,CAACM,QAAT,CAAkBa,OAAlB,CAA0B,UAAUC,IAAV,EAAgB;IACtC,IAAI,CAACA,IAAI,CAACH,UAAV,EAAsB;MAClBG,IAAI,CAACH,UAAL,GAAkB,EAAlB;IACH;;IACD,IAAII,IAAI,GAAGzB,QAAQ,CAACwB,IAAD,CAAnB;IACA,IAAIE,eAAe,GAAGlB,KAAK,CAACmB,MAAN,CAAa;MAC/Bb,IAAI,EAAEW,IAAI,CAAC,CAAD,CADqB;MAE/BR,IAAI,EAAEQ,IAAI,CAAC,CAAD,CAFqB;MAG/BP,IAAI,EAAEO,IAAI,CAAC,CAAD,CAHqB;MAI/BN,IAAI,EAAEM,IAAI,CAAC,CAAD;IAJqB,CAAb,CAAtB;IAMA,IAAIG,MAAM,GAAG,EAAb;IACAF,eAAe,CAACH,OAAhB,CAAwB,UAAUM,EAAV,EAAc;MAClC,IAAI5B,qBAAqB,CAAC,CAAC4B,EAAE,CAACf,IAAJ,EAAUe,EAAE,CAACZ,IAAb,CAAD,EAAqBO,IAArB,CAAzB,EAAqD;QACjDI,MAAM,CAACE,IAAP,CAAYD,EAAE,CAACT,QAAf;MACH;IACJ,CAJD;IAKAI,IAAI,CAACH,UAAL,CAAgBd,WAAhB,IAA+BqB,MAA/B;EACH,CAlBD;EAmBA,OAAOxB,QAAP;AACH;;AACD,eAAeD,OAAf"},"metadata":{},"sourceType":"module"}