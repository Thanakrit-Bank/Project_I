{"ast":null,"code":"import distance from '@turf/distance';\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @name square\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * var bbox = [-20, -20, -15, 0];\n * var squared = turf.square(bbox);\n *\n * //addToMap\n * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\n\nfunction square(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [west, verticalMidpoint - (east - west) / 2, east, verticalMidpoint + (east - west) / 2];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [horizontalMidpoint - (north - south) / 2, south, horizontalMidpoint + (north - south) / 2, north];\n  }\n}\n\nexport default square;","map":{"version":3,"names":["distance","square","bbox","west","south","east","north","horizontalDistance","slice","verticalDistance","verticalMidpoint","horizontalMidpoint"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/square/dist/es/index.js"],"sourcesContent":["import distance from '@turf/distance';\n\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @name square\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * var bbox = [-20, -20, -15, 0];\n * var squared = turf.square(bbox);\n *\n * //addToMap\n * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\nfunction square(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [\n      west,\n      verticalMidpoint - (east - west) / 2,\n      east,\n      verticalMidpoint + (east - west) / 2,\n    ];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [\n      horizontalMidpoint - (north - south) / 2,\n      south,\n      horizontalMidpoint + (north - south) / 2,\n      north,\n    ];\n  }\n}\n\nexport default square;\n"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,gBAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,MAAT,CAAgBC,IAAhB,EAAsB;EACpB,IAAIC,IAAI,GAAGD,IAAI,CAAC,CAAD,CAAf;EACA,IAAIE,KAAK,GAAGF,IAAI,CAAC,CAAD,CAAhB;EACA,IAAIG,IAAI,GAAGH,IAAI,CAAC,CAAD,CAAf;EACA,IAAII,KAAK,GAAGJ,IAAI,CAAC,CAAD,CAAhB;EAEA,IAAIK,kBAAkB,GAAGP,QAAQ,CAACE,IAAI,CAACM,KAAL,CAAW,CAAX,EAAc,CAAd,CAAD,EAAmB,CAACH,IAAD,EAAOD,KAAP,CAAnB,CAAjC;EACA,IAAIK,gBAAgB,GAAGT,QAAQ,CAACE,IAAI,CAACM,KAAL,CAAW,CAAX,EAAc,CAAd,CAAD,EAAmB,CAACL,IAAD,EAAOG,KAAP,CAAnB,CAA/B;;EACA,IAAIC,kBAAkB,IAAIE,gBAA1B,EAA4C;IAC1C,IAAIC,gBAAgB,GAAG,CAACN,KAAK,GAAGE,KAAT,IAAkB,CAAzC;IACA,OAAO,CACLH,IADK,EAELO,gBAAgB,GAAG,CAACL,IAAI,GAAGF,IAAR,IAAgB,CAF9B,EAGLE,IAHK,EAILK,gBAAgB,GAAG,CAACL,IAAI,GAAGF,IAAR,IAAgB,CAJ9B,CAAP;EAMD,CARD,MAQO;IACL,IAAIQ,kBAAkB,GAAG,CAACR,IAAI,GAAGE,IAAR,IAAgB,CAAzC;IACA,OAAO,CACLM,kBAAkB,GAAG,CAACL,KAAK,GAAGF,KAAT,IAAkB,CADlC,EAELA,KAFK,EAGLO,kBAAkB,GAAG,CAACL,KAAK,GAAGF,KAAT,IAAkB,CAHlC,EAILE,KAJK,CAAP;EAMD;AACF;;AAED,eAAeL,MAAf"},"metadata":{},"sourceType":"module"}