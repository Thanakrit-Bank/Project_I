{"ast":null,"code":"import { getCoords, getType } from '@turf/invariant';\nimport { featureCollection, point } from '@turf/helpers';\nimport calcBbox from '@turf/bbox';\nimport explode from '@turf/explode';\nimport nearestPoint from '@turf/nearest-point';\n/**\r\n * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.\r\n *\r\n * @name polygonTangents\r\n * @param {Coord} pt to calculate the tangent points from\r\n * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from\r\n * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points\r\n * @example\r\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\r\n * var point = turf.point([61, 5]);\r\n *\r\n * var tangents = turf.polygonTangents(point, polygon)\r\n *\r\n * //addToMap\r\n * var addToMap = [tangents, point, polygon];\r\n */\n\nfunction polygonTangents(pt, polygon) {\n  var pointCoords = getCoords(pt);\n  var polyCoords = getCoords(polygon);\n  var rtan;\n  var ltan;\n  var enext;\n  var eprev;\n  var bbox = calcBbox(polygon);\n  var nearestPtIndex = 0;\n  var nearest = null; // If the point lies inside the polygon bbox then we need to be a bit trickier\n  // otherwise points lying inside reflex angles on concave polys can have issues\n\n  if (pointCoords[0] > bbox[0] && pointCoords[0] < bbox[2] && pointCoords[1] > bbox[1] && pointCoords[1] < bbox[3]) {\n    nearest = nearestPoint(pt, explode(polygon));\n    nearestPtIndex = nearest.properties.featureIndex;\n  }\n\n  var type = getType(polygon);\n\n  switch (type) {\n    case \"Polygon\":\n      rtan = polyCoords[0][nearestPtIndex];\n      ltan = polyCoords[0][0];\n\n      if (nearest !== null) {\n        if (nearest.geometry.coordinates[1] < pointCoords[1]) ltan = polyCoords[0][nearestPtIndex];\n      }\n\n      eprev = isLeft(polyCoords[0][0], polyCoords[0][polyCoords[0].length - 1], pointCoords);\n      var out = processPolygon(polyCoords[0], pointCoords, eprev, enext, rtan, ltan);\n      rtan = out[0];\n      ltan = out[1];\n      break;\n\n    case \"MultiPolygon\":\n      var closestFeature = 0;\n      var closestVertex = 0;\n      var verticesCounted = 0;\n\n      for (var i = 0; i < polyCoords[0].length; i++) {\n        closestFeature = i;\n        var verticeFound = false;\n\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\n          closestVertex = i2;\n\n          if (verticesCounted === nearestPtIndex) {\n            verticeFound = true;\n            break;\n          }\n\n          verticesCounted++;\n        }\n\n        if (verticeFound) break;\n      }\n\n      rtan = polyCoords[0][closestFeature][closestVertex];\n      ltan = polyCoords[0][closestFeature][closestVertex];\n      eprev = isLeft(polyCoords[0][0][0], polyCoords[0][0][polyCoords[0][0].length - 1], pointCoords);\n      polyCoords.forEach(function (ring) {\n        var out = processPolygon(ring[0], pointCoords, eprev, enext, rtan, ltan);\n        rtan = out[0];\n        ltan = out[1];\n      });\n      break;\n  }\n\n  return featureCollection([point(rtan), point(ltan)]);\n}\n\nfunction processPolygon(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {\n  for (var i = 0; i < polygonCoords.length; i++) {\n    var currentCoords = polygonCoords[i];\n    var nextCoordPair = polygonCoords[i + 1];\n\n    if (i === polygonCoords.length - 1) {\n      nextCoordPair = polygonCoords[0];\n    }\n\n    enext = isLeft(currentCoords, nextCoordPair, ptCoords);\n\n    if (eprev <= 0 && enext > 0) {\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\n        rtan = currentCoords;\n      }\n    } else if (eprev > 0 && enext <= 0) {\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\n        ltan = currentCoords;\n      }\n    }\n\n    eprev = enext;\n  }\n\n  return [rtan, ltan];\n}\n\nfunction isAbove(point1, point2, point3) {\n  return isLeft(point1, point2, point3) > 0;\n}\n\nfunction isBelow(point1, point2, point3) {\n  return isLeft(point1, point2, point3) < 0;\n}\n\nfunction isLeft(point1, point2, point3) {\n  return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);\n}\n\nexport default polygonTangents;","map":{"version":3,"names":["getCoords","getType","featureCollection","point","calcBbox","explode","nearestPoint","polygonTangents","pt","polygon","pointCoords","polyCoords","rtan","ltan","enext","eprev","bbox","nearestPtIndex","nearest","properties","featureIndex","type","geometry","coordinates","isLeft","length","out","processPolygon","closestFeature","closestVertex","verticesCounted","i","verticeFound","i2","forEach","ring","polygonCoords","ptCoords","currentCoords","nextCoordPair","isBelow","isAbove","point1","point2","point3"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/polygon-tangents/dist/es/index.js"],"sourcesContent":["import { getCoords, getType } from '@turf/invariant';\r\nimport { featureCollection, point } from '@turf/helpers';\r\nimport calcBbox from '@turf/bbox';\r\nimport explode from '@turf/explode';\r\nimport nearestPoint from '@turf/nearest-point';\r\n\r\n/**\r\n * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.\r\n *\r\n * @name polygonTangents\r\n * @param {Coord} pt to calculate the tangent points from\r\n * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from\r\n * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points\r\n * @example\r\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\r\n * var point = turf.point([61, 5]);\r\n *\r\n * var tangents = turf.polygonTangents(point, polygon)\r\n *\r\n * //addToMap\r\n * var addToMap = [tangents, point, polygon];\r\n */\r\nfunction polygonTangents(pt, polygon) {\r\n  var pointCoords = getCoords(pt);\r\n  var polyCoords = getCoords(polygon);\r\n\r\n  var rtan;\r\n  var ltan;\r\n  var enext;\r\n  var eprev;\r\n  var bbox = calcBbox(polygon);\r\n  var nearestPtIndex = 0;\r\n  var nearest = null;\r\n\r\n  // If the point lies inside the polygon bbox then we need to be a bit trickier\r\n  // otherwise points lying inside reflex angles on concave polys can have issues\r\n  if (\r\n    pointCoords[0] > bbox[0] &&\r\n    pointCoords[0] < bbox[2] &&\r\n    pointCoords[1] > bbox[1] &&\r\n    pointCoords[1] < bbox[3]\r\n  ) {\r\n    nearest = nearestPoint(pt, explode(polygon));\r\n    nearestPtIndex = nearest.properties.featureIndex;\r\n  }\r\n  var type = getType(polygon);\r\n  switch (type) {\r\n    case \"Polygon\":\r\n      rtan = polyCoords[0][nearestPtIndex];\r\n      ltan = polyCoords[0][0];\r\n      if (nearest !== null) {\r\n        if (nearest.geometry.coordinates[1] < pointCoords[1])\r\n          ltan = polyCoords[0][nearestPtIndex];\r\n      }\r\n      eprev = isLeft(\r\n        polyCoords[0][0],\r\n        polyCoords[0][polyCoords[0].length - 1],\r\n        pointCoords\r\n      );\r\n      var out = processPolygon(\r\n        polyCoords[0],\r\n        pointCoords,\r\n        eprev,\r\n        enext,\r\n        rtan,\r\n        ltan);\r\n      rtan = out[0];\r\n      ltan = out[1];\r\n      break;\r\n    case \"MultiPolygon\":\r\n      var closestFeature = 0;\r\n      var closestVertex = 0;\r\n      var verticesCounted = 0;\r\n      for (var i = 0; i < polyCoords[0].length; i++) {\r\n        closestFeature = i;\r\n        var verticeFound = false;\r\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\r\n          closestVertex = i2;\r\n          if (verticesCounted === nearestPtIndex) {\r\n            verticeFound = true;\r\n            break;\r\n          }\r\n          verticesCounted++;\r\n        }\r\n        if (verticeFound) break;\r\n      }\r\n      rtan = polyCoords[0][closestFeature][closestVertex];\r\n      ltan = polyCoords[0][closestFeature][closestVertex];\r\n      eprev = isLeft(\r\n        polyCoords[0][0][0],\r\n        polyCoords[0][0][polyCoords[0][0].length - 1],\r\n        pointCoords\r\n      );\r\n      polyCoords.forEach(function (ring) {\r\n        var out = processPolygon(\r\n          ring[0],\r\n          pointCoords,\r\n          eprev,\r\n          enext,\r\n          rtan,\r\n          ltan);\r\n        rtan = out[0];\r\n        ltan = out[1];\r\n      });\r\n      break;\r\n  }\r\n  return featureCollection([point(rtan), point(ltan)]);\r\n}\r\n\r\nfunction processPolygon(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {\r\n  for (var i = 0; i < polygonCoords.length; i++) {\r\n    var currentCoords = polygonCoords[i];\r\n    var nextCoordPair = polygonCoords[i + 1];\r\n    if (i === polygonCoords.length - 1) {\r\n      nextCoordPair = polygonCoords[0];\r\n    }\r\n    enext = isLeft(currentCoords, nextCoordPair, ptCoords);\r\n    if (eprev <= 0 && enext > 0) {\r\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\r\n        rtan = currentCoords;\r\n      }\r\n    } else if (eprev > 0 && enext <= 0) {\r\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\r\n        ltan = currentCoords;\r\n      }\r\n    }\r\n    eprev = enext;\r\n  }\r\n  return [rtan, ltan];\r\n}\r\n\r\nfunction isAbove(point1, point2, point3) {\r\n  return isLeft(point1, point2, point3) > 0;\r\n}\r\n\r\nfunction isBelow(point1, point2, point3) {\r\n  return isLeft(point1, point2, point3) < 0;\r\n}\r\n\r\nfunction isLeft(point1, point2, point3) {\r\n  return (\r\n    (point2[0] - point1[0]) * (point3[1] - point1[1]) -\r\n    (point3[0] - point1[0]) * (point2[1] - point1[1])\r\n  );\r\n}\r\n\r\nexport default polygonTangents;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}