{"ast":null,"code":"import length from '@turf/length';\nimport lineSliceAlong from '@turf/line-slice-along';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, featureCollection } from '@turf/helpers';\n/**\r\n * Divides a {@link LineString} into chunks of a specified length.\r\n * If the line is shorter than the segment length then the original line is returned.\r\n *\r\n * @name lineChunk\r\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\r\n * @param {number} segmentLength how long to make each segment\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers\r\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\r\n * @returns {FeatureCollection<LineString>} collection of line segments\r\n * @example\r\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\r\n *\r\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\r\n *\r\n * //addToMap\r\n * var addToMap = [chunk];\r\n */\n\nfunction lineChunk(geojson, segmentLength, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var reverse = options.reverse; // Validation\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0) throw new Error(\"segmentLength must be greater than 0\"); // Container\n\n  var results = []; // Flatten each feature to simple LineString\n\n  flattenEach(geojson, function (feature) {\n    // reverses coordinates to start the first chunked segment at the end\n    if (reverse) feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\n      results.push(segment);\n    });\n  });\n  return featureCollection(results);\n}\n/**\r\n * Slice Line Segments\r\n *\r\n * @private\r\n * @param {Feature<LineString>} line GeoJSON LineString\r\n * @param {number} segmentLength how long to make each segment\r\n * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers\r\n * @param {Function} callback iterate over sliced line segments\r\n * @returns {void}\r\n */\n\n\nfunction sliceLineSegments(line, segmentLength, units, callback) {\n  var lineLength = length(line, {\n    units: units\n  }); // If the line is shorter than the segment length then the orginal line is returned.\n\n  if (lineLength <= segmentLength) return callback(line);\n  var numberOfSegments = lineLength / segmentLength; // If numberOfSegments is integer, no need to plus 1\n\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(line, segmentLength * i, segmentLength * (i + 1), {\n      units: units\n    });\n    callback(outline, i);\n  }\n}\n\nexport default lineChunk;","map":{"version":3,"names":["length","lineSliceAlong","flattenEach","isObject","featureCollection","lineChunk","geojson","segmentLength","options","Error","units","reverse","results","feature","geometry","coordinates","sliceLineSegments","segment","push","line","callback","lineLength","numberOfSegments","Number","isInteger","Math","floor","i","outline"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/line-chunk/dist/es/index.js"],"sourcesContent":["import length from '@turf/length';\r\nimport lineSliceAlong from '@turf/line-slice-along';\r\nimport { flattenEach } from '@turf/meta';\r\nimport { isObject, featureCollection } from '@turf/helpers';\r\n\r\n/**\r\n * Divides a {@link LineString} into chunks of a specified length.\r\n * If the line is shorter than the segment length then the original line is returned.\r\n *\r\n * @name lineChunk\r\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\r\n * @param {number} segmentLength how long to make each segment\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers\r\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\r\n * @returns {FeatureCollection<LineString>} collection of line segments\r\n * @example\r\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\r\n *\r\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\r\n *\r\n * //addToMap\r\n * var addToMap = [chunk];\r\n */\r\nfunction lineChunk(geojson, segmentLength, options) {\r\n  // Optional parameters\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var units = options.units;\r\n  var reverse = options.reverse;\r\n\r\n  // Validation\r\n  if (!geojson) throw new Error(\"geojson is required\");\r\n  if (segmentLength <= 0)\r\n    throw new Error(\"segmentLength must be greater than 0\");\r\n\r\n  // Container\r\n  var results = [];\r\n\r\n  // Flatten each feature to simple LineString\r\n  flattenEach(geojson, function (feature) {\r\n    // reverses coordinates to start the first chunked segment at the end\r\n    if (reverse)\r\n      feature.geometry.coordinates = feature.geometry.coordinates.reverse();\r\n\r\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\r\n      results.push(segment);\r\n    });\r\n  });\r\n  return featureCollection(results);\r\n}\r\n\r\n/**\r\n * Slice Line Segments\r\n *\r\n * @private\r\n * @param {Feature<LineString>} line GeoJSON LineString\r\n * @param {number} segmentLength how long to make each segment\r\n * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers\r\n * @param {Function} callback iterate over sliced line segments\r\n * @returns {void}\r\n */\r\nfunction sliceLineSegments(line, segmentLength, units, callback) {\r\n  var lineLength = length(line, { units: units });\r\n\r\n  // If the line is shorter than the segment length then the orginal line is returned.\r\n  if (lineLength <= segmentLength) return callback(line);\r\n\r\n  var numberOfSegments = lineLength / segmentLength;\r\n\r\n  // If numberOfSegments is integer, no need to plus 1\r\n  if (!Number.isInteger(numberOfSegments)) {\r\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\r\n  }\r\n\r\n  for (var i = 0; i < numberOfSegments; i++) {\r\n    var outline = lineSliceAlong(\r\n      line,\r\n      segmentLength * i,\r\n      segmentLength * (i + 1),\r\n      { units: units }\r\n    );\r\n    callback(outline, i);\r\n  }\r\n}\r\n\r\nexport default lineChunk;\r\n"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,cAAnB;AACA,OAAOC,cAAP,MAA2B,wBAA3B;AACA,SAASC,WAAT,QAA4B,YAA5B;AACA,SAASC,QAAT,EAAmBC,iBAAnB,QAA4C,eAA5C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,aAA5B,EAA2CC,OAA3C,EAAoD;EAClD;EACAA,OAAO,GAAGA,OAAO,IAAI,EAArB;EACA,IAAI,CAACL,QAAQ,CAACK,OAAD,CAAb,EAAwB,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;EACxB,IAAIC,KAAK,GAAGF,OAAO,CAACE,KAApB;EACA,IAAIC,OAAO,GAAGH,OAAO,CAACG,OAAtB,CALkD,CAOlD;;EACA,IAAI,CAACL,OAAL,EAAc,MAAM,IAAIG,KAAJ,CAAU,qBAAV,CAAN;EACd,IAAIF,aAAa,IAAI,CAArB,EACE,MAAM,IAAIE,KAAJ,CAAU,sCAAV,CAAN,CAVgD,CAYlD;;EACA,IAAIG,OAAO,GAAG,EAAd,CAbkD,CAelD;;EACAV,WAAW,CAACI,OAAD,EAAU,UAAUO,OAAV,EAAmB;IACtC;IACA,IAAIF,OAAJ,EACEE,OAAO,CAACC,QAAR,CAAiBC,WAAjB,GAA+BF,OAAO,CAACC,QAAR,CAAiBC,WAAjB,CAA6BJ,OAA7B,EAA/B;IAEFK,iBAAiB,CAACH,OAAD,EAAUN,aAAV,EAAyBG,KAAzB,EAAgC,UAAUO,OAAV,EAAmB;MAClEL,OAAO,CAACM,IAAR,CAAaD,OAAb;IACD,CAFgB,CAAjB;EAGD,CARU,CAAX;EASA,OAAOb,iBAAiB,CAACQ,OAAD,CAAxB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,iBAAT,CAA2BG,IAA3B,EAAiCZ,aAAjC,EAAgDG,KAAhD,EAAuDU,QAAvD,EAAiE;EAC/D,IAAIC,UAAU,GAAGrB,MAAM,CAACmB,IAAD,EAAO;IAAET,KAAK,EAAEA;EAAT,CAAP,CAAvB,CAD+D,CAG/D;;EACA,IAAIW,UAAU,IAAId,aAAlB,EAAiC,OAAOa,QAAQ,CAACD,IAAD,CAAf;EAEjC,IAAIG,gBAAgB,GAAGD,UAAU,GAAGd,aAApC,CAN+D,CAQ/D;;EACA,IAAI,CAACgB,MAAM,CAACC,SAAP,CAAiBF,gBAAjB,CAAL,EAAyC;IACvCA,gBAAgB,GAAGG,IAAI,CAACC,KAAL,CAAWJ,gBAAX,IAA+B,CAAlD;EACD;;EAED,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,gBAApB,EAAsCK,CAAC,EAAvC,EAA2C;IACzC,IAAIC,OAAO,GAAG3B,cAAc,CAC1BkB,IAD0B,EAE1BZ,aAAa,GAAGoB,CAFU,EAG1BpB,aAAa,IAAIoB,CAAC,GAAG,CAAR,CAHa,EAI1B;MAAEjB,KAAK,EAAEA;IAAT,CAJ0B,CAA5B;IAMAU,QAAQ,CAACQ,OAAD,EAAUD,CAAV,CAAR;EACD;AACF;;AAED,eAAetB,SAAf"},"metadata":{},"sourceType":"module"}