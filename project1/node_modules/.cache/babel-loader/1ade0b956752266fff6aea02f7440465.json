{"ast":null,"code":"import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\n\nfunction booleanPointOnLine(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  } // Normalize inputs\n\n\n  var ptCoords = getCoord(pt);\n  var lineCoords = getCoords(line); // Main\n\n  for (var i = 0; i < lineCoords.length - 1; i++) {\n    var ignoreBoundary = false;\n\n    if (options.ignoreEndVertices) {\n      if (i === 0) {\n        ignoreBoundary = \"start\";\n      }\n\n      if (i === lineCoords.length - 2) {\n        ignoreBoundary = \"end\";\n      }\n\n      if (i === 0 && i + 1 === lineCoords.length - 1) {\n        ignoreBoundary = \"both\";\n      }\n    }\n\n    if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n      return true;\n    }\n  }\n\n  return false;\n} // See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\n\n\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n  var x = pt[0];\n  var y = pt[1];\n  var x1 = lineSegmentStart[0];\n  var y1 = lineSegmentStart[1];\n  var x2 = lineSegmentEnd[0];\n  var y2 = lineSegmentEnd[1];\n  var dxc = pt[0] - x1;\n  var dyc = pt[1] - y1;\n  var dxl = x2 - x1;\n  var dyl = y2 - y1;\n  var cross = dxc * dyl - dyc * dxl;\n\n  if (epsilon !== null) {\n    if (Math.abs(cross) > epsilon) {\n      return false;\n    }\n  } else if (cross !== 0) {\n    return false;\n  }\n\n  if (!excludeBoundary) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n    }\n\n    return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n  } else if (excludeBoundary === \"start\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n    }\n\n    return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n  } else if (excludeBoundary === \"end\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n    }\n\n    return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n  } else if (excludeBoundary === \"both\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n    }\n\n    return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n  }\n\n  return false;\n}\n\nexport default booleanPointOnLine;","map":{"version":3,"names":["getCoord","getCoords","booleanPointOnLine","pt","line","options","ptCoords","lineCoords","i","length","ignoreBoundary","ignoreEndVertices","isPointOnLineSegment","epsilon","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","cross","Math","abs"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/boolean-point-on-line/dist/es/index.js"],"sourcesContent":["import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = getCoord(pt);\n    var lineCoords = getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (epsilon !== null) {\n        if (Math.abs(cross) > epsilon) {\n            return false;\n        }\n    }\n    else if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexport default booleanPointOnLine;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}