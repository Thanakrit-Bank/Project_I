{"ast":null,"code":"import calcBbox from \"@turf/bbox\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport isPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getGeom } from \"@turf/invariant\";\n/**\r\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\r\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\r\n * must not intersect the exterior of the primary (geometry a).\r\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\r\n *\r\n * @name booleanContains\r\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\r\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\r\n * @returns {boolean} true/false\r\n * @example\r\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\r\n * var point = turf.point([1, 2]);\r\n *\r\n * turf.booleanContains(line, point);\r\n * //=true\r\n */\n\nexport default function booleanContains(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n  var coords1 = geom1.coordinates;\n  var coords2 = geom2.coordinates;\n\n  switch (type1) {\n    case \"Point\":\n      switch (type2) {\n        case \"Point\":\n          return compareCoords(coords1, coords2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"Point\":\n          return isPointInMultiPoint(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointInMultiPoint(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"LineString\":\n      switch (type2) {\n        case \"Point\":\n          return isPointOnLine(geom2, geom1, {\n            ignoreEndVertices: true\n          });\n\n        case \"LineString\":\n          return isLineOnLine(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointOnLine(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"Polygon\":\n      switch (type2) {\n        case \"Point\":\n          return booleanPointInPolygon(geom2, geom1, {\n            ignoreBoundary: true\n          });\n\n        case \"LineString\":\n          return isLineInPoly(geom1, geom2);\n\n        case \"Polygon\":\n          return isPolyInPoly(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointInPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\nexport function isPointInMultiPoint(multiPoint, pt) {\n  var i;\n  var output = false;\n\n  for (i = 0; i < multiPoint.coordinates.length; i++) {\n    if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n      output = true;\n      break;\n    }\n  }\n\n  return output;\n}\nexport function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n  for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n    var coord2 = _a[_i];\n    var matchFound = false;\n\n    for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n      var coord1 = _c[_b];\n\n      if (compareCoords(coord2, coord1)) {\n        matchFound = true;\n        break;\n      }\n    }\n\n    if (!matchFound) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function isMultiPointOnLine(lineString, multiPoint) {\n  var haveFoundInteriorPoint = false;\n\n  for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n    var coord = _a[_i];\n\n    if (isPointOnLine(coord, lineString, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n\n    if (!isPointOnLine(coord, lineString)) {\n      return false;\n    }\n  }\n\n  if (haveFoundInteriorPoint) {\n    return true;\n  }\n\n  return false;\n}\nexport function isMultiPointInPoly(polygon, multiPoint) {\n  for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n    var coord = _a[_i];\n\n    if (!booleanPointInPolygon(coord, polygon, {\n      ignoreBoundary: true\n    })) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function isLineOnLine(lineString1, lineString2) {\n  var haveFoundInteriorPoint = false;\n\n  for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n    var coords = _a[_i];\n\n    if (isPointOnLine({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n\n    if (!isPointOnLine({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: false\n    })) {\n      return false;\n    }\n  }\n\n  return haveFoundInteriorPoint;\n}\nexport function isLineInPoly(polygon, linestring) {\n  var output = false;\n  var i = 0;\n  var polyBbox = calcBbox(polygon);\n  var lineBbox = calcBbox(linestring);\n\n  if (!doBBoxOverlap(polyBbox, lineBbox)) {\n    return false;\n  }\n\n  for (i; i < linestring.coordinates.length - 1; i++) {\n    var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n\n    if (booleanPointInPolygon({\n      type: \"Point\",\n      coordinates: midPoint\n    }, polygon, {\n      ignoreBoundary: true\n    })) {\n      output = true;\n      break;\n    }\n  }\n\n  return output;\n}\n/**\r\n * Is Polygon2 in Polygon1\r\n * Only takes into account outer rings\r\n *\r\n * @private\r\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\r\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\r\n * @returns {boolean} true/false\r\n */\n\nexport function isPolyInPoly(feature1, feature2) {\n  // Handle Nulls\n  if (feature1.type === \"Feature\" && feature1.geometry === null) {\n    return false;\n  }\n\n  if (feature2.type === \"Feature\" && feature2.geometry === null) {\n    return false;\n  }\n\n  var poly1Bbox = calcBbox(feature1);\n  var poly2Bbox = calcBbox(feature2);\n\n  if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n    return false;\n  }\n\n  var coords = getGeom(feature2).coordinates;\n\n  for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n    var ring = coords_1[_i];\n\n    for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n      var coord = ring_1[_a];\n\n      if (!booleanPointInPolygon(coord, feature1)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\nexport function doBBoxOverlap(bbox1, bbox2) {\n  if (bbox1[0] > bbox2[0]) {\n    return false;\n  }\n\n  if (bbox1[2] < bbox2[2]) {\n    return false;\n  }\n\n  if (bbox1[1] > bbox2[1]) {\n    return false;\n  }\n\n  if (bbox1[3] < bbox2[3]) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * compareCoords\r\n *\r\n * @private\r\n * @param {Position} pair1 point [x,y]\r\n * @param {Position} pair2 point [x,y]\r\n * @returns {boolean} true/false if coord pairs match\r\n */\n\nexport function compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport function getMidpoint(pair1, pair2) {\n  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}","map":{"version":3,"names":["calcBbox","booleanPointInPolygon","isPointOnLine","getGeom","booleanContains","feature1","feature2","geom1","geom2","type1","type","type2","coords1","coordinates","coords2","compareCoords","Error","isPointInMultiPoint","isMultiPointInMultiPoint","ignoreEndVertices","isLineOnLine","isMultiPointOnLine","ignoreBoundary","isLineInPoly","isPolyInPoly","isMultiPointInPoly","multiPoint","pt","i","output","length","multiPoint1","multiPoint2","_i","_a","coord2","matchFound","_b","_c","coord1","lineString","haveFoundInteriorPoint","coord","polygon","lineString1","lineString2","coords","linestring","polyBbox","lineBbox","doBBoxOverlap","midPoint","getMidpoint","geometry","poly1Bbox","poly2Bbox","coords_1","ring","ring_1","bbox1","bbox2","pair1","pair2"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/boolean-contains/dist/es/index.js"],"sourcesContent":["import calcBbox from \"@turf/bbox\";\r\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\r\nimport isPointOnLine from \"@turf/boolean-point-on-line\";\r\nimport { getGeom } from \"@turf/invariant\";\r\n/**\r\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\r\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\r\n * must not intersect the exterior of the primary (geometry a).\r\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\r\n *\r\n * @name booleanContains\r\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\r\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\r\n * @returns {boolean} true/false\r\n * @example\r\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\r\n * var point = turf.point([1, 2]);\r\n *\r\n * turf.booleanContains(line, point);\r\n * //=true\r\n */\r\nexport default function booleanContains(feature1, feature2) {\r\n    var geom1 = getGeom(feature1);\r\n    var geom2 = getGeom(feature2);\r\n    var type1 = geom1.type;\r\n    var type2 = geom2.type;\r\n    var coords1 = geom1.coordinates;\r\n    var coords2 = geom2.coordinates;\r\n    switch (type1) {\r\n        case \"Point\":\r\n            switch (type2) {\r\n                case \"Point\":\r\n                    return compareCoords(coords1, coords2);\r\n                default:\r\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\r\n            }\r\n        case \"MultiPoint\":\r\n            switch (type2) {\r\n                case \"Point\":\r\n                    return isPointInMultiPoint(geom1, geom2);\r\n                case \"MultiPoint\":\r\n                    return isMultiPointInMultiPoint(geom1, geom2);\r\n                default:\r\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\r\n            }\r\n        case \"LineString\":\r\n            switch (type2) {\r\n                case \"Point\":\r\n                    return isPointOnLine(geom2, geom1, { ignoreEndVertices: true });\r\n                case \"LineString\":\r\n                    return isLineOnLine(geom1, geom2);\r\n                case \"MultiPoint\":\r\n                    return isMultiPointOnLine(geom1, geom2);\r\n                default:\r\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\r\n            }\r\n        case \"Polygon\":\r\n            switch (type2) {\r\n                case \"Point\":\r\n                    return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });\r\n                case \"LineString\":\r\n                    return isLineInPoly(geom1, geom2);\r\n                case \"Polygon\":\r\n                    return isPolyInPoly(geom1, geom2);\r\n                case \"MultiPoint\":\r\n                    return isMultiPointInPoly(geom1, geom2);\r\n                default:\r\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\r\n            }\r\n        default:\r\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\r\n    }\r\n}\r\nexport function isPointInMultiPoint(multiPoint, pt) {\r\n    var i;\r\n    var output = false;\r\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\r\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\r\n            output = true;\r\n            break;\r\n        }\r\n    }\r\n    return output;\r\n}\r\nexport function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\r\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\r\n        var coord2 = _a[_i];\r\n        var matchFound = false;\r\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\r\n            var coord1 = _c[_b];\r\n            if (compareCoords(coord2, coord1)) {\r\n                matchFound = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!matchFound) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function isMultiPointOnLine(lineString, multiPoint) {\r\n    var haveFoundInteriorPoint = false;\r\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\r\n        var coord = _a[_i];\r\n        if (isPointOnLine(coord, lineString, { ignoreEndVertices: true })) {\r\n            haveFoundInteriorPoint = true;\r\n        }\r\n        if (!isPointOnLine(coord, lineString)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (haveFoundInteriorPoint) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function isMultiPointInPoly(polygon, multiPoint) {\r\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\r\n        var coord = _a[_i];\r\n        if (!booleanPointInPolygon(coord, polygon, { ignoreBoundary: true })) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function isLineOnLine(lineString1, lineString2) {\r\n    var haveFoundInteriorPoint = false;\r\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\r\n        var coords = _a[_i];\r\n        if (isPointOnLine({ type: \"Point\", coordinates: coords }, lineString1, {\r\n            ignoreEndVertices: true,\r\n        })) {\r\n            haveFoundInteriorPoint = true;\r\n        }\r\n        if (!isPointOnLine({ type: \"Point\", coordinates: coords }, lineString1, {\r\n            ignoreEndVertices: false,\r\n        })) {\r\n            return false;\r\n        }\r\n    }\r\n    return haveFoundInteriorPoint;\r\n}\r\nexport function isLineInPoly(polygon, linestring) {\r\n    var output = false;\r\n    var i = 0;\r\n    var polyBbox = calcBbox(polygon);\r\n    var lineBbox = calcBbox(linestring);\r\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\r\n        return false;\r\n    }\r\n    for (i; i < linestring.coordinates.length - 1; i++) {\r\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\r\n        if (booleanPointInPolygon({ type: \"Point\", coordinates: midPoint }, polygon, {\r\n            ignoreBoundary: true,\r\n        })) {\r\n            output = true;\r\n            break;\r\n        }\r\n    }\r\n    return output;\r\n}\r\n/**\r\n * Is Polygon2 in Polygon1\r\n * Only takes into account outer rings\r\n *\r\n * @private\r\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\r\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\r\n * @returns {boolean} true/false\r\n */\r\nexport function isPolyInPoly(feature1, feature2) {\r\n    // Handle Nulls\r\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\r\n        return false;\r\n    }\r\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\r\n        return false;\r\n    }\r\n    var poly1Bbox = calcBbox(feature1);\r\n    var poly2Bbox = calcBbox(feature2);\r\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\r\n        return false;\r\n    }\r\n    var coords = getGeom(feature2).coordinates;\r\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\r\n        var ring = coords_1[_i];\r\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\r\n            var coord = ring_1[_a];\r\n            if (!booleanPointInPolygon(coord, feature1)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function doBBoxOverlap(bbox1, bbox2) {\r\n    if (bbox1[0] > bbox2[0]) {\r\n        return false;\r\n    }\r\n    if (bbox1[2] < bbox2[2]) {\r\n        return false;\r\n    }\r\n    if (bbox1[1] > bbox2[1]) {\r\n        return false;\r\n    }\r\n    if (bbox1[3] < bbox2[3]) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * compareCoords\r\n *\r\n * @private\r\n * @param {Position} pair1 point [x,y]\r\n * @param {Position} pair2 point [x,y]\r\n * @returns {boolean} true/false if coord pairs match\r\n */\r\nexport function compareCoords(pair1, pair2) {\r\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\r\n}\r\nexport function getMidpoint(pair1, pair2) {\r\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}