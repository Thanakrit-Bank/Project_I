{"ast":null,"code":"import bbox from '@turf/bbox';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { collectionOf, getCoords } from '@turf/invariant';\nimport { isObject, featureCollection, multiLineString } from '@turf/helpers';\nimport objectAssign from 'object-assign';\n/**\r\n * @license GNU Affero General Public License.\r\n * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\r\n * v. 1.2.0\r\n * https://github.com/RaumZeit/MarchingSquares.js\r\n *\r\n * MarchingSquaresJS is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * MarchingSquaresJS is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * As additional permission under GNU Affero General Public License version 3\r\n * section 7, third-party projects (personal or commercial) may distribute,\r\n * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\r\n * requirement that said third-party project for that reason alone becomes\r\n * subject to any requirement of the GNU Affero General Public License version 3.\r\n * Any modifications to MarchingSquaresJS, however, must be shared with the public\r\n * and made available.\r\n *\r\n * In summary this:\r\n * - allows you to use MarchingSquaresJS at no cost\r\n * - allows you to use MarchingSquaresJS for both personal and commercial purposes\r\n * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\r\n *   license as long as this license notice is included\r\n * - enables you to keep the source code of your program that uses MarchingSquaresJS\r\n *   undisclosed\r\n * - forces you to share any modifications you have made to MarchingSquaresJS,\r\n *   e.g. bug-fixes\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\r\n */\n\n/**\r\n * Compute the isocontour(s) of a scalar 2D field given\r\n * a certain threshold by applying the Marching Squares\r\n * Algorithm. The function returns a list of path coordinates\r\n */\n\nvar defaultSettings = {\n  successCallback: null,\n  verbose: false\n};\nvar settings = {};\n\nfunction isoContours(data, threshold, options) {\n  /* process options */\n  options = options ? options : {};\n  var optionKeys = Object.keys(defaultSettings);\n\n  for (var i = 0; i < optionKeys.length; i++) {\n    var key = optionKeys[i];\n    var val = options[key];\n    val = typeof val !== \"undefined\" && val !== null ? val : defaultSettings[key];\n    settings[key] = val;\n  }\n\n  if (settings.verbose) console.log(\"MarchingSquaresJS-isoContours: computing isocontour for \" + threshold);\n  var ret = contourGrid2Paths(computeContourGrid(data, threshold));\n  if (typeof settings.successCallback === \"function\") settings.successCallback(ret);\n  return ret;\n}\n/*\r\n  Thats all for the public interface, below follows the actual\r\n  implementation\r\n*/\n\n/*\r\n################################\r\nIsocontour implementation below\r\n################################\r\n*/\n\n/* assume that x1 == 1 &&  x0 == 0 */\n\n\nfunction interpolateX(y, y0, y1) {\n  return (y - y0) / (y1 - y0);\n}\n/* compute the isocontour 4-bit grid */\n\n\nfunction computeContourGrid(data, threshold) {\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n  var ContourGrid = {\n    rows: rows,\n    cols: cols,\n    cells: []\n  };\n\n  for (var j = 0; j < rows; ++j) {\n    ContourGrid.cells[j] = [];\n\n    for (var i = 0; i < cols; ++i) {\n      /* compose the 4-bit corner representation */\n      var cval = 0;\n      var tl = data[j + 1][i];\n      var tr = data[j + 1][i + 1];\n      var br = data[j][i + 1];\n      var bl = data[j][i];\n\n      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {\n        continue;\n      }\n\n      cval |= tl >= threshold ? 8 : 0;\n      cval |= tr >= threshold ? 4 : 0;\n      cval |= br >= threshold ? 2 : 0;\n      cval |= bl >= threshold ? 1 : 0;\n      /* resolve ambiguity for cval == 5 || 10 via averaging */\n\n      var flipped = false;\n\n      if (cval === 5 || cval === 10) {\n        var average = (tl + tr + br + bl) / 4;\n\n        if (cval === 5 && average < threshold) {\n          cval = 10;\n          flipped = true;\n        } else if (cval === 10 && average < threshold) {\n          cval = 5;\n          flipped = true;\n        }\n      }\n      /* add cell to ContourGrid if it contains edges */\n\n\n      if (cval !== 0 && cval !== 15) {\n        var top, bottom, left, right;\n        top = bottom = left = right = 0.5;\n        /* interpolate edges of cell */\n\n        if (cval === 1) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          bottom = 1 - interpolateX(threshold, br, bl);\n        } else if (cval === 2) {\n          bottom = interpolateX(threshold, bl, br);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 3) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 4) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 5) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n          bottom = 1 - interpolateX(threshold, br, bl);\n          left = 1 - interpolateX(threshold, tl, bl);\n        } else if (cval === 6) {\n          bottom = interpolateX(threshold, bl, br);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 7) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 8) {\n          left = interpolateX(threshold, bl, tl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 9) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 10) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n          bottom = interpolateX(threshold, bl, br);\n          left = interpolateX(threshold, bl, tl);\n        } else if (cval === 11) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 12) {\n          left = interpolateX(threshold, bl, tl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 13) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 14) {\n          left = interpolateX(threshold, bl, tl);\n          bottom = interpolateX(threshold, bl, br);\n        } else {\n          console.log(\"MarchingSquaresJS-isoContours: Illegal cval detected: \" + cval);\n        }\n\n        ContourGrid.cells[j][i] = {\n          cval: cval,\n          flipped: flipped,\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left\n        };\n      }\n    }\n  }\n\n  return ContourGrid;\n}\n\nfunction isSaddle(cell) {\n  return cell.cval === 5 || cell.cval === 10;\n}\n\nfunction isTrivial(cell) {\n  return cell.cval === 0 || cell.cval === 15;\n}\n\nfunction clearCell(cell) {\n  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {\n    cell.cval = 15;\n  }\n}\n\nfunction getXY(cell, edge) {\n  if (edge === \"top\") {\n    return [cell.top, 1.0];\n  } else if (edge === \"bottom\") {\n    return [cell.bottom, 0.0];\n  } else if (edge === \"right\") {\n    return [1.0, cell.right];\n  } else if (edge === \"left\") {\n    return [0.0, cell.left];\n  }\n}\n\nfunction contourGrid2Paths(grid) {\n  var paths = [];\n  var path_idx = 0;\n  var epsilon = 1e-7;\n  grid.cells.forEach(function (g, j) {\n    g.forEach(function (gg, i) {\n      if (typeof gg !== \"undefined\" && !isSaddle(gg) && !isTrivial(gg)) {\n        var p = tracePath(grid.cells, j, i);\n        var merged = false;\n        /* we may try to merge paths at this point */\n\n        if (p.info === \"mergeable\") {\n          /*\r\n            search backwards through the path array to find an entry\r\n            that starts with where the current path ends...\r\n          */\n          var x = p.path[p.path.length - 1][0],\n              y = p.path[p.path.length - 1][1];\n\n          for (var k = path_idx - 1; k >= 0; k--) {\n            if (Math.abs(paths[k][0][0] - x) <= epsilon && Math.abs(paths[k][0][1] - y) <= epsilon) {\n              for (var l = p.path.length - 2; l >= 0; --l) {\n                paths[k].unshift(p.path[l]);\n              }\n\n              merged = true;\n              break;\n            }\n          }\n        }\n\n        if (!merged) paths[path_idx++] = p.path;\n      }\n    });\n  });\n  return paths;\n}\n/*\r\n  construct consecutive line segments from starting cell by\r\n  walking arround the enclosed area clock-wise\r\n  */\n\n\nfunction tracePath(grid, j, i) {\n  var maxj = grid.length;\n  var p = [];\n  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];\n  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];\n  var dx, dy;\n  var startEdge = [\"none\", \"left\", \"bottom\", \"left\", \"right\", \"none\", \"bottom\", \"left\", \"top\", \"top\", \"none\", \"top\", \"right\", \"right\", \"bottom\", \"none\"];\n  var nextEdge = [\"none\", \"bottom\", \"right\", \"right\", \"top\", \"top\", \"top\", \"top\", \"left\", \"bottom\", \"right\", \"right\", \"left\", \"bottom\", \"left\", \"none\"];\n  var edge;\n  var currentCell = grid[j][i];\n  var cval = currentCell.cval;\n  var edge = startEdge[cval];\n  var pt = getXY(currentCell, edge);\n  /* push initial segment */\n\n  p.push([i + pt[0], j + pt[1]]);\n  edge = nextEdge[cval];\n  pt = getXY(currentCell, edge);\n  p.push([i + pt[0], j + pt[1]]);\n  clearCell(currentCell);\n  /* now walk arround the enclosed area in clockwise-direction */\n\n  var k = i + dxContour[cval];\n  var l = j + dyContour[cval];\n  var prev_cval = cval;\n\n  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {\n    currentCell = grid[l][k];\n\n    if (typeof currentCell === \"undefined\") {\n      /* path ends here */\n      //console.log(k + \" \" + l + \" is undefined, stopping path!\");\n      break;\n    }\n\n    cval = currentCell.cval;\n\n    if (cval === 0 || cval === 15) {\n      return {\n        path: p,\n        info: \"mergeable\"\n      };\n    }\n\n    edge = nextEdge[cval];\n    dx = dxContour[cval];\n    dy = dyContour[cval];\n\n    if (cval === 5 || cval === 10) {\n      /* select upper or lower band, depending on previous cells cval */\n      if (cval === 5) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 10 */\n          if (dyContour[prev_cval] === -1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          } else {\n            edge = \"right\";\n            dx = 1;\n            dy = 0;\n          }\n        } else {\n          /* real case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        }\n      } else if (cval === 10) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"top\";\n            dx = 0;\n            dy = 1;\n          } else {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        } else {\n          /* real case 10 */\n          if (dyContour[prev_cval] === 1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          }\n        }\n      }\n    }\n\n    pt = getXY(currentCell, edge);\n    p.push([k + pt[0], l + pt[1]]);\n    clearCell(currentCell);\n    k += dx;\n    l += dy;\n    prev_cval = cval;\n  }\n\n  return {\n    path: p,\n    info: \"closed\"\n  };\n}\n/**\r\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\r\n * of the 'property' values\r\n *\r\n * @name gridToMatrix\r\n * @param {FeatureCollection<Point>} grid of points\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\r\n * @param {boolean} [options.flip=false] returns the matrix upside-down\r\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\r\n * the grid points with coordinates on the matrix\r\n * @returns {Array<Array<number>>} matrix of property values\r\n * @example\r\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\r\n *   var cellSize = 3;\r\n *   var grid = turf.pointGrid(extent, cellSize);\r\n *   // add a random property to each point between 0 and 60\r\n *   for (var i = 0; i < grid.features.length; i++) {\r\n *     grid.features[i].properties.elevation = (Math.random() * 60);\r\n *   }\r\n *   gridToMatrix(grid);\r\n *   //= [\r\n *     [ 1, 13, 10,  9, 10, 13, 18],\r\n *     [34,  8,  5,  4,  5,  8, 13],\r\n *     [10,  5,  2,  1,  2,  5,  4],\r\n *     [ 0,  4, 56, 19,  1,  4,  9],\r\n *     [10,  5,  2,  1,  2,  5, 10],\r\n *     [57,  8,  5,  4,  5,  0, 57],\r\n *     [ 3, 13, 10,  9,  5, 13, 18],\r\n *     [18, 13, 10,  9, 78, 13, 18]\r\n *   ]\r\n */\n\n\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags; // validation\n\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = []; // create property matrix from sorted points\n  // looping order matters here\n\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c]; // Check if zProperty exist\n\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0); // add flags\n\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n/**\r\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\r\n *\r\n * @private\r\n * @param {FeatureCollection<Point>} points GeoJSON Point features\r\n * @param {boolean} [flip=false] returns the matrix upside-down\r\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\r\n */\n\n\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {}; // divide points by rows with the same latitude\n\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  }); // sort points (with the same latitude) by longitude\n\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  }); // sort rows (of points with the same latitude) by latitude\n\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n/**\r\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\r\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\r\n *\r\n * @name isolines\r\n * @param {FeatureCollection<Point>} pointGrid input points\r\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\r\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\r\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\r\n * the breaks array will define the order in which the isolines are created\r\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\r\n * @example\r\n * // create a grid of points with random z-values in their properties\r\n * var extent = [0, 30, 20, 50];\r\n * var cellWidth = 100;\r\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\r\n *\r\n * for (var i = 0; i < pointGrid.features.length; i++) {\r\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\r\n * }\r\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n *\r\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\r\n *\r\n * //addToMap\r\n * var addToMap = [lines];\r\n */\n\n\nfunction isolines(pointGrid, breaks, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var commonProperties = options.commonProperties || {};\n  var breaksProperties = options.breaksProperties || []; // Input validation\n\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject(commonProperties)) throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties must be an Array\"); // Isoline methods\n\n  var matrix = gridToMatrix(pointGrid, {\n    zProperty: zProperty,\n    flip: true\n  });\n  var createdIsoLines = createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties);\n  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n  return featureCollection(scaledIsolines);\n}\n/**\r\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\r\n *\r\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\r\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\r\n * rescaled, with turfjs, to the original area and proportions on the map\r\n *\r\n * @private\r\n * @param {Array<Array<number>>} matrix Grid Data\r\n * @param {Array<number>} breaks Breaks\r\n * @param {string} zProperty name of the z-values property\r\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\r\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\r\n * @returns {Array<MultiLineString>} isolines\r\n */\n\n\nfunction createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {\n  var results = [];\n\n  for (var i = 1; i < breaks.length; i++) {\n    var threshold = +breaks[i]; // make sure it's a number\n\n    var properties = objectAssign({}, commonProperties, breaksProperties[i]);\n    properties[zProperty] = threshold;\n    var isoline = multiLineString(isoContours(matrix, threshold), properties);\n    results.push(isoline);\n  }\n\n  return results;\n}\n/**\r\n * Translates and scales isolines\r\n *\r\n * @private\r\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\r\n * @param {Array<Array<number>>} matrix Grid Data\r\n * @param {Object} points Points by Latitude\r\n * @returns {Array<MultiLineString>} isolines\r\n */\n\n\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  // get dimensions (on the map) of the original grid\n  var gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n\n  var originalWidth = gridBbox[2] - gridBbox[0];\n  var originalHeigth = gridBbox[3] - gridBbox[1]; // get origin, which is the first point of the last row on the rectangular data on the map\n\n  var x0 = gridBbox[0];\n  var y0 = gridBbox[1]; // get number of cells per side\n\n  var matrixWidth = matrix[0].length - 1;\n  var matrixHeight = matrix.length - 1; // calculate the scaling factor between matrix and rectangular grid on the map\n\n  var scaleX = originalWidth / matrixWidth;\n  var scaleY = originalHeigth / matrixHeight;\n\n  var resize = function resize(point) {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  }; // resize and shift each point/line of the createdIsoLines\n\n\n  createdIsoLines.forEach(function (isoline) {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\n\nexport default isolines;","map":{"version":3,"names":["bbox","featureEach","coordEach","collectionOf","getCoords","isObject","featureCollection","multiLineString","objectAssign","defaultSettings","successCallback","verbose","settings","isoContours","data","threshold","options","optionKeys","Object","keys","i","length","key","val","console","log","ret","contourGrid2Paths","computeContourGrid","interpolateX","y","y0","y1","rows","cols","ContourGrid","cells","j","cval","tl","tr","br","bl","isNaN","flipped","average","top","bottom","left","right","isSaddle","cell","isTrivial","clearCell","getXY","edge","grid","paths","path_idx","epsilon","forEach","g","gg","p","tracePath","merged","info","x","path","k","Math","abs","l","unshift","maxj","dxContour","dyContour","dx","dy","startEdge","nextEdge","currentCell","pt","push","prev_cval","gridToMatrix","Error","zProperty","flip","flags","pointsMatrix","sortPointsByLatLng","matrix","r","pointRow","row","c","point","properties","matrixPosition","points","pointsByLatitude","lat","orderedRowsByLatitude","map","rowOrderedByLongitude","sort","a","b","pointMatrix","isolines","pointGrid","breaks","commonProperties","breaksProperties","Array","isArray","createdIsoLines","createIsoLines","scaledIsolines","rescaleIsolines","results","isoline","gridBbox","originalWidth","originalHeigth","x0","matrixWidth","matrixHeight","scaleX","scaleY","resize"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/isolines/dist/es/index.js"],"sourcesContent":["import bbox from '@turf/bbox';\r\nimport { featureEach, coordEach } from '@turf/meta';\r\nimport { collectionOf, getCoords } from '@turf/invariant';\r\nimport { isObject, featureCollection, multiLineString } from '@turf/helpers';\r\nimport objectAssign from 'object-assign';\r\n\r\n/**\r\n * @license GNU Affero General Public License.\r\n * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\r\n * v. 1.2.0\r\n * https://github.com/RaumZeit/MarchingSquares.js\r\n *\r\n * MarchingSquaresJS is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * MarchingSquaresJS is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * As additional permission under GNU Affero General Public License version 3\r\n * section 7, third-party projects (personal or commercial) may distribute,\r\n * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\r\n * requirement that said third-party project for that reason alone becomes\r\n * subject to any requirement of the GNU Affero General Public License version 3.\r\n * Any modifications to MarchingSquaresJS, however, must be shared with the public\r\n * and made available.\r\n *\r\n * In summary this:\r\n * - allows you to use MarchingSquaresJS at no cost\r\n * - allows you to use MarchingSquaresJS for both personal and commercial purposes\r\n * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\r\n *   license as long as this license notice is included\r\n * - enables you to keep the source code of your program that uses MarchingSquaresJS\r\n *   undisclosed\r\n * - forces you to share any modifications you have made to MarchingSquaresJS,\r\n *   e.g. bug-fixes\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/**\r\n * Compute the isocontour(s) of a scalar 2D field given\r\n * a certain threshold by applying the Marching Squares\r\n * Algorithm. The function returns a list of path coordinates\r\n */\r\nvar defaultSettings = {\r\n  successCallback: null,\r\n  verbose: false,\r\n};\r\n\r\nvar settings = {};\r\n\r\nfunction isoContours(data, threshold, options) {\r\n  /* process options */\r\n  options = options ? options : {};\r\n\r\n  var optionKeys = Object.keys(defaultSettings);\r\n\r\n  for (var i = 0; i < optionKeys.length; i++) {\r\n    var key = optionKeys[i];\r\n    var val = options[key];\r\n    val =\r\n      typeof val !== \"undefined\" && val !== null ? val : defaultSettings[key];\r\n\r\n    settings[key] = val;\r\n  }\r\n\r\n  if (settings.verbose)\r\n    console.log(\r\n      \"MarchingSquaresJS-isoContours: computing isocontour for \" + threshold\r\n    );\r\n\r\n  var ret = contourGrid2Paths(computeContourGrid(data, threshold));\r\n\r\n  if (typeof settings.successCallback === \"function\")\r\n    settings.successCallback(ret);\r\n\r\n  return ret;\r\n}\r\n\r\n/*\r\n  Thats all for the public interface, below follows the actual\r\n  implementation\r\n*/\r\n\r\n/*\r\n################################\r\nIsocontour implementation below\r\n################################\r\n*/\r\n\r\n/* assume that x1 == 1 &&  x0 == 0 */\r\nfunction interpolateX(y, y0, y1) {\r\n  return (y - y0) / (y1 - y0);\r\n}\r\n\r\n/* compute the isocontour 4-bit grid */\r\nfunction computeContourGrid(data, threshold) {\r\n  var rows = data.length - 1;\r\n  var cols = data[0].length - 1;\r\n  var ContourGrid = { rows: rows, cols: cols, cells: [] };\r\n\r\n  for (var j = 0; j < rows; ++j) {\r\n    ContourGrid.cells[j] = [];\r\n    for (var i = 0; i < cols; ++i) {\r\n      /* compose the 4-bit corner representation */\r\n      var cval = 0;\r\n\r\n      var tl = data[j + 1][i];\r\n      var tr = data[j + 1][i + 1];\r\n      var br = data[j][i + 1];\r\n      var bl = data[j][i];\r\n\r\n      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {\r\n        continue;\r\n      }\r\n      cval |= tl >= threshold ? 8 : 0;\r\n      cval |= tr >= threshold ? 4 : 0;\r\n      cval |= br >= threshold ? 2 : 0;\r\n      cval |= bl >= threshold ? 1 : 0;\r\n\r\n      /* resolve ambiguity for cval == 5 || 10 via averaging */\r\n      var flipped = false;\r\n      if (cval === 5 || cval === 10) {\r\n        var average = (tl + tr + br + bl) / 4;\r\n        if (cval === 5 && average < threshold) {\r\n          cval = 10;\r\n          flipped = true;\r\n        } else if (cval === 10 && average < threshold) {\r\n          cval = 5;\r\n          flipped = true;\r\n        }\r\n      }\r\n\r\n      /* add cell to ContourGrid if it contains edges */\r\n      if (cval !== 0 && cval !== 15) {\r\n        var top, bottom, left, right;\r\n        top = bottom = left = right = 0.5;\r\n        /* interpolate edges of cell */\r\n        if (cval === 1) {\r\n          left = 1 - interpolateX(threshold, tl, bl);\r\n          bottom = 1 - interpolateX(threshold, br, bl);\r\n        } else if (cval === 2) {\r\n          bottom = interpolateX(threshold, bl, br);\r\n          right = 1 - interpolateX(threshold, tr, br);\r\n        } else if (cval === 3) {\r\n          left = 1 - interpolateX(threshold, tl, bl);\r\n          right = 1 - interpolateX(threshold, tr, br);\r\n        } else if (cval === 4) {\r\n          top = interpolateX(threshold, tl, tr);\r\n          right = interpolateX(threshold, br, tr);\r\n        } else if (cval === 5) {\r\n          top = interpolateX(threshold, tl, tr);\r\n          right = interpolateX(threshold, br, tr);\r\n          bottom = 1 - interpolateX(threshold, br, bl);\r\n          left = 1 - interpolateX(threshold, tl, bl);\r\n        } else if (cval === 6) {\r\n          bottom = interpolateX(threshold, bl, br);\r\n          top = interpolateX(threshold, tl, tr);\r\n        } else if (cval === 7) {\r\n          left = 1 - interpolateX(threshold, tl, bl);\r\n          top = interpolateX(threshold, tl, tr);\r\n        } else if (cval === 8) {\r\n          left = interpolateX(threshold, bl, tl);\r\n          top = 1 - interpolateX(threshold, tr, tl);\r\n        } else if (cval === 9) {\r\n          bottom = 1 - interpolateX(threshold, br, bl);\r\n          top = 1 - interpolateX(threshold, tr, tl);\r\n        } else if (cval === 10) {\r\n          top = 1 - interpolateX(threshold, tr, tl);\r\n          right = 1 - interpolateX(threshold, tr, br);\r\n          bottom = interpolateX(threshold, bl, br);\r\n          left = interpolateX(threshold, bl, tl);\r\n        } else if (cval === 11) {\r\n          top = 1 - interpolateX(threshold, tr, tl);\r\n          right = 1 - interpolateX(threshold, tr, br);\r\n        } else if (cval === 12) {\r\n          left = interpolateX(threshold, bl, tl);\r\n          right = interpolateX(threshold, br, tr);\r\n        } else if (cval === 13) {\r\n          bottom = 1 - interpolateX(threshold, br, bl);\r\n          right = interpolateX(threshold, br, tr);\r\n        } else if (cval === 14) {\r\n          left = interpolateX(threshold, bl, tl);\r\n          bottom = interpolateX(threshold, bl, br);\r\n        } else {\r\n          console.log(\r\n            \"MarchingSquaresJS-isoContours: Illegal cval detected: \" + cval\r\n          );\r\n        }\r\n        ContourGrid.cells[j][i] = {\r\n          cval: cval,\r\n          flipped: flipped,\r\n          top: top,\r\n          right: right,\r\n          bottom: bottom,\r\n          left: left,\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  return ContourGrid;\r\n}\r\n\r\nfunction isSaddle(cell) {\r\n  return cell.cval === 5 || cell.cval === 10;\r\n}\r\n\r\nfunction isTrivial(cell) {\r\n  return cell.cval === 0 || cell.cval === 15;\r\n}\r\n\r\nfunction clearCell(cell) {\r\n  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {\r\n    cell.cval = 15;\r\n  }\r\n}\r\n\r\nfunction getXY(cell, edge) {\r\n  if (edge === \"top\") {\r\n    return [cell.top, 1.0];\r\n  } else if (edge === \"bottom\") {\r\n    return [cell.bottom, 0.0];\r\n  } else if (edge === \"right\") {\r\n    return [1.0, cell.right];\r\n  } else if (edge === \"left\") {\r\n    return [0.0, cell.left];\r\n  }\r\n}\r\n\r\nfunction contourGrid2Paths(grid) {\r\n  var paths = [];\r\n  var path_idx = 0;\r\n  var epsilon = 1e-7;\r\n\r\n  grid.cells.forEach(function (g, j) {\r\n    g.forEach(function (gg, i) {\r\n      if (typeof gg !== \"undefined\" && !isSaddle(gg) && !isTrivial(gg)) {\r\n        var p = tracePath(grid.cells, j, i);\r\n        var merged = false;\r\n        /* we may try to merge paths at this point */\r\n        if (p.info === \"mergeable\") {\r\n          /*\r\n            search backwards through the path array to find an entry\r\n            that starts with where the current path ends...\r\n          */\r\n          var x = p.path[p.path.length - 1][0],\r\n            y = p.path[p.path.length - 1][1];\r\n\r\n          for (var k = path_idx - 1; k >= 0; k--) {\r\n            if (\r\n              Math.abs(paths[k][0][0] - x) <= epsilon &&\r\n              Math.abs(paths[k][0][1] - y) <= epsilon\r\n            ) {\r\n              for (var l = p.path.length - 2; l >= 0; --l) {\r\n                paths[k].unshift(p.path[l]);\r\n              }\r\n              merged = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (!merged) paths[path_idx++] = p.path;\r\n      }\r\n    });\r\n  });\r\n\r\n  return paths;\r\n}\r\n\r\n/*\r\n  construct consecutive line segments from starting cell by\r\n  walking arround the enclosed area clock-wise\r\n  */\r\nfunction tracePath(grid, j, i) {\r\n  var maxj = grid.length;\r\n  var p = [];\r\n  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];\r\n  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];\r\n  var dx, dy;\r\n  var startEdge = [\r\n    \"none\",\r\n    \"left\",\r\n    \"bottom\",\r\n    \"left\",\r\n    \"right\",\r\n    \"none\",\r\n    \"bottom\",\r\n    \"left\",\r\n    \"top\",\r\n    \"top\",\r\n    \"none\",\r\n    \"top\",\r\n    \"right\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"none\",\r\n  ];\r\n  var nextEdge = [\r\n    \"none\",\r\n    \"bottom\",\r\n    \"right\",\r\n    \"right\",\r\n    \"top\",\r\n    \"top\",\r\n    \"top\",\r\n    \"top\",\r\n    \"left\",\r\n    \"bottom\",\r\n    \"right\",\r\n    \"right\",\r\n    \"left\",\r\n    \"bottom\",\r\n    \"left\",\r\n    \"none\",\r\n  ];\r\n  var edge;\r\n\r\n  var currentCell = grid[j][i];\r\n\r\n  var cval = currentCell.cval;\r\n  var edge = startEdge[cval];\r\n\r\n  var pt = getXY(currentCell, edge);\r\n\r\n  /* push initial segment */\r\n  p.push([i + pt[0], j + pt[1]]);\r\n  edge = nextEdge[cval];\r\n  pt = getXY(currentCell, edge);\r\n  p.push([i + pt[0], j + pt[1]]);\r\n  clearCell(currentCell);\r\n\r\n  /* now walk arround the enclosed area in clockwise-direction */\r\n  var k = i + dxContour[cval];\r\n  var l = j + dyContour[cval];\r\n  var prev_cval = cval;\r\n\r\n  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {\r\n    currentCell = grid[l][k];\r\n    if (typeof currentCell === \"undefined\") {\r\n      /* path ends here */\r\n      //console.log(k + \" \" + l + \" is undefined, stopping path!\");\r\n      break;\r\n    }\r\n    cval = currentCell.cval;\r\n    if (cval === 0 || cval === 15) {\r\n      return { path: p, info: \"mergeable\" };\r\n    }\r\n    edge = nextEdge[cval];\r\n    dx = dxContour[cval];\r\n    dy = dyContour[cval];\r\n    if (cval === 5 || cval === 10) {\r\n      /* select upper or lower band, depending on previous cells cval */\r\n      if (cval === 5) {\r\n        if (currentCell.flipped) {\r\n          /* this is actually a flipped case 10 */\r\n          if (dyContour[prev_cval] === -1) {\r\n            edge = \"left\";\r\n            dx = -1;\r\n            dy = 0;\r\n          } else {\r\n            edge = \"right\";\r\n            dx = 1;\r\n            dy = 0;\r\n          }\r\n        } else {\r\n          /* real case 5 */\r\n          if (dxContour[prev_cval] === -1) {\r\n            edge = \"bottom\";\r\n            dx = 0;\r\n            dy = -1;\r\n          }\r\n        }\r\n      } else if (cval === 10) {\r\n        if (currentCell.flipped) {\r\n          /* this is actually a flipped case 5 */\r\n          if (dxContour[prev_cval] === -1) {\r\n            edge = \"top\";\r\n            dx = 0;\r\n            dy = 1;\r\n          } else {\r\n            edge = \"bottom\";\r\n            dx = 0;\r\n            dy = -1;\r\n          }\r\n        } else {\r\n          /* real case 10 */\r\n          if (dyContour[prev_cval] === 1) {\r\n            edge = \"left\";\r\n            dx = -1;\r\n            dy = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    pt = getXY(currentCell, edge);\r\n    p.push([k + pt[0], l + pt[1]]);\r\n    clearCell(currentCell);\r\n    k += dx;\r\n    l += dy;\r\n    prev_cval = cval;\r\n  }\r\n\r\n  return { path: p, info: \"closed\" };\r\n}\r\n\r\n/**\r\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\r\n * of the 'property' values\r\n *\r\n * @name gridToMatrix\r\n * @param {FeatureCollection<Point>} grid of points\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\r\n * @param {boolean} [options.flip=false] returns the matrix upside-down\r\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\r\n * the grid points with coordinates on the matrix\r\n * @returns {Array<Array<number>>} matrix of property values\r\n * @example\r\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\r\n *   var cellSize = 3;\r\n *   var grid = turf.pointGrid(extent, cellSize);\r\n *   // add a random property to each point between 0 and 60\r\n *   for (var i = 0; i < grid.features.length; i++) {\r\n *     grid.features[i].properties.elevation = (Math.random() * 60);\r\n *   }\r\n *   gridToMatrix(grid);\r\n *   //= [\r\n *     [ 1, 13, 10,  9, 10, 13, 18],\r\n *     [34,  8,  5,  4,  5,  8, 13],\r\n *     [10,  5,  2,  1,  2,  5,  4],\r\n *     [ 0,  4, 56, 19,  1,  4,  9],\r\n *     [10,  5,  2,  1,  2,  5, 10],\r\n *     [57,  8,  5,  4,  5,  0, 57],\r\n *     [ 3, 13, 10,  9,  5, 13, 18],\r\n *     [18, 13, 10,  9, 78, 13, 18]\r\n *   ]\r\n */\r\nfunction gridToMatrix(grid, options) {\r\n  // Optional parameters\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var zProperty = options.zProperty || \"elevation\";\r\n  var flip = options.flip;\r\n  var flags = options.flags;\r\n\r\n  // validation\r\n  collectionOf(grid, \"Point\", \"input must contain Points\");\r\n\r\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\r\n\r\n  var matrix = [];\r\n  // create property matrix from sorted points\r\n  // looping order matters here\r\n  for (var r = 0; r < pointsMatrix.length; r++) {\r\n    var pointRow = pointsMatrix[r];\r\n    var row = [];\r\n    for (var c = 0; c < pointRow.length; c++) {\r\n      var point = pointRow[c];\r\n      // Check if zProperty exist\r\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\r\n      else row.push(0);\r\n      // add flags\r\n      if (flags === true) point.properties.matrixPosition = [r, c];\r\n    }\r\n    matrix.push(row);\r\n  }\r\n\r\n  return matrix;\r\n}\r\n\r\n/**\r\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\r\n *\r\n * @private\r\n * @param {FeatureCollection<Point>} points GeoJSON Point features\r\n * @param {boolean} [flip=false] returns the matrix upside-down\r\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\r\n */\r\nfunction sortPointsByLatLng(points, flip) {\r\n  var pointsByLatitude = {};\r\n\r\n  // divide points by rows with the same latitude\r\n  featureEach(points, function (point) {\r\n    var lat = getCoords(point)[1];\r\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\r\n    pointsByLatitude[lat].push(point);\r\n  });\r\n\r\n  // sort points (with the same latitude) by longitude\r\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\r\n    var row = pointsByLatitude[lat];\r\n    var rowOrderedByLongitude = row.sort(function (a, b) {\r\n      return getCoords(a)[0] - getCoords(b)[0];\r\n    });\r\n    return rowOrderedByLongitude;\r\n  });\r\n\r\n  // sort rows (of points with the same latitude) by latitude\r\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\r\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];\r\n    else return getCoords(b[0])[1] - getCoords(a[0])[1];\r\n  });\r\n\r\n  return pointMatrix;\r\n}\r\n\r\n/**\r\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\r\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\r\n *\r\n * @name isolines\r\n * @param {FeatureCollection<Point>} pointGrid input points\r\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\r\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\r\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\r\n * the breaks array will define the order in which the isolines are created\r\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\r\n * @example\r\n * // create a grid of points with random z-values in their properties\r\n * var extent = [0, 30, 20, 50];\r\n * var cellWidth = 100;\r\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\r\n *\r\n * for (var i = 0; i < pointGrid.features.length; i++) {\r\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\r\n * }\r\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n *\r\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\r\n *\r\n * //addToMap\r\n * var addToMap = [lines];\r\n */\r\nfunction isolines(pointGrid, breaks, options) {\r\n  // Optional parameters\r\n  options = options || {};\r\n  if (!isObject(options)) throw new Error(\"options is invalid\");\r\n  var zProperty = options.zProperty || \"elevation\";\r\n  var commonProperties = options.commonProperties || {};\r\n  var breaksProperties = options.breaksProperties || [];\r\n\r\n  // Input validation\r\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\r\n  if (!breaks) throw new Error(\"breaks is required\");\r\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\r\n  if (!isObject(commonProperties))\r\n    throw new Error(\"commonProperties must be an Object\");\r\n  if (!Array.isArray(breaksProperties))\r\n    throw new Error(\"breaksProperties must be an Array\");\r\n\r\n  // Isoline methods\r\n  var matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\r\n  var createdIsoLines = createIsoLines(\r\n    matrix,\r\n    breaks,\r\n    zProperty,\r\n    commonProperties,\r\n    breaksProperties\r\n  );\r\n  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\r\n\r\n  return featureCollection(scaledIsolines);\r\n}\r\n\r\n/**\r\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\r\n *\r\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\r\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\r\n * rescaled, with turfjs, to the original area and proportions on the map\r\n *\r\n * @private\r\n * @param {Array<Array<number>>} matrix Grid Data\r\n * @param {Array<number>} breaks Breaks\r\n * @param {string} zProperty name of the z-values property\r\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\r\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\r\n * @returns {Array<MultiLineString>} isolines\r\n */\r\nfunction createIsoLines(\r\n  matrix,\r\n  breaks,\r\n  zProperty,\r\n  commonProperties,\r\n  breaksProperties\r\n) {\r\n  var results = [];\r\n  for (var i = 1; i < breaks.length; i++) {\r\n    var threshold = +breaks[i]; // make sure it's a number\r\n\r\n    var properties = objectAssign({}, commonProperties, breaksProperties[i]);\r\n    properties[zProperty] = threshold;\r\n    var isoline = multiLineString(isoContours(matrix, threshold), properties);\r\n\r\n    results.push(isoline);\r\n  }\r\n  return results;\r\n}\r\n\r\n/**\r\n * Translates and scales isolines\r\n *\r\n * @private\r\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\r\n * @param {Array<Array<number>>} matrix Grid Data\r\n * @param {Object} points Points by Latitude\r\n * @returns {Array<MultiLineString>} isolines\r\n */\r\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\r\n  // get dimensions (on the map) of the original grid\r\n  var gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\r\n  var originalWidth = gridBbox[2] - gridBbox[0];\r\n  var originalHeigth = gridBbox[3] - gridBbox[1];\r\n\r\n  // get origin, which is the first point of the last row on the rectangular data on the map\r\n  var x0 = gridBbox[0];\r\n  var y0 = gridBbox[1];\r\n\r\n  // get number of cells per side\r\n  var matrixWidth = matrix[0].length - 1;\r\n  var matrixHeight = matrix.length - 1;\r\n\r\n  // calculate the scaling factor between matrix and rectangular grid on the map\r\n  var scaleX = originalWidth / matrixWidth;\r\n  var scaleY = originalHeigth / matrixHeight;\r\n\r\n  var resize = function (point) {\r\n    point[0] = point[0] * scaleX + x0;\r\n    point[1] = point[1] * scaleY + y0;\r\n  };\r\n\r\n  // resize and shift each point/line of the createdIsoLines\r\n  createdIsoLines.forEach(function (isoline) {\r\n    coordEach(isoline, resize);\r\n  });\r\n  return createdIsoLines;\r\n}\r\n\r\nexport default isolines;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}