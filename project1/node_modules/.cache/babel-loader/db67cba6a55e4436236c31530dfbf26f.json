{"ast":null,"code":"'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n  if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n  this._maxEntries = Math.max(4, maxEntries || 9);\n  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n  if (format) {\n    this._initFormat(format);\n  }\n\n  this.clear();\n}\n\nrbush.prototype = {\n  all: function all() {\n    return this._all(this.data, []);\n  },\n  search: function search(bbox) {\n    var node = this.data,\n        result = [],\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return result;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  collides: function collides(bbox) {\n    var node = this.data,\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return false;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) return true;\n          nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return false;\n  },\n  load: function load(data) {\n    if (!(data && data.length)) return this;\n\n    if (data.length < this._minEntries) {\n      for (var i = 0, len = data.length; i < len; i++) {\n        this.insert(data[i]);\n      }\n\n      return this;\n    } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      } // insert the small tree into the large tree at appropriate level\n\n\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n  },\n  insert: function insert(item) {\n    if (item) this._insert(item, this.data.height - 1);\n    return this;\n  },\n  clear: function clear() {\n    this.data = createNode([]);\n    return this;\n  },\n  remove: function remove(item, equalsFn) {\n    if (!item) return this;\n    var node = this.data,\n        bbox = this.toBBox(item),\n        path = [],\n        indexes = [],\n        i,\n        parent,\n        index,\n        goingUp; // depth-first iterative tree traversal\n\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n\n      if (node.leaf) {\n        // check current node\n        index = findItem(item, node.children, equalsFn);\n\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n\n          this._condense(path);\n\n          return this;\n        }\n      }\n\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else node = null; // nothing found\n\n    }\n\n    return this;\n  },\n  toBBox: function toBBox(item) {\n    return item;\n  },\n  compareMinX: compareNodeMinX,\n  compareMinY: compareNodeMinY,\n  toJSON: function toJSON() {\n    return this.data;\n  },\n  fromJSON: function fromJSON(data) {\n    this.data = data;\n    return this;\n  },\n  _all: function _all(node, result) {\n    var nodesToSearch = [];\n\n    while (node) {\n      if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  _build: function _build(items, left, right, height) {\n    var N = right - left + 1,\n        M = this._maxEntries,\n        node;\n\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height; // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M),\n        N1 = N2 * Math.ceil(Math.sqrt(M)),\n        i,\n        j,\n        right2,\n        right3;\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (i = left; i <= right; i += N1) {\n      right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n\n      for (j = i; j <= right2; j += N2) {\n        right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n\n    calcBBox(node, this.toBBox);\n    return node;\n  },\n  _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) break;\n      minArea = minEnlargement = Infinity;\n\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        area = bboxArea(child);\n        enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n\n      node = targetNode || node.children[0];\n    }\n\n    return node;\n  },\n  _insert: function _insert(item, level, isNode) {\n    var toBBox = this.toBBox,\n        bbox = isNode ? item : toBBox(item),\n        insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n    node.children.push(item);\n    extend(node, bbox); // split on node overflow; propagate upwards if necessary\n\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n\n        level--;\n      } else break;\n    } // adjust bboxes along the insertion path\n\n\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  },\n  // split overflowed node into two\n  _split: function _split(insertPath, level) {\n    var node = insertPath[level],\n        M = node.children.length,\n        m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n  },\n  _splitRoot: function _splitRoot(node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  },\n  _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n    minOverlap = minArea = Infinity;\n\n    for (i = m; i <= M - m; i++) {\n      bbox1 = distBBox(node, 0, i, this.toBBox);\n      bbox2 = distBBox(node, i, M, this.toBBox);\n      overlap = intersectionArea(bbox1, bbox2);\n      area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n\n    return index;\n  },\n  // sorts node children by the best axis for split\n  _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n        xMargin = this._allDistMargin(node, m, M, compareMinX),\n        yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n\n\n    if (xMargin < yMargin) node.children.sort(compareMinX);\n  },\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin: function _allDistMargin(node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox,\n        leftBBox = distBBox(node, 0, m, toBBox),\n        rightBBox = distBBox(node, M - m, M, toBBox),\n        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n        i,\n        child;\n\n    for (i = m; i < M - m; i++) {\n      child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n\n    for (i = M - m - 1; i >= m; i--) {\n      child = node.children[i];\n      extend(rightBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n  },\n  _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  },\n  _condense: function _condense(path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else this.clear();\n      } else calcBBox(path[i], this.toBBox);\n    }\n  },\n  _initFormat: function _initFormat(format) {\n    // data format (minX, minY, maxX, maxY accessors)\n    // uses eval-type function compilation instead of just accepting a toBBox function\n    // because the algorithms are very sensitive to sorting functions performance,\n    // so they should be dead simple and without inner calls\n    var compareArr = ['return a', ' - b', ';'];\n    this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n    this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n    this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n  }\n};\n\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) return items.indexOf(item);\n\n  for (var i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) return i;\n  }\n\n  return -1;\n} // calculate node's bbox from bboxes of its children\n\n\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n} // min bounding rectangle of node children from k to p-1\n\n\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n\n  for (var i = k, child; i < p; i++) {\n    child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n\n  return destNode;\n}\n\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\n\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\n\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\n\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\n\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n  var minX = Math.max(a.minX, b.minX),\n      minY = Math.max(a.minY, b.minY),\n      maxX = Math.min(a.maxX, b.maxX),\n      maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n  return {\n    children: children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n} // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\n\nfunction multiSelect(arr, left, right, n, compare) {\n  var stack = [left, right],\n      mid;\n\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n) continue;\n    mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}","map":{"version":3,"names":["module","exports","rbush","default","quickselect","require","maxEntries","format","_maxEntries","Math","max","_minEntries","ceil","_initFormat","clear","prototype","all","_all","data","search","bbox","node","result","toBBox","intersects","nodesToSearch","i","len","child","childBBox","children","length","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","index","goingUp","findItem","splice","_condense","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","toJSON","fromJSON","apply","items","left","right","N","M","calcBBox","log","pow","N2","N1","sqrt","j","right2","right3","multiSelect","min","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","Infinity","bboxArea","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","distBBox","intersectionArea","xMargin","_allDistMargin","yMargin","sort","compare","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","compareArr","Function","join","k","p","destNode","minX","minY","maxX","maxY","a","b","arr","n","stack","mid"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/rbush/index.js"],"sourcesContent":["'use strict';\r\n\r\nmodule.exports = rbush;\r\nmodule.exports.default = rbush;\r\n\r\nvar quickselect = require('quickselect');\r\n\r\nfunction rbush(maxEntries, format) {\r\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\r\n\r\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\r\n    this._maxEntries = Math.max(4, maxEntries || 9);\r\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\r\n\r\n    if (format) {\r\n        this._initFormat(format);\r\n    }\r\n\r\n    this.clear();\r\n}\r\n\r\nrbush.prototype = {\r\n\r\n    all: function () {\r\n        return this._all(this.data, []);\r\n    },\r\n\r\n    search: function (bbox) {\r\n\r\n        var node = this.data,\r\n            result = [],\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return result;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf) result.push(child);\r\n                    else if (contains(bbox, childBBox)) this._all(child, result);\r\n                    else nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    collides: function (bbox) {\r\n\r\n        var node = this.data,\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return false;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf || contains(bbox, childBBox)) return true;\r\n                    nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    load: function (data) {\r\n        if (!(data && data.length)) return this;\r\n\r\n        if (data.length < this._minEntries) {\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                this.insert(data[i]);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // recursively build the tree with the given data from scratch using OMT algorithm\r\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\r\n\r\n        if (!this.data.children.length) {\r\n            // save as is if tree is empty\r\n            this.data = node;\r\n\r\n        } else if (this.data.height === node.height) {\r\n            // split root if trees have the same height\r\n            this._splitRoot(this.data, node);\r\n\r\n        } else {\r\n            if (this.data.height < node.height) {\r\n                // swap trees if inserted one is bigger\r\n                var tmpNode = this.data;\r\n                this.data = node;\r\n                node = tmpNode;\r\n            }\r\n\r\n            // insert the small tree into the large tree at appropriate level\r\n            this._insert(node, this.data.height - node.height - 1, true);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    insert: function (item) {\r\n        if (item) this._insert(item, this.data.height - 1);\r\n        return this;\r\n    },\r\n\r\n    clear: function () {\r\n        this.data = createNode([]);\r\n        return this;\r\n    },\r\n\r\n    remove: function (item, equalsFn) {\r\n        if (!item) return this;\r\n\r\n        var node = this.data,\r\n            bbox = this.toBBox(item),\r\n            path = [],\r\n            indexes = [],\r\n            i, parent, index, goingUp;\r\n\r\n        // depth-first iterative tree traversal\r\n        while (node || path.length) {\r\n\r\n            if (!node) { // go up\r\n                node = path.pop();\r\n                parent = path[path.length - 1];\r\n                i = indexes.pop();\r\n                goingUp = true;\r\n            }\r\n\r\n            if (node.leaf) { // check current node\r\n                index = findItem(item, node.children, equalsFn);\r\n\r\n                if (index !== -1) {\r\n                    // item found, remove the item and condense tree upwards\r\n                    node.children.splice(index, 1);\r\n                    path.push(node);\r\n                    this._condense(path);\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\r\n                path.push(node);\r\n                indexes.push(i);\r\n                i = 0;\r\n                parent = node;\r\n                node = node.children[0];\r\n\r\n            } else if (parent) { // go right\r\n                i++;\r\n                node = parent.children[i];\r\n                goingUp = false;\r\n\r\n            } else node = null; // nothing found\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    toBBox: function (item) { return item; },\r\n\r\n    compareMinX: compareNodeMinX,\r\n    compareMinY: compareNodeMinY,\r\n\r\n    toJSON: function () { return this.data; },\r\n\r\n    fromJSON: function (data) {\r\n        this.data = data;\r\n        return this;\r\n    },\r\n\r\n    _all: function (node, result) {\r\n        var nodesToSearch = [];\r\n        while (node) {\r\n            if (node.leaf) result.push.apply(result, node.children);\r\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\r\n\r\n            node = nodesToSearch.pop();\r\n        }\r\n        return result;\r\n    },\r\n\r\n    _build: function (items, left, right, height) {\r\n\r\n        var N = right - left + 1,\r\n            M = this._maxEntries,\r\n            node;\r\n\r\n        if (N <= M) {\r\n            // reached leaf level; return leaf\r\n            node = createNode(items.slice(left, right + 1));\r\n            calcBBox(node, this.toBBox);\r\n            return node;\r\n        }\r\n\r\n        if (!height) {\r\n            // target height of the bulk-loaded tree\r\n            height = Math.ceil(Math.log(N) / Math.log(M));\r\n\r\n            // target number of root entries to maximize storage utilization\r\n            M = Math.ceil(N / Math.pow(M, height - 1));\r\n        }\r\n\r\n        node = createNode([]);\r\n        node.leaf = false;\r\n        node.height = height;\r\n\r\n        // split the items into M mostly square tiles\r\n\r\n        var N2 = Math.ceil(N / M),\r\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\r\n            i, j, right2, right3;\r\n\r\n        multiSelect(items, left, right, N1, this.compareMinX);\r\n\r\n        for (i = left; i <= right; i += N1) {\r\n\r\n            right2 = Math.min(i + N1 - 1, right);\r\n\r\n            multiSelect(items, i, right2, N2, this.compareMinY);\r\n\r\n            for (j = i; j <= right2; j += N2) {\r\n\r\n                right3 = Math.min(j + N2 - 1, right2);\r\n\r\n                // pack each entry recursively\r\n                node.children.push(this._build(items, j, right3, height - 1));\r\n            }\r\n        }\r\n\r\n        calcBBox(node, this.toBBox);\r\n\r\n        return node;\r\n    },\r\n\r\n    _chooseSubtree: function (bbox, node, level, path) {\r\n\r\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\r\n\r\n        while (true) {\r\n            path.push(node);\r\n\r\n            if (node.leaf || path.length - 1 === level) break;\r\n\r\n            minArea = minEnlargement = Infinity;\r\n\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n                child = node.children[i];\r\n                area = bboxArea(child);\r\n                enlargement = enlargedArea(bbox, child) - area;\r\n\r\n                // choose entry with the least area enlargement\r\n                if (enlargement < minEnlargement) {\r\n                    minEnlargement = enlargement;\r\n                    minArea = area < minArea ? area : minArea;\r\n                    targetNode = child;\r\n\r\n                } else if (enlargement === minEnlargement) {\r\n                    // otherwise choose one with the smallest area\r\n                    if (area < minArea) {\r\n                        minArea = area;\r\n                        targetNode = child;\r\n                    }\r\n                }\r\n            }\r\n\r\n            node = targetNode || node.children[0];\r\n        }\r\n\r\n        return node;\r\n    },\r\n\r\n    _insert: function (item, level, isNode) {\r\n\r\n        var toBBox = this.toBBox,\r\n            bbox = isNode ? item : toBBox(item),\r\n            insertPath = [];\r\n\r\n        // find the best node for accommodating the item, saving all nodes along the path too\r\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\r\n\r\n        // put the item into the node\r\n        node.children.push(item);\r\n        extend(node, bbox);\r\n\r\n        // split on node overflow; propagate upwards if necessary\r\n        while (level >= 0) {\r\n            if (insertPath[level].children.length > this._maxEntries) {\r\n                this._split(insertPath, level);\r\n                level--;\r\n            } else break;\r\n        }\r\n\r\n        // adjust bboxes along the insertion path\r\n        this._adjustParentBBoxes(bbox, insertPath, level);\r\n    },\r\n\r\n    // split overflowed node into two\r\n    _split: function (insertPath, level) {\r\n\r\n        var node = insertPath[level],\r\n            M = node.children.length,\r\n            m = this._minEntries;\r\n\r\n        this._chooseSplitAxis(node, m, M);\r\n\r\n        var splitIndex = this._chooseSplitIndex(node, m, M);\r\n\r\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\r\n        newNode.height = node.height;\r\n        newNode.leaf = node.leaf;\r\n\r\n        calcBBox(node, this.toBBox);\r\n        calcBBox(newNode, this.toBBox);\r\n\r\n        if (level) insertPath[level - 1].children.push(newNode);\r\n        else this._splitRoot(node, newNode);\r\n    },\r\n\r\n    _splitRoot: function (node, newNode) {\r\n        // split root node\r\n        this.data = createNode([node, newNode]);\r\n        this.data.height = node.height + 1;\r\n        this.data.leaf = false;\r\n        calcBBox(this.data, this.toBBox);\r\n    },\r\n\r\n    _chooseSplitIndex: function (node, m, M) {\r\n\r\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\r\n\r\n        minOverlap = minArea = Infinity;\r\n\r\n        for (i = m; i <= M - m; i++) {\r\n            bbox1 = distBBox(node, 0, i, this.toBBox);\r\n            bbox2 = distBBox(node, i, M, this.toBBox);\r\n\r\n            overlap = intersectionArea(bbox1, bbox2);\r\n            area = bboxArea(bbox1) + bboxArea(bbox2);\r\n\r\n            // choose distribution with minimum overlap\r\n            if (overlap < minOverlap) {\r\n                minOverlap = overlap;\r\n                index = i;\r\n\r\n                minArea = area < minArea ? area : minArea;\r\n\r\n            } else if (overlap === minOverlap) {\r\n                // otherwise choose distribution with minimum area\r\n                if (area < minArea) {\r\n                    minArea = area;\r\n                    index = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        return index;\r\n    },\r\n\r\n    // sorts node children by the best axis for split\r\n    _chooseSplitAxis: function (node, m, M) {\r\n\r\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\r\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\r\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\r\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\r\n\r\n        // if total distributions margin value is minimal for x, sort by minX,\r\n        // otherwise it's already sorted by minY\r\n        if (xMargin < yMargin) node.children.sort(compareMinX);\r\n    },\r\n\r\n    // total margin of all possible split distributions where each node is at least m full\r\n    _allDistMargin: function (node, m, M, compare) {\r\n\r\n        node.children.sort(compare);\r\n\r\n        var toBBox = this.toBBox,\r\n            leftBBox = distBBox(node, 0, m, toBBox),\r\n            rightBBox = distBBox(node, M - m, M, toBBox),\r\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\r\n            i, child;\r\n\r\n        for (i = m; i < M - m; i++) {\r\n            child = node.children[i];\r\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(leftBBox);\r\n        }\r\n\r\n        for (i = M - m - 1; i >= m; i--) {\r\n            child = node.children[i];\r\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(rightBBox);\r\n        }\r\n\r\n        return margin;\r\n    },\r\n\r\n    _adjustParentBBoxes: function (bbox, path, level) {\r\n        // adjust bboxes along the given tree path\r\n        for (var i = level; i >= 0; i--) {\r\n            extend(path[i], bbox);\r\n        }\r\n    },\r\n\r\n    _condense: function (path) {\r\n        // go through the path, removing empty nodes and updating bboxes\r\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\r\n            if (path[i].children.length === 0) {\r\n                if (i > 0) {\r\n                    siblings = path[i - 1].children;\r\n                    siblings.splice(siblings.indexOf(path[i]), 1);\r\n\r\n                } else this.clear();\r\n\r\n            } else calcBBox(path[i], this.toBBox);\r\n        }\r\n    },\r\n\r\n    _initFormat: function (format) {\r\n        // data format (minX, minY, maxX, maxY accessors)\r\n\r\n        // uses eval-type function compilation instead of just accepting a toBBox function\r\n        // because the algorithms are very sensitive to sorting functions performance,\r\n        // so they should be dead simple and without inner calls\r\n\r\n        var compareArr = ['return a', ' - b', ';'];\r\n\r\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\r\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\r\n\r\n        this.toBBox = new Function('a',\r\n            'return {minX: a' + format[0] +\r\n            ', minY: a' + format[1] +\r\n            ', maxX: a' + format[2] +\r\n            ', maxY: a' + format[3] + '};');\r\n    }\r\n};\r\n\r\nfunction findItem(item, items, equalsFn) {\r\n    if (!equalsFn) return items.indexOf(item);\r\n\r\n    for (var i = 0; i < items.length; i++) {\r\n        if (equalsFn(item, items[i])) return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n// calculate node's bbox from bboxes of its children\r\nfunction calcBBox(node, toBBox) {\r\n    distBBox(node, 0, node.children.length, toBBox, node);\r\n}\r\n\r\n// min bounding rectangle of node children from k to p-1\r\nfunction distBBox(node, k, p, toBBox, destNode) {\r\n    if (!destNode) destNode = createNode(null);\r\n    destNode.minX = Infinity;\r\n    destNode.minY = Infinity;\r\n    destNode.maxX = -Infinity;\r\n    destNode.maxY = -Infinity;\r\n\r\n    for (var i = k, child; i < p; i++) {\r\n        child = node.children[i];\r\n        extend(destNode, node.leaf ? toBBox(child) : child);\r\n    }\r\n\r\n    return destNode;\r\n}\r\n\r\nfunction extend(a, b) {\r\n    a.minX = Math.min(a.minX, b.minX);\r\n    a.minY = Math.min(a.minY, b.minY);\r\n    a.maxX = Math.max(a.maxX, b.maxX);\r\n    a.maxY = Math.max(a.maxY, b.maxY);\r\n    return a;\r\n}\r\n\r\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\r\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\r\n\r\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\r\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\r\n\r\nfunction enlargedArea(a, b) {\r\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\r\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\r\n}\r\n\r\nfunction intersectionArea(a, b) {\r\n    var minX = Math.max(a.minX, b.minX),\r\n        minY = Math.max(a.minY, b.minY),\r\n        maxX = Math.min(a.maxX, b.maxX),\r\n        maxY = Math.min(a.maxY, b.maxY);\r\n\r\n    return Math.max(0, maxX - minX) *\r\n           Math.max(0, maxY - minY);\r\n}\r\n\r\nfunction contains(a, b) {\r\n    return a.minX <= b.minX &&\r\n           a.minY <= b.minY &&\r\n           b.maxX <= a.maxX &&\r\n           b.maxY <= a.maxY;\r\n}\r\n\r\nfunction intersects(a, b) {\r\n    return b.minX <= a.maxX &&\r\n           b.minY <= a.maxY &&\r\n           b.maxX >= a.minX &&\r\n           b.maxY >= a.minY;\r\n}\r\n\r\nfunction createNode(children) {\r\n    return {\r\n        children: children,\r\n        height: 1,\r\n        leaf: true,\r\n        minX: Infinity,\r\n        minY: Infinity,\r\n        maxX: -Infinity,\r\n        maxY: -Infinity\r\n    };\r\n}\r\n\r\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\r\n// combines selection algorithm with binary divide & conquer approach\r\n\r\nfunction multiSelect(arr, left, right, n, compare) {\r\n    var stack = [left, right],\r\n        mid;\r\n\r\n    while (stack.length) {\r\n        right = stack.pop();\r\n        left = stack.pop();\r\n\r\n        if (right - left <= n) continue;\r\n\r\n        mid = left + Math.ceil((right - left) / n / 2) * n;\r\n        quickselect(arr, mid, left, right, compare);\r\n\r\n        stack.push(left, mid, mid, right);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}