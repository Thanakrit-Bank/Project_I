{"ast":null,"code":"import { flattenEach, featureEach } from '@turf/meta';\nimport { polygon, featureCollection } from '@turf/helpers';\nimport rbush from 'rbush';\nimport area from '@turf/area';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon'; // Find self-intersections in geojson polygon (possibly with interior rings)\n\nfunction isects(feature, filterFn, useSpatialIndex) {\n  if (feature.geometry.type !== \"Polygon\") throw new Error(\"The input feature must be a Polygon\");\n  if (useSpatialIndex === undefined) useSpatialIndex = 1;\n  var coord = feature.geometry.coordinates;\n  var output = [];\n  var seen = {};\n\n  if (useSpatialIndex) {\n    var allEdgesAsRbushTreeItems = [];\n\n    for (var ring0 = 0; ring0 < coord.length; ring0++) {\n      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));\n      }\n    }\n\n    var tree = rbush();\n    tree.load(allEdgesAsRbushTreeItems);\n  }\n\n  for (var ringA = 0; ringA < coord.length; ringA++) {\n    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {\n      if (useSpatialIndex) {\n        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));\n        bboxOverlaps.forEach(function (bboxIsect) {\n          var ring1 = bboxIsect.ring;\n          var edge1 = bboxIsect.edge;\n          ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n        });\n      } else {\n        for (var ring1 = 0; ring1 < coord.length; ring1++) {\n          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n            // TODO: speedup possible if only interested in unique: start last two loops at ringA and edgeA+1\n            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n          }\n        }\n      }\n    }\n  }\n\n  if (!filterFn) output = {\n    type: \"Feature\",\n    geometry: {\n      type: \"MultiPoint\",\n      coordinates: output\n    }\n  };\n  return output; // Function to check if two edges intersect and add the intersection to the output\n\n  function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {\n    var start0 = coord[ring0][edge0];\n    var end0 = coord[ring0][edge0 + 1];\n    var start1 = coord[ring1][edge1];\n    var end1 = coord[ring1][edge1 + 1];\n    var isect = intersect(start0, end0, start1, end1);\n    if (isect === null) return; // discard parallels and coincidence\n\n    var frac0;\n    var frac1;\n\n    if (end0[0] !== start0[0]) {\n      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);\n    } else {\n      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);\n    }\n\n    if (end1[0] !== start1[0]) {\n      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);\n    } else {\n      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);\n    }\n\n    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection\n\n    var key = isect;\n    var unique = !seen[key];\n\n    if (unique) {\n      seen[key] = true;\n    }\n\n    if (filterFn) {\n      output.push(filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique));\n    } else {\n      output.push(isect);\n    }\n  } // Function to return a rbush tree item given an ring and edge number\n\n\n  function rbushTreeItem(ring, edge) {\n    var start = coord[ring][edge];\n    var end = coord[ring][edge + 1];\n    var minX;\n    var maxX;\n    var minY;\n    var maxY;\n\n    if (start[0] < end[0]) {\n      minX = start[0];\n      maxX = end[0];\n    } else {\n      minX = end[0];\n      maxX = start[0];\n    }\n\n    if (start[1] < end[1]) {\n      minY = start[1];\n      maxY = end[1];\n    } else {\n      minY = end[1];\n      maxY = start[1];\n    }\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      ring: ring,\n      edge: edge\n    };\n  }\n} // Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n\n\nfunction intersect(start0, end0, start1, end1) {\n  if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1)) return null;\n  var x0 = start0[0],\n      y0 = start0[1],\n      x1 = end0[0],\n      y1 = end0[1],\n      x2 = start1[0],\n      y2 = start1[1],\n      x3 = end1[0],\n      y3 = end1[1];\n  var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n  if (denom === 0) return null;\n  var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n  var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n  return [x4, y4];\n} // Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\n\n\nfunction equalArrays(array1, array2) {\n  // if the other array is a falsy value, return\n  if (!array1 || !array2) return false; // compare lengths - can save a lot of time\n\n  if (array1.length !== array2.length) return false;\n\n  for (var i = 0, l = array1.length; i < l; i++) {\n    // Check if we have nested arrays\n    if (array1[i] instanceof Array && array2[i] instanceof Array) {\n      // recurse into the nested arrays\n      if (!equalArrays(array1[i], array2[i])) return false;\n    } else if (array1[i] !== array2[i]) {\n      // Warning - two different object instances will never be equal: {x:20} !== {x:20}\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.\r\n *\r\n * @module simplepolygon\r\n * @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.\r\n * @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.\r\n *\r\n * @example\r\n * var poly = {\r\n *   \"type\": \"Feature\",\r\n *   \"geometry\": {\r\n *     \"type\": \"Polygon\",\r\n *     \"coordinates\": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]\r\n *   }\r\n * };\r\n *\r\n * var result = simplepolygon(poly);\r\n *\r\n * // =result\r\n * // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1\r\n */\n\n\nfunction simplepolygon(feature) {\n  // Check input\n  if (feature.type != \"Feature\") throw new Error(\"The input must a geojson object of type Feature\");\n  if (feature.geometry === undefined || feature.geometry == null) throw new Error(\"The input must a geojson object with a non-empty geometry\");\n  if (feature.geometry.type != \"Polygon\") throw new Error(\"The input must be a geojson Polygon\"); // Process input\n\n  var numRings = feature.geometry.coordinates.length;\n  var vertices = [];\n\n  for (var i = 0; i < numRings; i++) {\n    var ring = feature.geometry.coordinates[i];\n\n    if (!equalArrays$1(ring[0], ring[ring.length - 1])) {\n      ring.push(ring[0]); // Close input ring if it is not\n    }\n\n    vertices.push.apply(vertices, ring.slice(0, ring.length - 1));\n  }\n\n  if (!isUnique(vertices)) throw new Error(\"The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)\");\n  var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted\n  // Compute self-intersections\n\n  var selfIsectsData = isects(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {\n    return [isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique];\n  });\n  var numSelfIsect = selfIsectsData.length; // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.\n\n  if (numSelfIsect == 0) {\n    var outputFeatureArray = [];\n\n    for (var i = 0; i < numRings; i++) {\n      outputFeatureArray.push(polygon([feature.geometry.coordinates[i]], {\n        parent: -1,\n        winding: windingOfRing(feature.geometry.coordinates[i])\n      }));\n    }\n\n    var output = featureCollection(outputFeatureArray);\n    determineParents();\n    setNetWinding();\n    return output;\n  } // If self-intersections are found, we will compute the output rings with the help of two intermediate variables\n  // First, we build the pseudo vertex list and intersection list\n  // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.\n\n\n  var pseudoVtxListByRingAndEdge = []; // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.\n\n  var isectList = []; // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList\n\n  for (var i = 0; i < numRings; i++) {\n    pseudoVtxListByRingAndEdge.push([]);\n\n    for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {\n      // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.\n      pseudoVtxListByRingAndEdge[i].push([new PseudoVtx(feature.geometry.coordinates[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)], 1, [i, j], [i, modulo(j + 1, feature.geometry.coordinates[i].length - 1)], undefined)]); // The first numvertices elements in isectList correspond to the ring-vertex-intersections\n\n      isectList.push(new Isect(feature.geometry.coordinates[i][j], [i, modulo(j - 1, feature.geometry.coordinates[i].length - 1)], [i, j], undefined, undefined, false, true));\n    }\n  } // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList\n\n\n  for (var i = 0; i < numSelfIsect; i++) {\n    // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge\n    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined)); // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList\n\n    if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined, undefined, true, true));\n  }\n\n  var numIsect = isectList.length; // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'\n\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n      pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {\n        return a.param < b.param ? -1 : 1;\n      });\n    }\n  } // Make a spatial index of intersections, in preperation for the following two steps\n\n\n  var allIsectsAsIsectRbushTreeItem = [];\n\n  for (var i = 0; i < numIsect; i++) {\n    allIsectsAsIsectRbushTreeItem.push({\n      minX: isectList[i].coord[0],\n      minY: isectList[i].coord[1],\n      maxX: isectList[i].coord[0],\n      maxY: isectList[i].coord[1],\n      index: i\n    }); // could pass isect: isectList[i], but not necessary\n  }\n\n  var isectRbushTree = rbush();\n  isectRbushTree.load(allIsectsAsIsectRbushTreeItem); // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.\n  // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:\n  // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates\n\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n        var coordToFind;\n\n        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {\n          // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.\n          coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)][0].coord;\n        } else {\n          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;\n        }\n\n        var IsectRbushTreeItemFound = isectRbushTree.search({\n          minX: coordToFind[0],\n          minY: coordToFind[1],\n          maxX: coordToFind[0],\n          maxY: coordToFind[1]\n        })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\n\n        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;\n      }\n    }\n  } // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection\n\n\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;\n        var IsectRbushTreeItemFound = isectRbushTree.search({\n          minX: coordToFind[0],\n          minY: coordToFind[1],\n          maxX: coordToFind[0],\n          maxY: coordToFind[1]\n        })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\n\n        var l = IsectRbushTreeItemFound.index;\n\n        if (l < numvertices) {\n          // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.\n          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n        } else {\n          // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.\n          if (equalArrays$1(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {\n            isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n          } else {\n            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n          }\n        }\n      }\n    }\n  } // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!\n  // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.\n  // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).\n\n\n  var queue = []; // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.\n\n  var i = 0;\n\n  for (var j = 0; j < numRings; j++) {\n    var leftIsect = i;\n\n    for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {\n      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {\n        leftIsect = i;\n      }\n\n      i++;\n    } // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.\n    // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong\n\n\n    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;\n\n    for (var k = 0; k < isectList.length; k++) {\n      if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {\n        var isectBeforeLeftIsect = k;\n        break;\n      }\n    }\n\n    var windingAtIsect = isConvex([isectList[isectBeforeLeftIsect].coord, isectList[leftIsect].coord, isectList[isectAfterLeftIsect].coord], true) ? 1 : -1;\n    queue.push({\n      isect: leftIsect,\n      parent: -1,\n      winding: windingAtIsect\n    });\n  } // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.\n\n\n  queue.sort(function (a, b) {\n    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;\n  }); // Initialise output\n\n  var outputFeatureArray = []; // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.\n\n  while (queue.length > 0) {\n    // Get the last object out of the queue\n    var popped = queue.pop();\n    var startIsect = popped.isect;\n    var currentOutputRingParent = popped.parent;\n    var currentOutputRingWinding = popped.winding; // Make new output ring and add vertex from starting intersection\n\n    var currentOutputRing = outputFeatureArray.length;\n    var currentOutputRingCoords = [isectList[startIsect].coord]; // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'\n\n    var currentIsect = startIsect;\n\n    if (isectList[startIsect].ringAndEdge1Walkable) {\n      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;\n      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;\n    } else {\n      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;\n      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;\n    } // While we have not arrived back at the same intersection, keep walking\n\n\n    while (!equalArrays$1(isectList[startIsect].coord, isectList[nxtIsect].coord)) {\n      currentOutputRingCoords.push(isectList[nxtIsect].coord); // If the next intersection is queued, we can remove it, because we will go there now.\n\n      var nxtIsectInQueue = undefined;\n\n      for (var i = 0; i < queue.length; i++) {\n        if (queue[i].isect == nxtIsect) {\n          nxtIsectInQueue = i;\n          break;\n        }\n      }\n\n      if (nxtIsectInQueue != undefined) {\n        queue.splice(nxtIsectInQueue, 1);\n      } // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),\n      // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it\n      // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue\n      // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)\n      // We then update the other two walking variables.\n\n\n      if (equalArrays$1(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {\n        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;\n        isectList[nxtIsect].ringAndEdge2Walkable = false;\n\n        if (isectList[nxtIsect].ringAndEdge1Walkable) {\n          var pushing = {\n            isect: nxtIsect\n          };\n\n          if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord], currentOutputRingWinding == 1)) {\n            pushing.parent = currentOutputRingParent;\n            pushing.winding = -currentOutputRingWinding;\n          } else {\n            pushing.parent = currentOutputRing;\n            pushing.winding = currentOutputRingWinding;\n          }\n\n          queue.push(pushing);\n        }\n\n        currentIsect = nxtIsect;\n        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;\n      } else {\n        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;\n        isectList[nxtIsect].ringAndEdge1Walkable = false;\n\n        if (isectList[nxtIsect].ringAndEdge2Walkable) {\n          var pushing = {\n            isect: nxtIsect\n          };\n\n          if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord], currentOutputRingWinding == 1)) {\n            pushing.parent = currentOutputRingParent;\n            pushing.winding = -currentOutputRingWinding;\n          } else {\n            pushing.parent = currentOutputRing;\n            pushing.winding = currentOutputRingWinding;\n          }\n\n          queue.push(pushing);\n        }\n\n        currentIsect = nxtIsect;\n        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;\n      }\n    } // Close output ring\n\n\n    currentOutputRingCoords.push(isectList[nxtIsect].coord); // Push output ring to output\n\n    outputFeatureArray.push(polygon([currentOutputRingCoords], {\n      index: currentOutputRing,\n      parent: currentOutputRingParent,\n      winding: currentOutputRingWinding,\n      netWinding: undefined\n    }));\n  }\n\n  var output = featureCollection(outputFeatureArray);\n  determineParents();\n  setNetWinding(); // These functions are also used if no intersections are found\n\n  function determineParents() {\n    var featuresWithoutParent = [];\n\n    for (var i = 0; i < output.features.length; i++) {\n      if (output.features[i].properties.parent == -1) featuresWithoutParent.push(i);\n    }\n\n    if (featuresWithoutParent.length > 1) {\n      for (var i = 0; i < featuresWithoutParent.length; i++) {\n        var parent = -1;\n        var parentArea = Infinity;\n\n        for (var j = 0; j < output.features.length; j++) {\n          if (featuresWithoutParent[i] == j) continue;\n\n          if (booleanPointInPolygon(output.features[featuresWithoutParent[i]].geometry.coordinates[0][0], output.features[j], {\n            ignoreBoundary: true\n          })) {\n            if (area(output.features[j]) < parentArea) {\n              parent = j;\n            }\n          }\n        }\n\n        output.features[featuresWithoutParent[i]].properties.parent = parent;\n      }\n    }\n  }\n\n  function setNetWinding() {\n    for (var i = 0; i < output.features.length; i++) {\n      if (output.features[i].properties.parent == -1) {\n        var netWinding = output.features[i].properties.winding;\n        output.features[i].properties.netWinding = netWinding;\n        setNetWindingOfChildren(i, netWinding);\n      }\n    }\n  }\n\n  function setNetWindingOfChildren(parent, ParentNetWinding) {\n    for (var i = 0; i < output.features.length; i++) {\n      if (output.features[i].properties.parent == parent) {\n        var netWinding = ParentNetWinding + output.features[i].properties.winding;\n        output.features[i].properties.netWinding = netWinding;\n        setNetWindingOfChildren(i, netWinding);\n      }\n    }\n  }\n\n  return output;\n} // Constructor for (ring- or intersection-) pseudo-vertices.\n\n\nvar PseudoVtx = function PseudoVtx(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {\n  this.coord = coord; // [x,y] of this pseudo-vertex\n\n  this.param = param; // fractional distance of this intersection on incomming edge\n\n  this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge\n\n  this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge\n\n  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)\n}; // Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.\n\n\nvar Isect = function Isect(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {\n  this.coord = coord; // [x,y] of this intersection\n\n  this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection\n\n  this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection\n\n  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1\n\n  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2\n\n  this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?\n\n  this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?\n}; // Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded\n\n\nfunction isConvex(pts, righthanded) {\n  // 'pts' is an [x,y] pair\n  // 'righthanded' is a boolean\n  if (typeof righthanded === \"undefined\") righthanded = true;\n  if (pts.length != 3) throw new Error(\"This function requires an array of three points [x,y]\");\n  var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);\n  return d >= 0 == righthanded;\n} // Function to compute winding of simple, non-self-intersecting ring\n\n\nfunction windingOfRing(ring) {\n  // 'ring' is an array of [x,y] pairs with the last equal to the first\n  // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong\n  var leftVtx = 0;\n\n  for (var i = 0; i < ring.length - 1; i++) {\n    if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;\n  }\n\n  if (isConvex([ring[modulo(leftVtx - 1, ring.length - 1)], ring[leftVtx], ring[modulo(leftVtx + 1, ring.length - 1)]], true)) {\n    var winding = 1;\n  } else {\n    var winding = -1;\n  }\n\n  return winding;\n} // Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\n\n\nfunction equalArrays$1(array1, array2) {\n  // if the other array is a falsy value, return\n  if (!array1 || !array2) return false; // compare lengths - can save a lot of time\n\n  if (array1.length != array2.length) return false;\n\n  for (var i = 0, l = array1.length; i < l; i++) {\n    // Check if we have nested arrays\n    if (array1[i] instanceof Array && array2[i] instanceof Array) {\n      // recurse into the nested arrays\n      if (!equalArrays$1(array1[i], array2[i])) return false;\n    } else if (array1[i] != array2[i]) {\n      // Warning - two different object instances will never be equal: {x:20} != {x:20}\n      return false;\n    }\n  }\n\n  return true;\n} // Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving\n\n\nfunction modulo(n, m) {\n  return (n % m + m) % m;\n} // Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)\n\n\nfunction isUnique(array) {\n  var u = {};\n  var isUnique = 1;\n\n  for (var i = 0, l = array.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(u, array[i])) {\n      isUnique = 0;\n      break;\n    }\n\n    u[array[i]] = 1;\n  }\n\n  return isUnique;\n}\n/**\r\n * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.\r\n * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.\r\n *\r\n * @name unkinkPolygon\r\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon\r\n * @returns {FeatureCollection<Polygon>} Unkinked polygons\r\n * @example\r\n * var poly = turf.polygon([[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]);\r\n *\r\n * var result = turf.unkinkPolygon(poly);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly, result]\r\n */\n\n\nfunction unkinkPolygon(geojson) {\n  var features = [];\n  flattenEach(geojson, function (feature) {\n    if (feature.geometry.type !== \"Polygon\") return;\n    featureEach(simplepolygon(feature), function (poly) {\n      features.push(polygon(poly.geometry.coordinates, feature.properties));\n    });\n  });\n  return featureCollection(features);\n}\n\nexport default unkinkPolygon;","map":{"version":3,"names":["flattenEach","featureEach","polygon","featureCollection","rbush","area","booleanPointInPolygon","isects","feature","filterFn","useSpatialIndex","geometry","type","Error","undefined","coord","coordinates","output","seen","allEdgesAsRbushTreeItems","ring0","length","edge0","push","rbushTreeItem","tree","load","ringA","edgeA","bboxOverlaps","search","forEach","bboxIsect","ring1","ring","edge1","edge","ifIsectAddToOutput","start0","end0","start1","end1","isect","intersect","frac0","frac1","key","unique","start","end","minX","maxX","minY","maxY","equalArrays","x0","y0","x1","y1","x2","y2","x3","y3","denom","x4","y4","array1","array2","i","l","Array","simplepolygon","numRings","vertices","equalArrays$1","apply","slice","isUnique","numvertices","selfIsectsData","numSelfIsect","outputFeatureArray","parent","winding","windingOfRing","determineParents","setNetWinding","pseudoVtxListByRingAndEdge","isectList","j","PseudoVtx","modulo","Isect","numIsect","sort","a","b","param","allIsectsAsIsectRbushTreeItem","index","isectRbushTree","k","coordToFind","IsectRbushTreeItemFound","nxtIsectAlongEdgeIn","nxtIsectAlongRingAndEdge2","ringAndEdge1","ringAndEdgeIn","nxtIsectAlongRingAndEdge1","queue","leftIsect","isectAfterLeftIsect","isectBeforeLeftIsect","windingAtIsect","isConvex","popped","pop","startIsect","currentOutputRingParent","currentOutputRingWinding","currentOutputRing","currentOutputRingCoords","currentIsect","ringAndEdge1Walkable","walkingRingAndEdge","nxtIsect","ringAndEdge2","nxtIsectInQueue","splice","ringAndEdge2Walkable","pushing","netWinding","featuresWithoutParent","features","properties","parentArea","Infinity","ignoreBoundary","setNetWindingOfChildren","ParentNetWinding","ringAndEdgeOut","pts","righthanded","d","leftVtx","n","m","array","u","Object","prototype","hasOwnProperty","call","unkinkPolygon","geojson","poly"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/unkink-polygon/dist/es/index.js"],"sourcesContent":["import { flattenEach, featureEach } from '@turf/meta';\r\nimport { polygon, featureCollection } from '@turf/helpers';\r\nimport rbush from 'rbush';\r\nimport area from '@turf/area';\r\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\r\n\r\n// Find self-intersections in geojson polygon (possibly with interior rings)\r\n\r\nfunction isects (feature, filterFn, useSpatialIndex) {\r\n  if (feature.geometry.type !== \"Polygon\")\r\n    throw new Error(\"The input feature must be a Polygon\");\r\n  if (useSpatialIndex === undefined) useSpatialIndex = 1;\r\n\r\n  var coord = feature.geometry.coordinates;\r\n\r\n  var output = [];\r\n  var seen = {};\r\n\r\n  if (useSpatialIndex) {\r\n    var allEdgesAsRbushTreeItems = [];\r\n    for (var ring0 = 0; ring0 < coord.length; ring0++) {\r\n      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\r\n        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));\r\n      }\r\n    }\r\n    var tree = rbush();\r\n    tree.load(allEdgesAsRbushTreeItems);\r\n  }\r\n\r\n  for (var ringA = 0; ringA < coord.length; ringA++) {\r\n    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {\r\n      if (useSpatialIndex) {\r\n        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));\r\n        bboxOverlaps.forEach(function (bboxIsect) {\r\n          var ring1 = bboxIsect.ring;\r\n          var edge1 = bboxIsect.edge;\r\n          ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\r\n        });\r\n      } else {\r\n        for (var ring1 = 0; ring1 < coord.length; ring1++) {\r\n          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\r\n            // TODO: speedup possible if only interested in unique: start last two loops at ringA and edgeA+1\r\n            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!filterFn)\r\n    output = {\r\n      type: \"Feature\",\r\n      geometry: { type: \"MultiPoint\", coordinates: output },\r\n    };\r\n  return output;\r\n\r\n  // Function to check if two edges intersect and add the intersection to the output\r\n  function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {\r\n    var start0 = coord[ring0][edge0];\r\n    var end0 = coord[ring0][edge0 + 1];\r\n    var start1 = coord[ring1][edge1];\r\n    var end1 = coord[ring1][edge1 + 1];\r\n\r\n    var isect = intersect(start0, end0, start1, end1);\r\n\r\n    if (isect === null) return; // discard parallels and coincidence\r\n    var frac0;\r\n    var frac1;\r\n    if (end0[0] !== start0[0]) {\r\n      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);\r\n    } else {\r\n      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);\r\n    }\r\n    if (end1[0] !== start1[0]) {\r\n      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);\r\n    } else {\r\n      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);\r\n    }\r\n    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection\r\n\r\n    var key = isect;\r\n    var unique = !seen[key];\r\n    if (unique) {\r\n      seen[key] = true;\r\n    }\r\n\r\n    if (filterFn) {\r\n      output.push(\r\n        filterFn(\r\n          isect,\r\n          ring0,\r\n          edge0,\r\n          start0,\r\n          end0,\r\n          frac0,\r\n          ring1,\r\n          edge1,\r\n          start1,\r\n          end1,\r\n          frac1,\r\n          unique\r\n        )\r\n      );\r\n    } else {\r\n      output.push(isect);\r\n    }\r\n  }\r\n\r\n  // Function to return a rbush tree item given an ring and edge number\r\n  function rbushTreeItem(ring, edge) {\r\n    var start = coord[ring][edge];\r\n    var end = coord[ring][edge + 1];\r\n    var minX;\r\n    var maxX;\r\n    var minY;\r\n    var maxY;\r\n    if (start[0] < end[0]) {\r\n      minX = start[0];\r\n      maxX = end[0];\r\n    } else {\r\n      minX = end[0];\r\n      maxX = start[0];\r\n    }\r\n    if (start[1] < end[1]) {\r\n      minY = start[1];\r\n      maxY = end[1];\r\n    } else {\r\n      minY = end[1];\r\n      maxY = start[1];\r\n    }\r\n    return {\r\n      minX: minX,\r\n      minY: minY,\r\n      maxX: maxX,\r\n      maxY: maxY,\r\n      ring: ring,\r\n      edge: edge,\r\n    };\r\n  }\r\n}\r\n\r\n// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\r\nfunction intersect(start0, end0, start1, end1) {\r\n  if (\r\n    equalArrays(start0, start1) ||\r\n    equalArrays(start0, end1) ||\r\n    equalArrays(end0, start1) ||\r\n    equalArrays(end1, start1)\r\n  )\r\n    return null;\r\n  var x0 = start0[0],\r\n    y0 = start0[1],\r\n    x1 = end0[0],\r\n    y1 = end0[1],\r\n    x2 = start1[0],\r\n    y2 = start1[1],\r\n    x3 = end1[0],\r\n    y3 = end1[1];\r\n  var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\r\n  if (denom === 0) return null;\r\n  var x4 =\r\n    ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\r\n  var y4 =\r\n    ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\r\n  return [x4, y4];\r\n}\r\n\r\n// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\r\nfunction equalArrays(array1, array2) {\r\n  // if the other array is a falsy value, return\r\n  if (!array1 || !array2) return false;\r\n\r\n  // compare lengths - can save a lot of time\r\n  if (array1.length !== array2.length) return false;\r\n\r\n  for (var i = 0, l = array1.length; i < l; i++) {\r\n    // Check if we have nested arrays\r\n    if (array1[i] instanceof Array && array2[i] instanceof Array) {\r\n      // recurse into the nested arrays\r\n      if (!equalArrays(array1[i], array2[i])) return false;\r\n    } else if (array1[i] !== array2[i]) {\r\n      // Warning - two different object instances will never be equal: {x:20} !== {x:20}\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.\r\n *\r\n * @module simplepolygon\r\n * @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.\r\n * @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.\r\n *\r\n * @example\r\n * var poly = {\r\n *   \"type\": \"Feature\",\r\n *   \"geometry\": {\r\n *     \"type\": \"Polygon\",\r\n *     \"coordinates\": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]\r\n *   }\r\n * };\r\n *\r\n * var result = simplepolygon(poly);\r\n *\r\n * // =result\r\n * // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1\r\n */\r\nfunction simplepolygon (feature) {\r\n  // Check input\r\n  if (feature.type != \"Feature\")\r\n    throw new Error(\"The input must a geojson object of type Feature\");\r\n  if (feature.geometry === undefined || feature.geometry == null)\r\n    throw new Error(\r\n      \"The input must a geojson object with a non-empty geometry\"\r\n    );\r\n  if (feature.geometry.type != \"Polygon\")\r\n    throw new Error(\"The input must be a geojson Polygon\");\r\n\r\n  // Process input\r\n  var numRings = feature.geometry.coordinates.length;\r\n  var vertices = [];\r\n  for (var i = 0; i < numRings; i++) {\r\n    var ring = feature.geometry.coordinates[i];\r\n    if (!equalArrays$1(ring[0], ring[ring.length - 1])) {\r\n      ring.push(ring[0]); // Close input ring if it is not\r\n    }\r\n    vertices.push.apply(vertices, ring.slice(0, ring.length - 1));\r\n  }\r\n  if (!isUnique(vertices))\r\n    throw new Error(\r\n      \"The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)\"\r\n    );\r\n  var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted\r\n\r\n  // Compute self-intersections\r\n  var selfIsectsData = isects(\r\n    feature,\r\n    function filterFn(\r\n      isect,\r\n      ring0,\r\n      edge0,\r\n      start0,\r\n      end0,\r\n      frac0,\r\n      ring1,\r\n      edge1,\r\n      start1,\r\n      end1,\r\n      frac1,\r\n      unique\r\n    ) {\r\n      return [\r\n        isect,\r\n        ring0,\r\n        edge0,\r\n        start0,\r\n        end0,\r\n        frac0,\r\n        ring1,\r\n        edge1,\r\n        start1,\r\n        end1,\r\n        frac1,\r\n        unique,\r\n      ];\r\n    }\r\n  );\r\n  var numSelfIsect = selfIsectsData.length;\r\n\r\n  // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.\r\n  if (numSelfIsect == 0) {\r\n    var outputFeatureArray = [];\r\n    for (var i = 0; i < numRings; i++) {\r\n      outputFeatureArray.push(\r\n        polygon([feature.geometry.coordinates[i]], {\r\n          parent: -1,\r\n          winding: windingOfRing(feature.geometry.coordinates[i]),\r\n        })\r\n      );\r\n    }\r\n    var output = featureCollection(outputFeatureArray);\r\n    determineParents();\r\n    setNetWinding();\r\n\r\n    return output;\r\n  }\r\n\r\n  // If self-intersections are found, we will compute the output rings with the help of two intermediate variables\r\n  // First, we build the pseudo vertex list and intersection list\r\n  // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.\r\n  var pseudoVtxListByRingAndEdge = [];\r\n  // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.\r\n  var isectList = [];\r\n  // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList\r\n  for (var i = 0; i < numRings; i++) {\r\n    pseudoVtxListByRingAndEdge.push([]);\r\n    for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {\r\n      // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.\r\n      pseudoVtxListByRingAndEdge[i].push([\r\n        new PseudoVtx(\r\n          feature.geometry.coordinates[i][\r\n            modulo(j + 1, feature.geometry.coordinates[i].length - 1)\r\n          ],\r\n          1,\r\n          [i, j],\r\n          [i, modulo(j + 1, feature.geometry.coordinates[i].length - 1)],\r\n          undefined\r\n        ),\r\n      ]);\r\n      // The first numvertices elements in isectList correspond to the ring-vertex-intersections\r\n      isectList.push(\r\n        new Isect(\r\n          feature.geometry.coordinates[i][j],\r\n          [i, modulo(j - 1, feature.geometry.coordinates[i].length - 1)],\r\n          [i, j],\r\n          undefined,\r\n          undefined,\r\n          false,\r\n          true\r\n        )\r\n      );\r\n    }\r\n  }\r\n  // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList\r\n  for (var i = 0; i < numSelfIsect; i++) {\r\n    // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge\r\n    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(\r\n      new PseudoVtx(\r\n        selfIsectsData[i][0],\r\n        selfIsectsData[i][5],\r\n        [selfIsectsData[i][1], selfIsectsData[i][2]],\r\n        [selfIsectsData[i][6], selfIsectsData[i][7]],\r\n        undefined\r\n      )\r\n    );\r\n    // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList\r\n    if (selfIsectsData[i][11])\r\n      isectList.push(\r\n        new Isect(\r\n          selfIsectsData[i][0],\r\n          [selfIsectsData[i][1], selfIsectsData[i][2]],\r\n          [selfIsectsData[i][6], selfIsectsData[i][7]],\r\n          undefined,\r\n          undefined,\r\n          true,\r\n          true\r\n        )\r\n      );\r\n  }\r\n  var numIsect = isectList.length;\r\n  // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'\r\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\r\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\r\n      pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {\r\n        return a.param < b.param ? -1 : 1;\r\n      });\r\n    }\r\n  }\r\n\r\n  // Make a spatial index of intersections, in preperation for the following two steps\r\n  var allIsectsAsIsectRbushTreeItem = [];\r\n  for (var i = 0; i < numIsect; i++) {\r\n    allIsectsAsIsectRbushTreeItem.push({\r\n      minX: isectList[i].coord[0],\r\n      minY: isectList[i].coord[1],\r\n      maxX: isectList[i].coord[0],\r\n      maxY: isectList[i].coord[1],\r\n      index: i,\r\n    }); // could pass isect: isectList[i], but not necessary\r\n  }\r\n  var isectRbushTree = rbush();\r\n  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);\r\n\r\n  // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.\r\n  // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:\r\n  // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates\r\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\r\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\r\n      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\r\n        var coordToFind;\r\n        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {\r\n          // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.\r\n          coordToFind =\r\n            pseudoVtxListByRingAndEdge[i][\r\n              modulo(j + 1, feature.geometry.coordinates[i].length - 1)\r\n            ][0].coord;\r\n        } else {\r\n          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;\r\n        }\r\n        var IsectRbushTreeItemFound = isectRbushTree.search({\r\n          minX: coordToFind[0],\r\n          minY: coordToFind[1],\r\n          maxX: coordToFind[0],\r\n          maxY: coordToFind[1],\r\n        })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\r\n        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn =\r\n          IsectRbushTreeItemFound.index;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection\r\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\r\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\r\n      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\r\n        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;\r\n        var IsectRbushTreeItemFound = isectRbushTree.search({\r\n          minX: coordToFind[0],\r\n          minY: coordToFind[1],\r\n          maxX: coordToFind[0],\r\n          maxY: coordToFind[1],\r\n        })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\r\n        var l = IsectRbushTreeItemFound.index;\r\n        if (l < numvertices) {\r\n          // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.\r\n          isectList[l].nxtIsectAlongRingAndEdge2 =\r\n            pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\r\n        } else {\r\n          // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.\r\n          if (\r\n            equalArrays$1(\r\n              isectList[l].ringAndEdge1,\r\n              pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn\r\n            )\r\n          ) {\r\n            isectList[l].nxtIsectAlongRingAndEdge1 =\r\n              pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\r\n          } else {\r\n            isectList[l].nxtIsectAlongRingAndEdge2 =\r\n              pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!\r\n\r\n  // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.\r\n  // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).\r\n  var queue = [];\r\n  // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.\r\n  var i = 0;\r\n  for (var j = 0; j < numRings; j++) {\r\n    var leftIsect = i;\r\n    for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {\r\n      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {\r\n        leftIsect = i;\r\n      }\r\n      i++;\r\n    }\r\n    // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.\r\n    // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong\r\n    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;\r\n    for (var k = 0; k < isectList.length; k++) {\r\n      if (\r\n        isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect ||\r\n        isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect\r\n      ) {\r\n        var isectBeforeLeftIsect = k;\r\n        break;\r\n      }\r\n    }\r\n    var windingAtIsect = isConvex(\r\n      [\r\n        isectList[isectBeforeLeftIsect].coord,\r\n        isectList[leftIsect].coord,\r\n        isectList[isectAfterLeftIsect].coord,\r\n      ],\r\n      true\r\n    )\r\n      ? 1\r\n      : -1;\r\n\r\n    queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });\r\n  }\r\n  // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.\r\n  queue.sort(function (a, b) {\r\n    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;\r\n  });\r\n\r\n  // Initialise output\r\n  var outputFeatureArray = [];\r\n\r\n  // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.\r\n  while (queue.length > 0) {\r\n    // Get the last object out of the queue\r\n    var popped = queue.pop();\r\n    var startIsect = popped.isect;\r\n    var currentOutputRingParent = popped.parent;\r\n    var currentOutputRingWinding = popped.winding;\r\n    // Make new output ring and add vertex from starting intersection\r\n    var currentOutputRing = outputFeatureArray.length;\r\n    var currentOutputRingCoords = [isectList[startIsect].coord];\r\n    // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'\r\n    var currentIsect = startIsect;\r\n    if (isectList[startIsect].ringAndEdge1Walkable) {\r\n      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;\r\n      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;\r\n    } else {\r\n      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;\r\n      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;\r\n    }\r\n    // While we have not arrived back at the same intersection, keep walking\r\n    while (\r\n      !equalArrays$1(isectList[startIsect].coord, isectList[nxtIsect].coord)\r\n    ) {\r\n      currentOutputRingCoords.push(isectList[nxtIsect].coord);\r\n      // If the next intersection is queued, we can remove it, because we will go there now.\r\n      var nxtIsectInQueue = undefined;\r\n      for (var i = 0; i < queue.length; i++) {\r\n        if (queue[i].isect == nxtIsect) {\r\n          nxtIsectInQueue = i;\r\n          break;\r\n        }\r\n      }\r\n      if (nxtIsectInQueue != undefined) {\r\n        queue.splice(nxtIsectInQueue, 1);\r\n      }\r\n      // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),\r\n      // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it\r\n      // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue\r\n      // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)\r\n      // We then update the other two walking variables.\r\n      if (equalArrays$1(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {\r\n        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;\r\n        isectList[nxtIsect].ringAndEdge2Walkable = false;\r\n        if (isectList[nxtIsect].ringAndEdge1Walkable) {\r\n          var pushing = { isect: nxtIsect };\r\n          if (\r\n            isConvex(\r\n              [\r\n                isectList[currentIsect].coord,\r\n                isectList[nxtIsect].coord,\r\n                isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord,\r\n              ],\r\n              currentOutputRingWinding == 1\r\n            )\r\n          ) {\r\n            pushing.parent = currentOutputRingParent;\r\n            pushing.winding = -currentOutputRingWinding;\r\n          } else {\r\n            pushing.parent = currentOutputRing;\r\n            pushing.winding = currentOutputRingWinding;\r\n          }\r\n          queue.push(pushing);\r\n        }\r\n        currentIsect = nxtIsect;\r\n        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;\r\n      } else {\r\n        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;\r\n        isectList[nxtIsect].ringAndEdge1Walkable = false;\r\n        if (isectList[nxtIsect].ringAndEdge2Walkable) {\r\n          var pushing = { isect: nxtIsect };\r\n          if (\r\n            isConvex(\r\n              [\r\n                isectList[currentIsect].coord,\r\n                isectList[nxtIsect].coord,\r\n                isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord,\r\n              ],\r\n              currentOutputRingWinding == 1\r\n            )\r\n          ) {\r\n            pushing.parent = currentOutputRingParent;\r\n            pushing.winding = -currentOutputRingWinding;\r\n          } else {\r\n            pushing.parent = currentOutputRing;\r\n            pushing.winding = currentOutputRingWinding;\r\n          }\r\n          queue.push(pushing);\r\n        }\r\n        currentIsect = nxtIsect;\r\n        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;\r\n      }\r\n    }\r\n    // Close output ring\r\n    currentOutputRingCoords.push(isectList[nxtIsect].coord);\r\n    // Push output ring to output\r\n    outputFeatureArray.push(\r\n      polygon([currentOutputRingCoords], {\r\n        index: currentOutputRing,\r\n        parent: currentOutputRingParent,\r\n        winding: currentOutputRingWinding,\r\n        netWinding: undefined,\r\n      })\r\n    );\r\n  }\r\n\r\n  var output = featureCollection(outputFeatureArray);\r\n\r\n  determineParents();\r\n\r\n  setNetWinding();\r\n\r\n  // These functions are also used if no intersections are found\r\n  function determineParents() {\r\n    var featuresWithoutParent = [];\r\n    for (var i = 0; i < output.features.length; i++) {\r\n      if (output.features[i].properties.parent == -1)\r\n        featuresWithoutParent.push(i);\r\n    }\r\n    if (featuresWithoutParent.length > 1) {\r\n      for (var i = 0; i < featuresWithoutParent.length; i++) {\r\n        var parent = -1;\r\n        var parentArea = Infinity;\r\n        for (var j = 0; j < output.features.length; j++) {\r\n          if (featuresWithoutParent[i] == j) continue;\r\n          if (\r\n            booleanPointInPolygon(\r\n              output.features[featuresWithoutParent[i]].geometry\r\n                .coordinates[0][0],\r\n              output.features[j],\r\n              { ignoreBoundary: true }\r\n            )\r\n          ) {\r\n            if (area(output.features[j]) < parentArea) {\r\n              parent = j;\r\n            }\r\n          }\r\n        }\r\n        output.features[featuresWithoutParent[i]].properties.parent = parent;\r\n      }\r\n    }\r\n  }\r\n\r\n  function setNetWinding() {\r\n    for (var i = 0; i < output.features.length; i++) {\r\n      if (output.features[i].properties.parent == -1) {\r\n        var netWinding = output.features[i].properties.winding;\r\n        output.features[i].properties.netWinding = netWinding;\r\n        setNetWindingOfChildren(i, netWinding);\r\n      }\r\n    }\r\n  }\r\n\r\n  function setNetWindingOfChildren(parent, ParentNetWinding) {\r\n    for (var i = 0; i < output.features.length; i++) {\r\n      if (output.features[i].properties.parent == parent) {\r\n        var netWinding =\r\n          ParentNetWinding + output.features[i].properties.winding;\r\n        output.features[i].properties.netWinding = netWinding;\r\n        setNetWindingOfChildren(i, netWinding);\r\n      }\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\n// Constructor for (ring- or intersection-) pseudo-vertices.\r\nvar PseudoVtx = function (\r\n  coord,\r\n  param,\r\n  ringAndEdgeIn,\r\n  ringAndEdgeOut,\r\n  nxtIsectAlongEdgeIn\r\n) {\r\n  this.coord = coord; // [x,y] of this pseudo-vertex\r\n  this.param = param; // fractional distance of this intersection on incomming edge\r\n  this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge\r\n  this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge\r\n  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)\r\n};\r\n\r\n// Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.\r\nvar Isect = function (\r\n  coord,\r\n  ringAndEdge1,\r\n  ringAndEdge2,\r\n  nxtIsectAlongRingAndEdge1,\r\n  nxtIsectAlongRingAndEdge2,\r\n  ringAndEdge1Walkable,\r\n  ringAndEdge2Walkable\r\n) {\r\n  this.coord = coord; // [x,y] of this intersection\r\n  this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection\r\n  this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection\r\n  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1\r\n  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2\r\n  this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?\r\n  this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?\r\n};\r\n\r\n// Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded\r\nfunction isConvex(pts, righthanded) {\r\n  // 'pts' is an [x,y] pair\r\n  // 'righthanded' is a boolean\r\n  if (typeof righthanded === \"undefined\") righthanded = true;\r\n  if (pts.length != 3)\r\n    throw new Error(\"This function requires an array of three points [x,y]\");\r\n  var d =\r\n    (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) -\r\n    (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);\r\n  return d >= 0 == righthanded;\r\n}\r\n\r\n// Function to compute winding of simple, non-self-intersecting ring\r\nfunction windingOfRing(ring) {\r\n  // 'ring' is an array of [x,y] pairs with the last equal to the first\r\n  // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong\r\n  var leftVtx = 0;\r\n  for (var i = 0; i < ring.length - 1; i++) {\r\n    if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;\r\n  }\r\n  if (\r\n    isConvex(\r\n      [\r\n        ring[modulo(leftVtx - 1, ring.length - 1)],\r\n        ring[leftVtx],\r\n        ring[modulo(leftVtx + 1, ring.length - 1)],\r\n      ],\r\n      true\r\n    )\r\n  ) {\r\n    var winding = 1;\r\n  } else {\r\n    var winding = -1;\r\n  }\r\n  return winding;\r\n}\r\n\r\n// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\r\nfunction equalArrays$1(array1, array2) {\r\n  // if the other array is a falsy value, return\r\n  if (!array1 || !array2) return false;\r\n\r\n  // compare lengths - can save a lot of time\r\n  if (array1.length != array2.length) return false;\r\n\r\n  for (var i = 0, l = array1.length; i < l; i++) {\r\n    // Check if we have nested arrays\r\n    if (array1[i] instanceof Array && array2[i] instanceof Array) {\r\n      // recurse into the nested arrays\r\n      if (!equalArrays$1(array1[i], array2[i])) return false;\r\n    } else if (array1[i] != array2[i]) {\r\n      // Warning - two different object instances will never be equal: {x:20} != {x:20}\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving\r\nfunction modulo(n, m) {\r\n  return ((n % m) + m) % m;\r\n}\r\n\r\n// Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)\r\nfunction isUnique(array) {\r\n  var u = {};\r\n  var isUnique = 1;\r\n  for (var i = 0, l = array.length; i < l; ++i) {\r\n    if (Object.prototype.hasOwnProperty.call(u, array[i])) {\r\n      isUnique = 0;\r\n      break;\r\n    }\r\n    u[array[i]] = 1;\r\n  }\r\n  return isUnique;\r\n}\r\n\r\n/**\r\n * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.\r\n * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.\r\n *\r\n * @name unkinkPolygon\r\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon\r\n * @returns {FeatureCollection<Polygon>} Unkinked polygons\r\n * @example\r\n * var poly = turf.polygon([[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]);\r\n *\r\n * var result = turf.unkinkPolygon(poly);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly, result]\r\n */\r\nfunction unkinkPolygon(geojson) {\r\n  var features = [];\r\n  flattenEach(geojson, function (feature) {\r\n    if (feature.geometry.type !== \"Polygon\") return;\r\n    featureEach(simplepolygon(feature), function (poly) {\r\n      features.push(polygon(poly.geometry.coordinates, feature.properties));\r\n    });\r\n  });\r\n  return featureCollection(features);\r\n}\r\n\r\nexport default unkinkPolygon;\r\n"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,WAAtB,QAAyC,YAAzC;AACA,SAASC,OAAT,EAAkBC,iBAAlB,QAA2C,eAA3C;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,OAAOC,qBAAP,MAAkC,gCAAlC,C,CAEA;;AAEA,SAASC,MAAT,CAAiBC,OAAjB,EAA0BC,QAA1B,EAAoCC,eAApC,EAAqD;EACnD,IAAIF,OAAO,CAACG,QAAR,CAAiBC,IAAjB,KAA0B,SAA9B,EACE,MAAM,IAAIC,KAAJ,CAAU,qCAAV,CAAN;EACF,IAAIH,eAAe,KAAKI,SAAxB,EAAmCJ,eAAe,GAAG,CAAlB;EAEnC,IAAIK,KAAK,GAAGP,OAAO,CAACG,QAAR,CAAiBK,WAA7B;EAEA,IAAIC,MAAM,GAAG,EAAb;EACA,IAAIC,IAAI,GAAG,EAAX;;EAEA,IAAIR,eAAJ,EAAqB;IACnB,IAAIS,wBAAwB,GAAG,EAA/B;;IACA,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGL,KAAK,CAACM,MAAlC,EAA0CD,KAAK,EAA/C,EAAmD;MACjD,KAAK,IAAIE,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGP,KAAK,CAACK,KAAD,CAAL,CAAaC,MAAb,GAAsB,CAAlD,EAAqDC,KAAK,EAA1D,EAA8D;QAC5DH,wBAAwB,CAACI,IAAzB,CAA8BC,aAAa,CAACJ,KAAD,EAAQE,KAAR,CAA3C;MACD;IACF;;IACD,IAAIG,IAAI,GAAGrB,KAAK,EAAhB;IACAqB,IAAI,CAACC,IAAL,CAAUP,wBAAV;EACD;;EAED,KAAK,IAAIQ,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGZ,KAAK,CAACM,MAAlC,EAA0CM,KAAK,EAA/C,EAAmD;IACjD,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGb,KAAK,CAACY,KAAD,CAAL,CAAaN,MAAb,GAAsB,CAAlD,EAAqDO,KAAK,EAA1D,EAA8D;MAC5D,IAAIlB,eAAJ,EAAqB;QACnB,IAAImB,YAAY,GAAGJ,IAAI,CAACK,MAAL,CAAYN,aAAa,CAACG,KAAD,EAAQC,KAAR,CAAzB,CAAnB;QACAC,YAAY,CAACE,OAAb,CAAqB,UAAUC,SAAV,EAAqB;UACxC,IAAIC,KAAK,GAAGD,SAAS,CAACE,IAAtB;UACA,IAAIC,KAAK,GAAGH,SAAS,CAACI,IAAtB;UACAC,kBAAkB,CAACV,KAAD,EAAQC,KAAR,EAAeK,KAAf,EAAsBE,KAAtB,CAAlB;QACD,CAJD;MAKD,CAPD,MAOO;QACL,KAAK,IAAIF,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGlB,KAAK,CAACM,MAAlC,EAA0CY,KAAK,EAA/C,EAAmD;UACjD,KAAK,IAAIE,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGpB,KAAK,CAACkB,KAAD,CAAL,CAAaZ,MAAb,GAAsB,CAAlD,EAAqDc,KAAK,EAA1D,EAA8D;YAC5D;YACAE,kBAAkB,CAACV,KAAD,EAAQC,KAAR,EAAeK,KAAf,EAAsBE,KAAtB,CAAlB;UACD;QACF;MACF;IACF;EACF;;EAED,IAAI,CAAC1B,QAAL,EACEQ,MAAM,GAAG;IACPL,IAAI,EAAE,SADC;IAEPD,QAAQ,EAAE;MAAEC,IAAI,EAAE,YAAR;MAAsBI,WAAW,EAAEC;IAAnC;EAFH,CAAT;EAIF,OAAOA,MAAP,CA9CmD,CAgDnD;;EACA,SAASoB,kBAAT,CAA4BjB,KAA5B,EAAmCE,KAAnC,EAA0CW,KAA1C,EAAiDE,KAAjD,EAAwD;IACtD,IAAIG,MAAM,GAAGvB,KAAK,CAACK,KAAD,CAAL,CAAaE,KAAb,CAAb;IACA,IAAIiB,IAAI,GAAGxB,KAAK,CAACK,KAAD,CAAL,CAAaE,KAAK,GAAG,CAArB,CAAX;IACA,IAAIkB,MAAM,GAAGzB,KAAK,CAACkB,KAAD,CAAL,CAAaE,KAAb,CAAb;IACA,IAAIM,IAAI,GAAG1B,KAAK,CAACkB,KAAD,CAAL,CAAaE,KAAK,GAAG,CAArB,CAAX;IAEA,IAAIO,KAAK,GAAGC,SAAS,CAACL,MAAD,EAASC,IAAT,EAAeC,MAAf,EAAuBC,IAAvB,CAArB;IAEA,IAAIC,KAAK,KAAK,IAAd,EAAoB,OARkC,CAQ1B;;IAC5B,IAAIE,KAAJ;IACA,IAAIC,KAAJ;;IACA,IAAIN,IAAI,CAAC,CAAD,CAAJ,KAAYD,MAAM,CAAC,CAAD,CAAtB,EAA2B;MACzBM,KAAK,GAAG,CAACF,KAAK,CAAC,CAAD,CAAL,GAAWJ,MAAM,CAAC,CAAD,CAAlB,KAA0BC,IAAI,CAAC,CAAD,CAAJ,GAAUD,MAAM,CAAC,CAAD,CAA1C,CAAR;IACD,CAFD,MAEO;MACLM,KAAK,GAAG,CAACF,KAAK,CAAC,CAAD,CAAL,GAAWJ,MAAM,CAAC,CAAD,CAAlB,KAA0BC,IAAI,CAAC,CAAD,CAAJ,GAAUD,MAAM,CAAC,CAAD,CAA1C,CAAR;IACD;;IACD,IAAIG,IAAI,CAAC,CAAD,CAAJ,KAAYD,MAAM,CAAC,CAAD,CAAtB,EAA2B;MACzBK,KAAK,GAAG,CAACH,KAAK,CAAC,CAAD,CAAL,GAAWF,MAAM,CAAC,CAAD,CAAlB,KAA0BC,IAAI,CAAC,CAAD,CAAJ,GAAUD,MAAM,CAAC,CAAD,CAA1C,CAAR;IACD,CAFD,MAEO;MACLK,KAAK,GAAG,CAACH,KAAK,CAAC,CAAD,CAAL,GAAWF,MAAM,CAAC,CAAD,CAAlB,KAA0BC,IAAI,CAAC,CAAD,CAAJ,GAAUD,MAAM,CAAC,CAAD,CAA1C,CAAR;IACD;;IACD,IAAII,KAAK,IAAI,CAAT,IAAcA,KAAK,IAAI,CAAvB,IAA4BC,KAAK,IAAI,CAArC,IAA0CA,KAAK,IAAI,CAAvD,EAA0D,OArBJ,CAqBY;;IAElE,IAAIC,GAAG,GAAGJ,KAAV;IACA,IAAIK,MAAM,GAAG,CAAC7B,IAAI,CAAC4B,GAAD,CAAlB;;IACA,IAAIC,MAAJ,EAAY;MACV7B,IAAI,CAAC4B,GAAD,CAAJ,GAAY,IAAZ;IACD;;IAED,IAAIrC,QAAJ,EAAc;MACZQ,MAAM,CAACM,IAAP,CACEd,QAAQ,CACNiC,KADM,EAENtB,KAFM,EAGNE,KAHM,EAINgB,MAJM,EAKNC,IALM,EAMNK,KANM,EAONX,KAPM,EAQNE,KARM,EASNK,MATM,EAUNC,IAVM,EAWNI,KAXM,EAYNE,MAZM,CADV;IAgBD,CAjBD,MAiBO;MACL9B,MAAM,CAACM,IAAP,CAAYmB,KAAZ;IACD;EACF,CAlGkD,CAoGnD;;;EACA,SAASlB,aAAT,CAAuBU,IAAvB,EAA6BE,IAA7B,EAAmC;IACjC,IAAIY,KAAK,GAAGjC,KAAK,CAACmB,IAAD,CAAL,CAAYE,IAAZ,CAAZ;IACA,IAAIa,GAAG,GAAGlC,KAAK,CAACmB,IAAD,CAAL,CAAYE,IAAI,GAAG,CAAnB,CAAV;IACA,IAAIc,IAAJ;IACA,IAAIC,IAAJ;IACA,IAAIC,IAAJ;IACA,IAAIC,IAAJ;;IACA,IAAIL,KAAK,CAAC,CAAD,CAAL,GAAWC,GAAG,CAAC,CAAD,CAAlB,EAAuB;MACrBC,IAAI,GAAGF,KAAK,CAAC,CAAD,CAAZ;MACAG,IAAI,GAAGF,GAAG,CAAC,CAAD,CAAV;IACD,CAHD,MAGO;MACLC,IAAI,GAAGD,GAAG,CAAC,CAAD,CAAV;MACAE,IAAI,GAAGH,KAAK,CAAC,CAAD,CAAZ;IACD;;IACD,IAAIA,KAAK,CAAC,CAAD,CAAL,GAAWC,GAAG,CAAC,CAAD,CAAlB,EAAuB;MACrBG,IAAI,GAAGJ,KAAK,CAAC,CAAD,CAAZ;MACAK,IAAI,GAAGJ,GAAG,CAAC,CAAD,CAAV;IACD,CAHD,MAGO;MACLG,IAAI,GAAGH,GAAG,CAAC,CAAD,CAAV;MACAI,IAAI,GAAGL,KAAK,CAAC,CAAD,CAAZ;IACD;;IACD,OAAO;MACLE,IAAI,EAAEA,IADD;MAELE,IAAI,EAAEA,IAFD;MAGLD,IAAI,EAAEA,IAHD;MAILE,IAAI,EAAEA,IAJD;MAKLnB,IAAI,EAAEA,IALD;MAMLE,IAAI,EAAEA;IAND,CAAP;EAQD;AACF,C,CAED;;;AACA,SAASO,SAAT,CAAmBL,MAAnB,EAA2BC,IAA3B,EAAiCC,MAAjC,EAAyCC,IAAzC,EAA+C;EAC7C,IACEa,WAAW,CAAChB,MAAD,EAASE,MAAT,CAAX,IACAc,WAAW,CAAChB,MAAD,EAASG,IAAT,CADX,IAEAa,WAAW,CAACf,IAAD,EAAOC,MAAP,CAFX,IAGAc,WAAW,CAACb,IAAD,EAAOD,MAAP,CAJb,EAME,OAAO,IAAP;EACF,IAAIe,EAAE,GAAGjB,MAAM,CAAC,CAAD,CAAf;EAAA,IACEkB,EAAE,GAAGlB,MAAM,CAAC,CAAD,CADb;EAAA,IAEEmB,EAAE,GAAGlB,IAAI,CAAC,CAAD,CAFX;EAAA,IAGEmB,EAAE,GAAGnB,IAAI,CAAC,CAAD,CAHX;EAAA,IAIEoB,EAAE,GAAGnB,MAAM,CAAC,CAAD,CAJb;EAAA,IAKEoB,EAAE,GAAGpB,MAAM,CAAC,CAAD,CALb;EAAA,IAMEqB,EAAE,GAAGpB,IAAI,CAAC,CAAD,CANX;EAAA,IAOEqB,EAAE,GAAGrB,IAAI,CAAC,CAAD,CAPX;EAQA,IAAIsB,KAAK,GAAG,CAACR,EAAE,GAAGE,EAAN,KAAaG,EAAE,GAAGE,EAAlB,IAAwB,CAACN,EAAE,GAAGE,EAAN,KAAaC,EAAE,GAAGE,EAAlB,CAApC;EACA,IAAIE,KAAK,KAAK,CAAd,EAAiB,OAAO,IAAP;EACjB,IAAIC,EAAE,GACJ,CAAC,CAACT,EAAE,GAAGG,EAAL,GAAUF,EAAE,GAAGC,EAAhB,KAAuBE,EAAE,GAAGE,EAA5B,IAAkC,CAACN,EAAE,GAAGE,EAAN,KAAaE,EAAE,GAAGG,EAAL,GAAUF,EAAE,GAAGC,EAA5B,CAAnC,IAAsEE,KADxE;EAEA,IAAIE,EAAE,GACJ,CAAC,CAACV,EAAE,GAAGG,EAAL,GAAUF,EAAE,GAAGC,EAAhB,KAAuBG,EAAE,GAAGE,EAA5B,IAAkC,CAACN,EAAE,GAAGE,EAAN,KAAaC,EAAE,GAAGG,EAAL,GAAUF,EAAE,GAAGC,EAA5B,CAAnC,IAAsEE,KADxE;EAEA,OAAO,CAACC,EAAD,EAAKC,EAAL,CAAP;AACD,C,CAED;;;AACA,SAASX,WAAT,CAAqBY,MAArB,EAA6BC,MAA7B,EAAqC;EACnC;EACA,IAAI,CAACD,MAAD,IAAW,CAACC,MAAhB,EAAwB,OAAO,KAAP,CAFW,CAInC;;EACA,IAAID,MAAM,CAAC7C,MAAP,KAAkB8C,MAAM,CAAC9C,MAA7B,EAAqC,OAAO,KAAP;;EAErC,KAAK,IAAI+C,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGH,MAAM,CAAC7C,MAA3B,EAAmC+C,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;IAC7C;IACA,IAAIF,MAAM,CAACE,CAAD,CAAN,YAAqBE,KAArB,IAA8BH,MAAM,CAACC,CAAD,CAAN,YAAqBE,KAAvD,EAA8D;MAC5D;MACA,IAAI,CAAChB,WAAW,CAACY,MAAM,CAACE,CAAD,CAAP,EAAYD,MAAM,CAACC,CAAD,CAAlB,CAAhB,EAAwC,OAAO,KAAP;IACzC,CAHD,MAGO,IAAIF,MAAM,CAACE,CAAD,CAAN,KAAcD,MAAM,CAACC,CAAD,CAAxB,EAA6B;MAClC;MACA,OAAO,KAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,aAAT,CAAwB/D,OAAxB,EAAiC;EAC/B;EACA,IAAIA,OAAO,CAACI,IAAR,IAAgB,SAApB,EACE,MAAM,IAAIC,KAAJ,CAAU,iDAAV,CAAN;EACF,IAAIL,OAAO,CAACG,QAAR,KAAqBG,SAArB,IAAkCN,OAAO,CAACG,QAAR,IAAoB,IAA1D,EACE,MAAM,IAAIE,KAAJ,CACJ,2DADI,CAAN;EAGF,IAAIL,OAAO,CAACG,QAAR,CAAiBC,IAAjB,IAAyB,SAA7B,EACE,MAAM,IAAIC,KAAJ,CAAU,qCAAV,CAAN,CAT6B,CAW/B;;EACA,IAAI2D,QAAQ,GAAGhE,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BK,MAA5C;EACA,IAAIoD,QAAQ,GAAG,EAAf;;EACA,KAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,QAApB,EAA8BJ,CAAC,EAA/B,EAAmC;IACjC,IAAIlC,IAAI,GAAG1B,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,CAAX;;IACA,IAAI,CAACM,aAAa,CAACxC,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAACA,IAAI,CAACb,MAAL,GAAc,CAAf,CAAd,CAAlB,EAAoD;MAClDa,IAAI,CAACX,IAAL,CAAUW,IAAI,CAAC,CAAD,CAAd,EADkD,CAC9B;IACrB;;IACDuC,QAAQ,CAAClD,IAAT,CAAcoD,KAAd,CAAoBF,QAApB,EAA8BvC,IAAI,CAAC0C,KAAL,CAAW,CAAX,EAAc1C,IAAI,CAACb,MAAL,GAAc,CAA5B,CAA9B;EACD;;EACD,IAAI,CAACwD,QAAQ,CAACJ,QAAD,CAAb,EACE,MAAM,IAAI5D,KAAJ,CACJ,uGADI,CAAN;EAGF,IAAIiE,WAAW,GAAGL,QAAQ,CAACpD,MAA3B,CAzB+B,CAyBI;EAEnC;;EACA,IAAI0D,cAAc,GAAGxE,MAAM,CACzBC,OADyB,EAEzB,SAASC,QAAT,CACEiC,KADF,EAEEtB,KAFF,EAGEE,KAHF,EAIEgB,MAJF,EAKEC,IALF,EAMEK,KANF,EAOEX,KAPF,EAQEE,KARF,EASEK,MATF,EAUEC,IAVF,EAWEI,KAXF,EAYEE,MAZF,EAaE;IACA,OAAO,CACLL,KADK,EAELtB,KAFK,EAGLE,KAHK,EAILgB,MAJK,EAKLC,IALK,EAMLK,KANK,EAOLX,KAPK,EAQLE,KARK,EASLK,MATK,EAULC,IAVK,EAWLI,KAXK,EAYLE,MAZK,CAAP;EAcD,CA9BwB,CAA3B;EAgCA,IAAIiC,YAAY,GAAGD,cAAc,CAAC1D,MAAlC,CA5D+B,CA8D/B;;EACA,IAAI2D,YAAY,IAAI,CAApB,EAAuB;IACrB,IAAIC,kBAAkB,GAAG,EAAzB;;IACA,KAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,QAApB,EAA8BJ,CAAC,EAA/B,EAAmC;MACjCa,kBAAkB,CAAC1D,IAAnB,CACErB,OAAO,CAAC,CAACM,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,CAAD,CAAD,EAAoC;QACzCc,MAAM,EAAE,CAAC,CADgC;QAEzCC,OAAO,EAAEC,aAAa,CAAC5E,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,CAAD;MAFmB,CAApC,CADT;IAMD;;IACD,IAAInD,MAAM,GAAGd,iBAAiB,CAAC8E,kBAAD,CAA9B;IACAI,gBAAgB;IAChBC,aAAa;IAEb,OAAOrE,MAAP;EACD,CA9E8B,CAgF/B;EACA;EACA;;;EACA,IAAIsE,0BAA0B,GAAG,EAAjC,CAnF+B,CAoF/B;;EACA,IAAIC,SAAS,GAAG,EAAhB,CArF+B,CAsF/B;;EACA,KAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,QAApB,EAA8BJ,CAAC,EAA/B,EAAmC;IACjCmB,0BAA0B,CAAChE,IAA3B,CAAgC,EAAhC;;IACA,KAAK,IAAIkE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjF,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,EAAgC/C,MAAhC,GAAyC,CAA7D,EAAgEoE,CAAC,EAAjE,EAAqE;MACnE;MACAF,0BAA0B,CAACnB,CAAD,CAA1B,CAA8B7C,IAA9B,CAAmC,CACjC,IAAImE,SAAJ,CACElF,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,EACEuB,MAAM,CAACF,CAAC,GAAG,CAAL,EAAQjF,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,EAAgC/C,MAAhC,GAAyC,CAAjD,CADR,CADF,EAIE,CAJF,EAKE,CAAC+C,CAAD,EAAIqB,CAAJ,CALF,EAME,CAACrB,CAAD,EAAIuB,MAAM,CAACF,CAAC,GAAG,CAAL,EAAQjF,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,EAAgC/C,MAAhC,GAAyC,CAAjD,CAAV,CANF,EAOEP,SAPF,CADiC,CAAnC,EAFmE,CAanE;;MACA0E,SAAS,CAACjE,IAAV,CACE,IAAIqE,KAAJ,CACEpF,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,EAAgCqB,CAAhC,CADF,EAEE,CAACrB,CAAD,EAAIuB,MAAM,CAACF,CAAC,GAAG,CAAL,EAAQjF,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,EAAgC/C,MAAhC,GAAyC,CAAjD,CAAV,CAFF,EAGE,CAAC+C,CAAD,EAAIqB,CAAJ,CAHF,EAIE3E,SAJF,EAKEA,SALF,EAME,KANF,EAOE,IAPF,CADF;IAWD;EACF,CAnH8B,CAoH/B;;;EACA,KAAK,IAAIsD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,YAApB,EAAkCZ,CAAC,EAAnC,EAAuC;IACrC;IACAmB,0BAA0B,CAACR,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAD,CAA1B,CAAiDW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAjD,EAAuE7C,IAAvE,CACE,IAAImE,SAAJ,CACEX,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CADF,EAEEW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAFF,EAGE,CAACW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAD,EAAuBW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAvB,CAHF,EAIE,CAACW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAD,EAAuBW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAvB,CAJF,EAKEtD,SALF,CADF,EAFqC,CAWrC;;IACA,IAAIiE,cAAc,CAACX,CAAD,CAAd,CAAkB,EAAlB,CAAJ,EACEoB,SAAS,CAACjE,IAAV,CACE,IAAIqE,KAAJ,CACEb,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CADF,EAEE,CAACW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAD,EAAuBW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAvB,CAFF,EAGE,CAACW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAD,EAAuBW,cAAc,CAACX,CAAD,CAAd,CAAkB,CAAlB,CAAvB,CAHF,EAIEtD,SAJF,EAKEA,SALF,EAME,IANF,EAOE,IAPF,CADF;EAWH;;EACD,IAAI+E,QAAQ,GAAGL,SAAS,CAACnE,MAAzB,CA9I+B,CA+I/B;;EACA,KAAK,IAAI+C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,0BAA0B,CAAClE,MAA/C,EAAuD+C,CAAC,EAAxD,EAA4D;IAC1D,KAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,0BAA0B,CAACnB,CAAD,CAA1B,CAA8B/C,MAAlD,EAA0DoE,CAAC,EAA3D,EAA+D;MAC7DF,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCK,IAAjC,CAAsC,UAAUC,CAAV,EAAaC,CAAb,EAAgB;QACpD,OAAOD,CAAC,CAACE,KAAF,GAAUD,CAAC,CAACC,KAAZ,GAAoB,CAAC,CAArB,GAAyB,CAAhC;MACD,CAFD;IAGD;EACF,CAtJ8B,CAwJ/B;;;EACA,IAAIC,6BAA6B,GAAG,EAApC;;EACA,KAAK,IAAI9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyB,QAApB,EAA8BzB,CAAC,EAA/B,EAAmC;IACjC8B,6BAA6B,CAAC3E,IAA9B,CAAmC;MACjC2B,IAAI,EAAEsC,SAAS,CAACpB,CAAD,CAAT,CAAarD,KAAb,CAAmB,CAAnB,CAD2B;MAEjCqC,IAAI,EAAEoC,SAAS,CAACpB,CAAD,CAAT,CAAarD,KAAb,CAAmB,CAAnB,CAF2B;MAGjCoC,IAAI,EAAEqC,SAAS,CAACpB,CAAD,CAAT,CAAarD,KAAb,CAAmB,CAAnB,CAH2B;MAIjCsC,IAAI,EAAEmC,SAAS,CAACpB,CAAD,CAAT,CAAarD,KAAb,CAAmB,CAAnB,CAJ2B;MAKjCoF,KAAK,EAAE/B;IAL0B,CAAnC,EADiC,CAO7B;EACL;;EACD,IAAIgC,cAAc,GAAGhG,KAAK,EAA1B;EACAgG,cAAc,CAAC1E,IAAf,CAAoBwE,6BAApB,EApK+B,CAsK/B;EACA;EACA;;EACA,KAAK,IAAI9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,0BAA0B,CAAClE,MAA/C,EAAuD+C,CAAC,EAAxD,EAA4D;IAC1D,KAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,0BAA0B,CAACnB,CAAD,CAA1B,CAA8B/C,MAAlD,EAA0DoE,CAAC,EAA3D,EAA+D;MAC7D,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCpE,MAArD,EAA6DgF,CAAC,EAA9D,EAAkE;QAChE,IAAIC,WAAJ;;QACA,IAAID,CAAC,IAAId,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCpE,MAAjC,GAA0C,CAAnD,EAAsD;UACpD;UACAiF,WAAW,GACTf,0BAA0B,CAACnB,CAAD,CAA1B,CACEuB,MAAM,CAACF,CAAC,GAAG,CAAL,EAAQjF,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6BoD,CAA7B,EAAgC/C,MAAhC,GAAyC,CAAjD,CADR,EAEE,CAFF,EAEKN,KAHP;QAID,CAND,MAMO;UACLuF,WAAW,GAAGf,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCY,CAAC,GAAG,CAArC,EAAwCtF,KAAtD;QACD;;QACD,IAAIwF,uBAAuB,GAAGH,cAAc,CAACtE,MAAf,CAAsB;UAClDoB,IAAI,EAAEoD,WAAW,CAAC,CAAD,CADiC;UAElDlD,IAAI,EAAEkD,WAAW,CAAC,CAAD,CAFiC;UAGlDnD,IAAI,EAAEmD,WAAW,CAAC,CAAD,CAHiC;UAIlDjD,IAAI,EAAEiD,WAAW,CAAC,CAAD;QAJiC,CAAtB,EAK3B,CAL2B,CAA9B,CAXgE,CAgBzD;;QACPf,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCY,CAAjC,EAAoCG,mBAApC,GACED,uBAAuB,CAACJ,KAD1B;MAED;IACF;EACF,CAhM8B,CAkM/B;;;EACA,KAAK,IAAI/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,0BAA0B,CAAClE,MAA/C,EAAuD+C,CAAC,EAAxD,EAA4D;IAC1D,KAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,0BAA0B,CAACnB,CAAD,CAA1B,CAA8B/C,MAAlD,EAA0DoE,CAAC,EAA3D,EAA+D;MAC7D,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCpE,MAArD,EAA6DgF,CAAC,EAA9D,EAAkE;QAChE,IAAIC,WAAW,GAAGf,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCY,CAAjC,EAAoCtF,KAAtD;QACA,IAAIwF,uBAAuB,GAAGH,cAAc,CAACtE,MAAf,CAAsB;UAClDoB,IAAI,EAAEoD,WAAW,CAAC,CAAD,CADiC;UAElDlD,IAAI,EAAEkD,WAAW,CAAC,CAAD,CAFiC;UAGlDnD,IAAI,EAAEmD,WAAW,CAAC,CAAD,CAHiC;UAIlDjD,IAAI,EAAEiD,WAAW,CAAC,CAAD;QAJiC,CAAtB,EAK3B,CAL2B,CAA9B,CAFgE,CAOzD;;QACP,IAAIjC,CAAC,GAAGkC,uBAAuB,CAACJ,KAAhC;;QACA,IAAI9B,CAAC,GAAGS,WAAR,EAAqB;UACnB;UACAU,SAAS,CAACnB,CAAD,CAAT,CAAaoC,yBAAb,GACElB,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCY,CAAjC,EAAoCG,mBADtC;QAED,CAJD,MAIO;UACL;UACA,IACE9B,aAAa,CACXc,SAAS,CAACnB,CAAD,CAAT,CAAaqC,YADF,EAEXnB,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCY,CAAjC,EAAoCM,aAFzB,CADf,EAKE;YACAnB,SAAS,CAACnB,CAAD,CAAT,CAAauC,yBAAb,GACErB,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCY,CAAjC,EAAoCG,mBADtC;UAED,CARD,MAQO;YACLhB,SAAS,CAACnB,CAAD,CAAT,CAAaoC,yBAAb,GACElB,0BAA0B,CAACnB,CAAD,CAA1B,CAA8BqB,CAA9B,EAAiCY,CAAjC,EAAoCG,mBADtC;UAED;QACF;MACF;IACF;EACF,CAnO8B,CAoO/B;EAEA;EACA;;;EACA,IAAIK,KAAK,GAAG,EAAZ,CAxO+B,CAyO/B;;EACA,IAAIzC,CAAC,GAAG,CAAR;;EACA,KAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,QAApB,EAA8BiB,CAAC,EAA/B,EAAmC;IACjC,IAAIqB,SAAS,GAAG1C,CAAhB;;IACA,KAAK,IAAIiC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7F,OAAO,CAACG,QAAR,CAAiBK,WAAjB,CAA6ByE,CAA7B,EAAgCpE,MAAhC,GAAyC,CAA7D,EAAgEgF,CAAC,EAAjE,EAAqE;MACnE,IAAIb,SAAS,CAACpB,CAAD,CAAT,CAAarD,KAAb,CAAmB,CAAnB,IAAwByE,SAAS,CAACsB,SAAD,CAAT,CAAqB/F,KAArB,CAA2B,CAA3B,CAA5B,EAA2D;QACzD+F,SAAS,GAAG1C,CAAZ;MACD;;MACDA,CAAC;IACF,CAPgC,CAQjC;IACA;;;IACA,IAAI2C,mBAAmB,GAAGvB,SAAS,CAACsB,SAAD,CAAT,CAAqBL,yBAA/C;;IACA,KAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,SAAS,CAACnE,MAA9B,EAAsCgF,CAAC,EAAvC,EAA2C;MACzC,IACEb,SAAS,CAACa,CAAD,CAAT,CAAaO,yBAAb,IAA0CE,SAA1C,IACAtB,SAAS,CAACa,CAAD,CAAT,CAAaI,yBAAb,IAA0CK,SAF5C,EAGE;QACA,IAAIE,oBAAoB,GAAGX,CAA3B;QACA;MACD;IACF;;IACD,IAAIY,cAAc,GAAGC,QAAQ,CAC3B,CACE1B,SAAS,CAACwB,oBAAD,CAAT,CAAgCjG,KADlC,EAEEyE,SAAS,CAACsB,SAAD,CAAT,CAAqB/F,KAFvB,EAGEyE,SAAS,CAACuB,mBAAD,CAAT,CAA+BhG,KAHjC,CAD2B,EAM3B,IAN2B,CAAR,GAQjB,CARiB,GASjB,CAAC,CATL;IAWA8F,KAAK,CAACtF,IAAN,CAAW;MAAEmB,KAAK,EAAEoE,SAAT;MAAoB5B,MAAM,EAAE,CAAC,CAA7B;MAAgCC,OAAO,EAAE8B;IAAzC,CAAX;EACD,CA3Q8B,CA4Q/B;;;EACAJ,KAAK,CAACf,IAAN,CAAW,UAAUC,CAAV,EAAaC,CAAb,EAAgB;IACzB,OAAOR,SAAS,CAACO,CAAC,CAACrD,KAAH,CAAT,CAAmB3B,KAAnB,GAA2ByE,SAAS,CAACQ,CAAC,CAACtD,KAAH,CAAT,CAAmB3B,KAA9C,GAAsD,CAAC,CAAvD,GAA2D,CAAlE;EACD,CAFD,EA7Q+B,CAiR/B;;EACA,IAAIkE,kBAAkB,GAAG,EAAzB,CAlR+B,CAoR/B;;EACA,OAAO4B,KAAK,CAACxF,MAAN,GAAe,CAAtB,EAAyB;IACvB;IACA,IAAI8F,MAAM,GAAGN,KAAK,CAACO,GAAN,EAAb;IACA,IAAIC,UAAU,GAAGF,MAAM,CAACzE,KAAxB;IACA,IAAI4E,uBAAuB,GAAGH,MAAM,CAACjC,MAArC;IACA,IAAIqC,wBAAwB,GAAGJ,MAAM,CAAChC,OAAtC,CALuB,CAMvB;;IACA,IAAIqC,iBAAiB,GAAGvC,kBAAkB,CAAC5D,MAA3C;IACA,IAAIoG,uBAAuB,GAAG,CAACjC,SAAS,CAAC6B,UAAD,CAAT,CAAsBtG,KAAvB,CAA9B,CARuB,CASvB;;IACA,IAAI2G,YAAY,GAAGL,UAAnB;;IACA,IAAI7B,SAAS,CAAC6B,UAAD,CAAT,CAAsBM,oBAA1B,EAAgD;MAC9C,IAAIC,kBAAkB,GAAGpC,SAAS,CAAC6B,UAAD,CAAT,CAAsBX,YAA/C;MACA,IAAImB,QAAQ,GAAGrC,SAAS,CAAC6B,UAAD,CAAT,CAAsBT,yBAArC;IACD,CAHD,MAGO;MACL,IAAIgB,kBAAkB,GAAGpC,SAAS,CAAC6B,UAAD,CAAT,CAAsBS,YAA/C;MACA,IAAID,QAAQ,GAAGrC,SAAS,CAAC6B,UAAD,CAAT,CAAsBZ,yBAArC;IACD,CAjBsB,CAkBvB;;;IACA,OACE,CAAC/B,aAAa,CAACc,SAAS,CAAC6B,UAAD,CAAT,CAAsBtG,KAAvB,EAA8ByE,SAAS,CAACqC,QAAD,CAAT,CAAoB9G,KAAlD,CADhB,EAEE;MACA0G,uBAAuB,CAAClG,IAAxB,CAA6BiE,SAAS,CAACqC,QAAD,CAAT,CAAoB9G,KAAjD,EADA,CAEA;;MACA,IAAIgH,eAAe,GAAGjH,SAAtB;;MACA,KAAK,IAAIsD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,KAAK,CAACxF,MAA1B,EAAkC+C,CAAC,EAAnC,EAAuC;QACrC,IAAIyC,KAAK,CAACzC,CAAD,CAAL,CAAS1B,KAAT,IAAkBmF,QAAtB,EAAgC;UAC9BE,eAAe,GAAG3D,CAAlB;UACA;QACD;MACF;;MACD,IAAI2D,eAAe,IAAIjH,SAAvB,EAAkC;QAChC+F,KAAK,CAACmB,MAAN,CAAaD,eAAb,EAA8B,CAA9B;MACD,CAZD,CAaA;MACA;MACA;MACA;MACA;;;MACA,IAAIrD,aAAa,CAACkD,kBAAD,EAAqBpC,SAAS,CAACqC,QAAD,CAAT,CAAoBnB,YAAzC,CAAjB,EAAyE;QACvEkB,kBAAkB,GAAGpC,SAAS,CAACqC,QAAD,CAAT,CAAoBC,YAAzC;QACAtC,SAAS,CAACqC,QAAD,CAAT,CAAoBI,oBAApB,GAA2C,KAA3C;;QACA,IAAIzC,SAAS,CAACqC,QAAD,CAAT,CAAoBF,oBAAxB,EAA8C;UAC5C,IAAIO,OAAO,GAAG;YAAExF,KAAK,EAAEmF;UAAT,CAAd;;UACA,IACEX,QAAQ,CACN,CACE1B,SAAS,CAACkC,YAAD,CAAT,CAAwB3G,KAD1B,EAEEyE,SAAS,CAACqC,QAAD,CAAT,CAAoB9G,KAFtB,EAGEyE,SAAS,CAACA,SAAS,CAACqC,QAAD,CAAT,CAAoBpB,yBAArB,CAAT,CAAyD1F,KAH3D,CADM,EAMNwG,wBAAwB,IAAI,CANtB,CADV,EASE;YACAW,OAAO,CAAChD,MAAR,GAAiBoC,uBAAjB;YACAY,OAAO,CAAC/C,OAAR,GAAkB,CAACoC,wBAAnB;UACD,CAZD,MAYO;YACLW,OAAO,CAAChD,MAAR,GAAiBsC,iBAAjB;YACAU,OAAO,CAAC/C,OAAR,GAAkBoC,wBAAlB;UACD;;UACDV,KAAK,CAACtF,IAAN,CAAW2G,OAAX;QACD;;QACDR,YAAY,GAAGG,QAAf;QACAA,QAAQ,GAAGrC,SAAS,CAACqC,QAAD,CAAT,CAAoBpB,yBAA/B;MACD,CAzBD,MAyBO;QACLmB,kBAAkB,GAAGpC,SAAS,CAACqC,QAAD,CAAT,CAAoBnB,YAAzC;QACAlB,SAAS,CAACqC,QAAD,CAAT,CAAoBF,oBAApB,GAA2C,KAA3C;;QACA,IAAInC,SAAS,CAACqC,QAAD,CAAT,CAAoBI,oBAAxB,EAA8C;UAC5C,IAAIC,OAAO,GAAG;YAAExF,KAAK,EAAEmF;UAAT,CAAd;;UACA,IACEX,QAAQ,CACN,CACE1B,SAAS,CAACkC,YAAD,CAAT,CAAwB3G,KAD1B,EAEEyE,SAAS,CAACqC,QAAD,CAAT,CAAoB9G,KAFtB,EAGEyE,SAAS,CAACA,SAAS,CAACqC,QAAD,CAAT,CAAoBjB,yBAArB,CAAT,CAAyD7F,KAH3D,CADM,EAMNwG,wBAAwB,IAAI,CANtB,CADV,EASE;YACAW,OAAO,CAAChD,MAAR,GAAiBoC,uBAAjB;YACAY,OAAO,CAAC/C,OAAR,GAAkB,CAACoC,wBAAnB;UACD,CAZD,MAYO;YACLW,OAAO,CAAChD,MAAR,GAAiBsC,iBAAjB;YACAU,OAAO,CAAC/C,OAAR,GAAkBoC,wBAAlB;UACD;;UACDV,KAAK,CAACtF,IAAN,CAAW2G,OAAX;QACD;;QACDR,YAAY,GAAGG,QAAf;QACAA,QAAQ,GAAGrC,SAAS,CAACqC,QAAD,CAAT,CAAoBjB,yBAA/B;MACD;IACF,CA1FsB,CA2FvB;;;IACAa,uBAAuB,CAAClG,IAAxB,CAA6BiE,SAAS,CAACqC,QAAD,CAAT,CAAoB9G,KAAjD,EA5FuB,CA6FvB;;IACAkE,kBAAkB,CAAC1D,IAAnB,CACErB,OAAO,CAAC,CAACuH,uBAAD,CAAD,EAA4B;MACjCtB,KAAK,EAAEqB,iBAD0B;MAEjCtC,MAAM,EAAEoC,uBAFyB;MAGjCnC,OAAO,EAAEoC,wBAHwB;MAIjCY,UAAU,EAAErH;IAJqB,CAA5B,CADT;EAQD;;EAED,IAAIG,MAAM,GAAGd,iBAAiB,CAAC8E,kBAAD,CAA9B;EAEAI,gBAAgB;EAEhBC,aAAa,GAjYkB,CAmY/B;;EACA,SAASD,gBAAT,GAA4B;IAC1B,IAAI+C,qBAAqB,GAAG,EAA5B;;IACA,KAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnD,MAAM,CAACoH,QAAP,CAAgBhH,MAApC,EAA4C+C,CAAC,EAA7C,EAAiD;MAC/C,IAAInD,MAAM,CAACoH,QAAP,CAAgBjE,CAAhB,EAAmBkE,UAAnB,CAA8BpD,MAA9B,IAAwC,CAAC,CAA7C,EACEkD,qBAAqB,CAAC7G,IAAtB,CAA2B6C,CAA3B;IACH;;IACD,IAAIgE,qBAAqB,CAAC/G,MAAtB,GAA+B,CAAnC,EAAsC;MACpC,KAAK,IAAI+C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgE,qBAAqB,CAAC/G,MAA1C,EAAkD+C,CAAC,EAAnD,EAAuD;QACrD,IAAIc,MAAM,GAAG,CAAC,CAAd;QACA,IAAIqD,UAAU,GAAGC,QAAjB;;QACA,KAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxE,MAAM,CAACoH,QAAP,CAAgBhH,MAApC,EAA4CoE,CAAC,EAA7C,EAAiD;UAC/C,IAAI2C,qBAAqB,CAAChE,CAAD,CAArB,IAA4BqB,CAAhC,EAAmC;;UACnC,IACEnF,qBAAqB,CACnBW,MAAM,CAACoH,QAAP,CAAgBD,qBAAqB,CAAChE,CAAD,CAArC,EAA0CzD,QAA1C,CACGK,WADH,CACe,CADf,EACkB,CADlB,CADmB,EAGnBC,MAAM,CAACoH,QAAP,CAAgB5C,CAAhB,CAHmB,EAInB;YAAEgD,cAAc,EAAE;UAAlB,CAJmB,CADvB,EAOE;YACA,IAAIpI,IAAI,CAACY,MAAM,CAACoH,QAAP,CAAgB5C,CAAhB,CAAD,CAAJ,GAA2B8C,UAA/B,EAA2C;cACzCrD,MAAM,GAAGO,CAAT;YACD;UACF;QACF;;QACDxE,MAAM,CAACoH,QAAP,CAAgBD,qBAAqB,CAAChE,CAAD,CAArC,EAA0CkE,UAA1C,CAAqDpD,MAArD,GAA8DA,MAA9D;MACD;IACF;EACF;;EAED,SAASI,aAAT,GAAyB;IACvB,KAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnD,MAAM,CAACoH,QAAP,CAAgBhH,MAApC,EAA4C+C,CAAC,EAA7C,EAAiD;MAC/C,IAAInD,MAAM,CAACoH,QAAP,CAAgBjE,CAAhB,EAAmBkE,UAAnB,CAA8BpD,MAA9B,IAAwC,CAAC,CAA7C,EAAgD;QAC9C,IAAIiD,UAAU,GAAGlH,MAAM,CAACoH,QAAP,CAAgBjE,CAAhB,EAAmBkE,UAAnB,CAA8BnD,OAA/C;QACAlE,MAAM,CAACoH,QAAP,CAAgBjE,CAAhB,EAAmBkE,UAAnB,CAA8BH,UAA9B,GAA2CA,UAA3C;QACAO,uBAAuB,CAACtE,CAAD,EAAI+D,UAAJ,CAAvB;MACD;IACF;EACF;;EAED,SAASO,uBAAT,CAAiCxD,MAAjC,EAAyCyD,gBAAzC,EAA2D;IACzD,KAAK,IAAIvE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnD,MAAM,CAACoH,QAAP,CAAgBhH,MAApC,EAA4C+C,CAAC,EAA7C,EAAiD;MAC/C,IAAInD,MAAM,CAACoH,QAAP,CAAgBjE,CAAhB,EAAmBkE,UAAnB,CAA8BpD,MAA9B,IAAwCA,MAA5C,EAAoD;QAClD,IAAIiD,UAAU,GACZQ,gBAAgB,GAAG1H,MAAM,CAACoH,QAAP,CAAgBjE,CAAhB,EAAmBkE,UAAnB,CAA8BnD,OADnD;QAEAlE,MAAM,CAACoH,QAAP,CAAgBjE,CAAhB,EAAmBkE,UAAnB,CAA8BH,UAA9B,GAA2CA,UAA3C;QACAO,uBAAuB,CAACtE,CAAD,EAAI+D,UAAJ,CAAvB;MACD;IACF;EACF;;EAED,OAAOlH,MAAP;AACD,C,CAED;;;AACA,IAAIyE,SAAS,GAAG,SAAZA,SAAY,CACd3E,KADc,EAEdkF,KAFc,EAGdU,aAHc,EAIdiC,cAJc,EAKdpC,mBALc,EAMd;EACA,KAAKzF,KAAL,GAAaA,KAAb,CADA,CACoB;;EACpB,KAAKkF,KAAL,GAAaA,KAAb,CAFA,CAEoB;;EACpB,KAAKU,aAAL,GAAqBA,aAArB,CAHA,CAGoC;;EACpC,KAAKiC,cAAL,GAAsBA,cAAtB,CAJA,CAIsC;;EACtC,KAAKpC,mBAAL,GAA2BA,mBAA3B,CALA,CAKgD;AACjD,CAZD,C,CAcA;;;AACA,IAAIZ,KAAK,GAAG,SAARA,KAAQ,CACV7E,KADU,EAEV2F,YAFU,EAGVoB,YAHU,EAIVlB,yBAJU,EAKVH,yBALU,EAMVkB,oBANU,EAOVM,oBAPU,EAQV;EACA,KAAKlH,KAAL,GAAaA,KAAb,CADA,CACoB;;EACpB,KAAK2F,YAAL,GAAoBA,YAApB,CAFA,CAEkC;;EAClC,KAAKoB,YAAL,GAAoBA,YAApB,CAHA,CAGkC;;EAClC,KAAKlB,yBAAL,GAAiCA,yBAAjC,CAJA,CAI4D;;EAC5D,KAAKH,yBAAL,GAAiCA,yBAAjC,CALA,CAK4D;;EAC5D,KAAKkB,oBAAL,GAA4BA,oBAA5B,CANA,CAMkD;;EAClD,KAAKM,oBAAL,GAA4BA,oBAA5B,CAPA,CAOkD;AACnD,CAhBD,C,CAkBA;;;AACA,SAASf,QAAT,CAAkB2B,GAAlB,EAAuBC,WAAvB,EAAoC;EAClC;EACA;EACA,IAAI,OAAOA,WAAP,KAAuB,WAA3B,EAAwCA,WAAW,GAAG,IAAd;EACxC,IAAID,GAAG,CAACxH,MAAJ,IAAc,CAAlB,EACE,MAAM,IAAIR,KAAJ,CAAU,uDAAV,CAAN;EACF,IAAIkI,CAAC,GACH,CAACF,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,IAAYA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,CAAb,KAA2BA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,IAAYA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,CAAvC,IACA,CAACA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,IAAYA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,CAAb,KAA2BA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,IAAYA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,CAAvC,CAFF;EAGA,OAAOE,CAAC,IAAI,CAAL,IAAUD,WAAjB;AACD,C,CAED;;;AACA,SAAS1D,aAAT,CAAuBlD,IAAvB,EAA6B;EAC3B;EACA;EACA,IAAI8G,OAAO,GAAG,CAAd;;EACA,KAAK,IAAI5E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlC,IAAI,CAACb,MAAL,GAAc,CAAlC,EAAqC+C,CAAC,EAAtC,EAA0C;IACxC,IAAIlC,IAAI,CAACkC,CAAD,CAAJ,CAAQ,CAAR,IAAalC,IAAI,CAAC8G,OAAD,CAAJ,CAAc,CAAd,CAAjB,EAAmCA,OAAO,GAAG5E,CAAV;EACpC;;EACD,IACE8C,QAAQ,CACN,CACEhF,IAAI,CAACyD,MAAM,CAACqD,OAAO,GAAG,CAAX,EAAc9G,IAAI,CAACb,MAAL,GAAc,CAA5B,CAAP,CADN,EAEEa,IAAI,CAAC8G,OAAD,CAFN,EAGE9G,IAAI,CAACyD,MAAM,CAACqD,OAAO,GAAG,CAAX,EAAc9G,IAAI,CAACb,MAAL,GAAc,CAA5B,CAAP,CAHN,CADM,EAMN,IANM,CADV,EASE;IACA,IAAI8D,OAAO,GAAG,CAAd;EACD,CAXD,MAWO;IACL,IAAIA,OAAO,GAAG,CAAC,CAAf;EACD;;EACD,OAAOA,OAAP;AACD,C,CAED;;;AACA,SAAST,aAAT,CAAuBR,MAAvB,EAA+BC,MAA/B,EAAuC;EACrC;EACA,IAAI,CAACD,MAAD,IAAW,CAACC,MAAhB,EAAwB,OAAO,KAAP,CAFa,CAIrC;;EACA,IAAID,MAAM,CAAC7C,MAAP,IAAiB8C,MAAM,CAAC9C,MAA5B,EAAoC,OAAO,KAAP;;EAEpC,KAAK,IAAI+C,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGH,MAAM,CAAC7C,MAA3B,EAAmC+C,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;IAC7C;IACA,IAAIF,MAAM,CAACE,CAAD,CAAN,YAAqBE,KAArB,IAA8BH,MAAM,CAACC,CAAD,CAAN,YAAqBE,KAAvD,EAA8D;MAC5D;MACA,IAAI,CAACI,aAAa,CAACR,MAAM,CAACE,CAAD,CAAP,EAAYD,MAAM,CAACC,CAAD,CAAlB,CAAlB,EAA0C,OAAO,KAAP;IAC3C,CAHD,MAGO,IAAIF,MAAM,CAACE,CAAD,CAAN,IAAaD,MAAM,CAACC,CAAD,CAAvB,EAA4B;MACjC;MACA,OAAO,KAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD,C,CAED;;;AACA,SAASuB,MAAT,CAAgBsD,CAAhB,EAAmBC,CAAnB,EAAsB;EACpB,OAAO,CAAED,CAAC,GAAGC,CAAL,GAAUA,CAAX,IAAgBA,CAAvB;AACD,C,CAED;;;AACA,SAASrE,QAAT,CAAkBsE,KAAlB,EAAyB;EACvB,IAAIC,CAAC,GAAG,EAAR;EACA,IAAIvE,QAAQ,GAAG,CAAf;;EACA,KAAK,IAAIT,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8E,KAAK,CAAC9H,MAA1B,EAAkC+C,CAAC,GAAGC,CAAtC,EAAyC,EAAED,CAA3C,EAA8C;IAC5C,IAAIiF,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,CAArC,EAAwCD,KAAK,CAAC/E,CAAD,CAA7C,CAAJ,EAAuD;MACrDS,QAAQ,GAAG,CAAX;MACA;IACD;;IACDuE,CAAC,CAACD,KAAK,CAAC/E,CAAD,CAAN,CAAD,GAAc,CAAd;EACD;;EACD,OAAOS,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS4E,aAAT,CAAuBC,OAAvB,EAAgC;EAC9B,IAAIrB,QAAQ,GAAG,EAAf;EACArI,WAAW,CAAC0J,OAAD,EAAU,UAAUlJ,OAAV,EAAmB;IACtC,IAAIA,OAAO,CAACG,QAAR,CAAiBC,IAAjB,KAA0B,SAA9B,EAAyC;IACzCX,WAAW,CAACsE,aAAa,CAAC/D,OAAD,CAAd,EAAyB,UAAUmJ,IAAV,EAAgB;MAClDtB,QAAQ,CAAC9G,IAAT,CAAcrB,OAAO,CAACyJ,IAAI,CAAChJ,QAAL,CAAcK,WAAf,EAA4BR,OAAO,CAAC8H,UAApC,CAArB;IACD,CAFU,CAAX;EAGD,CALU,CAAX;EAMA,OAAOnI,iBAAiB,CAACkI,QAAD,CAAxB;AACD;;AAED,eAAeoB,aAAf"},"metadata":{},"sourceType":"module"}