{"ast":null,"code":"import turfBBox from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport clone from \"@turf/clone\";\n/**\r\n * Converts (Multi)LineString(s) to Polygon(s).\r\n *\r\n * @name lineToPolygon\r\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\r\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\r\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\r\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\r\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\r\n * @example\r\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\r\n *\r\n * var polygon = turf.lineToPolygon(line);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon];\r\n */\n\nfunction lineToPolygon(lines, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a, _b, _c; // Optional parameters\n\n\n  var properties = options.properties;\n  var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;\n  var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;\n  var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;\n\n  if (!mutate) {\n    lines = clone(lines);\n  }\n\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords = [];\n      lines.features.forEach(function (line) {\n        coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));\n      });\n      return multiPolygon(coords, properties);\n\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\n/**\r\n * LineString to Polygon\r\n *\r\n * @private\r\n * @param {Feature<LineString|MultiLineString>} line line\r\n * @param {Object} [properties] translates GeoJSON properties to Feature\r\n * @param {boolean} [autoComplete=true] auto complete linestrings\r\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\r\n * @returns {Feature<Polygon>} line converted to Polygon\r\n */\n\n\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n  properties = properties ? properties : line.type === \"Feature\" ? line.properties : {};\n  var geom = getGeom(line);\n  var coords = geom.coordinates;\n  var type = geom.type;\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords);\n      return polygon([coords], properties);\n\n    case \"MultiLineString\":\n      var multiCoords = [];\n      var largestArea = 0;\n      coords.forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord); // Largest LineString to be placed in the first position of the coordinates array\n\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\n/**\r\n * Auto Complete Coords - matches first & last coordinates\r\n *\r\n * @private\r\n * @param {Array<Array<number>>} coords Coordinates\r\n * @returns {Array<Array<number>>} auto completed coordinates\r\n */\n\n\nfunction autoCompleteCoords(coords) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n\n  return coords;\n}\n/**\r\n * area - quick approximate area calculation (used to sort)\r\n *\r\n * @private\r\n * @param {Array<number>} bbox BBox [west, south, east, north]\r\n * @returns {number} very quick area calculation\r\n */\n\n\nfunction calculateArea(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\n\nexport default lineToPolygon;","map":{"version":3,"names":["turfBBox","getCoords","getGeom","polygon","multiPolygon","lineString","clone","lineToPolygon","lines","options","_a","_b","_c","properties","autoComplete","orderCoords","mutate","type","coords","features","forEach","line","push","lineStringToPolygon","geom","coordinates","length","Error","autoCompleteCoords","multiCoords","largestArea","coord","area","calculateArea","unshift","first","x1","y1","last","x2","y2","bbox","west","south","east","north","Math","abs"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/line-to-polygon/dist/es/index.js"],"sourcesContent":["import turfBBox from \"@turf/bbox\";\r\nimport { getCoords, getGeom } from \"@turf/invariant\";\r\nimport { polygon, multiPolygon, lineString, } from \"@turf/helpers\";\r\nimport clone from \"@turf/clone\";\r\n/**\r\n * Converts (Multi)LineString(s) to Polygon(s).\r\n *\r\n * @name lineToPolygon\r\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\r\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\r\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\r\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\r\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\r\n * @example\r\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\r\n *\r\n * var polygon = turf.lineToPolygon(line);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon];\r\n */\r\nfunction lineToPolygon(lines, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var _a, _b, _c;\r\n    // Optional parameters\r\n    var properties = options.properties;\r\n    var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;\r\n    var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;\r\n    var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;\r\n    if (!mutate) {\r\n        lines = clone(lines);\r\n    }\r\n    switch (lines.type) {\r\n        case \"FeatureCollection\":\r\n            var coords = [];\r\n            lines.features.forEach(function (line) {\r\n                coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));\r\n            });\r\n            return multiPolygon(coords, properties);\r\n        default:\r\n            return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\r\n    }\r\n}\r\n/**\r\n * LineString to Polygon\r\n *\r\n * @private\r\n * @param {Feature<LineString|MultiLineString>} line line\r\n * @param {Object} [properties] translates GeoJSON properties to Feature\r\n * @param {boolean} [autoComplete=true] auto complete linestrings\r\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\r\n * @returns {Feature<Polygon>} line converted to Polygon\r\n */\r\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\r\n    properties = properties\r\n        ? properties\r\n        : line.type === \"Feature\"\r\n            ? line.properties\r\n            : {};\r\n    var geom = getGeom(line);\r\n    var coords = geom.coordinates;\r\n    var type = geom.type;\r\n    if (!coords.length)\r\n        throw new Error(\"line must contain coordinates\");\r\n    switch (type) {\r\n        case \"LineString\":\r\n            if (autoComplete)\r\n                coords = autoCompleteCoords(coords);\r\n            return polygon([coords], properties);\r\n        case \"MultiLineString\":\r\n            var multiCoords = [];\r\n            var largestArea = 0;\r\n            coords.forEach(function (coord) {\r\n                if (autoComplete)\r\n                    coord = autoCompleteCoords(coord);\r\n                // Largest LineString to be placed in the first position of the coordinates array\r\n                if (orderCoords) {\r\n                    var area = calculateArea(turfBBox(lineString(coord)));\r\n                    if (area > largestArea) {\r\n                        multiCoords.unshift(coord);\r\n                        largestArea = area;\r\n                    }\r\n                    else\r\n                        multiCoords.push(coord);\r\n                }\r\n                else {\r\n                    multiCoords.push(coord);\r\n                }\r\n            });\r\n            return polygon(multiCoords, properties);\r\n        default:\r\n            throw new Error(\"geometry type \" + type + \" is not supported\");\r\n    }\r\n}\r\n/**\r\n * Auto Complete Coords - matches first & last coordinates\r\n *\r\n * @private\r\n * @param {Array<Array<number>>} coords Coordinates\r\n * @returns {Array<Array<number>>} auto completed coordinates\r\n */\r\nfunction autoCompleteCoords(coords) {\r\n    var first = coords[0];\r\n    var x1 = first[0];\r\n    var y1 = first[1];\r\n    var last = coords[coords.length - 1];\r\n    var x2 = last[0];\r\n    var y2 = last[1];\r\n    if (x1 !== x2 || y1 !== y2) {\r\n        coords.push(first);\r\n    }\r\n    return coords;\r\n}\r\n/**\r\n * area - quick approximate area calculation (used to sort)\r\n *\r\n * @private\r\n * @param {Array<number>} bbox BBox [west, south, east, north]\r\n * @returns {number} very quick area calculation\r\n */\r\nfunction calculateArea(bbox) {\r\n    var west = bbox[0];\r\n    var south = bbox[1];\r\n    var east = bbox[2];\r\n    var north = bbox[3];\r\n    return Math.abs(west - east) * Math.abs(south - north);\r\n}\r\nexport default lineToPolygon;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}