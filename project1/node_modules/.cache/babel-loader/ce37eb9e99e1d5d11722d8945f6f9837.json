{"ast":null,"code":"import clipBuffer from \"./buffer\";\nimport clipPolygon from \"./polygon\";\nimport { epsilon, halfPi } from \"../math\";\nimport polygonContains from \"../polygonContains\";\nimport { merge } from \"d3-array\";\nexport default function (pointVisible, clipLine, interpolate, start) {\n  return function (rotate, sink) {\n    var line = clipLine(sink),\n        rotatedStart = rotate.invert(start[0], start[1]),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function polygonStart() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function polygonEnd() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function sphere() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i,\n          n = ringSegments.length,\n          m,\n          segment,\n          point;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n) return; // No intersections.\n\n      if (clean & 1) {\n        segment = ringSegments[0];\n\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n\n          for (i = 0; i < m; ++i) {\n            sink.point((point = segment[i])[0], point[1]);\n          }\n\n          sink.lineEnd();\n        }\n\n        return;\n      } // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n\n\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n} // Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\n\n\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}","map":{"version":3,"names":["clipBuffer","clipPolygon","epsilon","halfPi","polygonContains","merge","pointVisible","clipLine","interpolate","start","rotate","sink","line","rotatedStart","invert","ringBuffer","ringSink","polygonStarted","polygon","segments","ring","clip","point","lineStart","lineEnd","polygonStart","pointRing","ringStart","ringEnd","polygonEnd","startInside","length","compareIntersection","sphere","lambda","phi","pointLine","push","clean","ringSegments","result","i","n","m","segment","pop","concat","shift","filter","validSegment","a","b","x"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/d3-geo/src/clip/index.js"],"sourcesContent":["import clipBuffer from \"./buffer\";\r\nimport clipPolygon from \"./polygon\";\r\nimport {epsilon, halfPi} from \"../math\";\r\nimport polygonContains from \"../polygonContains\";\r\nimport {merge} from \"d3-array\";\r\n\r\nexport default function(pointVisible, clipLine, interpolate, start) {\r\n  return function(rotate, sink) {\r\n    var line = clipLine(sink),\r\n        rotatedStart = rotate.invert(start[0], start[1]),\r\n        ringBuffer = clipBuffer(),\r\n        ringSink = clipLine(ringBuffer),\r\n        polygonStarted = false,\r\n        polygon,\r\n        segments,\r\n        ring;\r\n\r\n    var clip = {\r\n      point: point,\r\n      lineStart: lineStart,\r\n      lineEnd: lineEnd,\r\n      polygonStart: function() {\r\n        clip.point = pointRing;\r\n        clip.lineStart = ringStart;\r\n        clip.lineEnd = ringEnd;\r\n        segments = [];\r\n        polygon = [];\r\n      },\r\n      polygonEnd: function() {\r\n        clip.point = point;\r\n        clip.lineStart = lineStart;\r\n        clip.lineEnd = lineEnd;\r\n        segments = merge(segments);\r\n        var startInside = polygonContains(polygon, rotatedStart);\r\n        if (segments.length) {\r\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\r\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\r\n        } else if (startInside) {\r\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\r\n          sink.lineStart();\r\n          interpolate(null, null, 1, sink);\r\n          sink.lineEnd();\r\n        }\r\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\r\n        segments = polygon = null;\r\n      },\r\n      sphere: function() {\r\n        sink.polygonStart();\r\n        sink.lineStart();\r\n        interpolate(null, null, 1, sink);\r\n        sink.lineEnd();\r\n        sink.polygonEnd();\r\n      }\r\n    };\r\n\r\n    function point(lambda, phi) {\r\n      var point = rotate(lambda, phi);\r\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\r\n    }\r\n\r\n    function pointLine(lambda, phi) {\r\n      var point = rotate(lambda, phi);\r\n      line.point(point[0], point[1]);\r\n    }\r\n\r\n    function lineStart() {\r\n      clip.point = pointLine;\r\n      line.lineStart();\r\n    }\r\n\r\n    function lineEnd() {\r\n      clip.point = point;\r\n      line.lineEnd();\r\n    }\r\n\r\n    function pointRing(lambda, phi) {\r\n      ring.push([lambda, phi]);\r\n      var point = rotate(lambda, phi);\r\n      ringSink.point(point[0], point[1]);\r\n    }\r\n\r\n    function ringStart() {\r\n      ringSink.lineStart();\r\n      ring = [];\r\n    }\r\n\r\n    function ringEnd() {\r\n      pointRing(ring[0][0], ring[0][1]);\r\n      ringSink.lineEnd();\r\n\r\n      var clean = ringSink.clean(),\r\n          ringSegments = ringBuffer.result(),\r\n          i, n = ringSegments.length, m,\r\n          segment,\r\n          point;\r\n\r\n      ring.pop();\r\n      polygon.push(ring);\r\n      ring = null;\r\n\r\n      if (!n) return;\r\n\r\n      // No intersections.\r\n      if (clean & 1) {\r\n        segment = ringSegments[0];\r\n        if ((m = segment.length - 1) > 0) {\r\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\r\n          sink.lineStart();\r\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\r\n          sink.lineEnd();\r\n        }\r\n        return;\r\n      }\r\n\r\n      // Rejoin connected segments.\r\n      // TODO reuse ringBuffer.rejoin()?\r\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\r\n\r\n      segments.push(ringSegments.filter(validSegment));\r\n    }\r\n\r\n    return clip;\r\n  };\r\n}\r\n\r\nfunction validSegment(segment) {\r\n  return segment.length > 1;\r\n}\r\n\r\n// Intersections are sorted along the clip edge. For both antimeridian cutting\r\n// and circle clipping, the same comparison is used.\r\nfunction compareIntersection(a, b) {\r\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\r\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}