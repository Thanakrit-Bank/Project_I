{"ast":null,"code":"import { getCoords, getType } from '@turf/invariant';\nimport { lineString } from '@turf/helpers';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Coord} startPt starting point\n * @param {Coord} stopPt stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var start = turf.point([-77.029609, 38.881946]);\n * var stop = turf.point([-77.021884, 38.889563]);\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //addToMap\n * var addToMap = [start, stop, line]\n */\n\nfunction lineSlice(startPt, stopPt, line) {\n  // Validation\n  var coords = getCoords(line);\n  if (getType(line) !== \"LineString\") throw new Error(\"line must be a LineString\");\n  var startVertex = nearestPointOnLine(line, startPt);\n  var stopVertex = nearestPointOnLine(line, stopPt);\n  var ends;\n\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n\n  var clipCoords = [ends[0].geometry.coordinates];\n\n  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n    clipCoords.push(coords[i]);\n  }\n\n  clipCoords.push(ends[1].geometry.coordinates);\n  return lineString(clipCoords, line.properties);\n}\n\nexport default lineSlice;","map":{"version":3,"names":["getCoords","getType","lineString","nearestPointOnLine","lineSlice","startPt","stopPt","line","coords","Error","startVertex","stopVertex","ends","properties","index","clipCoords","geometry","coordinates","i","push"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/@turf/line-slice/dist/es/index.js"],"sourcesContent":["import { getCoords, getType } from '@turf/invariant';\nimport { lineString } from '@turf/helpers';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\n\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Coord} startPt starting point\n * @param {Coord} stopPt stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var start = turf.point([-77.029609, 38.881946]);\n * var stop = turf.point([-77.021884, 38.889563]);\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //addToMap\n * var addToMap = [start, stop, line]\n */\nfunction lineSlice(startPt, stopPt, line) {\n  // Validation\n  var coords = getCoords(line);\n  if (getType(line) !== \"LineString\")\n    throw new Error(\"line must be a LineString\");\n\n  var startVertex = nearestPointOnLine(line, startPt);\n  var stopVertex = nearestPointOnLine(line, stopPt);\n  var ends;\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n  var clipCoords = [ends[0].geometry.coordinates];\n  for (\n    var i = ends[0].properties.index + 1;\n    i < ends[1].properties.index + 1;\n    i++\n  ) {\n    clipCoords.push(coords[i]);\n  }\n  clipCoords.push(ends[1].geometry.coordinates);\n  return lineString(clipCoords, line.properties);\n}\n\nexport default lineSlice;\n"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,OAApB,QAAmC,iBAAnC;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,OAAOC,kBAAP,MAA+B,6BAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,IAApC,EAA0C;EACxC;EACA,IAAIC,MAAM,GAAGR,SAAS,CAACO,IAAD,CAAtB;EACA,IAAIN,OAAO,CAACM,IAAD,CAAP,KAAkB,YAAtB,EACE,MAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;EAEF,IAAIC,WAAW,GAAGP,kBAAkB,CAACI,IAAD,EAAOF,OAAP,CAApC;EACA,IAAIM,UAAU,GAAGR,kBAAkB,CAACI,IAAD,EAAOD,MAAP,CAAnC;EACA,IAAIM,IAAJ;;EACA,IAAIF,WAAW,CAACG,UAAZ,CAAuBC,KAAvB,IAAgCH,UAAU,CAACE,UAAX,CAAsBC,KAA1D,EAAiE;IAC/DF,IAAI,GAAG,CAACF,WAAD,EAAcC,UAAd,CAAP;EACD,CAFD,MAEO;IACLC,IAAI,GAAG,CAACD,UAAD,EAAaD,WAAb,CAAP;EACD;;EACD,IAAIK,UAAU,GAAG,CAACH,IAAI,CAAC,CAAD,CAAJ,CAAQI,QAAR,CAAiBC,WAAlB,CAAjB;;EACA,KACE,IAAIC,CAAC,GAAGN,IAAI,CAAC,CAAD,CAAJ,CAAQC,UAAR,CAAmBC,KAAnB,GAA2B,CADrC,EAEEI,CAAC,GAAGN,IAAI,CAAC,CAAD,CAAJ,CAAQC,UAAR,CAAmBC,KAAnB,GAA2B,CAFjC,EAGEI,CAAC,EAHH,EAIE;IACAH,UAAU,CAACI,IAAX,CAAgBX,MAAM,CAACU,CAAD,CAAtB;EACD;;EACDH,UAAU,CAACI,IAAX,CAAgBP,IAAI,CAAC,CAAD,CAAJ,CAAQI,QAAR,CAAiBC,WAAjC;EACA,OAAOf,UAAU,CAACa,UAAD,EAAaR,IAAI,CAACM,UAAlB,CAAjB;AACD;;AAED,eAAeT,SAAf"},"metadata":{},"sourceType":"module"}