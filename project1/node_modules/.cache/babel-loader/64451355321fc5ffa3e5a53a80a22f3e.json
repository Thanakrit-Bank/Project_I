{"ast":null,"code":"import bounds from \"./bounds.js\";\nimport cut from \"./cut.js\";\nimport dedup from \"./dedup.js\";\nimport delta from \"./delta.js\";\nimport extract from \"./extract.js\";\nimport geometry from \"./geometry.js\";\nimport hashmap from \"./hash/hashmap.js\";\nimport { hasOwnProperty } from \"./object.js\";\nimport prequantize from \"./prequantize.js\"; // Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\n\nexport default function (objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n  objects = topology.objects; // for garbage collection\n\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function (arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && hasOwnProperty.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function GeometryCollection(o) {\n      o.geometries.forEach(indexGeometry);\n    },\n    LineString: function LineString(o) {\n      o.arcs = indexArcs(o.arcs);\n    },\n    MultiLineString: function MultiLineString(o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    Polygon: function Polygon(o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    MultiPolygon: function MultiPolygon(o) {\n      o.arcs = o.arcs.map(indexMultiArcs);\n    }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0],\n      j = arc[1],\n      t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0],\n      ja = arcA[1],\n      ib = arcB[0],\n      jb = arcB[1],\n      t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}","map":{"version":3,"names":["bounds","cut","dedup","delta","extract","geometry","hashmap","hasOwnProperty","prequantize","objects","quantization","bbox","transform","topology","coordinates","indexByArc","arcs","length","hashArc","equalArc","map","arc","i","set","slice","indexGeometry","call","indexGeometryType","type","GeometryCollection","o","geometries","forEach","LineString","indexArcs","MultiLineString","Polygon","MultiPolygon","indexMultiArcs","indexes","index","get","push","next","key","j","t","arcA","arcB","ia","ja","ib","jb"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/topojson-server/src/topology.js"],"sourcesContent":["import bounds from \"./bounds.js\";\nimport cut from \"./cut.js\";\nimport dedup from \"./dedup.js\";\nimport delta from \"./delta.js\";\nimport extract from \"./extract.js\";\nimport geometry from \"./geometry.js\";\nimport hashmap from \"./hash/hashmap.js\";\nimport {hasOwnProperty} from \"./object.js\";\nimport prequantize from \"./prequantize.js\";\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nexport default function(objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && hasOwnProperty.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}