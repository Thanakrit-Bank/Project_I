{"ast":null,"code":"import { getCoord, getGeom } from \"@turf/invariant\"; // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\r\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\r\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\r\n *\r\n * @name booleanPointInPolygon\r\n * @param {Coord} point input point\r\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\r\n * the point is inside the polygon otherwise false.\r\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\r\n * @example\r\n * var pt = turf.point([-77, 44]);\r\n * var poly = turf.polygon([[\r\n *   [-81, 41],\r\n *   [-81, 47],\r\n *   [-72, 47],\r\n *   [-72, 41],\r\n *   [-81, 41]\r\n * ]]);\r\n *\r\n * turf.booleanPointInPolygon(pt, poly);\r\n * //= true\r\n */\n\nexport default function booleanPointInPolygon(point, polygon, options) {\n  if (options === void 0) {\n    options = {};\n  } // validation\n\n\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n\n  var pt = getCoord(point);\n  var geom = getGeom(polygon);\n  var type = geom.type;\n  var bbox = polygon.bbox;\n  var polys = geom.coordinates; // Quick elimination if point is not inside bbox\n\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  } // normalize to multipolygon\n\n\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n\n  var insidePoly = false;\n\n  for (var i = 0; i < polys.length && !insidePoly; i++) {\n    // check if it is in the outer ring first\n    if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n      var inHole = false;\n      var k = 1; // check for the point in any of the holes\n\n      while (k < polys[i].length && !inHole) {\n        if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n          inHole = true;\n        }\n\n        k++;\n      }\n\n      if (!inHole) {\n        insidePoly = true;\n      }\n    }\n  }\n\n  return insidePoly;\n}\n/**\r\n * inRing\r\n *\r\n * @private\r\n * @param {Array<number>} pt [x,y]\r\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\r\n * @param {boolean} ignoreBoundary ignoreBoundary\r\n * @returns {boolean} inRing\r\n */\n\nfunction inRing(pt, ring, ignoreBoundary) {\n  var isInside = false;\n\n  if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n    ring = ring.slice(0, ring.length - 1);\n  }\n\n  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n    var xi = ring[i][0];\n    var yi = ring[i][1];\n    var xj = ring[j][0];\n    var yj = ring[j][1];\n    var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n\n    if (onBoundary) {\n      return !ignoreBoundary;\n    }\n\n    var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n\n  return isInside;\n}\n/**\r\n * inBBox\r\n *\r\n * @private\r\n * @param {Position} pt point [x,y]\r\n * @param {BBox} bbox BBox [west, south, east, north]\r\n * @returns {boolean} true/false if point is inside BBox\r\n */\n\n\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}","map":{"version":3,"names":["getCoord","getGeom","booleanPointInPolygon","point","polygon","options","Error","pt","geom","type","bbox","polys","coordinates","inBBox","insidePoly","i","length","inRing","ignoreBoundary","inHole","k","ring","isInside","slice","j","xi","yi","xj","yj","onBoundary","intersect"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/boolean-point-in-polygon/dist/es/index.js"],"sourcesContent":["import { getCoord, getGeom } from \"@turf/invariant\";\r\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\r\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\r\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\n/**\r\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\r\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\r\n *\r\n * @name booleanPointInPolygon\r\n * @param {Coord} point input point\r\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\r\n * the point is inside the polygon otherwise false.\r\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\r\n * @example\r\n * var pt = turf.point([-77, 44]);\r\n * var poly = turf.polygon([[\r\n *   [-81, 41],\r\n *   [-81, 47],\r\n *   [-72, 47],\r\n *   [-72, 41],\r\n *   [-81, 41]\r\n * ]]);\r\n *\r\n * turf.booleanPointInPolygon(pt, poly);\r\n * //= true\r\n */\r\nexport default function booleanPointInPolygon(point, polygon, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // validation\r\n    if (!point) {\r\n        throw new Error(\"point is required\");\r\n    }\r\n    if (!polygon) {\r\n        throw new Error(\"polygon is required\");\r\n    }\r\n    var pt = getCoord(point);\r\n    var geom = getGeom(polygon);\r\n    var type = geom.type;\r\n    var bbox = polygon.bbox;\r\n    var polys = geom.coordinates;\r\n    // Quick elimination if point is not inside bbox\r\n    if (bbox && inBBox(pt, bbox) === false) {\r\n        return false;\r\n    }\r\n    // normalize to multipolygon\r\n    if (type === \"Polygon\") {\r\n        polys = [polys];\r\n    }\r\n    var insidePoly = false;\r\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\r\n        // check if it is in the outer ring first\r\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\r\n            var inHole = false;\r\n            var k = 1;\r\n            // check for the point in any of the holes\r\n            while (k < polys[i].length && !inHole) {\r\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\r\n                    inHole = true;\r\n                }\r\n                k++;\r\n            }\r\n            if (!inHole) {\r\n                insidePoly = true;\r\n            }\r\n        }\r\n    }\r\n    return insidePoly;\r\n}\r\n/**\r\n * inRing\r\n *\r\n * @private\r\n * @param {Array<number>} pt [x,y]\r\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\r\n * @param {boolean} ignoreBoundary ignoreBoundary\r\n * @returns {boolean} inRing\r\n */\r\nfunction inRing(pt, ring, ignoreBoundary) {\r\n    var isInside = false;\r\n    if (ring[0][0] === ring[ring.length - 1][0] &&\r\n        ring[0][1] === ring[ring.length - 1][1]) {\r\n        ring = ring.slice(0, ring.length - 1);\r\n    }\r\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\r\n        var xi = ring[i][0];\r\n        var yi = ring[i][1];\r\n        var xj = ring[j][0];\r\n        var yj = ring[j][1];\r\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\r\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\r\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\r\n        if (onBoundary) {\r\n            return !ignoreBoundary;\r\n        }\r\n        var intersect = yi > pt[1] !== yj > pt[1] &&\r\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\r\n        if (intersect) {\r\n            isInside = !isInside;\r\n        }\r\n    }\r\n    return isInside;\r\n}\r\n/**\r\n * inBBox\r\n *\r\n * @private\r\n * @param {Position} pt point [x,y]\r\n * @param {BBox} bbox BBox [west, south, east, north]\r\n * @returns {boolean} true/false if point is inside BBox\r\n */\r\nfunction inBBox(pt, bbox) {\r\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}