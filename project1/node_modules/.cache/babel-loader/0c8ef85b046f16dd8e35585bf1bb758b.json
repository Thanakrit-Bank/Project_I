{"ast":null,"code":"import Node from \"./Node.js\";\nimport Edge from \"./Edge.js\";\nimport EdgeRing from \"./EdgeRing.js\";\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\n/**\r\n * Validates the geoJson.\r\n *\r\n * @param {GeoJSON} geoJson - input geoJson.\r\n * @throws {Error} if geoJson is invalid.\r\n */\n\nfunction validateGeoJson(geoJson) {\n  if (!geoJson) throw new Error(\"No geojson passed\");\n  if (geoJson.type !== \"FeatureCollection\" && geoJson.type !== \"GeometryCollection\" && geoJson.type !== \"MultiLineString\" && geoJson.type !== \"LineString\" && geoJson.type !== \"Feature\") throw new Error(\"Invalid input type '\" + geoJson.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\n}\n/**\r\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\r\n *\r\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\r\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\r\n * isn't a javascript transcription of the C++ source.\r\n *\r\n * This graph is directed (both directions are created)\r\n */\n\n\nvar Graph =\n/** @class */\nfunction () {\n  function Graph() {\n    this.edges = []; //< {Edge[]} dirEdges\n    // The key is the `id` of the Node (ie: coordinates.join(','))\n\n    this.nodes = {};\n  }\n  /**\r\n   * Creates a graph from a GeoJSON.\r\n   *\r\n   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\r\n   * @returns {Graph} - The newly created graph\r\n   * @throws {Error} if geoJson is invalid.\r\n   */\n\n\n  Graph.fromGeoJson = function (geoJson) {\n    validateGeoJson(geoJson);\n    var graph = new Graph();\n    flattenEach(geoJson, function (feature) {\n      featureOf(feature, \"LineString\", \"Graph::fromGeoJson\"); // When a LineString if formed by many segments, split them\n\n      coordReduce(feature, function (prev, cur) {\n        if (prev) {\n          var start = graph.getNode(prev),\n              end = graph.getNode(cur);\n          graph.addEdge(start, end);\n        }\n\n        return cur;\n      });\n    });\n    return graph;\n  };\n  /**\r\n   * Creates or get a Node.\r\n   *\r\n   * @param {number[]} coordinates - Coordinates of the node\r\n   * @returns {Node} - The created or stored node\r\n   */\n\n\n  Graph.prototype.getNode = function (coordinates) {\n    var id = Node.buildId(coordinates);\n    var node = this.nodes[id];\n    if (!node) node = this.nodes[id] = new Node(coordinates);\n    return node;\n  };\n  /**\r\n   * Adds an Edge and its symetricall.\r\n   *\r\n   * Edges are added symetrically, i.e.: we also add its symetric\r\n   *\r\n   * @param {Node} from - Node which starts the Edge\r\n   * @param {Node} to - Node which ends the Edge\r\n   */\n\n\n  Graph.prototype.addEdge = function (from, to) {\n    var edge = new Edge(from, to),\n        symetricEdge = edge.getSymetric();\n    this.edges.push(edge);\n    this.edges.push(symetricEdge);\n  };\n  /**\r\n   * Removes Dangle Nodes (nodes with grade 1).\r\n   */\n\n\n  Graph.prototype.deleteDangles = function () {\n    var _this = this;\n\n    Object.keys(this.nodes).map(function (id) {\n      return _this.nodes[id];\n    }).forEach(function (node) {\n      return _this._removeIfDangle(node);\n    });\n  };\n  /**\r\n   * Check if node is dangle, if so, remove it.\r\n   *\r\n   * It calls itself recursively, removing a dangling node might cause another dangling node\r\n   *\r\n   * @param {Node} node - Node to check if it's a dangle\r\n   */\n\n\n  Graph.prototype._removeIfDangle = function (node) {\n    var _this = this; // As edges are directed and symetrical, we count only innerEdges\n\n\n    if (node.innerEdges.length <= 1) {\n      var outerNodes = node.getOuterEdges().map(function (e) {\n        return e.to;\n      });\n      this.removeNode(node);\n      outerNodes.forEach(function (n) {\n        return _this._removeIfDangle(n);\n      });\n    }\n  };\n  /**\r\n   * Delete cut-edges (bridge edges).\r\n   *\r\n   * The graph will be traversed, all the edges will be labeled according the ring\r\n   * in which they are. (The label is a number incremented by 1). Edges with the same\r\n   * label are cut-edges.\r\n   */\n\n\n  Graph.prototype.deleteCutEdges = function () {\n    var _this = this;\n\n    this._computeNextCWEdges();\n\n    this._findLabeledEdgeRings(); // Cut-edges (bridges) are edges where both edges have the same label\n\n\n    this.edges.forEach(function (edge) {\n      if (edge.label === edge.symetric.label) {\n        _this.removeEdge(edge.symetric);\n\n        _this.removeEdge(edge);\n      }\n    });\n  };\n  /**\r\n   * Set the `next` property of each Edge.\r\n   *\r\n   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\r\n   * OuterEdges are sorted CCW.\r\n   *\r\n   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\r\n   */\n\n\n  Graph.prototype._computeNextCWEdges = function (node) {\n    var _this = this;\n\n    if (typeof node === \"undefined\") {\n      Object.keys(this.nodes).forEach(function (id) {\n        return _this._computeNextCWEdges(_this.nodes[id]);\n      });\n    } else {\n      node.getOuterEdges().forEach(function (edge, i) {\n        node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n      });\n    }\n  };\n  /**\r\n   * Computes the next edge pointers going CCW around the given node, for the given edgering label.\r\n   *\r\n   * This algorithm has the effect of converting maximal edgerings into minimal edgerings\r\n   *\r\n   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\r\n   * could be written in a more javascript way.\r\n   *\r\n   * @param {Node} node - Node\r\n   * @param {number} label - Ring's label\r\n   */\n\n\n  Graph.prototype._computeNextCCWEdges = function (node, label) {\n    var edges = node.getOuterEdges();\n    var firstOutDE, prevInDE;\n\n    for (var i = edges.length - 1; i >= 0; --i) {\n      var de = edges[i],\n          sym = de.symetric,\n          outDE = void 0,\n          inDE = void 0;\n      if (de.label === label) outDE = de;\n      if (sym.label === label) inDE = sym;\n      if (!outDE || !inDE) // This edge is not in edgering\n        continue;\n      if (inDE) prevInDE = inDE;\n\n      if (outDE) {\n        if (prevInDE) {\n          prevInDE.next = outDE;\n          prevInDE = undefined;\n        }\n\n        if (!firstOutDE) firstOutDE = outDE;\n      }\n    }\n\n    if (prevInDE) prevInDE.next = firstOutDE;\n  };\n  /**\r\n   * Finds rings and labels edges according to which rings are.\r\n   *\r\n   * The label is a number which is increased for each ring.\r\n   *\r\n   * @returns {Edge[]} edges that start rings\r\n   */\n\n\n  Graph.prototype._findLabeledEdgeRings = function () {\n    var edgeRingStarts = [];\n    var label = 0;\n    this.edges.forEach(function (edge) {\n      if (edge.label >= 0) return;\n      edgeRingStarts.push(edge);\n      var e = edge;\n\n      do {\n        e.label = label;\n        e = e.next;\n      } while (!edge.isEqual(e));\n\n      label++;\n    });\n    return edgeRingStarts;\n  };\n  /**\r\n   * Computes the EdgeRings formed by the edges in this graph.\r\n   *\r\n   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\r\n   */\n\n\n  Graph.prototype.getEdgeRings = function () {\n    var _this = this;\n\n    this._computeNextCWEdges(); // Clear labels\n\n\n    this.edges.forEach(function (edge) {\n      edge.label = undefined;\n    });\n\n    this._findLabeledEdgeRings().forEach(function (edge) {\n      // convertMaximalToMinimalEdgeRings\n      _this._findIntersectionNodes(edge).forEach(function (node) {\n        _this._computeNextCCWEdges(node, edge.label);\n      });\n    });\n\n    var edgeRingList = []; // find all edgerings\n\n    this.edges.forEach(function (edge) {\n      if (edge.ring) return;\n      edgeRingList.push(_this._findEdgeRing(edge));\n    });\n    return edgeRingList;\n  };\n  /**\r\n   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\r\n   *\r\n   * @param {Node} startEdge - Start Edge of the Ring\r\n   * @returns {Node[]} - intersection nodes\r\n   */\n\n\n  Graph.prototype._findIntersectionNodes = function (startEdge) {\n    var intersectionNodes = [];\n    var edge = startEdge;\n\n    var _loop_1 = function _loop_1() {\n      // getDegree\n      var degree = 0;\n      edge.from.getOuterEdges().forEach(function (e) {\n        if (e.label === startEdge.label) ++degree;\n      });\n      if (degree > 1) intersectionNodes.push(edge.from);\n      edge = edge.next;\n    };\n\n    do {\n      _loop_1();\n    } while (!startEdge.isEqual(edge));\n\n    return intersectionNodes;\n  };\n  /**\r\n   * Get the edge-ring which starts from the provided Edge.\r\n   *\r\n   * @param {Edge} startEdge - starting edge of the edge ring\r\n   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\r\n   */\n\n\n  Graph.prototype._findEdgeRing = function (startEdge) {\n    var edge = startEdge;\n    var edgeRing = new EdgeRing();\n\n    do {\n      edgeRing.push(edge);\n      edge.ring = edgeRing;\n      edge = edge.next;\n    } while (!startEdge.isEqual(edge));\n\n    return edgeRing;\n  };\n  /**\r\n   * Removes a node from the Graph.\r\n   *\r\n   * It also removes edges asociated to that node\r\n   * @param {Node} node - Node to be removed\r\n   */\n\n\n  Graph.prototype.removeNode = function (node) {\n    var _this = this;\n\n    node.getOuterEdges().forEach(function (edge) {\n      return _this.removeEdge(edge);\n    });\n    node.innerEdges.forEach(function (edge) {\n      return _this.removeEdge(edge);\n    });\n    delete this.nodes[node.id];\n  };\n  /**\r\n   * Remove edge from the graph and deletes the edge.\r\n   *\r\n   * @param {Edge} edge - Edge to be removed\r\n   */\n\n\n  Graph.prototype.removeEdge = function (edge) {\n    this.edges = this.edges.filter(function (e) {\n      return !e.isEqual(edge);\n    });\n    edge.deleteEdge();\n  };\n\n  return Graph;\n}();\n\nexport default Graph;","map":{"version":3,"names":["Node","Edge","EdgeRing","flattenEach","coordReduce","featureOf","validateGeoJson","geoJson","Error","type","Graph","edges","nodes","fromGeoJson","graph","feature","prev","cur","start","getNode","end","addEdge","prototype","coordinates","id","buildId","node","from","to","edge","symetricEdge","getSymetric","push","deleteDangles","_this","Object","keys","map","forEach","_removeIfDangle","innerEdges","length","outerNodes","getOuterEdges","e","removeNode","n","deleteCutEdges","_computeNextCWEdges","_findLabeledEdgeRings","label","symetric","removeEdge","i","getOuterEdge","next","_computeNextCCWEdges","firstOutDE","prevInDE","de","sym","outDE","inDE","undefined","edgeRingStarts","isEqual","getEdgeRings","_findIntersectionNodes","edgeRingList","ring","_findEdgeRing","startEdge","intersectionNodes","_loop_1","degree","edgeRing","filter","deleteEdge"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/polygonize/dist/es/lib/Graph.js"],"sourcesContent":["import Node from \"./Node.js\";\r\nimport Edge from \"./Edge.js\";\r\nimport EdgeRing from \"./EdgeRing.js\";\r\nimport { flattenEach, coordReduce } from \"@turf/meta\";\r\nimport { featureOf } from \"@turf/invariant\";\r\n/**\r\n * Validates the geoJson.\r\n *\r\n * @param {GeoJSON} geoJson - input geoJson.\r\n * @throws {Error} if geoJson is invalid.\r\n */\r\nfunction validateGeoJson(geoJson) {\r\n    if (!geoJson)\r\n        throw new Error(\"No geojson passed\");\r\n    if (geoJson.type !== \"FeatureCollection\" &&\r\n        geoJson.type !== \"GeometryCollection\" &&\r\n        geoJson.type !== \"MultiLineString\" &&\r\n        geoJson.type !== \"LineString\" &&\r\n        geoJson.type !== \"Feature\")\r\n        throw new Error(\"Invalid input type '\" + geoJson.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\r\n}\r\n/**\r\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\r\n *\r\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\r\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\r\n * isn't a javascript transcription of the C++ source.\r\n *\r\n * This graph is directed (both directions are created)\r\n */\r\nvar Graph = /** @class */ (function () {\r\n    function Graph() {\r\n        this.edges = []; //< {Edge[]} dirEdges\r\n        // The key is the `id` of the Node (ie: coordinates.join(','))\r\n        this.nodes = {};\r\n    }\r\n    /**\r\n     * Creates a graph from a GeoJSON.\r\n     *\r\n     * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\r\n     * @returns {Graph} - The newly created graph\r\n     * @throws {Error} if geoJson is invalid.\r\n     */\r\n    Graph.fromGeoJson = function (geoJson) {\r\n        validateGeoJson(geoJson);\r\n        var graph = new Graph();\r\n        flattenEach(geoJson, function (feature) {\r\n            featureOf(feature, \"LineString\", \"Graph::fromGeoJson\");\r\n            // When a LineString if formed by many segments, split them\r\n            coordReduce(feature, function (prev, cur) {\r\n                if (prev) {\r\n                    var start = graph.getNode(prev), end = graph.getNode(cur);\r\n                    graph.addEdge(start, end);\r\n                }\r\n                return cur;\r\n            });\r\n        });\r\n        return graph;\r\n    };\r\n    /**\r\n     * Creates or get a Node.\r\n     *\r\n     * @param {number[]} coordinates - Coordinates of the node\r\n     * @returns {Node} - The created or stored node\r\n     */\r\n    Graph.prototype.getNode = function (coordinates) {\r\n        var id = Node.buildId(coordinates);\r\n        var node = this.nodes[id];\r\n        if (!node)\r\n            node = this.nodes[id] = new Node(coordinates);\r\n        return node;\r\n    };\r\n    /**\r\n     * Adds an Edge and its symetricall.\r\n     *\r\n     * Edges are added symetrically, i.e.: we also add its symetric\r\n     *\r\n     * @param {Node} from - Node which starts the Edge\r\n     * @param {Node} to - Node which ends the Edge\r\n     */\r\n    Graph.prototype.addEdge = function (from, to) {\r\n        var edge = new Edge(from, to), symetricEdge = edge.getSymetric();\r\n        this.edges.push(edge);\r\n        this.edges.push(symetricEdge);\r\n    };\r\n    /**\r\n     * Removes Dangle Nodes (nodes with grade 1).\r\n     */\r\n    Graph.prototype.deleteDangles = function () {\r\n        var _this = this;\r\n        Object.keys(this.nodes)\r\n            .map(function (id) { return _this.nodes[id]; })\r\n            .forEach(function (node) { return _this._removeIfDangle(node); });\r\n    };\r\n    /**\r\n     * Check if node is dangle, if so, remove it.\r\n     *\r\n     * It calls itself recursively, removing a dangling node might cause another dangling node\r\n     *\r\n     * @param {Node} node - Node to check if it's a dangle\r\n     */\r\n    Graph.prototype._removeIfDangle = function (node) {\r\n        var _this = this;\r\n        // As edges are directed and symetrical, we count only innerEdges\r\n        if (node.innerEdges.length <= 1) {\r\n            var outerNodes = node.getOuterEdges().map(function (e) { return e.to; });\r\n            this.removeNode(node);\r\n            outerNodes.forEach(function (n) { return _this._removeIfDangle(n); });\r\n        }\r\n    };\r\n    /**\r\n     * Delete cut-edges (bridge edges).\r\n     *\r\n     * The graph will be traversed, all the edges will be labeled according the ring\r\n     * in which they are. (The label is a number incremented by 1). Edges with the same\r\n     * label are cut-edges.\r\n     */\r\n    Graph.prototype.deleteCutEdges = function () {\r\n        var _this = this;\r\n        this._computeNextCWEdges();\r\n        this._findLabeledEdgeRings();\r\n        // Cut-edges (bridges) are edges where both edges have the same label\r\n        this.edges.forEach(function (edge) {\r\n            if (edge.label === edge.symetric.label) {\r\n                _this.removeEdge(edge.symetric);\r\n                _this.removeEdge(edge);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Set the `next` property of each Edge.\r\n     *\r\n     * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\r\n     * OuterEdges are sorted CCW.\r\n     *\r\n     * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\r\n     */\r\n    Graph.prototype._computeNextCWEdges = function (node) {\r\n        var _this = this;\r\n        if (typeof node === \"undefined\") {\r\n            Object.keys(this.nodes).forEach(function (id) {\r\n                return _this._computeNextCWEdges(_this.nodes[id]);\r\n            });\r\n        }\r\n        else {\r\n            node.getOuterEdges().forEach(function (edge, i) {\r\n                node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Computes the next edge pointers going CCW around the given node, for the given edgering label.\r\n     *\r\n     * This algorithm has the effect of converting maximal edgerings into minimal edgerings\r\n     *\r\n     * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\r\n     * could be written in a more javascript way.\r\n     *\r\n     * @param {Node} node - Node\r\n     * @param {number} label - Ring's label\r\n     */\r\n    Graph.prototype._computeNextCCWEdges = function (node, label) {\r\n        var edges = node.getOuterEdges();\r\n        var firstOutDE, prevInDE;\r\n        for (var i = edges.length - 1; i >= 0; --i) {\r\n            var de = edges[i], sym = de.symetric, outDE = void 0, inDE = void 0;\r\n            if (de.label === label)\r\n                outDE = de;\r\n            if (sym.label === label)\r\n                inDE = sym;\r\n            if (!outDE || !inDE)\r\n                // This edge is not in edgering\r\n                continue;\r\n            if (inDE)\r\n                prevInDE = inDE;\r\n            if (outDE) {\r\n                if (prevInDE) {\r\n                    prevInDE.next = outDE;\r\n                    prevInDE = undefined;\r\n                }\r\n                if (!firstOutDE)\r\n                    firstOutDE = outDE;\r\n            }\r\n        }\r\n        if (prevInDE)\r\n            prevInDE.next = firstOutDE;\r\n    };\r\n    /**\r\n     * Finds rings and labels edges according to which rings are.\r\n     *\r\n     * The label is a number which is increased for each ring.\r\n     *\r\n     * @returns {Edge[]} edges that start rings\r\n     */\r\n    Graph.prototype._findLabeledEdgeRings = function () {\r\n        var edgeRingStarts = [];\r\n        var label = 0;\r\n        this.edges.forEach(function (edge) {\r\n            if (edge.label >= 0)\r\n                return;\r\n            edgeRingStarts.push(edge);\r\n            var e = edge;\r\n            do {\r\n                e.label = label;\r\n                e = e.next;\r\n            } while (!edge.isEqual(e));\r\n            label++;\r\n        });\r\n        return edgeRingStarts;\r\n    };\r\n    /**\r\n     * Computes the EdgeRings formed by the edges in this graph.\r\n     *\r\n     * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\r\n     */\r\n    Graph.prototype.getEdgeRings = function () {\r\n        var _this = this;\r\n        this._computeNextCWEdges();\r\n        // Clear labels\r\n        this.edges.forEach(function (edge) {\r\n            edge.label = undefined;\r\n        });\r\n        this._findLabeledEdgeRings().forEach(function (edge) {\r\n            // convertMaximalToMinimalEdgeRings\r\n            _this._findIntersectionNodes(edge).forEach(function (node) {\r\n                _this._computeNextCCWEdges(node, edge.label);\r\n            });\r\n        });\r\n        var edgeRingList = [];\r\n        // find all edgerings\r\n        this.edges.forEach(function (edge) {\r\n            if (edge.ring)\r\n                return;\r\n            edgeRingList.push(_this._findEdgeRing(edge));\r\n        });\r\n        return edgeRingList;\r\n    };\r\n    /**\r\n     * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\r\n     *\r\n     * @param {Node} startEdge - Start Edge of the Ring\r\n     * @returns {Node[]} - intersection nodes\r\n     */\r\n    Graph.prototype._findIntersectionNodes = function (startEdge) {\r\n        var intersectionNodes = [];\r\n        var edge = startEdge;\r\n        var _loop_1 = function () {\r\n            // getDegree\r\n            var degree = 0;\r\n            edge.from.getOuterEdges().forEach(function (e) {\r\n                if (e.label === startEdge.label)\r\n                    ++degree;\r\n            });\r\n            if (degree > 1)\r\n                intersectionNodes.push(edge.from);\r\n            edge = edge.next;\r\n        };\r\n        do {\r\n            _loop_1();\r\n        } while (!startEdge.isEqual(edge));\r\n        return intersectionNodes;\r\n    };\r\n    /**\r\n     * Get the edge-ring which starts from the provided Edge.\r\n     *\r\n     * @param {Edge} startEdge - starting edge of the edge ring\r\n     * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\r\n     */\r\n    Graph.prototype._findEdgeRing = function (startEdge) {\r\n        var edge = startEdge;\r\n        var edgeRing = new EdgeRing();\r\n        do {\r\n            edgeRing.push(edge);\r\n            edge.ring = edgeRing;\r\n            edge = edge.next;\r\n        } while (!startEdge.isEqual(edge));\r\n        return edgeRing;\r\n    };\r\n    /**\r\n     * Removes a node from the Graph.\r\n     *\r\n     * It also removes edges asociated to that node\r\n     * @param {Node} node - Node to be removed\r\n     */\r\n    Graph.prototype.removeNode = function (node) {\r\n        var _this = this;\r\n        node.getOuterEdges().forEach(function (edge) { return _this.removeEdge(edge); });\r\n        node.innerEdges.forEach(function (edge) { return _this.removeEdge(edge); });\r\n        delete this.nodes[node.id];\r\n    };\r\n    /**\r\n     * Remove edge from the graph and deletes the edge.\r\n     *\r\n     * @param {Edge} edge - Edge to be removed\r\n     */\r\n    Graph.prototype.removeEdge = function (edge) {\r\n        this.edges = this.edges.filter(function (e) { return !e.isEqual(edge); });\r\n        edge.deleteEdge();\r\n    };\r\n    return Graph;\r\n}());\r\nexport default Graph;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}