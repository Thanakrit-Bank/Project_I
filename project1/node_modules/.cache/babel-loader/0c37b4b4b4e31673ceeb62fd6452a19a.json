{"ast":null,"code":"import { hasOwnProperty } from \"./object.js\";\nexport default function (objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n),\n        // pessimistic\n    pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n\n    while (j < m) {\n      j = output.push([output[0][0], output[0][1]]);\n    }\n\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && hasOwnProperty.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function GeometryCollection(o) {\n      o.geometries.forEach(quantizeGeometry);\n    },\n    Point: function Point(o) {\n      o.coordinates = quantizePoint(o.coordinates);\n    },\n    MultiPoint: function MultiPoint(o) {\n      o.coordinates = o.coordinates.map(quantizePoint);\n    },\n    LineString: function LineString(o) {\n      o.arcs = quantizeLine(o.arcs);\n    },\n    MultiLineString: function MultiLineString(o) {\n      o.arcs = o.arcs.map(quantizeLine);\n    },\n    Polygon: function Polygon(o) {\n      o.arcs = quantizePolygon(o.arcs);\n    },\n    MultiPolygon: function MultiPolygon(o) {\n      o.arcs = o.arcs.map(quantizePolygon);\n    }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}","map":{"version":3,"names":["hasOwnProperty","objects","bbox","n","x0","y0","x1","y1","kx","ky","quantizePoint","input","Math","round","quantizePoints","m","i","j","length","output","Array","pi","px","py","x","y","push","quantizeLine","quantizeRing","quantizePolygon","map","quantizeGeometry","o","call","quantizeGeometryType","type","GeometryCollection","geometries","forEach","Point","coordinates","MultiPoint","LineString","arcs","MultiLineString","Polygon","MultiPolygon","key","scale","translate"],"sources":["D:/Project/Mix_Project/Project_I/project1/node_modules/topojson-server/src/prequantize.js"],"sourcesContent":["import {hasOwnProperty} from \"./object.js\";\n\nexport default function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && hasOwnProperty.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },\n    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },\n    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },\n    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}