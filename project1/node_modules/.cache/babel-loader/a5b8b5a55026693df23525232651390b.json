{"ast":null,"code":"import within from \"@turf/boolean-within\";\nimport distance from \"@turf/distance\";\nimport { point, featureCollection } from \"@turf/helpers\";\n/**\r\n * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.\r\n *\r\n * @name pointGrid\r\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\r\n * @param {number} cellSide the distance between points, in units\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers\r\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it\r\n * @param {Object} [options.properties={}] passed to each point of the grid\r\n * @returns {FeatureCollection<Point>} grid of points\r\n * @example\r\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\r\n * var cellSide = 3;\r\n * var options = {units: 'miles'};\r\n *\r\n * var grid = turf.pointGrid(extent, cellSide, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [grid];\r\n */\n\nfunction pointGrid(bbox, cellSide, options) {\n  if (options === void 0) {\n    options = {};\n  } // Default parameters\n\n\n  if (options.mask && !options.units) options.units = \"kilometers\"; // Containers\n\n  var results = []; // Typescript handles the Type Validation\n  // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');\n  // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');\n  // if (!bbox) throw new Error('bbox is required');\n  // if (!Array.isArray(bbox)) throw new Error('bbox must be array');\n  // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');\n  // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');\n\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var xFraction = cellSide / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = cellSide / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n  var bboxWidth = east - west;\n  var bboxHeight = north - south;\n  var columns = Math.floor(bboxWidth / cellWidth);\n  var rows = Math.floor(bboxHeight / cellHeight); // adjust origin of the grid\n\n  var deltaX = (bboxWidth - columns * cellWidth) / 2;\n  var deltaY = (bboxHeight - rows * cellHeight) / 2;\n  var currentX = west + deltaX;\n\n  while (currentX <= east) {\n    var currentY = south + deltaY;\n\n    while (currentY <= north) {\n      var cellPt = point([currentX, currentY], options.properties);\n\n      if (options.mask) {\n        if (within(cellPt, options.mask)) results.push(cellPt);\n      } else {\n        results.push(cellPt);\n      }\n\n      currentY += cellHeight;\n    }\n\n    currentX += cellWidth;\n  }\n\n  return featureCollection(results);\n}\n\nexport default pointGrid;","map":{"version":3,"names":["within","distance","point","featureCollection","pointGrid","bbox","cellSide","options","mask","units","results","west","south","east","north","xFraction","cellWidth","yFraction","cellHeight","bboxWidth","bboxHeight","columns","Math","floor","rows","deltaX","deltaY","currentX","currentY","cellPt","properties","push"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/point-grid/dist/es/index.js"],"sourcesContent":["import within from \"@turf/boolean-within\";\r\nimport distance from \"@turf/distance\";\r\nimport { point, featureCollection, } from \"@turf/helpers\";\r\n/**\r\n * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.\r\n *\r\n * @name pointGrid\r\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\r\n * @param {number} cellSide the distance between points, in units\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers\r\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it\r\n * @param {Object} [options.properties={}] passed to each point of the grid\r\n * @returns {FeatureCollection<Point>} grid of points\r\n * @example\r\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\r\n * var cellSide = 3;\r\n * var options = {units: 'miles'};\r\n *\r\n * var grid = turf.pointGrid(extent, cellSide, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [grid];\r\n */\r\nfunction pointGrid(bbox, cellSide, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // Default parameters\r\n    if (options.mask && !options.units)\r\n        options.units = \"kilometers\";\r\n    // Containers\r\n    var results = [];\r\n    // Typescript handles the Type Validation\r\n    // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');\r\n    // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');\r\n    // if (!bbox) throw new Error('bbox is required');\r\n    // if (!Array.isArray(bbox)) throw new Error('bbox must be array');\r\n    // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');\r\n    // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');\r\n    var west = bbox[0];\r\n    var south = bbox[1];\r\n    var east = bbox[2];\r\n    var north = bbox[3];\r\n    var xFraction = cellSide / distance([west, south], [east, south], options);\r\n    var cellWidth = xFraction * (east - west);\r\n    var yFraction = cellSide / distance([west, south], [west, north], options);\r\n    var cellHeight = yFraction * (north - south);\r\n    var bboxWidth = east - west;\r\n    var bboxHeight = north - south;\r\n    var columns = Math.floor(bboxWidth / cellWidth);\r\n    var rows = Math.floor(bboxHeight / cellHeight);\r\n    // adjust origin of the grid\r\n    var deltaX = (bboxWidth - columns * cellWidth) / 2;\r\n    var deltaY = (bboxHeight - rows * cellHeight) / 2;\r\n    var currentX = west + deltaX;\r\n    while (currentX <= east) {\r\n        var currentY = south + deltaY;\r\n        while (currentY <= north) {\r\n            var cellPt = point([currentX, currentY], options.properties);\r\n            if (options.mask) {\r\n                if (within(cellPt, options.mask))\r\n                    results.push(cellPt);\r\n            }\r\n            else {\r\n                results.push(cellPt);\r\n            }\r\n            currentY += cellHeight;\r\n        }\r\n        currentX += cellWidth;\r\n    }\r\n    return featureCollection(results);\r\n}\r\nexport default pointGrid;\r\n"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,sBAAnB;AACA,OAAOC,QAAP,MAAqB,gBAArB;AACA,SAASC,KAAT,EAAgBC,iBAAhB,QAA0C,eAA1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,QAAzB,EAAmCC,OAAnC,EAA4C;EACxC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe,CADD,CAExC;;;EACA,IAAIA,OAAO,CAACC,IAAR,IAAgB,CAACD,OAAO,CAACE,KAA7B,EACIF,OAAO,CAACE,KAAR,GAAgB,YAAhB,CAJoC,CAKxC;;EACA,IAAIC,OAAO,GAAG,EAAd,CANwC,CAOxC;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,IAAIC,IAAI,GAAGN,IAAI,CAAC,CAAD,CAAf;EACA,IAAIO,KAAK,GAAGP,IAAI,CAAC,CAAD,CAAhB;EACA,IAAIQ,IAAI,GAAGR,IAAI,CAAC,CAAD,CAAf;EACA,IAAIS,KAAK,GAAGT,IAAI,CAAC,CAAD,CAAhB;EACA,IAAIU,SAAS,GAAGT,QAAQ,GAAGL,QAAQ,CAAC,CAACU,IAAD,EAAOC,KAAP,CAAD,EAAgB,CAACC,IAAD,EAAOD,KAAP,CAAhB,EAA+BL,OAA/B,CAAnC;EACA,IAAIS,SAAS,GAAGD,SAAS,IAAIF,IAAI,GAAGF,IAAX,CAAzB;EACA,IAAIM,SAAS,GAAGX,QAAQ,GAAGL,QAAQ,CAAC,CAACU,IAAD,EAAOC,KAAP,CAAD,EAAgB,CAACD,IAAD,EAAOG,KAAP,CAAhB,EAA+BP,OAA/B,CAAnC;EACA,IAAIW,UAAU,GAAGD,SAAS,IAAIH,KAAK,GAAGF,KAAZ,CAA1B;EACA,IAAIO,SAAS,GAAGN,IAAI,GAAGF,IAAvB;EACA,IAAIS,UAAU,GAAGN,KAAK,GAAGF,KAAzB;EACA,IAAIS,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWJ,SAAS,GAAGH,SAAvB,CAAd;EACA,IAAIQ,IAAI,GAAGF,IAAI,CAACC,KAAL,CAAWH,UAAU,GAAGF,UAAxB,CAAX,CAzBwC,CA0BxC;;EACA,IAAIO,MAAM,GAAG,CAACN,SAAS,GAAGE,OAAO,GAAGL,SAAvB,IAAoC,CAAjD;EACA,IAAIU,MAAM,GAAG,CAACN,UAAU,GAAGI,IAAI,GAAGN,UAArB,IAAmC,CAAhD;EACA,IAAIS,QAAQ,GAAGhB,IAAI,GAAGc,MAAtB;;EACA,OAAOE,QAAQ,IAAId,IAAnB,EAAyB;IACrB,IAAIe,QAAQ,GAAGhB,KAAK,GAAGc,MAAvB;;IACA,OAAOE,QAAQ,IAAId,KAAnB,EAA0B;MACtB,IAAIe,MAAM,GAAG3B,KAAK,CAAC,CAACyB,QAAD,EAAWC,QAAX,CAAD,EAAuBrB,OAAO,CAACuB,UAA/B,CAAlB;;MACA,IAAIvB,OAAO,CAACC,IAAZ,EAAkB;QACd,IAAIR,MAAM,CAAC6B,MAAD,EAAStB,OAAO,CAACC,IAAjB,CAAV,EACIE,OAAO,CAACqB,IAAR,CAAaF,MAAb;MACP,CAHD,MAIK;QACDnB,OAAO,CAACqB,IAAR,CAAaF,MAAb;MACH;;MACDD,QAAQ,IAAIV,UAAZ;IACH;;IACDS,QAAQ,IAAIX,SAAZ;EACH;;EACD,OAAOb,iBAAiB,CAACO,OAAD,CAAxB;AACH;;AACD,eAAeN,SAAf"},"metadata":{},"sourceType":"module"}