{"ast":null,"code":"import { getCoords, getType } from '@turf/invariant';\nimport { lineString } from '@turf/helpers';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\n/**\r\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\r\n * and returns a subsection of the line in-between those points.\r\n * The start & stop points don't need to fall exactly on the line.\r\n *\r\n * This can be useful for extracting only the part of a route between waypoints.\r\n *\r\n * @name lineSlice\r\n * @param {Coord} startPt starting point\r\n * @param {Coord} stopPt stopping point\r\n * @param {Feature<LineString>|LineString} line line to slice\r\n * @returns {Feature<LineString>} sliced line\r\n * @example\r\n * var line = turf.lineString([\r\n *     [-77.031669, 38.878605],\r\n *     [-77.029609, 38.881946],\r\n *     [-77.020339, 38.884084],\r\n *     [-77.025661, 38.885821],\r\n *     [-77.021884, 38.889563],\r\n *     [-77.019824, 38.892368]\r\n * ]);\r\n * var start = turf.point([-77.029609, 38.881946]);\r\n * var stop = turf.point([-77.021884, 38.889563]);\r\n *\r\n * var sliced = turf.lineSlice(start, stop, line);\r\n *\r\n * //addToMap\r\n * var addToMap = [start, stop, line]\r\n */\n\nfunction lineSlice(startPt, stopPt, line) {\n  // Validation\n  var coords = getCoords(line);\n  if (getType(line) !== \"LineString\") throw new Error(\"line must be a LineString\");\n  var startVertex = nearestPointOnLine(line, startPt);\n  var stopVertex = nearestPointOnLine(line, stopPt);\n  var ends;\n\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n\n  var clipCoords = [ends[0].geometry.coordinates];\n\n  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n    clipCoords.push(coords[i]);\n  }\n\n  clipCoords.push(ends[1].geometry.coordinates);\n  return lineString(clipCoords, line.properties);\n}\n\nexport default lineSlice;","map":{"version":3,"names":["getCoords","getType","lineString","nearestPointOnLine","lineSlice","startPt","stopPt","line","coords","Error","startVertex","stopVertex","ends","properties","index","clipCoords","geometry","coordinates","i","push"],"sources":["C:/Users/Administrator/Desktop/Project_I/project1/node_modules/@turf/line-slice/dist/es/index.js"],"sourcesContent":["import { getCoords, getType } from '@turf/invariant';\r\nimport { lineString } from '@turf/helpers';\r\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\r\n\r\n/**\r\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\r\n * and returns a subsection of the line in-between those points.\r\n * The start & stop points don't need to fall exactly on the line.\r\n *\r\n * This can be useful for extracting only the part of a route between waypoints.\r\n *\r\n * @name lineSlice\r\n * @param {Coord} startPt starting point\r\n * @param {Coord} stopPt stopping point\r\n * @param {Feature<LineString>|LineString} line line to slice\r\n * @returns {Feature<LineString>} sliced line\r\n * @example\r\n * var line = turf.lineString([\r\n *     [-77.031669, 38.878605],\r\n *     [-77.029609, 38.881946],\r\n *     [-77.020339, 38.884084],\r\n *     [-77.025661, 38.885821],\r\n *     [-77.021884, 38.889563],\r\n *     [-77.019824, 38.892368]\r\n * ]);\r\n * var start = turf.point([-77.029609, 38.881946]);\r\n * var stop = turf.point([-77.021884, 38.889563]);\r\n *\r\n * var sliced = turf.lineSlice(start, stop, line);\r\n *\r\n * //addToMap\r\n * var addToMap = [start, stop, line]\r\n */\r\nfunction lineSlice(startPt, stopPt, line) {\r\n  // Validation\r\n  var coords = getCoords(line);\r\n  if (getType(line) !== \"LineString\")\r\n    throw new Error(\"line must be a LineString\");\r\n\r\n  var startVertex = nearestPointOnLine(line, startPt);\r\n  var stopVertex = nearestPointOnLine(line, stopPt);\r\n  var ends;\r\n  if (startVertex.properties.index <= stopVertex.properties.index) {\r\n    ends = [startVertex, stopVertex];\r\n  } else {\r\n    ends = [stopVertex, startVertex];\r\n  }\r\n  var clipCoords = [ends[0].geometry.coordinates];\r\n  for (\r\n    var i = ends[0].properties.index + 1;\r\n    i < ends[1].properties.index + 1;\r\n    i++\r\n  ) {\r\n    clipCoords.push(coords[i]);\r\n  }\r\n  clipCoords.push(ends[1].geometry.coordinates);\r\n  return lineString(clipCoords, line.properties);\r\n}\r\n\r\nexport default lineSlice;\r\n"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,OAApB,QAAmC,iBAAnC;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,OAAOC,kBAAP,MAA+B,6BAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,IAApC,EAA0C;EACxC;EACA,IAAIC,MAAM,GAAGR,SAAS,CAACO,IAAD,CAAtB;EACA,IAAIN,OAAO,CAACM,IAAD,CAAP,KAAkB,YAAtB,EACE,MAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;EAEF,IAAIC,WAAW,GAAGP,kBAAkB,CAACI,IAAD,EAAOF,OAAP,CAApC;EACA,IAAIM,UAAU,GAAGR,kBAAkB,CAACI,IAAD,EAAOD,MAAP,CAAnC;EACA,IAAIM,IAAJ;;EACA,IAAIF,WAAW,CAACG,UAAZ,CAAuBC,KAAvB,IAAgCH,UAAU,CAACE,UAAX,CAAsBC,KAA1D,EAAiE;IAC/DF,IAAI,GAAG,CAACF,WAAD,EAAcC,UAAd,CAAP;EACD,CAFD,MAEO;IACLC,IAAI,GAAG,CAACD,UAAD,EAAaD,WAAb,CAAP;EACD;;EACD,IAAIK,UAAU,GAAG,CAACH,IAAI,CAAC,CAAD,CAAJ,CAAQI,QAAR,CAAiBC,WAAlB,CAAjB;;EACA,KACE,IAAIC,CAAC,GAAGN,IAAI,CAAC,CAAD,CAAJ,CAAQC,UAAR,CAAmBC,KAAnB,GAA2B,CADrC,EAEEI,CAAC,GAAGN,IAAI,CAAC,CAAD,CAAJ,CAAQC,UAAR,CAAmBC,KAAnB,GAA2B,CAFjC,EAGEI,CAAC,EAHH,EAIE;IACAH,UAAU,CAACI,IAAX,CAAgBX,MAAM,CAACU,CAAD,CAAtB;EACD;;EACDH,UAAU,CAACI,IAAX,CAAgBP,IAAI,CAAC,CAAD,CAAJ,CAAQI,QAAR,CAAiBC,WAAjC;EACA,OAAOf,UAAU,CAACa,UAAD,EAAaR,IAAI,CAACM,UAAlB,CAAjB;AACD;;AAED,eAAeT,SAAf"},"metadata":{},"sourceType":"module"}