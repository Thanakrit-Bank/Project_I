"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListItemChildren = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var ListItemAddon_1 = require("./ListItemAddon");
var ListItemText_1 = require("./ListItemText");
/**
 * The `ListItemChildren` component is used to create a styled list item that
 * can have optional addons to the left or right of the children in the form of
 * icons, avatars, or media. The `children` can be replaced by the `primaryText`
 * and `secondaryText` props to create stacked text spanning two or more lines
 * with the default behavior of using `line-clamp` at three lines.
 *
 * Note: This will return a `React.Fragment` of the children and does not wrap
 * in a DOM node for styling. The parent component should normally have
 * `display: flex` for the styling to work.
 */
function ListItemChildren(_a) {
    var textClassName = _a.textClassName, secondaryTextClassName = _a.secondaryTextClassName, textChildren = _a.textChildren, primaryText = _a.primaryText, secondaryText = _a.secondaryText, leftAddon = _a.leftAddon, _b = _a.leftAddonType, leftAddonType = _b === void 0 ? "icon" : _b, _c = _a.leftAddonPosition, leftAddonPosition = _c === void 0 ? "middle" : _c, rightAddon = _a.rightAddon, _d = _a.rightAddonType, rightAddonType = _d === void 0 ? "icon" : _d, _e = _a.rightAddonPosition, rightAddonPosition = _e === void 0 ? "middle" : _e, forceAddonWrap = _a.forceAddonWrap, propChildren = _a.children;
    var stringifiedChildren = typeof propChildren === "number" ? "".concat(propChildren) : propChildren;
    var children = stringifiedChildren;
    if (primaryText || secondaryText || textChildren) {
        children = ((0, jsx_runtime_1.jsx)(ListItemText_1.ListItemText, __assign({ className: textClassName, secondaryText: secondaryText, secondaryTextClassName: secondaryTextClassName }, { children: (textChildren && children) || primaryText })));
    }
    children = ((0, jsx_runtime_1.jsx)(ListItemAddon_1.ListItemAddon, __assign({ addon: leftAddon, type: leftAddonType, position: leftAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })));
    children = ((0, jsx_runtime_1.jsx)(ListItemAddon_1.ListItemAddon, __assign({ addon: rightAddon, addonAfter: true, type: rightAddonType, position: rightAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })));
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [children, (primaryText && stringifiedChildren) || null] }));
}
exports.ListItemChildren = ListItemChildren;
//# sourceMappingURL=ListItemChildren.js.map