var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { useReducer, useRef } from "react";
import { useEnsuredRef, useIsomorphicLayoutEffect } from "@react-md/utils";
import { getTransitionTimeout } from "./utils";
var INITIAL_STATE = {
    appearing: false,
    rendered: true,
    stage: "exited",
};
/**
 * You'll most likely want to use the {@link useCSSTransition} hook instead
 * since this is just a low-level hook that can be used to transition using
 * timeouts.
 *
 * @typeParam E - The HTMLElement type used or the ref required for the
 * transition.
 * @remarks \@since 4.0.0
 */
export function useTransition(_a) {
    var nodeRef = _a.nodeRef, timeout = _a.timeout, transitionIn = _a.transitionIn, _b = _a.reflow, reflow = _b === void 0 ? false : _b, _c = _a.temporary, temporary = _c === void 0 ? false : _c, _d = _a.appear, appear = _d === void 0 ? false : _d, _e = _a.enter, enter = _e === void 0 ? true : _e, _f = _a.exit, exit = _f === void 0 ? true : _f, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited;
    var configuration = {
        appear: appear,
        timeout: getTransitionTimeout({ timeout: timeout, appear: appear, enter: enter, exit: exit }),
        reflow: reflow,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExit: onExit,
        onExiting: onExiting,
        onExited: onExited,
    };
    var configurationRef = useRef(configuration);
    configurationRef.current = configuration;
    var _g = __read(useEnsuredRef(nodeRef), 2), ref = _g[0], refCallback = _g[1];
    var _h = __read(useReducer(function reducer(state, action) {
        var _a = configuration.timeout, appear = _a.appear, enter = _a.enter, exit = _a.exit;
        var appearing = state.appearing;
        switch (action) {
            case "enter": {
                var duration = appearing ? appear : enter;
                return {
                    stage: duration > 0 ? "enter" : "entered",
                    rendered: true,
                    appearing: appearing,
                };
            }
            case "entering":
            case "entered":
                return {
                    stage: action,
                    rendered: true,
                    appearing: appearing,
                };
            case "exit": {
                var stage_1 = exit > 0 ? "exit" : "exited";
                return {
                    stage: stage_1,
                    rendered: !temporary || stage_1 !== "exited",
                    appearing: false,
                };
            }
            case "exiting":
            case "exited":
                return {
                    stage: action,
                    rendered: true,
                    appearing: false,
                };
            case "unmount":
                return {
                    stage: "exited",
                    rendered: false,
                    appearing: false,
                };
        }
    }, INITIAL_STATE, function () {
        return ({
            appearing: appear && transitionIn,
            rendered: !temporary || transitionIn,
            stage: transitionIn && !appear ? "entered" : "exited",
        });
    }), 2), state = _h[0], dispatch = _h[1];
    var appearing = state.appearing, rendered = state.rendered, stage = state.stage;
    var isFirstRender = useRef(true);
    useIsomorphicLayoutEffect(function () {
        var _a = configurationRef.current, appear = _a.appear, timeout = _a.timeout, reflow = _a.reflow, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited;
        if (isFirstRender.current) {
            isFirstRender.current = false;
            if (appear && transitionIn) {
                dispatch("enter");
            }
            return;
        }
        // Cancel any exiting/exited transitions and instead immediately start the
        // enter transition
        if (transitionIn && stage.startsWith("exit")) {
            dispatch("enter");
            return;
        }
        // Cancel any entering/entered transitions and instead immediately start the
        // exit transition
        if (!transitionIn && stage.startsWith("enter")) {
            dispatch("exit");
            return;
        }
        if (reflow && ref.current && stage !== "exited" && stage !== "entered") {
            // force reflow by accessing scrollTop
            ref.current.scrollTop;
        }
        var duration = 0;
        var nextStage = stage;
        switch (stage) {
            case "enter":
                onEnter === null || onEnter === void 0 ? void 0 : onEnter(appearing);
                nextStage = "entering";
                break;
            case "entering":
                onEntering === null || onEntering === void 0 ? void 0 : onEntering(appearing);
                duration = timeout.enter;
                nextStage = "entered";
                break;
            case "entered":
                onEntered === null || onEntered === void 0 ? void 0 : onEntered(appearing);
                break;
            case "exit":
                onExit === null || onExit === void 0 ? void 0 : onExit();
                nextStage = "exiting";
                break;
            case "exiting":
                onExiting === null || onExiting === void 0 ? void 0 : onExiting();
                duration = timeout.exit;
                nextStage = "exited";
                break;
            case "exited":
                onExited === null || onExited === void 0 ? void 0 : onExited();
                break;
        }
        if (stage === nextStage) {
            if (stage === "exited" && temporary) {
                dispatch("unmount");
            }
            return;
        }
        if (duration <= 0) {
            dispatch(nextStage);
            return;
        }
        var timer = window.setTimeout(function () {
            dispatch(nextStage);
        }, duration);
        return function () {
            window.clearTimeout(timer);
        };
    }, [appearing, ref, stage, temporary, transitionIn]);
    return {
        ref: refCallback,
        stage: stage,
        rendered: rendered,
        appearing: appearing,
        transitionTo: dispatch,
    };
}
//# sourceMappingURL=useTransition.js.map