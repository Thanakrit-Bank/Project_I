var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { useCallback, useEffect, useRef, useState } from "react";
import { BELOW_CENTER_ANCHOR, getFixedPosition, useEnsuredRef, useResizeListener, useScrollListener, } from "@react-md/utils";
import { isWithinViewport } from "./utils";
/**
 * This hook is used to attach a temporary (fixed) element to another element
 * within the page. In other words, this is a way to have an element with
 * `position: fixed` as if it were `position: absolute` to a parent element that
 * had `position: relative`.
 *
 * @example
 * Simple Example
 * ```tsx
 * import { ReactElement, useRef, useState } from "react";
 * import { Button } from "@react-md/button";
 * import { useCSSTransition, useFixedPositioning } from "@react-md/transition";
 *
 * function Example(): ReactElement {
 *   const fixedTo = useRef<HTMLButtonElement>(null);
 *   const [transitionIn, setTransitionIn] = useState(false);
 *   const { style, transitionOptions } = useFixedPositioning({
 *     fixedTo,
 *   });
 *   const { elementProps, rendered } = useCSSTransition({
 *     ...transitionOptions,
 *     transitionIn,
 *     temporary: true,
 *     timeout: {
 *       enter: 200,
 *       exit: 150,
 *     },
 *     classNames: {
 *       enter: "enter",
 *       enterActive: "enter--active",
 *       exit: "exit",
 *       exitActive: "exit--active",
 *     },
 *   });
 *
 *   return (
 *     <>
 *       <Button
 *         ref={fixedTo}
 *         onClick={() => setTransitionIn(!transitionIn)}
 *       >
 *         Toggle
 *       </Button>
 *       {rendered && (
 *         <div {...elementProps} style={style}>
 *           Fixed Temporary Element
 *         </div>
 *       )}
 *     </>
 *   );
 * }
 * ```
 *
 * @typeParam FixedToElement - An HTMLElement type for the static element.
 * @typeParam FixedElement - An HTMLElement type for the fixed element.
 * @remarks \@since 4.0.0
 */
export function useFixedPositioning(_a) {
    var propStyle = _a.style, nodeRef = _a.nodeRef, fixedTo = _a.fixedTo, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, _b = _a.anchor, anchor = _b === void 0 ? BELOW_CENTER_ANCHOR : _b, disableSwapping = _a.disableSwapping, disableVHBounds = _a.disableVHBounds, initialX = _a.initialX, initialY = _a.initialY, preventOverlap = _a.preventOverlap, transformOrigin = _a.transformOrigin, vhMargin = _a.vhMargin, vwMargin = _a.vwMargin, width = _a.width, xMargin = _a.xMargin, yMargin = _a.yMargin, getFixedPositionOptions = _a.getFixedPositionOptions, onScroll = _a.onScroll, onResize = _a.onResize;
    var _c = __read(useState(), 2), style = _c[0], setStyle = _c[1];
    var _d = __read(useState(false), 2), active = _d[0], setActive = _d[1];
    var _e = __read(useEnsuredRef(nodeRef), 2), ref = _e[0], refHandler = _e[1];
    var options = {
        ref: ref,
        fixedTo: fixedTo,
        anchor: anchor,
        disableSwapping: disableSwapping,
        disableVHBounds: disableVHBounds,
        preventOverlap: preventOverlap,
        transformOrigin: transformOrigin,
        vhMargin: vhMargin,
        vwMargin: vwMargin,
        width: width,
        xMargin: xMargin,
        yMargin: yMargin,
        getFixedPositionOptions: getFixedPositionOptions,
    };
    var optionsRef = useRef(options);
    optionsRef.current = options;
    var updateStyle = useCallback(function () {
        var _a = optionsRef.current, ref = _a.ref, fixedTo = _a.fixedTo, anchor = _a.anchor, disableSwapping = _a.disableSwapping, disableVHBounds = _a.disableVHBounds, preventOverlap = _a.preventOverlap, transformOrigin = _a.transformOrigin, vhMargin = _a.vhMargin, vwMargin = _a.vwMargin, width = _a.width, xMargin = _a.xMargin, yMargin = _a.yMargin, getFixedPositionOptions = _a.getFixedPositionOptions;
        var element = ref.current;
        var container = fixedTo.current;
        var style = getFixedPosition(__assign({ container: container, element: element, anchor: anchor, disableSwapping: disableSwapping, disableVHBounds: disableVHBounds, initialX: initialX, initialY: initialY, preventOverlap: preventOverlap, transformOrigin: transformOrigin, vhMargin: vhMargin, vwMargin: vwMargin, width: width, xMargin: xMargin, yMargin: yMargin }, getFixedPositionOptions === null || getFixedPositionOptions === void 0 ? void 0 : getFixedPositionOptions())).style;
        setStyle(style);
        setActive(!!element && !element.hidden);
        // Only changing the initialX and initialY should cause the useEffect below
        // to trigger, which is why everything else is set in a ref.
    }, [initialX, initialY]);
    useResizeListener({
        enabled: active,
        onResize: function (event) {
            onResize === null || onResize === void 0 ? void 0 : onResize(event);
            updateStyle();
        },
    });
    useScrollListener({
        enabled: active,
        onScroll: function (event) {
            var fixedElement = ref.current;
            var fixedToElement = fixedTo.current;
            if (onScroll && fixedElement && fixedToElement) {
                onScroll(event, {
                    visible: isWithinViewport({ fixedElement: fixedElement, fixedToElement: fixedToElement }),
                    fixedElement: fixedElement,
                    fixedToElement: fixedToElement,
                });
            }
            updateStyle();
        },
    });
    useEffect(function () {
        if (!ref.current || !ref.current.hidden) {
            updateStyle();
        }
    }, [ref, updateStyle]);
    var callbacks = {
        onEnter: function (appearing) {
            onEnter === null || onEnter === void 0 ? void 0 : onEnter(appearing);
            updateStyle();
        },
        onEntering: function (appearing) {
            onEntering === null || onEntering === void 0 ? void 0 : onEntering(appearing);
            updateStyle();
        },
        onEntered: function (appearing) {
            onEntered === null || onEntered === void 0 ? void 0 : onEntered(appearing);
            updateStyle();
        },
        onExited: function () {
            onExited === null || onExited === void 0 ? void 0 : onExited();
            setActive(false);
        },
    };
    return {
        ref: refHandler,
        style: __assign(__assign({}, style), propStyle),
        callbacks: callbacks,
        updateStyle: updateStyle,
        transitionOptions: __assign(__assign({}, callbacks), { nodeRef: refHandler }),
    };
}
//# sourceMappingURL=useFixedPositioning.js.map