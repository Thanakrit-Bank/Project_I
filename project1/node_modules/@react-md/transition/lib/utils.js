"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isWithinViewport = exports.getTransitionClassNames = exports.getElementSizing = exports.getTransitionTimeout = void 0;
var utils_1 = require("@react-md/utils");
/**
 * @remarks \@since 4.0.0
 * @internal
 */
function getTransitionTimeout(_a) {
    var _b;
    var timeout = _a.timeout, appear = _a.appear, enter = _a.enter, exit = _a.exit;
    if (typeof timeout === "number") {
        return {
            appear: appear ? timeout : 0,
            enter: enter ? timeout : 0,
            exit: exit ? timeout : 0,
        };
    }
    return {
        appear: (appear && ((_b = timeout.appear) !== null && _b !== void 0 ? _b : timeout.enter)) || 0,
        enter: (enter && timeout.enter) || 0,
        exit: (exit && timeout.exit) || 0,
    };
}
exports.getTransitionTimeout = getTransitionTimeout;
/**
 * A small util that will find the max-height, padding-top, and padding-bottom
 * for the provided element. This is really used to be able to transition the
 * max-height value since `max-height: auto` does not transition. The only way
 * to get transition is to change max-height values manually.
 *
 * @remarks \@since 4.0.0
 * @internal
 */
function getElementSizing(element) {
    var maxHeight;
    var paddingTop;
    var paddingBottom;
    if (element) {
        maxHeight = element.scrollHeight;
        // clone the element (not deep) just to figure out it's padding without the
        // inline styles applied
        var cloned = element.cloneNode(false);
        cloned.style.maxHeight = "";
        cloned.style.padding = "";
        cloned.style.paddingLeft = element.style.paddingLeft;
        cloned.style.paddingRight = element.style.paddingRight;
        cloned.style.visibility = "hidden";
        var container = element.parentElement || document.body;
        container.appendChild(cloned);
        var style = window.getComputedStyle(cloned);
        if (style.paddingTop) {
            paddingTop = parseFloat(style.paddingTop);
        }
        if (style.paddingBottom) {
            paddingBottom = parseFloat(style.paddingBottom);
        }
        container.removeChild(cloned);
    }
    return { maxHeight: maxHeight, paddingTop: paddingTop, paddingBottom: paddingBottom };
}
exports.getElementSizing = getElementSizing;
/**
 * @remarks \@since 4.0.0
 * @internal
 */
function getTransitionClassNames(_a) {
    var classNames = _a.classNames, timeoutOptions = __rest(_a, ["classNames"]);
    var timeout = getTransitionTimeout(timeoutOptions);
    if (typeof classNames === "string") {
        var appear_1 = timeout.appear, enter_1 = timeout.enter, exit_1 = timeout.exit;
        return {
            appear: appear_1 ? "".concat(classNames, "--appear") : "",
            appearActive: appear_1 ? "".concat(classNames, "--appear-active") : "",
            appearDone: "",
            enter: enter_1 ? "".concat(classNames, "--enter") : "",
            enterActive: enter_1 ? "".concat(classNames, "--enter-active") : "",
            enterDone: "",
            exit: exit_1 ? "".concat(classNames, "--exit") : "",
            exitActive: exit_1 ? "".concat(classNames, "--exit-active") : "",
            exitDone: "",
        };
    }
    var _b = classNames.enter, enter = _b === void 0 ? "" : _b, _c = classNames.enterActive, enterActive = _c === void 0 ? "" : _c, _d = classNames.enterDone, enterDone = _d === void 0 ? "" : _d, _e = classNames.exit, exit = _e === void 0 ? "" : _e, _f = classNames.exitActive, exitActive = _f === void 0 ? "" : _f, _g = classNames.exitDone, exitDone = _g === void 0 ? "" : _g, _h = classNames.appear, appear = _h === void 0 ? (timeout.appear && enter) || "" : _h, _j = classNames.appearActive, appearActive = _j === void 0 ? (timeout.appear && enterActive) || "" : _j, _k = classNames.appearDone, appearDone = _k === void 0 ? (timeout.appear && enterDone) || "" : _k;
    return {
        appear: appear,
        appearActive: appearActive,
        appearDone: appearDone,
        enter: enter,
        enterActive: enterActive,
        enterDone: enterDone,
        exit: exit,
        exitActive: exitActive,
        exitDone: exitDone,
    };
}
exports.getTransitionClassNames = getTransitionClassNames;
/**
 * @remarks \@since 4.0.0
 * @internal
 */
function isWithinViewport(_a) {
    var fixedElement = _a.fixedElement, fixedToElement = _a.fixedToElement;
    var fixedElementRect = fixedElement.getBoundingClientRect();
    var fixedToElementRect = fixedToElement.getBoundingClientRect();
    var vh = (0, utils_1.getViewportSize)("height");
    var vw = (0, utils_1.getViewportSize)("width");
    var top = Math.min(fixedElementRect.top, fixedToElementRect.top);
    var right = Math.max(fixedElementRect.right, fixedToElementRect.right);
    var bottom = Math.max(fixedElementRect.bottom, fixedToElementRect.bottom);
    var left = Math.min(fixedElementRect.left, fixedToElementRect.left);
    return bottom >= 0 && top <= vh && right >= 0 && left <= vw;
}
exports.isWithinViewport = isWithinViewport;
//# sourceMappingURL=utils.js.map