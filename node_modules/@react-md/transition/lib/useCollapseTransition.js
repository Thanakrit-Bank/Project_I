"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCollapseTransition = exports.DEFAULT_COLLAPSE_TIMEOUT = exports.DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM = exports.DEFAULT_COLLAPSE_MIN_PADDING_TOP = exports.DEFAULT_COLLAPSE_MIN_HEIGHT = void 0;
var react_1 = require("react");
var classnames_1 = __importDefault(require("classnames"));
var utils_1 = require("@react-md/utils");
var useTransition_1 = require("./useTransition");
var utils_2 = require("./utils");
/**
 * @remarks \@since 2.0.0
 */
exports.DEFAULT_COLLAPSE_MIN_HEIGHT = 0;
/**
 * @remarks \@since 2.0.0
 */
exports.DEFAULT_COLLAPSE_MIN_PADDING_TOP = 0;
/**
 * @remarks \@since 2.0.0
 */
exports.DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM = 0;
/**
 * @remarks \@since 2.0.0
 */
exports.DEFAULT_COLLAPSE_TIMEOUT = {
    enter: 250,
    exit: 200,
};
/**
 * This hook is used to create a transition to collapse and expand an element
 * **inline** with other content like an accordion by animating the
 * `max-height`, `padding-top`, and `padding-bottom` CSS properties. The default
 * behavior is to hide the element completely while collapsed, but providing the
 * `minHeight`, `minPaddingTop`, and `minPaddingBottom` options can make this
 * work like a "See More"/"Preview" type of element
 *
 * @example
 * Simple Example
 * ```tsx
 * import { ReactElement, useState } from "react";
 * import { Button } from "@react-md/button";
 * import { useCollapseTransition } from "@react-md/transition";
 * import { Typography } from "@react-md/typography";
 *
 * function Example(): ReactElement {
 *   const [collapsed, setCollapsed] = useState(true);
 *   const { elementProps, rendered } =
 *     useCollapseTransition({
 *       transitionIn: !collapsed,
 *       // If the collapsible element should maintain state by not unmounting
 *       // while collapsed, uncomment this next line
 *       // temporary: false,
 *     });
 *
 *   return (
 *     <>
 *       <Button onClick={() => setCollapsed(!collapsed)}>
 *         Toggle
 *       </Button>
 *       {rendered && (
 *         <div {...elementProps}>
 *           <Typography>Stuff that should be collapsed</Typography>
 *           <div>Whatever content...</div>
 *         </div>
 *       )}
 *     </>
 *   );
 * }
 * ```
 *
 * @example
 * See More Example
 * ```tsx
 * import { ReactElement, useState } from "react";
 * import { Button } from "@react-md/button";
 * import { IconRotator } from "@react-md/icon";
 * import { KeyboardArrowDownSVGIcon } from "@react-md/material-icons";
 * import { useCollapseTransition } from "@react-md/transition";
 * import { Typography } from "@react-md/typography";
 *
 * import styles from "./Example.module.scss";
 * // pretend styles:
 * //
 * // .container {
 * //   padding: 1rem;
 * //   position: relative;
 * // }
 * //
 * // .button {
 * //   position: absolute;
 * //   right: 0;
 * //   top: 0;
 * // }
 *
 *
 * function Example(): ReactElement {
 *   const [collapsed, setCollapsed] = useState(true);
 *   const { elementProps } =
 *     useCollapseTransition({
 *       transitionIn: !collapsed,
 *       minHeight: 120,
 *       minPaddingTop: 16,
 *       className: styles.container,
 *     });
 *
 *   return (
 *     <div {...elementProps}>
 *       <Button
 *         aria-expanded={!collapsed}
 *         aria-label="Expand"
 *         onClick={() => setCollapsed(!collapsed)}
 *         buttonType="icon"
 *         className={styles.button}
 *       >
 *         <IconRotator rotated={!collapsed}>
 *           <KeyboardArrowDownSVGIcon />
 *         </IconRotator>
 *       </Button>
 *       <SomeComponentWithALotOfContent />
 *     </div>
 *   );
 * }
 * ```
 *
 * @typeParam E - An HTMLElement type used for the ref required for the
 * transition.
 * @remarks \@since 4.0.0
 */
function useCollapseTransition(_a) {
    var propNodeRef = _a.nodeRef, propStyle = _a.style, className = _a.className, transitionIn = _a.transitionIn, _b = _a.timeout, timeout = _b === void 0 ? exports.DEFAULT_COLLAPSE_TIMEOUT : _b, _c = _a.minHeight, minHeight = _c === void 0 ? exports.DEFAULT_COLLAPSE_MIN_HEIGHT : _c, _d = _a.minPaddingTop, minPaddingTop = _d === void 0 ? exports.DEFAULT_COLLAPSE_MIN_PADDING_TOP : _d, _e = _a.minPaddingBottom, minPaddingBottom = _e === void 0 ? exports.DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM : _e, _f = _a.temporary, temporary = _f === void 0 ? minHeight === 0 && minPaddingTop === 0 && minPaddingBottom === 0 : _f, _g = _a.appear, appear = _g === void 0 ? false : _g, _h = _a.enter, enter = _h === void 0 ? true : _h, _j = _a.exit, exit = _j === void 0 ? true : _j, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited;
    var _k = __read((0, utils_1.useEnsuredRef)(propNodeRef), 2), nodeRef = _k[0], refCallback = _k[1];
    var _l = __read((0, react_1.useState)(function () {
        if (transitionIn) {
            return undefined;
        }
        return {
            maxHeight: minHeight,
            paddingTop: minPaddingTop,
            paddingBottom: minPaddingBottom,
        };
    }), 2), style = _l[0], setStyle = _l[1];
    var transitionTimeout = (0, utils_2.getTransitionTimeout)({
        timeout: timeout,
        appear: appear,
        enter: enter,
        exit: exit,
    });
    var _m = (0, useTransition_1.useTransition)({
        nodeRef: refCallback,
        timeout: timeout,
        transitionIn: transitionIn,
        reflow: true,
        appear: appear,
        enter: enter,
        exit: exit,
        temporary: temporary,
        onEnter: function (appearing) {
            onEnter === null || onEnter === void 0 ? void 0 : onEnter(appearing);
            setStyle({
                maxHeight: minHeight,
                paddingTop: minPaddingTop,
                paddingBottom: minPaddingBottom,
            });
        },
        onEntering: function (appearing) {
            onEntering === null || onEntering === void 0 ? void 0 : onEntering(appearing);
            var _a = (0, utils_2.getElementSizing)(nodeRef.current), maxHeight = _a.maxHeight, paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
            var duration = appearing
                ? transitionTimeout.appear
                : transitionTimeout.enter;
            setStyle({
                maxHeight: maxHeight,
                paddingTop: paddingTop,
                paddingBottom: paddingBottom,
                transitionDuration: "".concat(duration, "ms"),
            });
        },
        onEntered: function (appearing) {
            onEntered === null || onEntered === void 0 ? void 0 : onEntered(appearing);
            setStyle(undefined);
        },
        onExit: function () {
            onExit === null || onExit === void 0 ? void 0 : onExit();
            var _a = (0, utils_2.getElementSizing)(nodeRef.current), maxHeight = _a.maxHeight, paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
            setStyle({
                maxHeight: maxHeight,
                paddingTop: paddingTop,
                paddingBottom: paddingBottom,
                transitionDuration: "".concat(transitionTimeout.exit, "ms"),
            });
        },
        onExiting: function () {
            onExiting === null || onExiting === void 0 ? void 0 : onExiting();
            setStyle({
                maxHeight: minHeight,
                paddingTop: minPaddingTop,
                paddingBottom: minPaddingBottom,
                transitionDuration: "".concat(transitionTimeout.exit, "ms"),
            });
        },
        onExited: function () {
            onExited === null || onExited === void 0 ? void 0 : onExited();
            setStyle({
                maxHeight: minHeight,
                paddingTop: minPaddingTop,
                paddingBottom: minPaddingBottom,
            });
        },
    }), appearing = _m.appearing, rendered = _m.rendered, ref = _m.ref, stage = _m.stage, transitionTo = _m.transitionTo;
    var entering = stage === "enter" || stage === "entering";
    var exiting = stage === "exit" || stage === "exiting";
    var collapsible = transitionTimeout.enter !== 0 || transitionTimeout.exit !== 0;
    var elementProps = {
        ref: ref,
        style: __assign(__assign({}, style), propStyle),
        className: (0, classnames_1.default)({
            "rmd-collapse": collapsible,
            "rmd-collapse--enter": entering,
            "rmd-collapse--leave": exiting,
            "rmd-collapse--no-overflow": !transitionIn || style,
        }, className) || undefined,
        hidden: !transitionIn &&
            rendered &&
            stage === "exited" &&
            !temporary &&
            minHeight === 0 &&
            minPaddingTop === 0 &&
            minPaddingBottom === 0,
    };
    return __assign(__assign({}, elementProps), { stage: stage, rendered: rendered, appearing: appearing, elementProps: elementProps, transitionTo: transitionTo });
}
exports.useCollapseTransition = useCollapseTransition;
//# sourceMappingURL=useCollapseTransition.js.map