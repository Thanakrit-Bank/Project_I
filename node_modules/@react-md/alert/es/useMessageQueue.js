var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { useCallback, useEffect, useReducer, useRef } from "react";
import { useTimeout, useToggle } from "@react-md/utils";
import { DEFAULT_MESSAGE_QUEUE_TIMEOUT } from "./MessageQueueContext";
import { useWindowBlurPause } from "./useWindowBlurPause";
export var ADD_MESSAGE = "ADD_MESSAGE";
export var POP_MESSAGE = "POP_MESSAGE";
export var RESET_QUEUE = "RESET_QUEUE";
/**
 * @internal
 */
export function addMessage(message, duplicates) {
    return { type: ADD_MESSAGE, message: message, duplicates: duplicates };
}
/**
 * @internal
 */
export var popMessage = function () { return ({ type: POP_MESSAGE }); };
/**
 * @internal
 */
export var resetQueue = function () { return ({ type: RESET_QUEUE }); };
/**
 * This function is used to update the message queue state by adding a new
 * message when needed.
 *
 * @internal
 */
export function handleAddMessage(state, message, duplicates) {
    if (state.length === 0) {
        return [message];
    }
    var messageId = message.messageId, _a = message.messagePriority, messagePriority = _a === void 0 ? "normal" : _a;
    var i = state.findIndex(function (mes) { return mes.messageId === messageId; });
    var isNext = messagePriority === "next";
    var isNormal = messagePriority === "normal";
    var isReplace = messagePriority === "replace";
    var isImmediate = messagePriority === "immediate";
    var isDuplicable = duplicates === "allow";
    var isRestart = duplicates === "restart";
    if (isNext || isImmediate) {
        var nextState = state.slice();
        // remove the existing message if duplicated messages aren't allowed. This
        // will kind of act like a replace + next behavior
        if (!isDuplicable && i > 0) {
            nextState.splice(i, 1);
        }
        var _b = __read(nextState), current = _b[0], remaining = _b.slice(1);
        if (isImmediate && current.messagePriority !== "immediate") {
            return __spreadArray([current, message, current], __read(remaining), false);
        }
        return __spreadArray([current, message], __read(remaining), false);
    }
    if (i === -1 || (isDuplicable && isNormal)) {
        return __spreadArray(__spreadArray([], __read(state), false), [message], false);
    }
    if (isNormal) {
        if (isRestart) {
            // creating a new state so that the queue visibility hook can still be
            // triggered which will restart the timer
            return state.slice();
        }
        return state;
    }
    if (isReplace) {
        var nextState = state.slice();
        nextState[i] = message;
        return nextState;
    }
    return __spreadArray(__spreadArray([], __read(state), false), [message], false);
}
/**
 * @internal
 */
export function reducer(state, action) {
    switch (action.type) {
        case ADD_MESSAGE:
            return handleAddMessage(state, action.message, action.duplicates);
        case POP_MESSAGE:
            return state.length ? state.slice(1) : state;
        case RESET_QUEUE:
            return state.length ? [] : state;
        default:
            return state;
    }
}
/**
 * This is the main logic for the message queue behavior that will handle:
 *
 * - creating timeouts as needed to show/hide toasts within the `SnackbarQueue`
 *   component
 * - create a way to push messages with optional priority onto the queue
 *
 * @internal
 */
export function useMessageQueue(_a) {
    var _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b, _c = _a.duplicates, duplicates = _c === void 0 ? "allow" : _c, _d = _a.defaultQueue, defaultQueue = _d === void 0 ? [] : _d;
    var _e = __read(useReducer(function (state, action) { return reducer(state, action); }, defaultQueue), 2), queue = _e[0], dispatch = _e[1];
    var queueRef = useRef(queue);
    var addMessageDispatch = useCallback(function (message) {
        if (duplicates !== "allow" && !message.messageId) {
            throw new Error("A messageId is required when the \"".concat(duplicates, "\" duplicate behavior is enabled but it was not provided in the current message."));
        }
        dispatch({ type: ADD_MESSAGE, message: message, duplicates: duplicates });
    }, [duplicates]);
    var popMessageDispatch = useCallback(function () {
        dispatch(popMessage());
    }, []);
    var resetQueueDispatch = useCallback(function () {
        dispatch(resetQueue());
        return queueRef.current;
    }, []);
    var _f = __read(useToggle(defaultQueue.length > 0), 3), visible = _f[0], showMessage = _f[1], hideMessage = _f[2];
    var _g = __read(useTimeout(hideMessage, timeout), 3), startTimer = _g[0], stopTimer = _g[1], restartTimer = _g[2];
    useEffect(function () {
        // this effect will handle all the "logic" for transitioning between each
        // message along with the message priority updates.
        var _a = __read(queue, 2), message = _a[0], nextMessage = _a[1];
        if (!message) {
            return;
        }
        var prevQueue = queueRef.current;
        var _b = __read(prevQueue, 1), prevMessage = _b[0];
        if (message.messagePriority !== "immediate" &&
            nextMessage &&
            nextMessage.messagePriority === "immediate") {
            stopTimer();
            if (!visible) {
                popMessageDispatch();
                return;
            }
            hideMessage();
            return;
        }
        if (!visible) {
            showMessage();
        }
        if (queue.length === prevQueue.length && message === prevMessage) {
            restartTimer();
        }
        // only want to run this on queue changes
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [queue]);
    useWindowBlurPause({
        startTimer: startTimer,
        stopTimer: stopTimer,
        visible: visible,
        message: queue[0],
    });
    useEffect(function () {
        queueRef.current = queue;
    });
    return {
        queue: queue,
        resetQueue: resetQueueDispatch,
        visible: visible,
        hideMessage: hideMessage,
        addMessage: addMessageDispatch,
        popMessage: popMessageDispatch,
        startTimer: startTimer,
        stopTimer: stopTimer,
        restartTimer: restartTimer,
    };
}
//# sourceMappingURL=useMessageQueue.js.map