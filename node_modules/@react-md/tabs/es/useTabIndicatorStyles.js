var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { useCallback, useState } from "react";
import { useDir, useIsomorphicLayoutEffect, useKeyboardFocusContext, useResizeObserver, } from "@react-md/utils";
import { useTabs } from "./TabsManager";
var TAB_WIDTH_VAR = "--rmd-tab-width";
var TAB_OFFSET_VAR = "--rmd-tab-offset";
export function useTabIndicatorStyles(options) {
    var ref = options.ref, activeIndex = options.activeIndex;
    var isRTL = useDir().dir === "rtl";
    var tabs = useTabs().tabs;
    var watching = useKeyboardFocusContext().watching;
    var _a = __read(useState(function () {
        var _a;
        var tabWidth = "".concat(100 / tabs.length, "%");
        return _a = {},
            _a[TAB_WIDTH_VAR] = tabWidth,
            _a[TAB_OFFSET_VAR] = "calc(".concat(activeIndex, " * ").concat(tabWidth, ")"),
            _a;
    }), 2), indicatorStyles = _a[0], setIndicatorStyles = _a[1];
    var updateIndicatorStyles = useCallback(function () {
        var _a;
        var _b;
        // this is kind of hacky -- the styles should update when switching between
        // RTL, but the RTL state isn't required for any styles. Just reference it
        // so that the hooks eslint rule doesn't show a warning...
        isRTL;
        var current = (_b = watching.current[activeIndex]) === null || _b === void 0 ? void 0 : _b.element;
        if (!current) {
            return;
        }
        var cssVars = (_a = {},
            _a[TAB_WIDTH_VAR] = "".concat(current.offsetWidth, "px"),
            _a[TAB_OFFSET_VAR] = "".concat(current.offsetLeft, "px"),
            _a);
        setIndicatorStyles(function (prevStyles) {
            if (prevStyles[TAB_WIDTH_VAR] === cssVars[TAB_WIDTH_VAR] &&
                prevStyles[TAB_OFFSET_VAR] === cssVars[TAB_OFFSET_VAR]) {
                return prevStyles;
            }
            return cssVars;
        });
    }, [activeIndex, watching, isRTL]);
    var _b = __read(useResizeObserver(updateIndicatorStyles, {
        ref: ref,
    }), 2), nodeRef = _b[0], refCallback = _b[1];
    useIsomorphicLayoutEffect(function () {
        var _a;
        var activeTab = (_a = watching.current[activeIndex]) === null || _a === void 0 ? void 0 : _a.element;
        var container = nodeRef.current;
        if (!activeTab || !container) {
            return;
        }
        // NOTE: This should probably be moved into the `scrollIntoView` util
        // whenever I do another major version update. This is the same code, just
        // using horizontal properties
        var offsetLeft = activeTab.offsetLeft;
        var scrollLeft = container.scrollLeft;
        var tabRight = offsetLeft + activeTab.offsetWidth;
        var containerRight = container.offsetWidth + scrollLeft;
        if (tabRight > containerRight) {
            container.scrollLeft = tabRight - container.offsetWidth;
        }
        else if (offsetLeft < scrollLeft) {
            container.scrollLeft = offsetLeft;
        }
    }, [activeIndex, isRTL, nodeRef, watching]);
    return {
        refCallback: refCallback,
        indicatorStyles: indicatorStyles,
    };
}
//# sourceMappingURL=useTabIndicatorStyles.js.map