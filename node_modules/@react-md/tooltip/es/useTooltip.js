var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { useCallback, useEffect, useRef, useState } from "react";
import cn from "classnames";
import { useFixedPositioning } from "@react-md/transition";
import { ABOVE_CENTER_ANCHOR, BELOW_CENTER_ANCHOR, CENTER_LEFT_ANCHOR, CENTER_RIGHT_ANCHOR, unitToNumber, useHoverMode, useOnUnmount, useUserInteractionMode, } from "@react-md/utils";
import { DEFAULT_TOOLTIP_DELAY, DEFAULT_TOOLTIP_DENSE_SPACING, DEFAULT_TOOLTIP_MARGIN, DEFAULT_TOOLTIP_POSITION, DEFAULT_TOOLTIP_SPACING, DEFAULT_TOOLTIP_THRESHOLD, TOOLTIP_SPACING_VAR, } from "./constants";
import { useTooltipPosition } from "./useTooltipPosition";
/** @internal */
function getAnchor(position) {
    switch (position) {
        case "above":
            return ABOVE_CENTER_ANCHOR;
        case "below":
            return BELOW_CENTER_ANCHOR;
        case "left":
            return CENTER_LEFT_ANCHOR;
        case "right":
            return CENTER_RIGHT_ANCHOR;
        default:
            throw new Error("Invalid position: ".concat(position));
    }
}
/**
 * This hook is used to handle the positioning and visibility of the tooltip
 * component mostly within the {@link Tooltipped} component.
 *
 * @example
 * Simple Usage
 * ```tsx
 * import { Button } from "@react-md/button";
 * import { useTooltip, Tooltip } from "@react-md/tooltip";
 *
 * function Example() {
 *   const { tooltipProps, elementProps } = useTooltip({
 *     baseId: 'my-element',
 *   });
 *
 *   return (
 *     <>
 *       <Button {...elementProps}>Button</Button>
 *       <Tooltip {...tooltipProps}>
 *         Tooltip Content
 *       </Tooltip>
 *     </>
 *   );
 * }
 * ```
 *
 * @remarks \@since 2.8.0
 * @param options - All the {@link TooltipHookOptions} to configure the tooltip behavior.
 * @returns The {@link TooltipHookReturnValue}
 */
export function useTooltip(_a) {
    var baseId = _a.baseId, propStyle = _a.style, describedBy = _a.describedBy, _b = _a.dense, dense = _b === void 0 ? false : _b, _c = _a.spacing, spacing = _c === void 0 ? DEFAULT_TOOLTIP_SPACING : _c, _d = _a.denseSpacing, denseSpacing = _d === void 0 ? DEFAULT_TOOLTIP_DENSE_SPACING : _d, determinedPosition = _a.position, _e = _a.defaultPosition, defaultPosition = _e === void 0 ? DEFAULT_TOOLTIP_POSITION : _e, _f = _a.vwMargin, vwMargin = _f === void 0 ? DEFAULT_TOOLTIP_MARGIN : _f, _g = _a.vhMargin, vhMargin = _g === void 0 ? DEFAULT_TOOLTIP_MARGIN : _g, _h = _a.threshold, threshold = _h === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _h, _j = _a.touchTime, touchTime = _j === void 0 ? DEFAULT_TOOLTIP_DELAY : _j, _k = _a.focusTime, focusTime = _k === void 0 ? DEFAULT_TOOLTIP_DELAY : _k, propOnFocus = _a.onFocus, propOnBlur = _a.onBlur, propOnKeyDown = _a.onKeyDown, onClick = _a.onClick, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, propOnTouchStart = _a.onTouchStart, propOnContextMenu = _a.onContextMenu, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, _l = _a.disabled, disabled = _l === void 0 ? false : _l, _m = _a.disableSwapping, disableSwapping = _m === void 0 ? false : _m, propDisableHoverMode = _a.disableHoverMode, _o = _a.disableAutoSpacing, disableAutoSpacing = _o === void 0 ? process.env.NODE_ENV === "test" : _o;
    var containerRef = useRef(null);
    var _p = __read(useTooltipPosition({
        position: determinedPosition,
        defaultPosition: defaultPosition,
        threshold: threshold,
    }), 2), position = _p[0], updatePosition = _p[1];
    var mode = useUserInteractionMode();
    var _q = __read(useState(null), 2), initiatedBy = _q[0], setInitiatedBy = _q[1];
    var windowFocusEvent = useRef(false);
    var timeout = useRef(undefined);
    var _r = useHoverMode({
        disabled: propDisableHoverMode || disabled,
        exitVisibilityDelay: 0,
    }), visible = _r.visible, setVisible = _r.setVisible, handlers = _r.handlers, _hoverHandlers = _r.hoverHandlers, disableHoverMode = _r.disableHoverMode, clearHoverTimeout = _r.clearHoverTimeout, others = __rest(_r, ["visible", "setVisible", "handlers", "hoverHandlers", "disableHoverMode", "clearHoverTimeout"]);
    var hide = useCallback(function () {
        window.clearTimeout(timeout.current);
        setVisible(false);
        setInitiatedBy(null);
    }, [setVisible]);
    var onBlur = function (event) {
        propOnBlur === null || propOnBlur === void 0 ? void 0 : propOnBlur(event);
        if (disabled || initiatedBy !== "keyboard") {
            return;
        }
        hide();
    };
    var onFocus = function (event) {
        propOnFocus === null || propOnFocus === void 0 ? void 0 : propOnFocus(event);
        if (disabled) {
            return;
        }
        // if the element gained focus immediately after the browser window gains
        // focus, do not start timer and ignore this event instead
        if (windowFocusEvent.current) {
            windowFocusEvent.current = false;
            return;
        }
        if (mode !== "keyboard" || initiatedBy !== null) {
            return;
        }
        setInitiatedBy("keyboard");
        window.clearTimeout(timeout.current);
        containerRef.current = event.currentTarget;
        updatePosition(event.currentTarget);
        timeout.current = window.setTimeout(function () {
            setVisible(true);
        }, focusTime);
    };
    var onKeyDown = function (event) {
        propOnKeyDown === null || propOnKeyDown === void 0 ? void 0 : propOnKeyDown(event);
        if (disabled || initiatedBy !== "keyboard" || event.key !== "Escape") {
            return;
        }
        hide();
    };
    var onTouchStart = function (event) {
        propOnTouchStart === null || propOnTouchStart === void 0 ? void 0 : propOnTouchStart(event);
        if (event.isPropagationStopped() || disabled || mode !== "touch") {
            return;
        }
        setInitiatedBy("touch");
        window.clearTimeout(timeout.current);
        timeout.current = window.setTimeout(function () {
            setVisible(true);
        }, touchTime);
        containerRef.current = event.currentTarget;
        updatePosition(event.currentTarget);
    };
    var onContextMenu = function (event) {
        var _a;
        propOnContextMenu === null || propOnContextMenu === void 0 ? void 0 : propOnContextMenu(event);
        if (event.isPropagationStopped() || disabled || mode !== "touch") {
            return;
        }
        // Need to prevent the context menu from displaying and display the tooltip
        // instead.
        event.preventDefault();
        var selection = window.getSelection();
        var node = (_a = selection === null || selection === void 0 ? void 0 : selection.anchorNode) === null || _a === void 0 ? void 0 : _a.parentElement;
        /* istanbul ignore next */
        if (selection && node && event.currentTarget.contains(node)) {
            selection.empty();
        }
        setVisible(true);
    };
    useEffect(function () {
        if (disabled) {
            return;
        }
        if (mode !== "keyboard") {
            windowFocusEvent.current = false;
            return;
        }
        var handler = function () {
            if (document.hidden) {
                hide();
                windowFocusEvent.current =
                    document.activeElement === containerRef.current;
            }
        };
        window.addEventListener("visibilitychange", handler);
        return function () {
            window.removeEventListener("visibilitychange", handler);
        };
    }, [disabled, hide, mode]);
    useEffect(function () {
        if (initiatedBy !== "touch") {
            return;
        }
        window.addEventListener("scroll", hide, true);
        window.addEventListener("touchend", hide, true);
        return function () {
            window.removeEventListener("scroll", hide, true);
            window.removeEventListener("touchend", hide, true);
        };
    }, [hide, initiatedBy, setVisible]);
    useOnUnmount(function () {
        window.clearTimeout(timeout.current);
    });
    var nodeRef = useRef(null);
    var _s = useFixedPositioning({
        style: propStyle,
        nodeRef: nodeRef,
        anchor: getAnchor(position),
        disableSwapping: disableSwapping !== null && disableSwapping !== void 0 ? disableSwapping : !!determinedPosition,
        fixedTo: containerRef,
        getFixedPositionOptions: function () {
            var tooltipSpacing = dense ? denseSpacing : spacing;
            var node = nodeRef.current;
            /* istanbul ignore next */
            if (!disableAutoSpacing && node) {
                tooltipSpacing = window
                    .getComputedStyle(node)
                    .getPropertyValue(TOOLTIP_SPACING_VAR);
            }
            var currentSpacing = unitToNumber(tooltipSpacing);
            return {
                vwMargin: vwMargin,
                vhMargin: vhMargin,
                xMargin: currentSpacing,
                yMargin: currentSpacing,
            };
        },
        onResize: hide,
        onScroll: hide,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExited: onExited,
    }), ref = _s.ref, style = _s.style, transitionOptions = _s.callbacks;
    var tooltipHandlers = {
        onFocus: onFocus,
        onBlur: onBlur,
        onKeyDown: onKeyDown,
        onTouchStart: onTouchStart,
        onContextMenu: onContextMenu,
        onClick: function (event) {
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            if (event.isPropagationStopped() || disabled) {
                return;
            }
            setVisible(false);
            setInitiatedBy(null);
            window.clearTimeout(timeout.current);
            clearHoverTimeout();
        },
        onMouseEnter: function (event) {
            onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(event);
            if (disabled) {
                return;
            }
            if (initiatedBy !== null) {
                event.stopPropagation();
                return;
            }
            containerRef.current = event.currentTarget;
            updatePosition(event.currentTarget);
            setInitiatedBy("mouse");
            handlers.onMouseEnter(event);
        },
        onMouseLeave: function (event) {
            onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(event);
            if (disabled) {
                return;
            }
            if (initiatedBy !== "mouse") {
                event.stopPropagation();
                return;
            }
            setInitiatedBy(null);
            handlers.onMouseLeave(event);
        },
    };
    var tooltipId = "".concat(baseId, "-tooltip");
    var elementProps = __assign({ id: baseId, "aria-describedby": cn(visible && tooltipId, describedBy) || undefined }, tooltipHandlers);
    var tooltipProps = __assign({ id: tooltipId, ref: ref, dense: dense, visible: visible, position: position, style: style }, transitionOptions);
    return __assign(__assign({}, others), { visible: visible, setVisible: setVisible, handlers: tooltipHandlers, elementProps: elementProps, tooltipProps: tooltipProps, disableHoverMode: disableHoverMode, clearHoverTimeout: clearHoverTimeout });
}
//# sourceMappingURL=useTooltip.js.map