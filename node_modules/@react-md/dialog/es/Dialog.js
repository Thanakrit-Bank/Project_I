var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef } from "react";
import cn from "classnames";
import { Overlay } from "@react-md/overlay";
import { ConditionalPortal } from "@react-md/portal";
import { useCSSTransition } from "@react-md/transition";
import { bem, FocusContainer, useCloseOnEscape, useScrollLock, } from "@react-md/utils";
import { useNestedDialogFixes } from "./useNestedDialogFixes";
// used to disable the overlay click-to-close functionality when the `modal` prop is enabled.
var noop = function () {
    // do nothing
};
var block = bem("rmd-dialog");
/** @remarks \@since 4.0.0 */
export var DEFAULT_DIALOG_CLASSNAMES = {
    appear: "rmd-dialog--enter",
    appearActive: "rmd-dialog--enter-active",
    enter: "rmd-dialog--enter",
    enterActive: "rmd-dialog--enter-active",
    exit: "rmd-dialog--exit",
    exitActive: "rmd-dialog--exit-active",
};
/** @remarks \@since 4.0.0 */
export var DEFAULT_DIALOG_TIMEOUT = {
    enter: 200,
    exit: 150,
};
/**
 * A dialog is used to show important content above all other elements within
 * the page. This is normally used for alerts, confirmations, or just temporary
 * content. The dialog within react-md also has the additional features for
 * accessibility:
 *
 * - automatically focus the dialog on mount for keyboard users
 * - prevent elements outside of the dialog to be focused
 * - close via the escape key
 * - prevent the page outside of the dialog from being scrolled
 *
 * To complete the dialog accessibility requirements, every dialog **must**
 * provide an `id` and either an `aria-label` describing the dialog or an
 * `aria-labelledby` id that points to an element describing this dialog.
 *
 * @example
 * Simple Example
 * ```tsx
 * import { ReactElement, useState } from "react";
 * import { Button } from "@react-md/button";
 * import {
 *   Dialog,
 *   DialogHeader,
 *   DialogTitle,
 *   DialogContent,
 *   DialogFooter,
 * } from "@react-md/dialog";
 * import { Typography } from "@react-md/typography";
 *
 * function Example(): ReactElement {
 *   const [visible, setVisible] = useState(false);
 *   const hide = (): void => {
 *     setVisible(false);
 *   };
 *
 *   return (
 *     <>
 *       <Button onClick={() => setVisible(!visible)}>
 *         Show Dialog
 *       </Button>
 *       <Dialog
 *         aria-labelledby="dialog-title"
 *         id="simple-dialog"
 *         visible={visible}
 *         onRequestClose={hide}
 *       >
 *         <DialogHeader>
 *           <DialogTitle id="dialog-title">Simple Dialog</DialogTitle>
 *         </DialogHeader>
 *         <DialogContent>
 *           <Typography margin="none">This is some text in a dialog.</Typography>
 *         </DialogContent>
 *         <DialogFooter>
 *           <Button onClick={hide}>
 *             Close
 *           </Button>
 *         </DialogFooter>
 *       </Dialog>
 *     </>
 *   );
 * }
 * ```
 */
export var Dialog = forwardRef(function Dialog(_a, nodeRef) {
    var _b = _a.component, component = _b === void 0 ? "div" : _b, _c = _a.tabIndex, tabIndex = _c === void 0 ? -1 : _c, children = _a.children, className = _a.className, containerStyle = _a.containerStyle, containerClassName = _a.containerClassName, propOverlay = _a.overlay, overlayStyle = _a.overlayStyle, overlayClassName = _a.overlayClassName, _d = _a.overlayHidden, overlayHidden = _d === void 0 ? false : _d, visible = _a.visible, onRequestClose = _a.onRequestClose, _e = _a.forceContainer, forceContainer = _e === void 0 ? false : _e, _f = _a.defaultFocus, defaultFocus = _f === void 0 ? "first" : _f, _g = _a.portal, portal = _g === void 0 ? true : _g, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, _h = _a.appear, appear = _h === void 0 ? false : _h, _j = _a.enter, enter = _j === void 0 ? true : _j, _k = _a.exit, exit = _k === void 0 ? true : _k, _l = _a.disableTransition, disableTransition = _l === void 0 ? false : _l, _m = _a.classNames, classNames = _m === void 0 ? DEFAULT_DIALOG_CLASSNAMES : _m, _o = _a.timeout, timeout = _o === void 0 ? DEFAULT_DIALOG_TIMEOUT : _o, _p = _a.temporary, temporary = _p === void 0 ? true : _p, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, _q = _a.modal, modal = _q === void 0 ? false : _q, _r = _a.role, role = _r === void 0 ? "dialog" : _r, _s = _a.type, type = _s === void 0 ? "centered" : _s, _t = _a.disableScrollLock, disableScrollLock = _t === void 0 ? false : _t, _u = _a.disableEscapeClose, propDisableEscapeClose = _u === void 0 ? false : _u, _v = _a.disableFocusContainer, disableFocusContainer = _v === void 0 ? false : _v, _w = _a.disableTabFocusWrap, disableTabFocusWrap = _w === void 0 ? false : _w, _x = _a.disableFocusOnMount, disableFocusOnMount = _x === void 0 ? false : _x, _y = _a.disableFocusOnUnmount, disableFocusOnUnmount = _y === void 0 ? false : _y, _z = _a.disableNestedDialogFixes, disableNestedDialogFixes = _z === void 0 ? false : _z, onKeyDown = _a.onKeyDown, overlayProps = _a.overlayProps, props = __rest(_a, ["component", "tabIndex", "children", "className", "containerStyle", "containerClassName", "overlay", "overlayStyle", "overlayClassName", "overlayHidden", "visible", "onRequestClose", "forceContainer", "defaultFocus", "portal", "portalInto", "portalIntoId", "appear", "enter", "exit", "disableTransition", "classNames", "timeout", "temporary", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "modal", "role", "type", "disableScrollLock", "disableEscapeClose", "disableFocusContainer", "disableTabFocusWrap", "disableFocusOnMount", "disableFocusOnUnmount", "disableNestedDialogFixes", "onKeyDown", "overlayProps"]);
    var id = props.id;
    var isNoneRole = role === "none";
    var isFullPage = type === "full-page";
    var isCentered = type === "centered";
    var _0 = useNestedDialogFixes({
        id: id,
        visible: visible,
        disabled: disableNestedDialogFixes,
        disableEscapeClose: propDisableEscapeClose,
    }), disableOverlay = _0.disableOverlay, disableEscapeClose = _0.disableEscapeClose;
    useScrollLock(visible && !isNoneRole && !disableScrollLock);
    var overlayEl = null;
    if (typeof propOverlay === "boolean" ? propOverlay : !isFullPage) {
        // do not add the portal props to the overlay element since the portalling
        // is handled in here. With how portals work, this would be rendered **after**
        // the dialog instead of before which breaks some dialog styles
        overlayEl = (_jsx(Overlay, __assign({ id: "".concat(id, "-overlay") }, overlayProps, { style: overlayStyle, className: cn("rmd-dialog-overlay", overlayClassName), hidden: overlayHidden || disableOverlay, visible: visible, clickable: !modal, onRequestClose: modal ? noop : onRequestClose })));
    }
    var _1 = useCSSTransition({
        nodeRef: nodeRef,
        transitionIn: visible,
        timeout: timeout,
        classNames: classNames,
        className: cn(block({
            centered: isCentered,
            "full-page": isFullPage,
        }), className),
        appear: !disableTransition && appear,
        enter: !disableTransition && enter,
        exit: !disableTransition && exit,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExit: onExit,
        onExiting: onExiting,
        onExited: onExited,
        temporary: temporary,
    }), elementProps = _1.elementProps, rendered = _1.rendered;
    var dialog = (_jsx(FocusContainer, __assign({}, props, elementProps, { role: isNoneRole ? undefined : role, "aria-modal": (!isNoneRole && !!overlayEl) || undefined, tabIndex: tabIndex, component: component, defaultFocus: defaultFocus, disableTabFocusWrap: isNoneRole || disableTabFocusWrap || disableFocusContainer, disableFocusOnMount: isNoneRole || disableFocusContainer || disableFocusOnMount, disableFocusOnMountScroll: true, disableFocusOnUnmount: isNoneRole || disableFocusContainer || disableFocusOnUnmount, onKeyDown: useCloseOnEscape(onRequestClose, disableEscapeClose || isNoneRole, onKeyDown) }, { children: children })));
    if (isCentered || forceContainer) {
        // the additional container is only required when we don't have a full page dialog. it's just
        // used to apply flex center to the dialog and add some margin
        dialog = (_jsx("span", __assign({ id: "".concat(id, "-container"), style: containerStyle, className: cn("rmd-dialog-container", containerClassName) }, { children: dialog })));
    }
    return (_jsxs(ConditionalPortal, __assign({ portal: !isNoneRole && portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: [overlayEl, rendered && dialog] })));
});
//# sourceMappingURL=Dialog.js.map