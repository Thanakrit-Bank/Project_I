"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFixedPosition = void 0;
var constants_1 = require("./constants");
var createHorizontalPosition_1 = require("./createHorizontalPosition");
var createVerticalPosition_1 = require("./createVerticalPosition");
var findSizingContainer_1 = require("./findSizingContainer");
var getElementRect_1 = require("./getElementRect");
var getTransformOrigin_1 = require("./getTransformOrigin");
var getViewportSize_1 = require("./getViewportSize");
/**
 * This is used when there is no `container` element so that some styles can
 * still be created. The main use-case for this is context menus and when the
 * `initialX` and `initialY` options have been provided.
 *
 * @internal
 * @remarks \@since 5.0.0
 */
var FALLBACK_DOM_RECT = {
    x: 0,
    y: 0,
    height: 0,
    width: 0,
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    toJSON: function () {
        // do nothing
    },
};
/**
 * One of the most complicated functions in this project that will attempt to
 * position an element relative to another container element while still being
 * visible within the viewport. Below is the logical flow for attempting to fix
 * the element to the container:
 *
 * No Container: If there is no container element, return the provided x and y
 * positions and no styles since there's nothing we can use to calculate the
 * position.
 *
 * No Element: If the container was provided but the element to position does
 * not exist, return an style object containing the `left` and `top` values for
 * the container and apply as many of the positioning options as possible so
 * that the styles are "as close as possible" before the fixed element is added
 * to the DOM. This will also return the provided x and y positions since
 * nothing could be swapped around yet.
 *
 * Container and Element: If both the container and fixed element were provided,
 * apply all the positioning options to the `left` and `top` values of the
 * container based on the sizes of both elements.
 *
 * Now that the `left` and `top` values were applied, check to see if the
 * element is fully visible within the viewport with the provided positioning
 * options. If it is fully visible, do nothing else. If it isn't... follow the
 * next flow:
 *
 * First, check the horizontal sizes and make sure that the element is still
 * within the viewport with the provided viewwidth margin. If it isn't, first
 * try to swap only to a `right` style instead of left to see if that fixes it,
 * otherwise keep both the `left` and `right` styles.
 */
function getFixedPosition(_a) {
    var _b;
    var container = _a.container, element = _a.element, _c = _a.anchor, anchor = _c === void 0 ? constants_1.BELOW_CENTER_ANCHOR : _c, initialX = _a.initialX, initialY = _a.initialY, _d = _a.vwMargin, vwMargin = _d === void 0 ? 16 : _d, _e = _a.vhMargin, vhMargin = _e === void 0 ? 16 : _e, _f = _a.xMargin, xMargin = _f === void 0 ? 0 : _f, _g = _a.yMargin, yMargin = _g === void 0 ? 0 : _g, _h = _a.width, widthType = _h === void 0 ? "auto" : _h, _j = _a.preventOverlap, preventOverlap = _j === void 0 ? false : _j, _k = _a.transformOrigin, transformOrigin = _k === void 0 ? false : _k, _l = _a.disableSwapping, propDisableSwapping = _l === void 0 ? false : _l, _m = _a.disableVHBounds, disableVHBounds = _m === void 0 ? false : _m;
    container = (0, findSizingContainer_1.findSizingContainer)(container);
    if (process.env.NODE_ENV !== "production") {
        if (widthType !== "auto" && anchor.x !== "center") {
            throw new Error('Unable to use a calculated width when the horizontal anchor is not `"center"`.');
        }
        if (preventOverlap && anchor.y !== "above" && anchor.y !== "below") {
            throw new Error('Unable to prevent overlap when the vertical anchor is not `"above"` or `"below"`');
        }
    }
    if (!element) {
        return {
            actualX: anchor.x,
            actualY: anchor.y,
        };
    }
    var containerRect = (_b = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _b !== void 0 ? _b : FALLBACK_DOM_RECT;
    var vh = (0, getViewportSize_1.getViewportSize)("height");
    var vw = (0, getViewportSize_1.getViewportSize)("width");
    var _o = (0, getElementRect_1.getElementRect)(element), height = _o.height, elWidth = _o.width;
    if (disableVHBounds) {
        var dialog = element.closest("[role='dialog']");
        if (!dialog) {
            initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;
        }
    }
    var disableSwapping = propDisableSwapping || !container;
    var _p = (0, createHorizontalPosition_1.createHorizontalPosition)({
        x: anchor.x,
        vw: vw,
        vwMargin: vwMargin,
        xMargin: xMargin,
        width: widthType,
        elWidth: elWidth,
        initialX: initialX,
        containerRect: containerRect,
        disableSwapping: disableSwapping,
    }), left = _p.left, right = _p.right, width = _p.width, minWidth = _p.minWidth, actualX = _p.actualX;
    var _q = (0, createVerticalPosition_1.createVerticalPosition)({
        y: anchor.y,
        vh: vh,
        vhMargin: vhMargin,
        yMargin: yMargin,
        initialY: initialY,
        elHeight: height,
        containerRect: containerRect,
        disableSwapping: disableSwapping,
        preventOverlap: preventOverlap,
        disableVHBounds: disableVHBounds,
    }), top = _q.top, bottom = _q.bottom, actualY = _q.actualY;
    return {
        actualX: actualX,
        actualY: actualY,
        style: {
            left: left,
            top: top,
            right: right,
            bottom: bottom,
            width: width,
            minWidth: minWidth,
            position: disableVHBounds ? "absolute" : "fixed",
            transformOrigin: transformOrigin
                ? (0, getTransformOrigin_1.getTransformOrigin)({ x: actualX, y: actualY })
                : undefined,
        },
    };
}
exports.getFixedPosition = getFixedPosition;
//# sourceMappingURL=getFixedPosition.js.map