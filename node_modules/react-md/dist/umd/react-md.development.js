(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('crypto')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', 'crypto'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactMD = {}, global.React, global.ReactDOM, global.crypto));
})(this, (function (exports, require$$1, reactDom, crypto) { 'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
	var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);

	var jsxRuntime = {exports: {}};

	var reactJsxRuntime_production_min = {};

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	var objectAssign;
	var hasRequiredObjectAssign;

	function requireObjectAssign () {
		if (hasRequiredObjectAssign) return objectAssign;
		hasRequiredObjectAssign = 1;
		/* eslint-disable no-unused-vars */
		var getOwnPropertySymbols = Object.getOwnPropertySymbols;
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.prototype.propertyIsEnumerable;

		function toObject(val) {
			if (val === null || val === undefined) {
				throw new TypeError('Object.assign cannot be called with null or undefined');
			}

			return Object(val);
		}

		function shouldUseNative() {
			try {
				if (!Object.assign) {
					return false;
				}

				// Detect buggy property enumeration order in older V8 versions.

				// https://bugs.chromium.org/p/v8/issues/detail?id=4118
				var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
				test1[5] = 'de';
				if (Object.getOwnPropertyNames(test1)[0] === '5') {
					return false;
				}

				// https://bugs.chromium.org/p/v8/issues/detail?id=3056
				var test2 = {};
				for (var i = 0; i < 10; i++) {
					test2['_' + String.fromCharCode(i)] = i;
				}
				var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
					return test2[n];
				});
				if (order2.join('') !== '0123456789') {
					return false;
				}

				// https://bugs.chromium.org/p/v8/issues/detail?id=3056
				var test3 = {};
				'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
					test3[letter] = letter;
				});
				if (Object.keys(Object.assign({}, test3)).join('') !==
						'abcdefghijklmnopqrst') {
					return false;
				}

				return true;
			} catch (err) {
				// We don't expect any of the above to throw, but better to be safe.
				return false;
			}
		}

		objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
			var from;
			var to = toObject(target);
			var symbols;

			for (var s = 1; s < arguments.length; s++) {
				from = Object(arguments[s]);

				for (var key in from) {
					if (hasOwnProperty.call(from, key)) {
						to[key] = from[key];
					}
				}

				if (getOwnPropertySymbols) {
					symbols = getOwnPropertySymbols(from);
					for (var i = 0; i < symbols.length; i++) {
						if (propIsEnumerable.call(from, symbols[i])) {
							to[symbols[i]] = from[symbols[i]];
						}
					}
				}
			}

			return to;
		};
		return objectAssign;
	}

	/** @license React v17.0.2
	 * react-jsx-runtime.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactJsxRuntime_production_min;

	function requireReactJsxRuntime_production_min () {
		if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
		hasRequiredReactJsxRuntime_production_min = 1;
	requireObjectAssign();var f=require$$1__default["default"],g=60103;reactJsxRuntime_production_min.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");reactJsxRuntime_production_min.Fragment=h("react.fragment");}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};
		function q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;
		return reactJsxRuntime_production_min;
	}

	(function (module) {

		{
		  module.exports = requireReactJsxRuntime_production_min();
		}
	} (jsxRuntime));

	var classnames = {exports: {}};

	/*!
	  Copyright (c) 2018 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/

	(function (module) {
		/* global define */

		(function () {

			var hasOwn = {}.hasOwnProperty;

			function classNames() {
				var classes = [];

				for (var i = 0; i < arguments.length; i++) {
					var arg = arguments[i];
					if (!arg) continue;

					var argType = typeof arg;

					if (argType === 'string' || argType === 'number') {
						classes.push(arg);
					} else if (Array.isArray(arg)) {
						if (arg.length) {
							var inner = classNames.apply(null, arg);
							if (inner) {
								classes.push(inner);
							}
						}
					} else if (argType === 'object') {
						if (arg.toString === Object.prototype.toString) {
							for (var key in arg) {
								if (hasOwn.call(arg, key) && arg[key]) {
									classes.push(key);
								}
							}
						} else {
							classes.push(arg.toString());
						}
					}
				}

				return classes.join(' ');
			}

			if (module.exports) {
				classNames.default = classNames;
				module.exports = classNames;
			} else {
				window.classNames = classNames;
			}
		}());
	} (classnames));

	var cn = classnames.exports;

	/**
	 * A utility function to get the current container for the portal.  For SSR, the
	 * container will always be `null` since portals don't work server side.
	 *
	 * @param into - The element to portal into
	 * @param intoId - An id for an element to portal into
	 * @returns the portal container element or null
	 */
	function getContainer(into, intoId) {
	    if (typeof document === "undefined") {
	        return null;
	    }
	    var container = null;
	    if (typeof into === "undefined" && typeof intoId === "undefined") {
	        container = document.body;
	    }
	    else if (typeof intoId === "string") {
	        container = document.getElementById(intoId);
	    }
	    else if (typeof into === "string") {
	        container = document.querySelector(into);
	    }
	    else if (typeof into === "function") {
	        container = into();
	    }
	    else if (into) {
	        container = into;
	    }
	    return container;
	}

	var __read$1c = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This component is a simple wrapper for the `createPortal` API from ReactDOM
	 * that will just ensure that `null` is always returned for server side
	 * rendering as well as a "nice" way to choose specific portal targets or just
	 * falling back to the `document.body`.
	 */
	function Portal(_a) {
	    var into = _a.into, intoId = _a.intoId, children = _a.children;
	    var _b = __read$1c(require$$1.useState(null), 2), container = _b[0], setContainer = _b[1];
	    // setting the container via useEffect instead of immediately in the render
	    // just so that it doesn't throw an error immediately if the dom hasn't fully
	    // painted after a SSR
	    require$$1.useEffect(function () {
	        var nextContainer = getContainer(into, intoId);
	        if (container !== nextContainer) {
	            setContainer(nextContainer);
	        }
	    }, [into, intoId, container]);
	    if (!container) {
	        return null;
	    }
	    return reactDom.createPortal(children, container);
	}

	var __assign$3e = (undefined && undefined.__assign) || function () {
	    __assign$3e = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3e.apply(this, arguments);
	};
	/**
	 * This is a very simple component that is used in other places within react-md
	 * to conditionally render the children within a portal or not based on general
	 * portal config props.
	 */
	function ConditionalPortal(_a) {
	    var portal = _a.portal, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, children = _a.children;
	    if (!portal && !portalInto && !portalIntoId) {
	        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children });
	    }
	    return (jsxRuntime.exports.jsx(Portal, __assign$3e({ into: portalInto, intoId: portalIntoId }, { children: children })));
	}

	/**
	 * A small utility function that allows me to apply a passed in ref along with
	 * my own custom ref logic.
	 *
	 * @param instance - The DOM Node instance
	 * @param ref - The prop ref
	 */
	function applyRef(instance, ref) {
	    if (!ref) {
	        return;
	    }
	    if (typeof ref === "function") {
	        ref(instance);
	    }
	    else if (typeof ref === "object") {
	        ref.current = instance;
	    }
	}

	function modify(base, modifier) {
	    if (!modifier) {
	        return base;
	    }
	    var hasOwn = Object.prototype.hasOwnProperty;
	    return Object.keys(modifier).reduce(function (s, mod) {
	        if (hasOwn.call(modifier, mod) && modifier[mod]) {
	            s = "".concat(s, " ").concat(base, "--").concat(mod);
	        }
	        return s;
	    }, base);
	}
	/**
	 * Applies the BEM styled class name to an element.
	 *
	 * @see https://en.bem.info/methodology/css/
	 * @param base - The base class to use
	 * @returns a function to call that generates the full class name
	 */
	function bem(base) {
	    /**
	     * Creates the full class name from the base block name. This can be called
	     * without any arguments which will just return the base block name (kind of
	     * worthless), or you can provide a child element name and modifiers.
	     *
	     * @param elementOrModifier - This is either the child element name or an
	     * object of modifiers to apply. This **must** be a string if the second
	     * argument is provided.
	     * @param modifier - Any optional modifiers to apply to the block and optional
	     * element.
	     * @returns the full class name
	     */
	    return function block(elementOrModifier, modifier) {
	        if (!elementOrModifier) {
	            return base;
	        }
	        if (typeof elementOrModifier !== "string") {
	            return modify(base, elementOrModifier);
	        }
	        return modify("".concat(base, "__").concat(elementOrModifier), modifier);
	    };
	}

	var SHORTHAND_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	var VERBOSE_REGEX = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
	/**
	 * Converts a hex string into an rgb value. This is useful for detecting color
	 * contrast ratios and other stuff.
	 *
	 * @param hex - The hex string to convert
	 * @returns an object containing the r, g, b values for the color.
	 */
	function hexToRGB(hex) {
	    hex = hex.replace(SHORTHAND_REGEX, function (_m, r, g, b) { return "".concat(r).concat(r).concat(g).concat(g).concat(b).concat(b); });
	    var result = hex.match(VERBOSE_REGEX) || [];
	    var r = parseInt(result[1] || "", 16) || 0;
	    var g = parseInt(result[2] || "", 16) || 0;
	    var b = parseInt(result[3] || "", 16) || 0;
	    return [r, g, b];
	}

	var __read$1b = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var RED_MULTIPLIER = 0.2126;
	var GREEN_MULTIPLIER = 0.7152;
	var BLUE_MULTIPLIER = 0.0722;
	/**
	 * I really couldn't figure out how to name these "magic" numbers since the
	 * formula doesn't really describe it much:
	 *
	 * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
	 * @internal
	 */
	function get8BitColor(color) {
	    color /= 255;
	    if (color <= 0.03928) {
	        return color / 12.92;
	    }
	    return Math.pow(((color + 0.055) / 1.055), 2.4);
	}
	/**
	 * A number closest to 0 should be closest to black while a number closest to 1
	 * should be closest to white.
	 *
	 * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
	 * @internal
	 */
	function getLuminance(color) {
	    var _a = __read$1b(hexToRGB(color), 3), r = _a[0], g = _a[1], b = _a[2];
	    var red = get8BitColor(r) * RED_MULTIPLIER;
	    var green = get8BitColor(g) * GREEN_MULTIPLIER;
	    var blue = get8BitColor(b) * BLUE_MULTIPLIER;
	    return red + green + blue;
	}

	/**
	 * Gets the contrast ratio between a background color and a foreground color.
	 *
	 * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
	 *
	 * @param background - The background color
	 * @param foreground - The foreground color. This is normally the `color` css
	 * value.
	 * @returns the contrast ratio between the background and foreground colors.
	 */
	function getContrastRatio(background, foreground) {
	    var backgroundLuminance = getLuminance(background) + 0.05;
	    var foregroundLuminance = getLuminance(foreground) + 0.05;
	    return (Math.max(backgroundLuminance, foregroundLuminance) /
	        Math.min(backgroundLuminance, foregroundLuminance));
	}

	/**
	 * The contrast ratio that can be used for large text where large text is
	 * considered 18pt or 14pt bold.
	 */
	var LARGE_TEXT_CONTRAST_RATIO = 3;
	/**
	 * The contrast ratio that can be used for normal text.
	 */
	var NORMAL_TEXT_CONTRAST_RATIO = 4.5;
	/**
	 * The AAA contrast ratio for passing WGAC 2.0 color contrast ratios.
	 */
	var AAA_CONTRAST_RATIO = 7;
	/**
	 * Checks if there is an acceptable contrast ratio between the background and
	 * foreground colors based on the provided compliance level.
	 *
	 * @param background - The background color to check against
	 * @param foreground - The foreground color to check against
	 * @param compliance - The compliance level to use or a custom number as a
	 * ratio.
	 * @returns true if there is enough contrast between the foreground and
	 * background colors for the provided compliance level.
	 */
	function isContrastCompliant(background, foreground, compliance) {
	    if (compliance === void 0) { compliance = "normal"; }
	    var ratio;
	    switch (compliance) {
	        case "large":
	            ratio = LARGE_TEXT_CONTRAST_RATIO;
	            break;
	        case "normal":
	            ratio = NORMAL_TEXT_CONTRAST_RATIO;
	            break;
	        case "AAA":
	            ratio = AAA_CONTRAST_RATIO;
	            break;
	        default:
	            ratio = compliance;
	    }
	    return getContrastRatio(background, foreground) >= ratio;
	}

	/**
	 * Typeguard that will check if the provided checkable thing is a
	 * MutableRefObject or just an HTMLElement.
	 *
	 * @internal
	 */
	var isMutableRefObject = function (thing) {
	    return !!thing &&
	        typeof thing.current !== "undefined";
	};
	/**
	 * Gets the HTMLElement or null from the checkable thing.
	 *
	 * @internal
	 */
	var getElement$1 = function (thing) {
	    if (isMutableRefObject(thing)) {
	        return thing.current;
	    }
	    return thing;
	};
	/**
	 * Checks if a container element contains another element as a child while
	 * allowing for nulls or a MutableRefObject of HTMLElement or null. Mostly just
	 * a convenience function that should be used internally.
	 *
	 * @param container - The element to use as a container element. This can be an
	 * HTMLElement, null, or a MutableRefObject of HTMLElement or null.
	 * @param child - The element that might be a child of the container
	 * element. This can be an HTMLElement, null, or a MutableRefObject of
	 * HTMLElement or null.
	 * @returns True if the container contains the child element and both the
	 * container and child are valid HTMLElements (not null).
	 * @internal
	 */
	function containsElement(container, child) {
	    container = getElement$1(container);
	    child = getElement$1(child);
	    return !!(container && child && container.contains(child));
	}

	var __assign$3d = (undefined && undefined.__assign) || function () {
	    __assign$3d = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3d.apply(this, arguments);
	};
	/**
	 * This is normally used for reusable shareable configs that have multiple
	 * shared options with default values that should be used. This basically works
	 * just like `defaultProps` in react.
	 *
	 * @internal
	 * @param optional - The original object that has the optional/omitted values
	 * @param required - The required default values that should be used to fill the
	 * optional object with
	 * @returns a new object with both the values of the optional and required
	 * objects but use the optional values if they were defined.
	 */
	function defaults(optional, required) {
	    var keys = Object.keys(required);
	    return keys.reduce(function (result, key) {
	        if (typeof result[key] === "undefined") {
	            result[key] = required[key];
	        }
	        return result;
	    }, __assign$3d({}, optional));
	}

	var __assign$3c = (undefined && undefined.__assign) || function () {
	    __assign$3c = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3c.apply(this, arguments);
	};
	var __rest$2B = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$1a = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var context$g = require$$1.createContext({
	    root: true,
	    dir: "ltr",
	    toggleDir: function () {
	        throw new Error("Tried to toggle the current writing direction without initializing the `Dir` component.");
	    },
	});
	var Provider$9 = context$g.Provider;
	/**
	 * Gets the writing direction context which provides access to the current `dir`
	 * and a `toggleDir` function.
	 *
	 * @remarks \@since 2.3.0
	 */
	function useDir() {
	    var _a = require$$1.useContext(context$g); _a.root; var current = __rest$2B(_a, ["root"]);
	    return current;
	}
	/**
	 * @remarks \@since 2.3.0
	 */
	var DEFAULT_DIR = function () {
	    var dir = "ltr";
	    if (typeof document !== "undefined") {
	        var rootDir = document.documentElement.getAttribute("dir");
	        dir = rootDir === "rtl" ? "rtl" : "ltr";
	    }
	    return dir;
	};
	/**
	 * The `Dir` component is used to handle the current writing direction within
	 * your app as well as conditionally updating the writing direction for small
	 * sections in your app. When this component is used for the first time near the
	 * root of your React component tree, the current direction will be applied to
	 * the root `<html>` element. Otherwise the current dir will be cloned into the
	 * child element so it can be passed as a prop.
	 *
	 * ```tsx
	 * // html element will be updated to have `dir="ltr"`
	 * ReactDOM.render(<Dir><App /></Dir>, root)
	 * ```
	 *
	 * ```tsx
	 * // html element will be updated to have `dir="rtl"` while the `<span>` will
	 * // now be `<span dir="ltr">`
	 * ReactDOM.render(
	 *   <Dir defaultDir="rtl">
	 *     <Some>
	 *       <Other>
	 *         <Components>
	 *           <Dir defaultDir="ltr">
	 *             <span>Content</span>
	 *           </Dir>
	 *         </Components>
	 *       </Other>
	 *     </Some>
	 *   </Dir>,
	 *   root
	 * );
	 * ```
	 *
	 * Note: Since the `dir` is cloned into the child element, you need to make sure
	 * that the child is either a DOM element or the `dir` prop is passed from your
	 * custom component.
	 *
	 * @remarks \@since 2.3.0
	 */
	function Dir(_a) {
	    var children = _a.children, _b = _a.defaultDir, defaultDir = _b === void 0 ? DEFAULT_DIR : _b;
	    var root = require$$1.useContext(context$g).root;
	    var _c = __read$1a(require$$1.useState(defaultDir), 2), dir = _c[0], setDir = _c[1];
	    require$$1.useEffect(function () {
	        if (!root || typeof document === "undefined") {
	            return;
	        }
	        document.documentElement.setAttribute("dir", dir);
	        return function () {
	            document.documentElement.removeAttribute("dir");
	        };
	    }, [dir, root]);
	    var toggleDir = require$$1.useCallback(function () {
	        setDir(function (prevDir) { return (prevDir === "ltr" ? "rtl" : "ltr"); });
	    }, []);
	    var value = require$$1.useMemo(function () { return ({ root: false, dir: dir, toggleDir: toggleDir }); }, [dir, toggleDir]);
	    var child = require$$1.Children.only(children);
	    if (!root) {
	        child = require$$1.cloneElement(child, { dir: dir });
	    }
	    return jsxRuntime.exports.jsx(Provider$9, __assign$3c({ value: value }, { children: child }));
	}

	/**
	 * This hook allows you to provide anything that should be "cached" and puts it
	 * into a ref that'll be updated each render. This is pretty overkill for most
	 * places, but it's really nice when you want to create event handlers that
	 * shouldn't update if the developer used arrow functions to define callbacks.
	 * (A great example is for ref callbacks that *shouldn't* be triggered each
	 * render. But that might just be a programming error instead).
	 *
	 * @param cacheable - The cacheable thing that gets updated after each render.
	 * @returns a mutable ref object containing the current cache.
	 */
	function useRefCache(cacheable) {
	    var ref = require$$1.useRef(cacheable);
	    require$$1.useEffect(function () {
	        ref.current = cacheable;
	    });
	    return ref;
	}

	var delegatedEvents = [];
	/* eslint-disable @typescript-eslint/explicit-function-return-type */
	/**
	 * Creates the delegated event handler that will run all the callbacks once an
	 * event happens. The callbacks' invocation can also be throttled for event
	 * types that trigger rapidly for additional performance.
	 *
	 * The `<K extends keyof WindowEventMap` is a nice thing I found while looking
	 * through the `lib.d.ts` implementation of `addEventListener` that will allow
	 * you to get the "correct" event type when using the `add` and `remove`
	 * functions once you have created this event handler. Otherwise there'd be ts
	 * errors trying to do `MouseEvent` or `KeyboardEvent` in your listeners.
	 */
	function createEventHandler(throttle, callbacks) {
	    var running = false;
	    var runCallbacks = function (event) { return function () {
	        for (var i = 0; i < callbacks.length; i += 1) {
	            callbacks[i](event);
	        }
	        running = false;
	    }; };
	    return function eventHandler(event) {
	        if (!throttle) {
	            runCallbacks(event)();
	            return;
	        }
	        if (running) {
	            return;
	        }
	        running = true;
	        window.requestAnimationFrame(runCallbacks(event));
	    };
	}
	/* eslint-enable @typescript-eslint/explicit-function-return-type */
	/**
	 * Creates a throttled event handler for the provided event type and event
	 * target.
	 */
	function createDelegatedEventHandler(eventType, eventTarget, throttle, options) {
	    if (eventTarget === void 0) { eventTarget = window; }
	    if (throttle === void 0) { throttle = false; }
	    var callbacks = [];
	    var handler = createEventHandler(throttle, callbacks);
	    return {
	        /**
	         * Attempts to add the provided callback to the list of callbacks for the
	         * throttled event. If this is the first callback to be added, the throttled
	         * event will also be started.
	         */
	        add: function (callback) {
	            if (!callbacks.length) {
	                eventTarget.addEventListener(eventType, handler, options);
	            }
	            if (callbacks.indexOf(callback) === -1) {
	                callbacks.push(callback);
	            }
	        },
	        /**
	         * Attempts to remove the provided callback from the list of callbacks for
	         * the throttled event. If this is the last callback that was removed, the
	         * throttled event will also be stopped.
	         */
	        remove: function (callback) {
	            var i = callbacks.indexOf(callback);
	            if (i >= 0) {
	                callbacks.splice(i, 1);
	                if (!callbacks.length) {
	                    eventTarget.removeEventListener(eventType, handler, options);
	                }
	            }
	        },
	    };
	}
	/**
	 * Creates a delegated event listener using custom events. Most of this code
	 * comes from the MDN about resize listeners.
	 *
	 * This will return an object for adding or removing event handlers for the
	 * provided `eventType` since only one base throttled event listener will be
	 * created. Each callback that is added will be called with the event each time
	 * the event is triggered. This does mean that you will manually need to remove
	 * your callback like normal or else it can be called when no longer in use.
	 * This also means that it doesn't "hurt" to call this function without
	 * immediately calling the `add` function since the event won't start until
	 * there is at least 1 callback.
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/Events/resize#Examples
	 * @param eventType - One of the event types that should be used to create a
	 * delegated event for. This should be things like resize, click, scroll, etc.
	 * @param eventTarget - The target that should have the delegated event handler
	 * attached to. This is normally the window, but can be any element as needed.
	 * @param throttle - Boolean if the event should be throttled or not. Normally
	 * only event types like resize or scroll should be throttled for performance
	 * boosts, but anything can be.
	 * @returns The delegated event handler that allows you to add or remove
	 * `EventListener`s to that event.
	 */
	function delegateEvent(eventType, eventTarget, throttle, options) {
	    if (eventTarget === void 0) { eventTarget = window; }
	    if (throttle === void 0) { throttle = eventType === "resize" || eventType === "scroll"; }
	    var index = delegatedEvents.findIndex(function (event) {
	        return event.type === eventType &&
	            event.target === eventTarget &&
	            event.options === options &&
	            event.throttle === throttle;
	    });
	    if (index === -1) {
	        delegatedEvents.push({
	            type: eventType,
	            target: eventTarget,
	            options: options,
	            throttle: throttle,
	            handler: createDelegatedEventHandler(eventType, eventTarget, throttle, options),
	        });
	        index = delegatedEvents.length - 1;
	    }
	    return delegatedEvents[index].handler;
	}

	/**
	 *
	 * @remarks \@since 5.0.0 Moved the `AddEventListenerOptions` to no longer be
	 * part of an `options` object.
	 */
	function useScrollListener(_a) {
	    var once = _a.once, _b = _a.passive, passive = _b === void 0 ? true : _b, signal = _a.signal, capture = _a.capture, _c = _a.enabled, enabled = _c === void 0 ? true : _c, onScroll = _a.onScroll;
	    var scrollHandlerRef = useRefCache(onScroll);
	    require$$1.useEffect(function () {
	        if (!enabled) {
	            return;
	        }
	        var eventHandler = delegateEvent("scroll", window, true, {
	            once: once,
	            passive: passive,
	            signal: signal,
	            capture: capture,
	        });
	        var scrollHandler = scrollHandlerRef.current;
	        eventHandler.add(scrollHandler);
	        return function () {
	            eventHandler.remove(scrollHandler);
	        };
	    }, [capture, enabled, once, passive, scrollHandlerRef, signal]);
	}

	/**
	 * This is a simple component wrapper for the `useScrollListener` hook.
	 */
	function ScrollListener(props) {
	    useScrollListener(props);
	    return null;
	}

	/**
	 * Gets the current percentage based on the min, max, and current value.
	 *
	 * @returns the percentage that the `value` is between the `min` and `max`
	 * values.
	 * @internal
	 * @remarks \@since 4.0.1 uses an object for options instead of multiple
	 * arguments.
	 */
	function getPercentage(_a) {
	    var min = _a.min, max = _a.max, value = _a.value, _b = _a.validate, validate = _b === void 0 ? true : _b;
	    if (validate) {
	        if (min >= max) {
	            throw new RangeError("A range must have the min value less than the max value");
	        }
	        if (value > max || value < min) {
	            throw new RangeError("A value must be between the min and max values");
	        }
	    }
	    var range = max - min;
	    var start = value - min;
	    var percentage = start / range;
	    return Math.max(0, Math.min(Math.abs(percentage), 1));
	}

	/**
	 * The amount of time a user must hover an element before the temporary element
	 * becomes visible.
	 *
	 * @remarks \@since 2.8.0
	 */
	var DEFAULT_HOVER_MODE_VISIBLE_IN_TIME = 1000;
	/**
	 * The amount of time the user must no longer hover any element attached to the
	 * {@link HoverModeProvider} to disable the hover mode.
	 *
	 * @remarks \@since 2.8.0
	 */
	var DEFAULT_HOVER_MODE_DEACTIVATION_TIME = 1000;
	/**
	 * The amount of time the user must not hover any element attached to the same
	 * instance of the {@link useHoverMode} hook when the using the sticky mode.
	 *
	 * @remarks \@since 5.0.0 This was named the
	 * `DEFAULT_HOVER_MODE_STICKY_EXIT_TIME` before.
	 */
	var DEFAULT_HOVER_MODE_EXIT_TIME = 300;

	/**
	 * A simple hook that only triggers the callback when a component is unmounted.
	 * This will make sure that the callback function does not have a stale closure
	 * by the time the component unmounts as well.
	 *
	 * @example
	 * Simple Example
	 * ```ts
	 * useOnUnmount(() => {
	 *   console.log('Component is unmounted.');
	 * });
	 *
	 * const [data, setData] = useState(initialData);
	 * useOnUnmount(() => {
	 *   API.saveCurrentData(data);
	 * });
	 *
	 * // update data
	 * ```
	 *
	 * @remarks \@since 2.7.1
	 * @param callback - the function to call when the component unmounts.
	 */
	function useOnUnmount(callback) {
	    var ref = require$$1.useRef(callback);
	    require$$1.useEffect(function () {
	        ref.current = callback;
	    });
	    return require$$1.useEffect(function () { return function () { return ref.current(); }; }, []);
	}

	/** @internal */
	var noop$c = function () {
	    // do nothing
	};
	/** @internal */
	var context$f = require$$1.createContext({
	    visibleInTime: DEFAULT_HOVER_MODE_VISIBLE_IN_TIME,
	    enableHoverMode: noop$c,
	    disableHoverMode: noop$c,
	    startDisableTimer: noop$c,
	});
	/**
	 * @internal
	 * @remarks \@since 2.8.0
	 */
	var HoverModeContextProvider = context$f.Provider;
	/**
	 * Gets the {@link HoverModeContext} which allows you implement hover mode
	 * functionality for any component. This is mostly an internal hook since
	 * everything you need will be available in the {@link useHoverMode} hook.
	 *
	 * @internal
	 * @remarks \@since 2.8.0
	 * @returns The {@link HoverModeContext}
	 */
	function useHoverModeContext() {
	    return require$$1.useContext(context$f);
	}

	var __assign$3b = (undefined && undefined.__assign) || function () {
	    __assign$3b = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3b.apply(this, arguments);
	};
	var __read$19 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This component should normally be mounted near the root of your app to enable
	 * hover mode for child components. However, it can also be used at other levels
	 * if hover mode functionality should not carry over between two different parts
	 * of the screen.
	 *
	 * @example
	 * Separating Hover Mode
	 * ```tsx
	 * export default function Example(): ReactElement {
	 *   return (
	 *     <>
	 *       <HoverModeProvider>
	 *         <HeaderActions />
	 *       </HoverModeProvider>
	 *       <HoverModeProvider>
	 *         <MainContent />
	 *       </HoverModeProvider>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 2.8.0
	 */
	function HoverModeProvider(_a) {
	    var children = _a.children, _b = _a.disabled, disabled = _b === void 0 ? false : _b, _c = _a.defaultVisibleInTime, defaultVisibleInTime = _c === void 0 ? DEFAULT_HOVER_MODE_VISIBLE_IN_TIME : _c, _d = _a.deactivateTime, deactivateTime = _d === void 0 ? DEFAULT_HOVER_MODE_DEACTIVATION_TIME : _d;
	    var _e = __read$19(require$$1.useState(defaultVisibleInTime), 2), visibleInTime = _e[0], setVisibleInTime = _e[1];
	    var timeoutRef = require$$1.useRef();
	    var enableHoverMode = require$$1.useCallback(function () {
	        if (disabled) {
	            return;
	        }
	        window.clearTimeout(timeoutRef.current);
	        setVisibleInTime(0);
	    }, [disabled]);
	    var disableHoverMode = require$$1.useCallback(function () {
	        window.clearTimeout(timeoutRef.current);
	        setVisibleInTime(defaultVisibleInTime);
	    }, [defaultVisibleInTime]);
	    var startDisableTimer = require$$1.useCallback(function () {
	        window.clearTimeout(timeoutRef.current);
	        timeoutRef.current = window.setTimeout(function () {
	            setVisibleInTime(defaultVisibleInTime);
	        }, deactivateTime);
	    }, [defaultVisibleInTime, deactivateTime]);
	    require$$1.useEffect(function () {
	        if (disabled) {
	            window.clearTimeout(timeoutRef.current);
	            setVisibleInTime(defaultVisibleInTime);
	        }
	    }, [disabled, defaultVisibleInTime]);
	    useOnUnmount(function () {
	        window.clearTimeout(timeoutRef.current);
	    });
	    var context = require$$1.useMemo(function () { return ({
	        visibleInTime: visibleInTime,
	        enableHoverMode: enableHoverMode,
	        disableHoverMode: disableHoverMode,
	        startDisableTimer: startDisableTimer,
	    }); }, [disableHoverMode, enableHoverMode, startDisableTimer, visibleInTime]);
	    return (jsxRuntime.exports.jsx(HoverModeContextProvider, __assign$3b({ value: context }, { children: children })));
	}

	/**
	 * This is copy/pasted from react-redux which has some more information about
	 * this and how to fix "invalid" warnings while running tests.
	 *
	 * @see https://github.com/reduxjs/react-redux/blob/4c907c0870c6b9a136dd69be294c17d1dc63c8f5/src/utils/useIsomorphicLayoutEffect.js
	 */
	var useIsomorphicLayoutEffect = typeof window !== "undefined" &&
	    typeof window.document !== "undefined" &&
	    typeof window.document.createElement !== "undefined"
	    ? require$$1.useLayoutEffect
	    : require$$1.useEffect;

	var __read$18 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @internal
	 */
	var TOUCH_TIMEOUT = 1200;
	/**
	 * This hook helps determine the current interaction mode by attaching the
	 * required event listeners to the window. The `mode` will always be defaulted
	 * to `mouse` at first since it has the least possibilities of causing errors
	 * with styles since the mouse-only styles are normally just `:hover` effects.
	 *
	 * ## Switching between modes:
	 *
	 * ### While in `mouse` mode:
	 *
	 * - any `keydown` event will switch to `keyboard` mode
	 *   - this does have the side effect of meta keys also causing the switch over,
	 *     but it feels fine since it helps show the current focus in the document
	 *     as well
	 * - any `touchstart` event will switch to `touch` mode
	 *
	 * ### While in `keyboard` mode:
	 *
	 * - any `mousedown` event will switch to `mouse` mode
	 *   - it is perfectly okay to move the mouse while in keyboard mode, but still
	 *     want to keep the keyboard styles until the user actually starts clicking
	 * - any `touchstart` event will switch to `touch` mode
	 *
	 * ### While in `touch` mode:
	 *
	 * - any `mousemove` event will switch to `mouse` mode, but **only** if there
	 *   hasn't been a `contextmenu` event within the last `1.2s`
	 *   - you can really only switch back to `mouse` mode if you are using the
	 *     devtools to emulate devices OR using a touch-desktop. I don't know how
	 *     common this really is though.
	 *   - touching the screen will always fire a `mousemove` event (which is why
	 *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even
	 *     after the `contextmenu` event. Normally want to go back to `mouse` mode
	 *     when the mouse re-enters the `window`
	 *
	 * Note: It's currently impossible to switch from `touch` to `keyboard`
	 * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I
	 * don't really know of any use-cases other than the weird touch-desktop stuff
	 * and I have no experience using them.
	 *
	 * @internal
	 */
	function useInteractionMode() {
	    var _a = __read$18(require$$1.useState("mouse"), 2), mode = _a[0], setMode = _a[1];
	    var lastTouchTime = require$$1.useRef(0);
	    var isTouchContextMenu = require$$1.useRef(false);
	    useIsomorphicLayoutEffect(function () {
	        var enableMouseMode = function () { return setMode("mouse"); };
	        var enableKeyboardMode = function () { return setMode("keyboard"); };
	        var handleTouchStart = function () {
	            lastTouchTime.current = Date.now();
	            isTouchContextMenu.current = false;
	            setMode("touch");
	        };
	        var handleMouseMove = function () {
	            if (isTouchContextMenu.current ||
	                Date.now() - lastTouchTime.current < TOUCH_TIMEOUT) {
	                isTouchContextMenu.current = false;
	                return;
	            }
	            enableMouseMode();
	        };
	        var handleContextMenu = function () {
	            isTouchContextMenu.current = true;
	        };
	        var className = "rmd-utils--".concat(mode);
	        document.body.classList.add(className);
	        window.addEventListener("touchstart", handleTouchStart, true);
	        if (mode === "mouse") {
	            window.addEventListener("keydown", enableKeyboardMode, true);
	        }
	        else if (mode === "keyboard") {
	            window.addEventListener("mousedown", enableMouseMode, true);
	        }
	        else {
	            window.addEventListener("mousemove", handleMouseMove, true);
	            window.addEventListener("contextmenu", handleContextMenu, true);
	        }
	        return function () {
	            document.body.classList.remove(className);
	            window.removeEventListener("touchstart", handleTouchStart, true);
	            if (mode === "mouse") {
	                window.removeEventListener("keydown", enableKeyboardMode, true);
	            }
	            else if (mode === "keyboard") {
	                window.removeEventListener("mousedown", enableMouseMode, true);
	            }
	            else {
	                window.removeEventListener("mousemove", handleMouseMove, true);
	                window.removeEventListener("contextmenu", handleContextMenu, true);
	            }
	        };
	    }, [mode]);
	    return mode;
	}

	var __assign$3a = (undefined && undefined.__assign) || function () {
	    __assign$3a = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3a.apply(this, arguments);
	};
	/**
	 * @internal
	 */
	var modeContext = require$$1.createContext("mouse");
	/**
	 * @internal
	 */
	var parentContext = require$$1.createContext(false);
	/**
	 * @internal
	 */
	var UserInteractionModeProvider = modeContext.Provider;
	/**
	 * @internal
	 */
	var ParentProvider = parentContext.Provider;
	/**
	 * Returns the current user interaction mode.
	 *
	 * @returns {@link UserInteractionMode}
	 */
	function useUserInteractionMode() {
	    return require$$1.useContext(modeContext);
	}
	/**
	 * Example:
	 *
	 * ```ts
	 * const isKeyboard = useIsUserInteractionMode("keyboard");
	 * // do stuff if keyboard only
	 * ```
	 *
	 * @param mode - The {@link UserInteractionMode} to check against.
	 * @returns `true` if the current user interaction mode matches the provided
	 * mode.
	 */
	function useIsUserInteractionMode(mode) {
	    return useUserInteractionMode() === mode;
	}
	/**
	 * This component is used to determine how the user is current interacting with
	 * your app as well as modifying the `document.body`'s `className` with the
	 * current mode. This is what allows the `rmd-utils-phone-only`,
	 * `rmd-utils-keyboard-only`, and `rmd-utils-mouse-only` mixins to work.
	 *
	 * @remarks \@since 2.6.0 Renamed from `InteractionModeListener`
	 * @throws When this component has been mounted multiple times in your app.
	 */
	function UserInteractionModeListener(_a) {
	    var children = _a.children;
	    var mode = useInteractionMode();
	    if (require$$1.useContext(parentContext)) {
	        throw new Error("Mounted multiple `UserInteractionModeListener` components.");
	    }
	    return (jsxRuntime.exports.jsx(UserInteractionModeProvider, __assign$3a({ value: mode }, { children: jsxRuntime.exports.jsx(ParentProvider, __assign$3a({ value: true }, { children: children })) })));
	}

	var __read$17 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook is used to add the hover mode functionality to any component.
	 *
	 * @example
	 * Displaying a Color Preview when hovering a Hex Code
	 * ```tsx
	 * import type { ReactElement } from "react";
	 * import { CSSTransition } from "@react-md/transition";
	 * import { useHoverMode } from "@react-md/utils";
	 *
	 * interface Props {
	 *   value: string;
	 * }
	 *
	 * export default function Color({ value }: Props): ReactElement {
	 *   const { visible, onMouseEnter, onMouseLeave } =
	 *     useHoverMode({ exitVisibilityDelay: 0 });
	 *
	 *   return (
	 *     <>
	 *       <span
	 *         onMouseEnter={onMouseEnter}
	 *         onMouseLeave={onMouseLeave}
	 *         style={{
	 *           // pretend styles
	 *         }}
	 *       >
	 *         {value}
	 *       </span>
	 *       <CSSTransition
	 *         transitionIn={visible}
	 *         classNames="opacity-change"
	 *         timeout={150}
	 *         temporary
	 *       >
	 *         <span
	 *           style={{
	 *             backgroundColor: value,
	 *             // other styles
	 *           }}
	 *         />
	 *      </CSSTransition>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @example
	 * Sticky Usage with a Fixed Dialog
	 * ```tsx
	 * const {
	 *   stuck,
	 *   active,
	 *   visible,
	 *   setVisible,
	 *   handlers,
	 *   hoverHandlers,
	 * } = useHoverMode();
	 * const buttonRef = useRef<HTMLButtonElement>(null);
	 *
	 * return (
	 *   <>
	 *     <Button {...handlers} ref={buttonRef}>
	 *       Click Me
	 *     </Button>
	 *     <FixedDialog
	 *       {...hoverHandlers}
	 *       aria-labelledby="dialog-title-id"
	 *       id="dialog-id"
	 *       visible={visible}
	 *       onRequestClose={() => setVisible(false)}
	 *       fixedTo={buttonRef}
	 *       anchor={BELOW_CENTER_ANCHOR}
	 *       options={{ preventOverlap: true }}
	 *       // this allows the close on outside click"" behavior" to work
	 *       overlay={!stuck && active ? false : undefined}
	 *       disableScrollLock={active}
	 *     >
	 *       <YourDialogContent />
	 *    </FixedDialog>
	 *   </>
	 * );
	 * ```
	 *
	 * @remarks \@since 2.8.0
	 * @remarks \@since 5.0.0 This hook no longer returns `handlers` or
	 * `stickyHandlers` and does not hide when an element on the page is clicked.
	 * @param options - An optional object of options to use. See
	 * {@link HoverModeOptions} for more details.
	 * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}
	 */
	function useHoverMode(_a) {
	    var _b = _a === void 0 ? {} : _a, _c = _b.disabled, disabled = _c === void 0 ? false : _c, _d = _b.defaultVisible, defaultVisible = _d === void 0 ? false : _d, _e = _b.exitVisibilityDelay, exitVisibilityDelay = _e === void 0 ? DEFAULT_HOVER_MODE_EXIT_TIME : _e;
	    var mode = useUserInteractionMode();
	    var isTouch = mode === "touch";
	    var _f = __read$17(require$$1.useState(defaultVisible), 2), visible = _f[0], setVisible = _f[1];
	    var _g = __read$17(require$$1.useState(false), 2), stuck = _g[0], setStuck = _g[1];
	    var timeoutRef = require$$1.useRef();
	    var _h = useHoverModeContext(), visibleInTime = _h.visibleInTime, enableHoverMode = _h.enableHoverMode, disableHoverMode = _h.disableHoverMode, startDisableTimer = _h.startDisableTimer;
	    var active = visibleInTime === 0;
	    require$$1.useEffect(function () {
	        if (!visible) {
	            setStuck(false);
	        }
	    }, [visible]);
	    useOnUnmount(function () {
	        window.clearTimeout(timeoutRef.current);
	    });
	    var clearHoverTimeout = require$$1.useCallback(function () {
	        window.clearTimeout(timeoutRef.current);
	    }, []);
	    var onMouseEnter = require$$1.useCallback(function (event) {
	        if (stuck || disabled || isTouch || event.isPropagationStopped()) {
	            return;
	        }
	        clearHoverTimeout();
	        if (visibleInTime === 0) {
	            enableHoverMode();
	            setVisible(true);
	            return;
	        }
	        timeoutRef.current = window.setTimeout(function () {
	            enableHoverMode();
	            setVisible(true);
	        }, visibleInTime);
	    }, [
	        clearHoverTimeout,
	        disabled,
	        enableHoverMode,
	        isTouch,
	        stuck,
	        visibleInTime,
	    ]);
	    var onMouseLeave = require$$1.useCallback(function (event) {
	        if (stuck || disabled || isTouch || event.isPropagationStopped()) {
	            return;
	        }
	        startDisableTimer();
	        clearHoverTimeout();
	        if (exitVisibilityDelay === 0) {
	            setVisible(false);
	            return;
	        }
	        timeoutRef.current = window.setTimeout(function () {
	            setVisible(false);
	        }, exitVisibilityDelay);
	    }, [
	        clearHoverTimeout,
	        disabled,
	        exitVisibilityDelay,
	        isTouch,
	        startDisableTimer,
	        stuck,
	    ]);
	    var onClick = require$$1.useCallback(function (event) {
	        if (event.isPropagationStopped()) {
	            return;
	        }
	        // If the hover mode functionality is disabled, just allow this to behave
	        // like a toggle visibility handler.
	        if (!stuck && !disabled) {
	            setStuck(true);
	            setVisible(true);
	        }
	        else {
	            setStuck(false);
	            setVisible(function (prevVisible) { return !prevVisible; });
	        }
	    }, [disabled, stuck]);
	    return {
	        active: active,
	        stuck: stuck,
	        visible: visible,
	        setVisible: setVisible,
	        onClick: onClick,
	        onMouseEnter: onMouseEnter,
	        onMouseLeave: onMouseLeave,
	        enableHoverMode: enableHoverMode,
	        disableHoverMode: disableHoverMode,
	        startDisableTimer: startDisableTimer,
	        clearHoverTimeout: clearHoverTimeout,
	        handlers: {
	            onClick: onClick,
	            onMouseEnter: onMouseEnter,
	            onMouseLeave: onMouseLeave,
	        },
	        hoverHandlers: {
	            onMouseEnter: onMouseEnter,
	            onMouseLeave: onMouseLeave,
	        },
	    };
	}

	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var context$e = require$$1.createContext({
	    activeId: "",
	    setActiveId: function () {
	        throw new Error("ActiveDescendantMovementProvider must be a parent component.");
	    },
	});
	context$e.displayName = "ActiveDescendant";
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var ActiveDescendantContextProvider = context$e.Provider;
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	function useActiveDescendantContext() {
	    return require$$1.useContext(context$e);
	}

	var __assign$39 = (undefined && undefined.__assign) || function () {
	    __assign$39 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$39.apply(this, arguments);
	};
	/**
	 * This component should be used with the {@link KeyboardMovementProvider}
	 * component to implement custom keyboard focusable behavior using
	 * `aria-activedescendant`.
	 *
	 * @example
	 * Base Example
	 * ```tsx
	 * function Descendant({ id, children, ...props }: HTMLAttributes<HTMLDivElement>): ReactElement {
	 *   const { ref, active } = useActiveDescendant({ id });
	 *   return (
	 *     <div
	 *       {...props}
	 *       id={id}
	 *       ref={ref}
	 *       role="option"
	 *       tabIndex={-1}
	 *       className={active ? "active" : undefined}
	 *     >
	 *       {children}
	 *     </div>
	 *   );
	 * }
	 *
	 * function CustomFocus(): ReactElement {
	 *   const { providerProps, focusIndex, ...containerProps } =
	 *     useActiveDescendantFocus()
	 *
	 *   return (
	 *     <ActiveDescendantMovementProvider>
	 *       <div
	 *         {...containerProps}
	 *         id="some-unique-id"
	 *         role="listbox"
	 *         tabIndex={0}
	 *       >
	 *         <Descendant id="some-descendant-id">
	 *           Some Option
	 *         </Descendant>
	 *       </div>
	 *      </ActiveDescendantMovementProvider>
	 *   );
	 * }
	 *
	 * function Example() {
	 *   return (
	 *     <KeyboardMovementProvider loopable searchable>
	 *       <CustomFocus />
	 *     </KeyboardMovementProvider>
	 *   );
	 * }
	 * ```
	 *
	 * @see https://www.w3.org/TR/wai-aria-practices/#kbd_focus_activedescendant
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	function ActiveDescendantMovementProvider(_a) {
	    var children = _a.children, activeId = _a.activeId, setActiveId = _a.setActiveId;
	    return (jsxRuntime.exports.jsx(ActiveDescendantContextProvider, __assign$39({ value: require$$1.useMemo(function () { return ({
	            activeId: activeId,
	            setActiveId: setActiveId,
	        }); }, [activeId, setActiveId]) }, { children: children })));
	}

	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var noop$b = function () {
	};
	/**
	 * Most custom keyboard functionality use these keys.
	 *
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var DEFAULT_KEYBOARD_MOVEMENT = {
	    incrementKeys: ["ArrowDown"],
	    decrementKeys: ["ArrowUp"],
	    jumpToFirstKeys: ["Home"],
	    jumpToLastKeys: ["End"],
	};
	/**
	 * @remarks \@since 5.1.2
	 * @internal
	 */
	var DEFAULT_LTR_KEYBOARD_MOVEMENT = {
	    incrementKeys: ["ArrowRight"],
	    decrementKeys: ["ArrowLeft"],
	    jumpToFirstKeys: ["Home"],
	    jumpToLastKeys: ["End"],
	};
	/**
	 * @remarks \@since 5.1.2
	 * @internal
	 */
	var DEFAULT_RTL_KEYBOARD_MOVEMENT = {
	    incrementKeys: ["ArrowLeft"],
	    decrementKeys: ["ArrowRight"],
	    jumpToFirstKeys: ["Home"],
	    jumpToLastKeys: ["End"],
	};
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var context$d = require$$1.createContext({
	    attach: noop$b,
	    detach: noop$b,
	    watching: { current: [] },
	    loopable: false,
	    searchable: false,
	    horizontal: false,
	    includeDisabled: false,
	    config: { current: DEFAULT_KEYBOARD_MOVEMENT },
	});
	context$d.displayName = "KeyboardMovement";
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var KeyboardMovementContextProvider = context$d.Provider;
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	function useKeyboardFocusContext() {
	    return require$$1.useContext(context$d);
	}

	/**
	 * A small util that is used to increment or decrement a number until it reaches
	 * the max value or -1. When that happens, it will loop around to 0 or the max
	 * value respectively. This does not work for different increment numbers or any
	 * values below 0 for now.
	 *
	 * @internal
	 * @param options - {@link LoopOptions}
	 * @remarks \@since 2.7.0 The `min` option was added and the arguments changed to an
	 * object
	 */
	function loop(_a) {
	    var value = _a.value, _b = _a.min, min = _b === void 0 ? 0 : _b, max = _a.max, increment = _a.increment, _c = _a.minmax, minmax = _c === void 0 ? false : _c;
	    var next = value + (increment ? 1 : -1);
	    if (minmax) {
	        next = Math.min(max, Math.max(min, next));
	    }
	    else if (next > max) {
	        next = min;
	    }
	    else if (next < min) {
	        next = max;
	    }
	    return next;
	}

	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var focusElement = function (element) {
	    element.focus();
	};
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var isNotFocusable = function (element, includeDisabled) {
	    if (!element) {
	        return true;
	    }
	    if (includeDisabled) {
	        return false;
	    }
	    return (element.getAttribute("disabled") !== null ||
	        element.getAttribute("aria-disabled") === "true");
	};
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var getFirstFocusableIndex = function (watching, includeDisabled) {
	    if (!watching.length) {
	        return -1;
	    }
	    var firstIndex = 0;
	    while (firstIndex < watching.length - 1 &&
	        isNotFocusable(watching[firstIndex].element, includeDisabled)) {
	        firstIndex += 1;
	    }
	    if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {
	        return -1;
	    }
	    return firstIndex;
	};
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var getLastFocusableIndex = function (watching, includeDisabled) {
	    if (!watching.length) {
	        return -1;
	    }
	    var lastIndex = watching.length - 1;
	    while (lastIndex > 0 &&
	        isNotFocusable(watching[lastIndex].element, includeDisabled)) {
	        lastIndex -= 1;
	    }
	    if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {
	        return -1;
	    }
	    return lastIndex;
	};
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var getNextFocusableIndex = function (_a) {
	    var loopable = _a.loopable, watching = _a.watching, increment = _a.increment, includeDisabled = _a.includeDisabled, currentFocusIndex = _a.currentFocusIndex;
	    var min = getFirstFocusableIndex(watching, includeDisabled);
	    var max = getLastFocusableIndex(watching, includeDisabled);
	    var nextIndex = loop({
	        min: min,
	        max: max,
	        value: currentFocusIndex,
	        minmax: !loopable,
	        increment: increment,
	    });
	    while (isNotFocusable(watching[nextIndex].element, includeDisabled) &&
	        (loopable || nextIndex !== (increment ? max : min))) {
	        nextIndex = loop({
	            min: min,
	            max: max,
	            value: nextIndex,
	            minmax: !loopable,
	            increment: increment,
	        });
	    }
	    // Since the `min` and `max` values are "safely" set, I don't need to verify
	    // the nextIndex is still focusable
	    return nextIndex;
	};
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	function getSearchText(element, searchable) {
	    if (!searchable) {
	        return "";
	    }
	    var cloned = element.cloneNode(true);
	    cloned
	        .querySelectorAll(".rmd-icon--font,[aria-hidden=true],[hidden]")
	        .forEach(function (element) {
	        var _a;
	        (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);
	    });
	    // Note: It would be good to use `cloned.innerText` (maybe?) at some point,
	    // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe
	    // this is fine?
	    // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext
	    return (cloned.textContent || "").substring(0, 1).toUpperCase();
	}

	var __assign$38 = (undefined && undefined.__assign) || function () {
	    __assign$38 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$38.apply(this, arguments);
	};
	/**
	 * @example
	 * Main Usage
	 * ```tsx
	 * function Example() {
	 *   return (
	 *     <KeyboardMovementProvider>
	 *       <CustomKeyboardFocusWidget />
	 *     </KeyboardMovementProvider>
	 *   );
	 * }
	 *
	 * function CustomKeyboardFocusWidget() {
	 *   const { focusIndex: _focusIndex, ...eventHandlers } = useKeyboardFocus();
	 *   return (
	 *     <div {...eventHandlers}>
	 *       <FocusableChild />
	 *       <FocusableChild />
	 *       <FocusableChild />
	 *       <FocusableChild />
	 *     </div>
	 *   );
	 * }
	 *
	 * function FocusableChild() {
	 *   const refCallback = useKeyboardFocusableElement()
	 *
	 *   return <div role="menuitem" tabIndex={-1} ref={refCallback}>Content</div>;
	 * }
	 * ```
	 *
	 * @remarks \@since 5.0.0
	 */
	function KeyboardMovementProvider(_a) {
	    var children = _a.children, _b = _a.loopable, loopable = _b === void 0 ? false : _b, _c = _a.searchable, searchable = _c === void 0 ? false : _c, _d = _a.horizontal, horizontal = _d === void 0 ? false : _d, _e = _a.includeDisabled, includeDisabled = _e === void 0 ? false : _e, propIncrementKeys = _a.incrementKeys, propDecrementKeys = _a.decrementKeys, propJumpToFirstKeys = _a.jumpToFirstKeys, propJumpToLastKeys = _a.jumpToLastKeys;
	    var isRTL = useDir().dir === "rtl";
	    var defaults;
	    if (horizontal) {
	        defaults = isRTL
	            ? DEFAULT_RTL_KEYBOARD_MOVEMENT
	            : DEFAULT_LTR_KEYBOARD_MOVEMENT;
	    }
	    else {
	        defaults = DEFAULT_KEYBOARD_MOVEMENT;
	    }
	    var incrementKeys = propIncrementKeys || defaults.incrementKeys;
	    var decrementKeys = propDecrementKeys || defaults.decrementKeys;
	    var jumpToFirstKeys = propJumpToFirstKeys || defaults.jumpToFirstKeys;
	    var jumpToLastKeys = propJumpToLastKeys || defaults.jumpToLastKeys;
	    var watching = require$$1.useRef([]);
	    var configuration = {
	        incrementKeys: incrementKeys,
	        decrementKeys: decrementKeys,
	        jumpToFirstKeys: jumpToFirstKeys,
	        jumpToLastKeys: jumpToLastKeys,
	    };
	    var config = require$$1.useRef(configuration);
	    config.current = configuration;
	    var value = require$$1.useMemo(function () { return ({
	        attach: function (element) {
	            watching.current.push({
	                element: element,
	                content: getSearchText(element, searchable),
	            });
	        },
	        detach: function (element) {
	            watching.current = watching.current.filter(function (cache) { return cache.element !== element; });
	        },
	        watching: watching,
	        config: config,
	        loopable: loopable,
	        searchable: searchable,
	        horizontal: horizontal,
	        includeDisabled: includeDisabled,
	    }); }, [horizontal, includeDisabled, loopable, searchable]);
	    return (jsxRuntime.exports.jsx(KeyboardMovementContextProvider, __assign$38({ value: value }, { children: children })));
	}

	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	function useKeyboardFocusableElement(ref) {
	    var _a = useKeyboardFocusContext(), attach = _a.attach, detach = _a.detach;
	    var nodeRef = require$$1.useRef(null);
	    return require$$1.useCallback(function (instance) {
	        applyRef(instance, ref);
	        if (instance) {
	            attach(instance);
	        }
	        else if (nodeRef.current) {
	            detach(nodeRef.current);
	        }
	        nodeRef.current = instance;
	    }, [attach, detach, ref]);
	}

	/**
	 * @remarks \@since 5.0.0
	 */
	function useActiveDescendant(_a) {
	    var id = _a.id, ref = _a.ref;
	    var activeId = useActiveDescendantContext().activeId;
	    var refCallback = useKeyboardFocusableElement(ref);
	    return {
	        ref: refCallback,
	        active: id === activeId,
	    };
	}

	/**
	 * Attempts to find the first match index for a list of values that starts with
	 * the provided query string and is within the start and end indexes. If no
	 * matches are found, -1 will be returned instead.
	 *
	 * Since this is normally coming from a keydown event, the query *must* be a
	 * string of all capital letters to work as each value will be converted to
	 * uppercase before checking.
	 *
	 * @param value - The current query string to find within the values
	 * @param values - The list of values to search within
	 * @param startIndex - The start index for the search
	 * @param endIndex - The end index for the search
	 * @internal
	 */
	function findMatchInRange(value, values, startIndex, endIndex) {
	    value = value.toUpperCase();
	    for (var i = startIndex; i < endIndex; i += 1) {
	        var content = values[i];
	        if (content.toUpperCase().indexOf(value) === 0) {
	            return i;
	        }
	    }
	    return -1;
	}
	/**
	 * A function that is used to find the next match index within a list of values
	 * by comparing the start values ignoring case.
	 *
	 * If a match can not be found from the search string, `-1` will be returned.
	 * The search value is self-matchable by default, but it can be omitted by
	 * disabling the `isSelfMatchable` argument. This will make a self-match return
	 * `-1`.
	 *
	 * @param value - The current search value
	 * @param values - A list of values to search within
	 * @param startIndex - The index within the values list to start the search from
	 * @param isSelfMatchable - Boolean if the current index can be included in the
	 * search
	 * @internal
	 */
	function findMatchIndex(value, values, startIndex, isSelfMatchable) {
	    if (isSelfMatchable === void 0) { isSelfMatchable = true; }
	    var index = findMatchInRange(value, values, startIndex + 1, values.length);
	    if (index === -1) {
	        var endIndex = startIndex + (isSelfMatchable ? 1 : 0);
	        index = findMatchInRange(value, values, 0, endIndex);
	    }
	    return index;
	}

	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var noop$a = function () {
	    // do nothing
	};
	/**
	 * @remarks \@since 5.0.0
	 */
	function useKeyboardFocus(options) {
	    if (options === void 0) { options = {}; }
	    var _a = options.onFocus, onFocus = _a === void 0 ? noop$a : _a, _b = options.onKeyDown, onKeyDown = _b === void 0 ? noop$a : _b, _c = options.onSearch, onSearch = _c === void 0 ? noop$a : _c, _d = options.onIncrement, onIncrement = _d === void 0 ? noop$a : _d, _e = options.onDecrement, onDecrement = _e === void 0 ? noop$a : _e, _f = options.onJumpToFirst, onJumpToFirst = _f === void 0 ? noop$a : _f, _g = options.onJumpToLast, onJumpToLast = _g === void 0 ? noop$a : _g, _h = options.onFocusChange, onFocusChange = _h === void 0 ? focusElement : _h, getDefaultFocusIndex = options.getDefaultFocusIndex;
	    var mode = useUserInteractionMode();
	    var focusIndex = require$$1.useRef(-1);
	    var _j = useKeyboardFocusContext(), config = _j.config, loopable = _j.loopable, searchable = _j.searchable, watching = _j.watching, includeDisabled = _j.includeDisabled;
	    return {
	        focusIndex: focusIndex,
	        onFocus: function (event) {
	            var _a;
	            onFocus(event);
	            if (event.isPropagationStopped()) {
	                return;
	            }
	            if (event.target !== event.currentTarget) {
	                var i = watching.current.findIndex(function (_a) {
	                    var element = _a.element;
	                    return element === event.target;
	                });
	                if (i !== -1) {
	                    focusIndex.current = i;
	                }
	                return;
	            }
	            var defaultFocusIndex;
	            if (getDefaultFocusIndex) {
	                defaultFocusIndex = getDefaultFocusIndex(watching.current.map(function (_a) {
	                    var element = _a.element;
	                    return element;
	                }), event.currentTarget);
	            }
	            else {
	                defaultFocusIndex = getFirstFocusableIndex(watching.current, includeDisabled);
	            }
	            // this makes it so that if you click the container element without
	            // clicking any child, it doesn't focus the first element again
	            if (defaultFocusIndex === -1 || mode !== "keyboard") {
	                return;
	            }
	            focusIndex.current = defaultFocusIndex;
	            var element = (_a = watching.current[focusIndex.current]) === null || _a === void 0 ? void 0 : _a.element;
	            element && onFocusChange(element, focusIndex.current);
	        },
	        onKeyDown: function (event) {
	            onKeyDown(event);
	            if (event.isPropagationStopped()) {
	                return;
	            }
	            var key = event.key, altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey, shiftKey = event.shiftKey;
	            var _a = config.current, incrementKeys = _a.incrementKeys, decrementKeys = _a.decrementKeys, jumpToFirstKeys = _a.jumpToFirstKeys, jumpToLastKeys = _a.jumpToLastKeys;
	            var update = function (index) {
	                var _a;
	                event.preventDefault();
	                event.stopPropagation();
	                if (focusIndex.current === index) {
	                    return;
	                }
	                focusIndex.current = index;
	                var element = (_a = watching.current[index]) === null || _a === void 0 ? void 0 : _a.element;
	                element && onFocusChange(element, focusIndex.current);
	            };
	            if (searchable &&
	                key.length === 1 &&
	                // can't search with space since it is generally a click event
	                key !== " " &&
	                !altKey &&
	                !ctrlKey &&
	                !metaKey &&
	                !shiftKey) {
	                onSearch({ key: key, event: event });
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                var values = watching.current.map(function (_a) {
	                    var content = _a.content, element = _a.element;
	                    if (isNotFocusable(element, includeDisabled)) {
	                        return "";
	                    }
	                    return content;
	                });
	                update(findMatchIndex(key, values, focusIndex.current));
	            }
	            else if (jumpToFirstKeys.includes(key)) {
	                onJumpToFirst({ key: key, event: event });
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                update(getFirstFocusableIndex(watching.current, includeDisabled));
	            }
	            else if (jumpToLastKeys.includes(key)) {
	                onJumpToLast({ key: key, event: event });
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                update(getLastFocusableIndex(watching.current, includeDisabled));
	            }
	            else if (incrementKeys.includes(key)) {
	                onIncrement({ key: key, event: event });
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                update(getNextFocusableIndex({
	                    loopable: loopable,
	                    watching: watching.current,
	                    increment: true,
	                    includeDisabled: includeDisabled,
	                    currentFocusIndex: focusIndex.current,
	                }));
	            }
	            else if (decrementKeys.includes(key)) {
	                onDecrement({ key: key, event: event });
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                update(getNextFocusableIndex({
	                    loopable: loopable,
	                    watching: watching.current,
	                    increment: false,
	                    includeDisabled: includeDisabled,
	                    currentFocusIndex: focusIndex.current,
	                }));
	            }
	        },
	    };
	}

	var __assign$37 = (undefined && undefined.__assign) || function () {
	    __assign$37 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$37.apply(this, arguments);
	};
	var __rest$2A = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$16 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @see {@link ActiveDescendantMovementProvider} for an example
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	function useActiveDescendantFocus(_a) {
	    if (_a === void 0) { _a = {}; }
	    var _b = _a.defaultActiveId, defaultActiveId = _b === void 0 ? "" : _b, options = __rest$2A(_a, ["defaultActiveId"]);
	    var _c = __read$16(require$$1.useState(defaultActiveId), 2), activeId = _c[0], setActiveId = _c[1];
	    return __assign$37(__assign$37({}, useKeyboardFocus(__assign$37(__assign$37({}, options), { onFocusChange: function (element) {
	            setActiveId(element.id);
	        }, getDefaultFocusIndex: function (elements) {
	            if (!activeId) {
	                return -1;
	            }
	            return elements.findIndex(function (_a) {
	                var id = _a.id;
	                return id === activeId;
	            });
	        } }))), { "aria-activedescendant": activeId, providerProps: {
	            activeId: activeId,
	            setActiveId: setActiveId,
	        } });
	}

	var DEFAULT_DESKTOP_MIN_WIDTH = "".concat(1025 / 16, "em");
	var DEFAULT_TABLET_MIN_WIDTH = "".concat(768 / 16, "em");
	var DEFAULT_TABLET_MAX_WIDTH = "".concat(1024 / 16, "em");
	var DEFAULT_PHONE_MAX_WIDTH = "".concat(767 / 16, "em");
	var DEFAULT_DESKTOP_LARGE_MIN_WIDTH = "".concat(1280 / 16, "em");

	var __read$15 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * An extremely simple "pollyfill" for the `window.screen.orientation` just for
	 * the `type` value that is required for the `useOrientation` hook.
	 */
	var getOrientationType = function () {
	    var _a;
	    var screenOrientation = (_a = window.screen.orientation) === null || _a === void 0 ? void 0 : _a.type;
	    if (typeof screenOrientation === "string") {
	        return screenOrientation;
	    }
	    var _b = window.screen, availHeight = _b.availHeight, availWidth = _b.availWidth;
	    return availHeight > availWidth ? "portrait-primary" : "landscape-primary";
	};
	/**
	 * This media query is used to determine the current orientation of the app
	 * based on the `window.screen.orientation.type`. This will always be
	 * `"landscape-primary"` server side unless a default value is provided.
	 *
	 * @param defaultValue - an optional default value to use. When this is omitted,
	 * it will default to `"landscape-primary"` unless the `window` is defined. If
	 * the `window` is defined, it will immediately check the orientation type on
	 * mount.
	 * @returns the orientation type value.
	 */
	function useOrientation(defaultValue) {
	    var _a = __read$15(require$$1.useState(function () {
	        if (defaultValue) {
	            return defaultValue;
	        }
	        if (typeof window !== "undefined") {
	            return getOrientationType();
	        }
	        return "landscape-primary";
	    }), 2), value = _a[0], setValue = _a[1];
	    require$$1.useEffect(function () {
	        if (typeof window === "undefined") {
	            return;
	        }
	        var handler = function () {
	            setValue(getOrientationType());
	        };
	        window.addEventListener("orientationchange", handler);
	        return function () { return window.removeEventListener("orientationchange", handler); };
	    }, []);
	    return value;
	}

	var __read$14 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * A helper hook that is used to create a memoized media query tester for
	 * `window.matchMedia`.
	 *
	 * Note: This is a **client side only** hook as it requires the `window` to
	 * attach a resize event listener to.
	 *
	 * @param query - The media query to use
	 * @param defaultValue - The default value for if this media query matches. When
	 * this is `undefined`, it will default to `false` unless the `window` is
	 * defined and the `checkImmediately` param was not set to `false`. Otherwise,
	 * it will check the media query matches on mount and use that value.
	 * @param disabled - Boolean if the media query checking should be disabled.
	 * @param checkImmediately - Boolean if the media query should be checked
	 * immediately on mount. When omitted, it will default to checking when the
	 * window is defined.
	 * @returns true if the media query is a match.
	 */
	function useMediaQuery(query, defaultValue, disabled, checkImmediately) {
	    if (disabled === void 0) { disabled = false; }
	    if (checkImmediately === void 0) { checkImmediately = typeof window !== "undefined"; }
	    var _a = __read$14(require$$1.useState(function () {
	        if (typeof defaultValue !== "undefined") {
	            return defaultValue;
	        }
	        if (!disabled && checkImmediately && typeof window !== "undefined") {
	            return window.matchMedia(query).matches;
	        }
	        return false;
	    }), 2), matches = _a[0], setMatches = _a[1];
	    require$$1.useEffect(function () {
	        if (typeof window === "undefined" || disabled) {
	            return;
	        }
	        var mq = window.matchMedia(query);
	        var updater = function (_a) {
	            var matches = _a.matches;
	            return setMatches(matches);
	        };
	        mq.addEventListener("change", updater);
	        if (mq.matches !== matches) {
	            setMatches(mq.matches);
	        }
	        return function () {
	            mq.removeEventListener("change", updater);
	        };
	    }, [disabled, matches, query]);
	    return matches;
	}

	/**
	 * This is a small helper that will create a media query block based on the
	 * provided width value.
	 */
	var toWidthPart = function (v, prefix) {
	    var type = typeof v;
	    if (type === "undefined") {
	        return "";
	    }
	    var value = type === "number" ? "".concat(v, "px") : v;
	    return "(".concat(prefix, "-width: ").concat(value, ")");
	};
	/**
	 * This is a simple hoo that will create a memoized media query string with the
	 * provided min anx max values.
	 *
	 * @param min - An optional min value to use
	 * @param max - An optional max value to use
	 * @returns a boolean if the current media query is a match.
	 */
	function useWidthMediaQuery(_a) {
	    var min = _a.min, max = _a.max;
	    var query = require$$1.useMemo(function () {
	        var parts = [toWidthPart(min, "min"), toWidthPart(max, "max")]
	            .filter(Boolean)
	            .join(" and ");
	        return "screen and ".concat(parts);
	    }, [min, max]);
	    return useMediaQuery(query);
	}

	var __read$13 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var DEFAULT_APP_SIZE = {
	    isPhone: false,
	    isTablet: false,
	    isDesktop: true,
	    isLargeDesktop: false,
	    isLandscape: true,
	};
	/**
	 * This hook is used to determine the current application size based on the
	 * provided query sizes. When you want to render your app server side, you will
	 * need to provide a custom `defaultSize` that implements your logic to
	 * determine the type of device requesting a page. Once the app has been
	 * rendered in the DOM, this hook will attach event listeners to automatically
	 * update the app size when the page is resized.
	 *
	 * @internal
	 */
	function useAppSizeMedia(_a) {
	    var _b = _a === void 0 ? {} : _a, _c = _b.phoneMaxWidth, phoneMaxWidth = _c === void 0 ? DEFAULT_PHONE_MAX_WIDTH : _c, _d = _b.tabletMinWidth, tabletMinWidth = _d === void 0 ? DEFAULT_TABLET_MIN_WIDTH : _d, _e = _b.tabletMaxWidth, tabletMaxWidth = _e === void 0 ? DEFAULT_TABLET_MAX_WIDTH : _e, _f = _b.desktopMinWidth, desktopMinWidth = _f === void 0 ? DEFAULT_DESKTOP_MIN_WIDTH : _f, _g = _b.desktopLargeMinWidth, desktopLargeMinWidth = _g === void 0 ? DEFAULT_DESKTOP_LARGE_MIN_WIDTH : _g, _h = _b.defaultSize, defaultSize = _h === void 0 ? DEFAULT_APP_SIZE : _h;
	    /* eslint-disable react-hooks/rules-of-hooks */
	    // disabled since this is conditionally applied for SSR
	    if (typeof window === "undefined") {
	        return defaultSize;
	    }
	    var matchesDesktop = useWidthMediaQuery({ min: desktopMinWidth });
	    var matchesLargeDesktop = useWidthMediaQuery({ min: desktopLargeMinWidth });
	    var matchesTablet = useWidthMediaQuery({
	        min: tabletMinWidth,
	        max: tabletMaxWidth,
	    });
	    var matchesPhone = useWidthMediaQuery({ max: phoneMaxWidth });
	    var isDesktop = matchesDesktop;
	    var isTablet = !matchesDesktop && matchesTablet;
	    var isPhone = !isTablet && !isDesktop && matchesPhone;
	    var isLandscape = useOrientation().includes("landscape");
	    var isLargeDesktop = matchesLargeDesktop;
	    var _j = __read$13(require$$1.useState(defaultSize), 2), appSize = _j[0], setAppSize = _j[1];
	    require$$1.useEffect(function () {
	        if (appSize.isPhone === isPhone &&
	            appSize.isTablet === isTablet &&
	            appSize.isDesktop === isDesktop &&
	            appSize.isLargeDesktop === isLargeDesktop &&
	            appSize.isLandscape === isLandscape) {
	            return;
	        }
	        // for some reason, it's sometimes possible to fail every single matchMedia
	        // value when you are resizing the browser a lot. this is an "invalid" event
	        // so skip it. It normally happens between 760px-768px
	        if (!isPhone && !isTablet && !isDesktop && !isLargeDesktop) {
	            return;
	        }
	        setAppSize({ isPhone: isPhone, isTablet: isTablet, isDesktop: isDesktop, isLargeDesktop: isLargeDesktop, isLandscape: isLandscape });
	    }, [isPhone, isTablet, isDesktop, isLargeDesktop, isLandscape, appSize]);
	    return appSize;
	}

	var __assign$36 = (undefined && undefined.__assign) || function () {
	    __assign$36 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$36.apply(this, arguments);
	};
	var __rest$2z = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * @internal
	 */
	var AppSizeContext = require$$1.createContext(__assign$36(__assign$36({}, DEFAULT_APP_SIZE), { __initialized: false }));
	/**
	 * Gets the current app size.
	 *
	 * @returns the current AppSize
	 */
	function useAppSize() {
	    var _a = require$$1.useContext(AppSizeContext), __initialized = _a.__initialized, context = __rest$2z(_a, ["__initialized"]);
	    if (!__initialized) {
	        throw new Error("Unable to get the current `AppSize` from `react-md` because the `AppSizeListener` " +
	            "could not be found when using the `useAppSize` hook. To fix this error, either " +
	            "initialize the `AppSizeListener` component from `@react-md/utils` or the " +
	            "`Configuration` component from `@react-md/layout` near the root of your app.");
	    }
	    return context;
	}

	var __assign$35 = (undefined && undefined.__assign) || function () {
	    __assign$35 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$35.apply(this, arguments);
	};
	var __rest$2y = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$1a = bem("rmd-grid");
	var GridCell = require$$1.forwardRef(function GridCell(_a, ref) {
	    var _b, _c, _d, _e, _f, _g, _h;
	    var style = _a.style, className = _a.className, clone = _a.clone, children = _a.children, propColSpan = _a.colSpan, propColStart = _a.colStart, propColEnd = _a.colEnd, propRowSpan = _a.rowSpan, propRowStart = _a.rowStart, propRowEnd = _a.rowEnd, phone = _a.phone, tablet = _a.tablet, desktop = _a.desktop, largeDesktop = _a.largeDesktop, props = __rest$2y(_a, ["style", "className", "clone", "children", "colSpan", "colStart", "colEnd", "rowSpan", "rowStart", "rowEnd", "phone", "tablet", "desktop", "largeDesktop"]);
	    var _j = useAppSize(), isPhone = _j.isPhone, isTablet = _j.isTablet, isDesktop = _j.isDesktop, isLargeDesktop = _j.isLargeDesktop;
	    var colSpan = propColSpan;
	    var colStart = propColStart;
	    var colEnd = propColEnd;
	    var rowSpan = propRowSpan;
	    var rowStart = propRowStart;
	    var rowEnd = propRowEnd;
	    var media = (isPhone && phone) ||
	        (isTablet && tablet) ||
	        (isLargeDesktop && largeDesktop) ||
	        (isDesktop && desktop);
	    if (media) {
	        (_b = media.rowSpan, rowSpan = _b === void 0 ? propRowSpan : _b, _c = media.rowStart, rowStart = _c === void 0 ? propRowStart : _c, _d = media.rowEnd, rowEnd = _d === void 0 ? propRowEnd : _d, _e = media.colSpan, colSpan = _e === void 0 ? propColSpan : _e, _f = media.colStart, colStart = _f === void 0 ? propColStart : _f, _g = media.colEnd, colEnd = _g === void 0 ? propColEnd : _g);
	    }
	    var cellStyle = __assign$35({ gridColumnStart: colStart, gridColumnEnd: colEnd, gridRowStart: rowStart, gridRowEnd: rowSpan ? "span ".concat(rowSpan) : rowEnd }, style);
	    var cellClassName = cn(block$1a("cell", (_h = {},
	        _h["".concat(colSpan)] = colSpan,
	        _h)), className);
	    if (clone && require$$1.isValidElement(children)) {
	        var child = require$$1.Children.only(children);
	        return require$$1.cloneElement(child, {
	            style: __assign$35(__assign$35({}, child.props.style), cellStyle),
	            className: cn(cellClassName, child.props.className),
	        });
	    }
	    return (jsxRuntime.exports.jsx("div", __assign$35({}, props, { ref: ref, style: cellStyle, className: cellClassName }, { children: children })));
	});

	var __assign$34 = (undefined && undefined.__assign) || function () {
	    __assign$34 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$34.apply(this, arguments);
	};
	var __rest$2x = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This CSS Variable allows you to override the number of columns that should be
	 * displayed in the grid. This is automatically updated with media queries with
	 * the default grid implementation, but is used here to add additional
	 * inline-style overrides.
	 *
	 * @internal
	 */
	var GRID_COLUMNS_VAR = "--rmd-grid-cols";
	/**
	 * This CSS Variable allows you to override the gutter (grid-gap) between each
	 * cell in the grid.
	 *
	 * @internal
	 */
	var GRID_GUTTER_VAR = "--rmd-grid-gutter";
	var block$19 = bem("rmd-grid");
	/**
	 * The grid component is generally used for a base layout in your app to provide
	 * nice padding and spacing between each item.
	 *
	 * Note: This component relies on the `AppSizeListener` as a parent component to
	 * work and will throw an error if it does not exist as a parent.
	 */
	var Grid = require$$1.forwardRef(function Grid(_a, ref) {
	    var _b;
	    var style = _a.style, className = _a.className, children = _a.children, _c = _a.clone, clone = _c === void 0 ? false : _c, _d = _a.cloneStyles, cloneStyles = _d === void 0 ? false : _d, _e = _a.wrapOnly, wrapOnly = _e === void 0 ? false : _e, columns = _a.columns, phoneColumns = _a.phoneColumns, tabletColumns = _a.tabletColumns, desktopColumns = _a.desktopColumns, largeDesktopColumns = _a.largeDesktopColumns, padding = _a.padding, gutter = _a.gutter, minCellWidth = _a.minCellWidth, props = __rest$2x(_a, ["style", "className", "children", "clone", "cloneStyles", "wrapOnly", "columns", "phoneColumns", "tabletColumns", "desktopColumns", "largeDesktopColumns", "padding", "gutter", "minCellWidth"]);
	    var _f = useAppSize(), isPhone = _f.isPhone, isTablet = _f.isTablet, isDesktop = _f.isDesktop, isLargeDesktop = _f.isLargeDesktop;
	    var mergedStyle = __assign$34(__assign$34({ padding: (padding !== 0 && padding) || undefined, gridTemplateColumns: minCellWidth
	            ? "repeat(auto-fill, minmax(".concat(minCellWidth, ", 1fr))")
	            : undefined }, style), (_b = {}, _b[GRID_COLUMNS_VAR] = (isPhone && phoneColumns) ||
	        (isTablet && tabletColumns) ||
	        (isLargeDesktop && largeDesktopColumns) ||
	        (isDesktop && desktopColumns) ||
	        columns, _b[GRID_GUTTER_VAR] = gutter, _b));
	    var mergedClassName = cn(block$19({ "no-padding": padding === 0 }), className);
	    if (cloneStyles && require$$1.isValidElement(children)) {
	        var child = require$$1.Children.only(children);
	        return require$$1.cloneElement(child, {
	            style: __assign$34(__assign$34({}, mergedStyle), child.props.style),
	            className: cn(mergedClassName, child.props.className),
	        });
	    }
	    var content = children;
	    if (clone || wrapOnly) {
	        content = require$$1.Children.map(children, function (child) { return child && jsxRuntime.exports.jsx(GridCell, __assign$34({ clone: clone }, { children: child })); });
	    }
	    return (jsxRuntime.exports.jsx("div", __assign$34({}, props, { ref: ref, style: mergedStyle, className: mergedClassName }, { children: content })));
	});

	var __assign$33 = (undefined && undefined.__assign) || function () {
	    __assign$33 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$33.apply(this, arguments);
	};
	var __rest$2w = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$18 = bem("rmd-grid-list");
	var GridListCell = require$$1.forwardRef(function GridListCell(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a.square, square = _b === void 0 ? false : _b, _c = _a.clone, clone = _c === void 0 ? false : _c, props = __rest$2w(_a, ["className", "children", "square", "clone"]);
	    var cellClassName = cn(block$18("cell", { square: square }), className);
	    if (clone && require$$1.isValidElement(children)) {
	        var child = require$$1.Children.only(children);
	        return require$$1.cloneElement(child, {
	            className: cn(cellClassName, child.props.className),
	        });
	    }
	    return (jsxRuntime.exports.jsx("div", __assign$33({}, props, { ref: ref, className: cellClassName }, { children: children })));
	});

	var resizeObservers = [];

	var hasActiveObservations = function () {
	    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });
	};

	var hasSkippedObservations = function () {
	    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });
	};

	var msg = 'ResizeObserver loop completed with undelivered notifications.';
	var deliverResizeLoopError = function () {
	    var event;
	    if (typeof ErrorEvent === 'function') {
	        event = new ErrorEvent('error', {
	            message: msg
	        });
	    }
	    else {
	        event = document.createEvent('Event');
	        event.initEvent('error', false, false);
	        event.message = msg;
	    }
	    window.dispatchEvent(event);
	};

	var ResizeObserverBoxOptions;
	(function (ResizeObserverBoxOptions) {
	    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
	    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
	    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
	})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

	var freeze = function (obj) { return Object.freeze(obj); };

	var ResizeObserverSize = (function () {
	    function ResizeObserverSize(inlineSize, blockSize) {
	        this.inlineSize = inlineSize;
	        this.blockSize = blockSize;
	        freeze(this);
	    }
	    return ResizeObserverSize;
	}());

	var DOMRectReadOnly = (function () {
	    function DOMRectReadOnly(x, y, width, height) {
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;
	        this.top = this.y;
	        this.left = this.x;
	        this.bottom = this.top + this.height;
	        this.right = this.left + this.width;
	        return freeze(this);
	    }
	    DOMRectReadOnly.prototype.toJSON = function () {
	        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
	        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };
	    };
	    DOMRectReadOnly.fromRect = function (rectangle) {
	        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
	    };
	    return DOMRectReadOnly;
	}());

	var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };
	var isHidden = function (target) {
	    if (isSVG(target)) {
	        var _a = target.getBBox(), width = _a.width, height = _a.height;
	        return !width && !height;
	    }
	    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
	    return !(offsetWidth || offsetHeight || target.getClientRects().length);
	};
	var isElement = function (obj) {
	    var _a, _b;
	    if (obj instanceof Element) {
	        return true;
	    }
	    var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
	    return !!(scope && obj instanceof scope.Element);
	};
	var isReplacedElement = function (target) {
	    switch (target.tagName) {
	        case 'INPUT':
	            if (target.type !== 'image') {
	                break;
	            }
	        case 'VIDEO':
	        case 'AUDIO':
	        case 'EMBED':
	        case 'OBJECT':
	        case 'CANVAS':
	        case 'IFRAME':
	        case 'IMG':
	            return true;
	    }
	    return false;
	};

	var global = typeof window !== 'undefined' ? window : {};

	var cache = new WeakMap();
	var scrollRegexp = /auto|scroll/;
	var verticalRegexp = /^tb|vertical/;
	var IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);
	var parseDimension = function (pixel) { return parseFloat(pixel || '0'); };
	var size = function (inlineSize, blockSize, switchSizes) {
	    if (inlineSize === void 0) { inlineSize = 0; }
	    if (blockSize === void 0) { blockSize = 0; }
	    if (switchSizes === void 0) { switchSizes = false; }
	    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
	};
	var zeroBoxes = freeze({
	    devicePixelContentBoxSize: size(),
	    borderBoxSize: size(),
	    contentBoxSize: size(),
	    contentRect: new DOMRectReadOnly(0, 0, 0, 0)
	});
	var calculateBoxSizes = function (target, forceRecalculation) {
	    if (forceRecalculation === void 0) { forceRecalculation = false; }
	    if (cache.has(target) && !forceRecalculation) {
	        return cache.get(target);
	    }
	    if (isHidden(target)) {
	        cache.set(target, zeroBoxes);
	        return zeroBoxes;
	    }
	    var cs = getComputedStyle(target);
	    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
	    var removePadding = !IE && cs.boxSizing === 'border-box';
	    var switchSizes = verticalRegexp.test(cs.writingMode || '');
	    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
	    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
	    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
	    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
	    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
	    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
	    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
	    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
	    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
	    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
	    var horizontalPadding = paddingLeft + paddingRight;
	    var verticalPadding = paddingTop + paddingBottom;
	    var horizontalBorderArea = borderLeft + borderRight;
	    var verticalBorderArea = borderTop + borderBottom;
	    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
	    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
	    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
	    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
	    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
	    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
	    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
	    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
	    var boxes = freeze({
	        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
	        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
	        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
	        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
	    });
	    cache.set(target, boxes);
	    return boxes;
	};
	var calculateBoxSize = function (target, observedBox, forceRecalculation) {
	    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
	    switch (observedBox) {
	        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
	            return devicePixelContentBoxSize;
	        case ResizeObserverBoxOptions.BORDER_BOX:
	            return borderBoxSize;
	        default:
	            return contentBoxSize;
	    }
	};

	var ResizeObserverEntry = (function () {
	    function ResizeObserverEntry(target) {
	        var boxes = calculateBoxSizes(target);
	        this.target = target;
	        this.contentRect = boxes.contentRect;
	        this.borderBoxSize = freeze([boxes.borderBoxSize]);
	        this.contentBoxSize = freeze([boxes.contentBoxSize]);
	        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
	    }
	    return ResizeObserverEntry;
	}());

	var calculateDepthForNode = function (node) {
	    if (isHidden(node)) {
	        return Infinity;
	    }
	    var depth = 0;
	    var parent = node.parentNode;
	    while (parent) {
	        depth += 1;
	        parent = parent.parentNode;
	    }
	    return depth;
	};

	var broadcastActiveObservations = function () {
	    var shallowestDepth = Infinity;
	    var callbacks = [];
	    resizeObservers.forEach(function processObserver(ro) {
	        if (ro.activeTargets.length === 0) {
	            return;
	        }
	        var entries = [];
	        ro.activeTargets.forEach(function processTarget(ot) {
	            var entry = new ResizeObserverEntry(ot.target);
	            var targetDepth = calculateDepthForNode(ot.target);
	            entries.push(entry);
	            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
	            if (targetDepth < shallowestDepth) {
	                shallowestDepth = targetDepth;
	            }
	        });
	        callbacks.push(function resizeObserverCallback() {
	            ro.callback.call(ro.observer, entries, ro.observer);
	        });
	        ro.activeTargets.splice(0, ro.activeTargets.length);
	    });
	    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
	        var callback = callbacks_1[_i];
	        callback();
	    }
	    return shallowestDepth;
	};

	var gatherActiveObservationsAtDepth = function (depth) {
	    resizeObservers.forEach(function processObserver(ro) {
	        ro.activeTargets.splice(0, ro.activeTargets.length);
	        ro.skippedTargets.splice(0, ro.skippedTargets.length);
	        ro.observationTargets.forEach(function processTarget(ot) {
	            if (ot.isActive()) {
	                if (calculateDepthForNode(ot.target) > depth) {
	                    ro.activeTargets.push(ot);
	                }
	                else {
	                    ro.skippedTargets.push(ot);
	                }
	            }
	        });
	    });
	};

	var process = function () {
	    var depth = 0;
	    gatherActiveObservationsAtDepth(depth);
	    while (hasActiveObservations()) {
	        depth = broadcastActiveObservations();
	        gatherActiveObservationsAtDepth(depth);
	    }
	    if (hasSkippedObservations()) {
	        deliverResizeLoopError();
	    }
	    return depth > 0;
	};

	var trigger;
	var callbacks = [];
	var notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };
	var queueMicroTask = function (callback) {
	    if (!trigger) {
	        var toggle_1 = 0;
	        var el_1 = document.createTextNode('');
	        var config = { characterData: true };
	        new MutationObserver(function () { return notify(); }).observe(el_1, config);
	        trigger = function () { el_1.textContent = "" + (toggle_1 ? toggle_1-- : toggle_1++); };
	    }
	    callbacks.push(callback);
	    trigger();
	};

	var queueResizeObserver = function (cb) {
	    queueMicroTask(function ResizeObserver() {
	        requestAnimationFrame(cb);
	    });
	};

	var watching = 0;
	var isWatching = function () { return !!watching; };
	var CATCH_PERIOD = 250;
	var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
	var events = [
	    'resize',
	    'load',
	    'transitionend',
	    'animationend',
	    'animationstart',
	    'animationiteration',
	    'keyup',
	    'keydown',
	    'mouseup',
	    'mousedown',
	    'mouseover',
	    'mouseout',
	    'blur',
	    'focus'
	];
	var time = function (timeout) {
	    if (timeout === void 0) { timeout = 0; }
	    return Date.now() + timeout;
	};
	var scheduled = false;
	var Scheduler = (function () {
	    function Scheduler() {
	        var _this = this;
	        this.stopped = true;
	        this.listener = function () { return _this.schedule(); };
	    }
	    Scheduler.prototype.run = function (timeout) {
	        var _this = this;
	        if (timeout === void 0) { timeout = CATCH_PERIOD; }
	        if (scheduled) {
	            return;
	        }
	        scheduled = true;
	        var until = time(timeout);
	        queueResizeObserver(function () {
	            var elementsHaveResized = false;
	            try {
	                elementsHaveResized = process();
	            }
	            finally {
	                scheduled = false;
	                timeout = until - time();
	                if (!isWatching()) {
	                    return;
	                }
	                if (elementsHaveResized) {
	                    _this.run(1000);
	                }
	                else if (timeout > 0) {
	                    _this.run(timeout);
	                }
	                else {
	                    _this.start();
	                }
	            }
	        });
	    };
	    Scheduler.prototype.schedule = function () {
	        this.stop();
	        this.run();
	    };
	    Scheduler.prototype.observe = function () {
	        var _this = this;
	        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };
	        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);
	    };
	    Scheduler.prototype.start = function () {
	        var _this = this;
	        if (this.stopped) {
	            this.stopped = false;
	            this.observer = new MutationObserver(this.listener);
	            this.observe();
	            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });
	        }
	    };
	    Scheduler.prototype.stop = function () {
	        var _this = this;
	        if (!this.stopped) {
	            this.observer && this.observer.disconnect();
	            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });
	            this.stopped = true;
	        }
	    };
	    return Scheduler;
	}());
	var scheduler = new Scheduler();
	var updateCount = function (n) {
	    !watching && n > 0 && scheduler.start();
	    watching += n;
	    !watching && scheduler.stop();
	};

	var skipNotifyOnElement = function (target) {
	    return !isSVG(target)
	        && !isReplacedElement(target)
	        && getComputedStyle(target).display === 'inline';
	};
	var ResizeObservation = (function () {
	    function ResizeObservation(target, observedBox) {
	        this.target = target;
	        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
	        this.lastReportedSize = {
	            inlineSize: 0,
	            blockSize: 0
	        };
	    }
	    ResizeObservation.prototype.isActive = function () {
	        var size = calculateBoxSize(this.target, this.observedBox, true);
	        if (skipNotifyOnElement(this.target)) {
	            this.lastReportedSize = size;
	        }
	        if (this.lastReportedSize.inlineSize !== size.inlineSize
	            || this.lastReportedSize.blockSize !== size.blockSize) {
	            return true;
	        }
	        return false;
	    };
	    return ResizeObservation;
	}());

	var ResizeObserverDetail = (function () {
	    function ResizeObserverDetail(resizeObserver, callback) {
	        this.activeTargets = [];
	        this.skippedTargets = [];
	        this.observationTargets = [];
	        this.observer = resizeObserver;
	        this.callback = callback;
	    }
	    return ResizeObserverDetail;
	}());

	var observerMap = new WeakMap();
	var getObservationIndex = function (observationTargets, target) {
	    for (var i = 0; i < observationTargets.length; i += 1) {
	        if (observationTargets[i].target === target) {
	            return i;
	        }
	    }
	    return -1;
	};
	var ResizeObserverController = (function () {
	    function ResizeObserverController() {
	    }
	    ResizeObserverController.connect = function (resizeObserver, callback) {
	        var detail = new ResizeObserverDetail(resizeObserver, callback);
	        observerMap.set(resizeObserver, detail);
	    };
	    ResizeObserverController.observe = function (resizeObserver, target, options) {
	        var detail = observerMap.get(resizeObserver);
	        var firstObservation = detail.observationTargets.length === 0;
	        if (getObservationIndex(detail.observationTargets, target) < 0) {
	            firstObservation && resizeObservers.push(detail);
	            detail.observationTargets.push(new ResizeObservation(target, options && options.box));
	            updateCount(1);
	            scheduler.schedule();
	        }
	    };
	    ResizeObserverController.unobserve = function (resizeObserver, target) {
	        var detail = observerMap.get(resizeObserver);
	        var index = getObservationIndex(detail.observationTargets, target);
	        var lastObservation = detail.observationTargets.length === 1;
	        if (index >= 0) {
	            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
	            detail.observationTargets.splice(index, 1);
	            updateCount(-1);
	        }
	    };
	    ResizeObserverController.disconnect = function (resizeObserver) {
	        var _this = this;
	        var detail = observerMap.get(resizeObserver);
	        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });
	        detail.activeTargets.splice(0, detail.activeTargets.length);
	    };
	    return ResizeObserverController;
	}());

	var ResizeObserver = (function () {
	    function ResizeObserver(callback) {
	        if (arguments.length === 0) {
	            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
	        }
	        if (typeof callback !== 'function') {
	            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
	        }
	        ResizeObserverController.connect(this, callback);
	    }
	    ResizeObserver.prototype.observe = function (target, options) {
	        if (arguments.length === 0) {
	            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
	        }
	        if (!isElement(target)) {
	            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
	        }
	        ResizeObserverController.observe(this, target, options);
	    };
	    ResizeObserver.prototype.unobserve = function (target) {
	        if (arguments.length === 0) {
	            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
	        }
	        if (!isElement(target)) {
	            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
	        }
	        ResizeObserverController.unobserve(this, target);
	    };
	    ResizeObserver.prototype.disconnect = function () {
	        ResizeObserverController.disconnect(this);
	    };
	    ResizeObserver.toString = function () {
	        return 'function ResizeObserver () { [polyfill code] }';
	    };
	    return ResizeObserver;
	}());

	/**
	 * This is mostly an internal hook that allows for an optional ref (normally
	 * from props or hook options) to be merged with a hook's required `ref`. This
	 * will return a MutableRefObject used for DOM manipulation in a custom hook
	 * followed by a ref callback function that should be passed to the DOM node
	 * that will ensure that both the optional `propRef` and hook ref are updated.
	 *
	 * @remarks \@since 2.3.0
	 */
	function useEnsuredRef(propRef) {
	    var ref = require$$1.useRef(null);
	    var refHandler = require$$1.useCallback(function (instance) {
	        applyRef(instance, propRef);
	        ref.current = instance;
	    }, [propRef]);
	    return [ref, refHandler];
	}

	var __assign$32 = (undefined && undefined.__assign) || function () {
	    __assign$32 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$32.apply(this, arguments);
	};
	var __read$12 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @internal
	 */
	function isHeightChange(prevSize, nextSize) {
	    return (!prevSize ||
	        prevSize.height !== nextSize.height ||
	        prevSize.scrollHeight !== nextSize.scrollHeight);
	}
	/**
	 * @internal
	 */
	function isWidthChange(prevSize, nextSize) {
	    return (!prevSize ||
	        prevSize.width !== nextSize.width ||
	        prevSize.scrollWidth !== nextSize.scrollWidth);
	}
	/**
	 * Why is there a single shared observer instead of multiple and a
	 * "subscription" model?
	 *
	 * Note: Probably a bit of a premature optimization right now...
	 *
	 * @see https://github.com/WICG/resize-observer/issues/59
	 * @internal
	 */
	var sharedObserver;
	/**
	 *
	 * @internal
	 */
	var subscriptions = [];
	/**
	 * Lazy initializes the shared resize observer which will loop through all the
	 * subscriptions when a resize event is called.
	 *
	 * @internal
	 */
	function init() {
	    if (sharedObserver || typeof document === "undefined") {
	        return;
	    }
	    sharedObserver = new ResizeObserver(function (entries) {
	        var _loop_1 = function (i) {
	            var entry = entries[i];
	            var currentSubscriptions = subscriptions.filter(function (_a) {
	                var target = _a.target;
	                return target === entry.target;
	            });
	            if (!currentSubscriptions.length) {
	                return { value: void 0 };
	            }
	            var _a = entry.contentRect, height = _a.height, width = _a.width;
	            var _b = entry.target, scrollHeight = _b.scrollHeight, scrollWidth = _b.scrollWidth;
	            var nextSize = {
	                height: height,
	                width: width,
	                scrollHeight: scrollHeight,
	                scrollWidth: scrollWidth,
	            };
	            for (var j = 0; j < currentSubscriptions.length; j += 1) {
	                var subscription = currentSubscriptions[j];
	                var handler = subscription.handler, prevSize = subscription.prevSize, disableHeight = subscription.disableHeight, disableWidth = subscription.disableWidth;
	                var isNewHeight = isHeightChange(prevSize, nextSize);
	                var isNewWidth = isWidthChange(prevSize, nextSize);
	                if ((isNewHeight && !disableHeight) || (isNewWidth && !disableWidth)) {
	                    subscription.prevSize = nextSize;
	                    handler(__assign$32(__assign$32({}, nextSize), { element: entry.target }));
	                }
	            }
	        };
	        // Note: might need to wait until an requestAnimationFrame has completed to
	        // fix the resize observer loop exceeded error if switching to
	        // `useIsomorphicLayoutEffect` and a shared observer didn't fix that error:
	        // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
	        for (var i = 0; i < entries.length; i += 1) {
	            var state_1 = _loop_1(i);
	            if (typeof state_1 === "object")
	                return state_1.value;
	        }
	    });
	}
	/**
	 *
	 * @internal
	 */
	function subscribe(target, onResize, disableHeight, disableWidth) {
	    var exists = subscriptions.find(function (sub) { return sub.target === target; });
	    subscriptions.push({
	        target: target,
	        handler: onResize,
	        disableWidth: disableWidth,
	        disableHeight: disableHeight,
	        prevSize: undefined,
	    });
	    if (!exists) {
	        // I'll silently fail non-initialized observers for now until it becomes an
	        // issue... But how will I ever know?
	        sharedObserver === null || sharedObserver === void 0 ? void 0 : sharedObserver.observe(target);
	    }
	}
	/**
	 *
	 * @internal
	 */
	function unsubscribe(target, onResize, disableHeight, disableWidth) {
	    var i = subscriptions.findIndex(function (sub) {
	        return sub.target === target &&
	            sub.handler === onResize &&
	            sub.disableWidth === disableWidth &&
	            sub.disableHeight === disableHeight;
	    });
	    if (i !== -1) {
	        subscriptions.splice(i, 1);
	    }
	    var remaining = subscriptions.some(function (sub) { return sub.target === target; });
	    if (!remaining) {
	        // I'll silently fail non-initialized observers for now until it becomes an
	        // issue... But how will I ever know?
	        sharedObserver === null || sharedObserver === void 0 ? void 0 : sharedObserver.unobserve(target);
	    }
	}
	/**
	 * The new resize observer API that returns a `refHandler` to attach to a DOM
	 * node instead of using the weird `target` API.
	 *
	 * @remarks \@since 2.3.0
	 * @param onResize - The resize handler to call when the element has changed
	 * height or width. If you notice performance issues or other oddities, it is
	 * recommended to wrap this function in `useCallback`.
	 * @param options - Any additional options to use for the resize observer.
	 */
	function useResizeObserver(onResize, options) {
	    if (options === void 0) { options = {}; }
	    var propRef = options.ref, _a = options.disableWidth, disableWidth = _a === void 0 ? false : _a, _b = options.disableHeight, disableHeight = _b === void 0 ? false : _b;
	    var _c = __read$12(useEnsuredRef(propRef), 2), ref = _c[0], refHandler = _c[1];
	    useIsomorphicLayoutEffect(function () {
	        var target = ref.current;
	        if ((disableHeight && disableWidth) || !target) {
	            return;
	        }
	        init();
	        subscribe(target, onResize, disableHeight, disableWidth);
	        return function () {
	            unsubscribe(target, onResize, disableHeight, disableWidth);
	        };
	    }, [disableHeight, disableWidth, onResize]);
	    return [ref, refHandler];
	}

	var cached = {
	    height: undefined,
	    width: undefined,
	};
	/**
	 * This will return the scrollbar size for a specific OS by creating a
	 * temporary element to compare the height/width between it's inner element and
	 * it's own height/width when scrollbars are enabled. This is useful when your
	 * height/width calculations need to exclude scrollbars since they are included
	 * by default but content can't be shown underneath them for for static
	 * elements.
	 *
	 * Note: This will return `0` on Mac OS with the default "Only show scrollbars
	 * when scrolling" which is to be expected. These scrollbars overlay the content
	 * and actually don't take up height/width real estate.
	 *
	 * @see https://stackoverflow.com/a/13382873
	 * @param type - Either the string "height" or "width" to determine which size
	 * to get
	 * @param forced - Boolean if the scrollbar height/width should be force
	 * updated. When this is false, the "cached" value will be returned immediately
	 * instead
	 * @returns the current scrollbar width or -1 if running this on the server
	 */
	function scrollbarSize(type, forced) {
	    if (type === void 0) { type = "width"; }
	    if (forced === void 0) { forced = false; }
	    /* istanbul ignore if */
	    if (typeof window === "undefined") {
	        return -1;
	    }
	    var value = cached[type];
	    if (!forced && typeof value === "number") {
	        return value;
	    }
	    var outer = document.createElement("div");
	    outer.style.visibility = "hidden";
	    outer.style.overflow = "scroll";
	    document.body.appendChild(outer);
	    var inner = document.createElement("div");
	    outer.appendChild(inner);
	    var offsetType = type === "width" ? "offsetWidth" : "offsetHeight";
	    // the scrollbar width can be determined by comparing the width of the parent
	    // element that has scrollbars to the child element that does not.
	    value = outer[offsetType] - inner[offsetType];
	    cached[type] = value;
	    document.body.removeChild(outer);
	    return value;
	}

	var __assign$31 = (undefined && undefined.__assign) || function () {
	    __assign$31 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$31.apply(this, arguments);
	};
	var __read$11 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This is the css variable that is used store the current size of each cell.
	 */
	var CELL_SIZE_VAR = "--rmd-cell-size";
	/**
	 * This is the css variable that is used store the current margin of each cell.
	 */
	var CELL_MARGIN_VAR = "--rmd-cell-margin";
	/**
	 * @remarks \@since 2.3.0
	 */
	var DEFAULT_GRID_LIST_MAX_CELL_SIZE = 150;
	/**
	 * @remarks \@since 2.3.0
	 */
	var DEFAULT_GRID_LIST_PADDING = 16;
	var context$c = require$$1.createContext({
	    columns: -1,
	    cellWidth: -1,
	});
	/**
	 * @remarks \@since 2.3.0
	 */
	var GridListSizeProvider = context$c.Provider;
	/**
	 * Gets the current size of each cell within the `GridList` component. If this
	 * is used without a parent `GridList` component, `-1` is returned instead.
	 *
	 * @remarks \@since 2.3.0
	 */
	function useGridListSize() {
	    return require$$1.useContext(context$c);
	}
	/**
	 * The `useGridList` hook allows you to get all the grid and sizing
	 * functionality of the `GridList` component without needing to wrap your
	 * children in a `<div>` element.
	 *
	 * Example:
	 *
	 * ```tsx
	 * const [gridListProps] = useGridList({
	 *   cellMargin: 16,
	 *   maxCellSize: 300,
	 *   containerPadding: 4,
	 * });
	 *
	 * return <div {...gridListProps}>{children}</div>;
	 * ```
	 *
	 * Note: You must manually provide the `gridSize` to the `GridListSizeProvider`
	 * component that was added in 2.3.0 if you want to use the `useGridSize` hook.
	 *
	 * Example:
	 *
	 * ```tsx
	 * const [gridListProps, gridSize] = useGridList()
	 *
	 * return (
	 *   <GridListSizeProvider value={gridSize}>
	 *     <MyComponent {...gridListProps} />
	 *   </GridListSizeProvider>
	 * );
	 * ```
	 *
	 * @remarks \@since 2.3.0
	 */
	function useGridList(_a) {
	    var _b;
	    var _c = _a === void 0 ? {} : _a, propRef = _c.ref, style = _c.style, className = _c.className, cellMargin = _c.cellMargin, defaultSize = _c.defaultSize, _d = _c.maxCellSize, maxCellSize = _d === void 0 ? DEFAULT_GRID_LIST_MAX_CELL_SIZE : _d, _e = _c.disableHeight, disableHeight = _e === void 0 ? false : _e, _f = _c.disableWidth, disableWidth = _f === void 0 ? false : _f, _g = _c.containerPadding, containerPadding = _g === void 0 ? DEFAULT_GRID_LIST_PADDING : _g;
	    var _h = __read$11(useEnsuredRef(propRef), 2), ref = _h[0], mergedRef = _h[1];
	    var _j = __read$11(require$$1.useState(defaultSize || { columns: -1, cellWidth: maxCellSize }), 2), gridSize = _j[0], setGridSize = _j[1];
	    var recalculate = require$$1.useCallback(function () {
	        var target = ref.current;
	        if (!target) {
	            return;
	        }
	        // need to use rect instead of offsetWidth since we need decimal precision
	        // for the width since offsetWidth is basically Math.ceil(width). the
	        // calculations for max columns will be off on high-pixel-density monitors
	        // or some zoom levels.
	        var width = target.getBoundingClientRect().width;
	        width -= containerPadding;
	        // just need to see if there is a scrollbar visible and subtract that width.
	        // don't need decimal precision here since both values will be rounded
	        if (target.offsetHeight < target.scrollHeight) {
	            width -= scrollbarSize("width");
	        }
	        var columns = Math.ceil(width / maxCellSize);
	        setGridSize({ cellWidth: width / columns, columns: columns });
	    }, [containerPadding, maxCellSize, ref]);
	    var _k = __read$11(useResizeObserver(recalculate, {
	        ref: mergedRef,
	        disableHeight: disableHeight,
	        disableWidth: disableWidth,
	    }), 2), refHandler = _k[1];
	    var mergedStyle = __assign$31(__assign$31({}, style), (_b = {}, _b[CELL_SIZE_VAR] = "".concat(gridSize.cellWidth, "px"), _b));
	    if (cellMargin) {
	        mergedStyle[CELL_MARGIN_VAR] = cellMargin;
	    }
	    return [
	        {
	            ref: refHandler,
	            style: mergedStyle,
	            className: cn("rmd-grid-list", className),
	        },
	        gridSize,
	    ];
	}

	var __assign$30 = (undefined && undefined.__assign) || function () {
	    __assign$30 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$30.apply(this, arguments);
	};
	var __rest$2v = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$10 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var isRenderFunction = function (children) { return typeof children === "function"; };
	/**
	 * The `GridList` component is a different way to render a list of data where
	 * the number of columns is dynamic and based on the max-width for each cell.
	 * Instead of setting a percentage width to each cell based on the number of
	 * columns, this will dynamically add columns to fill up the remaining space and
	 * have each cell grow up to a set max-width. A really good use-case for this is
	 * displaying a list of images or thumbnails and allowing the user to see a full
	 * screen preview once selected/clicked.
	 */
	var GridList = require$$1.forwardRef(function GridList(_a, forwardedRef) {
	    var style = _a.style, className = _a.className, children = _a.children, _b = _a.clone, clone = _b === void 0 ? false : _b, _c = _a.wrapOnly, wrapOnly = _c === void 0 ? false : _c, cellMargin = _a.cellMargin, defaultSize = _a.defaultSize, _d = _a.maxCellSize, maxCellSize = _d === void 0 ? DEFAULT_GRID_LIST_MAX_CELL_SIZE : _d, _e = _a.containerPadding, containerPadding = _e === void 0 ? DEFAULT_GRID_LIST_PADDING : _e, _f = _a.disableHeightObserver, disableHeightObserver = _f === void 0 ? false : _f, _g = _a.disableWidthObserver, disableWidthObserver = _g === void 0 ? false : _g, props = __rest$2v(_a, ["style", "className", "children", "clone", "wrapOnly", "cellMargin", "defaultSize", "maxCellSize", "containerPadding", "disableHeightObserver", "disableWidthObserver"]);
	    var _h = __read$10(useGridList({
	        ref: forwardedRef,
	        style: style,
	        className: className,
	        cellMargin: cellMargin,
	        defaultSize: defaultSize,
	        maxCellSize: maxCellSize,
	        containerPadding: containerPadding,
	        disableHeight: disableHeightObserver,
	        disableWidth: disableWidthObserver,
	    }), 2), gridListProps = _h[0], gridSize = _h[1];
	    var content = null;
	    if (isRenderFunction(children)) {
	        content = children(gridSize);
	    }
	    else if (clone || wrapOnly) {
	        content = require$$1.Children.map(children, function (child) { return child && jsxRuntime.exports.jsx(GridListCell, __assign$30({ clone: clone }, { children: child })); });
	    }
	    else {
	        content = children;
	    }
	    return (jsxRuntime.exports.jsx(GridListSizeProvider, __assign$30({ value: gridSize }, { children: jsxRuntime.exports.jsx("div", __assign$30({}, props, gridListProps, { children: content })) })));
	});

	/**
	 * Rounds a number to the nearest step within a min/max range.
	 *
	 * @see https://stackoverflow.com/a/13635455
	 * @param value - The value to round to the nearest step
	 * @param min - The min value allowed
	 * @param max - The max value allowed
	 * @param steps - The number of steps in the min/max range
	 * @param range - The range allowed for the value that defaults to `max - min`
	 * @returns the value rounded to the nearest step in the min/max range
	 * @remarks \@since 2.5.0 - Added the `range` param
	 */
	function nearest(value, min, max, steps, range) {
	    if (range === void 0) { range = max - min; }
	    var rounded = Math.round(((value - min) * steps) / range) / steps;
	    var zeroToOne = Math.min(Math.max(rounded, 0), 1);
	    // have to calculate the number of allowed decimal places since decimal
	    // precision gets weird:
	    // 0.28 * 100 === 28.000000000000004
	    var step = range / steps;
	    var decimals = Number.isInteger(step)
	        ? range % steps
	        : step.toString().split(".")[1].length;
	    return Math.min(max, Math.max(min, parseFloat((zeroToOne * range + min).toFixed(decimals))));
	}

	/**
	 * Create a new object that does not contain the provided keys.
	 *
	 * @example
	 * Simple Examples
	 * ```ts
	 * const object = {
	 *   a: "",
	 *   b: 3,
	 *   c: false,
	 *   4: null,
	 * } as const;
	 *
	 * expect(omit(object, ["a"])).toEqual({
	 *   b: 3,
	 *   c: false,
	 *   4: null,
	 * });
	 * expect(omit(object, ["a", "c", "d"])).toEqual({ b: 3 });
	 * ```
	 *
	 * @internal
	 * @param object - The object to remove keys from
	 * @param omitKeys - The keys to remove.
	 * @returns a new object without the specified keys
	 */
	function omit(object, omitKeys) {
	    if (!omitKeys.length) {
	        return object;
	    }
	    var result = {};
	    for (var key in object) {
	        if (!omitKeys.includes(key)) {
	            result[key] = object[key];
	        }
	    }
	    return result;
	}

	/**
	 * Attempts to find a sizing container based on the provided HTMLElement. By
	 * default, the sizing element will just be the provided element unless:
	 * - the item has a known role within react-md that can target known classes
	 * - the item has a `data-sizing-selector` attribute that is a valid query
	 *   selector for the nested item.
	 *
	 * NOTE: The `data-sizing-selector` will be run from the current element instead
	 * of the `document`.
	 *
	 * @param el - The element to find a sizing container for.
	 * @returns the sizing container relative to the provided element, or `null` if
	 * none could be found.
	 * @throws This error will be thrown if using the `data-query-selector` and the
	 * query selector does not return an element on the page.
	 */
	function findSizingContainer(el) {
	    if (!el) {
	        return null;
	    }
	    if (/(tree|list)item/.test(el.getAttribute("role") || "")) {
	        var content = el.querySelector(".rmd-tree-item__content, .rmd-item-text");
	        if (content) {
	            return content;
	        }
	    }
	    else if (el.getAttribute("type") === "file") {
	        var label = document.querySelector("[for=\"".concat(el.id, "\"]"));
	        if (label) {
	            return label;
	        }
	    }
	    var data = el.getAttribute("data-sizing-selector");
	    if (data) {
	        var content = el.querySelector(data);
	        if (content) {
	            return content;
	        }
	    }
	    return el;
	}

	/**
	 * This is a simple wrapper to get the view width or view height.
	 *
	 * @param direction - Either the "height" or "width" string to get that
	 * dimension
	 * @returns the view width or view height.
	 */
	function getViewportSize(direction) {
	    var de = document.documentElement || { clientHeight: 0, clientWidth: 0 };
	    if (direction === "width") {
	        return window.innerWidth || de.clientWidth;
	    }
	    return window.innerHeight || de.clientHeight;
	}

	function applyCoords(coord) {
	    return typeof coord === "number" ? "".concat(coord, "px") : "";
	}
	/**
	 * This util is used to get the "true" `element.getBoundingClientRect()` that
	 * ensures that transitions using transforms don't mess up the sizing so that
	 * position calculations are easier to do.
	 *
	 * @param element - The element to get a rect for.
	 * @param coords - An optional object of coordinates to apply to the positioning
	 * styles. This should be used when the coords might resize the element since it
	 * needs to try to fit within the viewport.
	 * @returns either a DOMRect for the element
	 * @internal
	 */
	function getElementRect(element, coords) {
	    if (coords === void 0) { coords = {}; }
	    var cloned = element.cloneNode(true);
	    // remove the id so there won't be two elements with the same id on the page
	    cloned.removeAttribute("id");
	    // remove the role just in case the role would alert screen readers once added
	    // to the dom
	    cloned.removeAttribute("role");
	    // ensure the cloned node won't shift the page or be visible
	    cloned.style.position = "fixed";
	    cloned.style.visibility = "hidden";
	    // reset positioning to get a "pure" calculation. otherwise this will mess up
	    // the height and width if the element is able to line wrap.
	    cloned.style.left = applyCoords(coords.left);
	    cloned.style.top = applyCoords(coords.top);
	    cloned.style.right = applyCoords(coords.right);
	    cloned.style.bottom = applyCoords(coords.bottom);
	    // reset transforms so that custom animations don't mess with the sizing
	    cloned.style.webkitTransform = "none";
	    cloned.style.transform = "none";
	    var parent = element.parentElement || document.body;
	    parent.appendChild(cloned);
	    var rect = cloned.getBoundingClientRect();
	    parent.removeChild(cloned);
	    return rect;
	}

	var ABOVE_LEFT_ANCHOR = {
	    x: "left",
	    y: "above",
	};
	var ABOVE_INNER_LEFT_ANCHOR = {
	    x: "inner-left",
	    y: "above",
	};
	var ABOVE_CENTER_ANCHOR = {
	    x: "center",
	    y: "above",
	};
	var ABOVE_INNER_RIGHT_ANCHOR = {
	    x: "inner-right",
	    y: "above",
	};
	var ABOVE_RIGHT_ANCHOR = {
	    x: "right",
	    y: "above",
	};
	var TOP_LEFT_ANCHOR = {
	    x: "left",
	    y: "top",
	};
	var TOP_INNER_LEFT_ANCHOR = {
	    x: "inner-left",
	    y: "top",
	};
	var TOP_CENTER_ANCHOR = {
	    x: "center",
	    y: "top",
	};
	var TOP_INNER_RIGHT_ANCHOR = {
	    x: "inner-right",
	    y: "top",
	};
	var TOP_RIGHT_ANCHOR = {
	    x: "right",
	    y: "top",
	};
	var CENTER_LEFT_ANCHOR = {
	    x: "left",
	    y: "center",
	};
	var CENTER_INNER_LEFT_ANCHOR = {
	    x: "inner-left",
	    y: "center",
	};
	var CENTER_CENTER_ANCHOR = {
	    x: "center",
	    y: "center",
	};
	var CENTER_INNER_RIGHT_ANCHOR = {
	    x: "inner-right",
	    y: "center",
	};
	var CENTER_RIGHT_ANCHOR = {
	    x: "right",
	    y: "center",
	};
	var BOTTOM_LEFT_ANCHOR = {
	    x: "left",
	    y: "bottom",
	};
	var BOTTOM_INNER_LEFT_ANCHOR = {
	    x: "inner-left",
	    y: "bottom",
	};
	var BOTTOM_CENTER_ANCHOR = {
	    x: "center",
	    y: "bottom",
	};
	var BOTTOM_INNER_RIGHT_ANCHOR = {
	    x: "inner-right",
	    y: "bottom",
	};
	var BOTTOM_RIGHT_ANCHOR = {
	    x: "right",
	    y: "bottom",
	};
	var BELOW_LEFT_ANCHOR = {
	    x: "left",
	    y: "below",
	};
	var BELOW_INNER_LEFT_ANCHOR = {
	    x: "inner-left",
	    y: "below",
	};
	var BELOW_CENTER_ANCHOR = {
	    x: "center",
	    y: "below",
	};
	var BELOW_INNER_RIGHT_ANCHOR = {
	    x: "inner-right",
	    y: "below",
	};
	var BELOW_RIGHT_ANCHOR = {
	    x: "right",
	    y: "below",
	};

	/**
	 * Creates the `left` style value for an element that should be fixed to the
	 * (outer) left of the container element. So the right bounds of the fixed
	 * element will be equal to the left bounds of the container element (before the
	 * xMargin is applied).
	 * @internal
	 */
	function getLeftCoord(_a) {
	    var xMargin = _a.xMargin, elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect;
	    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) - elWidth - xMargin;
	}
	/**
	 * Creates the `left` style value for an element that should be fixed to the
	 * inner-left of the container element. So the left bounds of both the container
	 * and fixed elements will overlap (before the xMargin is applied)
	 * @internal
	 */
	function getInnerLeftCoord(_a) {
	    var xMargin = _a.xMargin, initialX = _a.initialX, containerRect = _a.containerRect;
	    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) + xMargin;
	}
	/**
	 * Creates the `left` style value for an element that should be fixed to the
	 * center of the container element. So the center point of the fixed element
	 * should be the center point of the container element.
	 *
	 * Note: Unlike all the other horizontal positioning logic, the center position
	 * does not use the xMargin.
	 * @internal
	 */
	function getCenterXCoord(_a) {
	    var elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect;
	    var containerCenter = containerRect.width / 2;
	    var elementCenter = elWidth / 2;
	    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerCenter) - elementCenter;
	}
	/**
	 * Creates the `left` style value for an element that should be fixed to the
	 * inner-right of the container element. So the right bounds for both the
	 * container and fixed elements will overlap (before the xMargin is applied).
	 * @internal
	 */
	function getInnerRightCoord(_a) {
	    var xMargin = _a.xMargin, elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect;
	    return ((initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) - elWidth - xMargin);
	}
	/**
	 * Creates the `left` style value for an element that should be fixed to the
	 * (outer) right of the container element. So the left bounds of the fixed
	 * element will overlap with the right bounds of the container element (before
	 * the xMargin is applied).
	 * @internal
	 */
	function getRightCoord(_a) {
	    var xMargin = _a.xMargin, initialX = _a.initialX, containerRect = _a.containerRect;
	    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) + xMargin;
	}
	/**
	 * Creates the `top` style value for an element that should be fixed above the
	 * container element. So the bottom bounds of the fixed element will overlap
	 * with the top bounds of the container element (before the yMargin is applied).
	 * @internal
	 */
	function getAboveCoord(_a) {
	    var yMargin = _a.yMargin, initialY = _a.initialY, elHeight = _a.elHeight, containerRect = _a.containerRect;
	    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) - elHeight - yMargin;
	}
	/**
	 * Creates the `top` style value for an element that should be fixed to the top
	 * of the container element. So the top bounds for both the container and fixed
	 * elements will overlap (before the yMargin is applied).
	 * @internal
	 */
	function getTopCoord(_a) {
	    var yMargin = _a.yMargin, initialY = _a.initialY, containerRect = _a.containerRect;
	    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) + yMargin;
	}
	/**
	 * Creates the `top` style value for an element that should be fixed vertically
	 * centered relative to the container element. So the vertical center point for
	 * the fixed element should overlap the vertical center point of the container
	 * element.
	 *
	 * Note: Unlike all the other vertical positioning logic, the center position
	 * does not use the yMargin.
	 */
	function getCenterYCoord(_a) {
	    var elHeight = _a.elHeight, initialY = _a.initialY, containerRect = _a.containerRect;
	    var containerCenter = containerRect.height / 2;
	    var elementCenter = elHeight / 2;
	    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerCenter) - elementCenter;
	}
	/**
	 * Creates the `top` style value for an element that should be fixed to the
	 * bottom of the container element. So the top bounds of the fixed element
	 * should overlap the bottom bounds of the container element (before the yMargin
	 * is applied).
	 * @internal
	 */
	function getBottomCoord(_a) {
	    var yMargin = _a.yMargin, initialY = _a.initialY, elHeight = _a.elHeight, containerRect = _a.containerRect;
	    return ((initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) - elHeight - yMargin);
	}
	/**
	 * Creates the `top` style value for an element that should be fixed to the
	 * bottom of the container element. So the bottom bounds of both the container
	 * and fixed elements should overlap (before the yMargin is applied).
	 * @internal
	 */
	function getBelowCoord(_a) {
	    var yMargin = _a.yMargin, initialY = _a.initialY, containerRect = _a.containerRect;
	    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) + yMargin;
	}

	/**
	 * Attempts to position the fixed element so that it will appear to the left of
	 * the container element but also within the viewport boundaries. When swapping
	 * is enabled, it will attempt to swap to the right position if it can't fit
	 * within the viewport to the left. If it can't fit in the viewport even after
	 * being swapped to the right or swapping is disabled, it will be positioned to
	 * the viewport left boundary.
	 *
	 * @internal
	 */
	function createAnchoredLeft(config) {
	    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
	    var left = getLeftCoord(config);
	    var actualX = "left";
	    if (left >= vwMargin) {
	        return { actualX: actualX, left: left };
	    }
	    var swappedLeft = getRightCoord(config);
	    if (disableSwapping || swappedLeft + elWidth > screenRight) {
	        left = vwMargin;
	    }
	    else {
	        left = swappedLeft;
	        actualX = "right";
	    }
	    return { actualX: actualX, left: left };
	}
	/**
	 * Attempts to position the fixed element so that it will appear to the
	 * inner-left of the container element but also within the viewport boundaries.
	 * When swapping is enabled, it will attempt to swap to the right position if it
	 * can't fit within the viewport to the left. If it can't fit in the viewport
	 * even after being swapped to the right or swapping is disabled, it will be
	 * positioned to the viewport left boundary.
	 *
	 * @internal
	 */
	function createAnchoredInnerLeft(config) {
	    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
	    var left = getInnerLeftCoord(config);
	    var actualX = "inner-left";
	    if (left + elWidth <= screenRight && left >= vwMargin) {
	        return { actualX: actualX, left: left };
	    }
	    if (disableSwapping) {
	        if (left + elWidth > screenRight) {
	            left = screenRight - elWidth;
	        }
	        else {
	            left = vwMargin;
	        }
	        return { actualX: actualX, left: left };
	    }
	    var swappedLeft = getInnerRightCoord(config);
	    if (swappedLeft < vwMargin) {
	        left = vwMargin;
	    }
	    else if (swappedLeft + elWidth > screenRight) {
	        left = screenRight - elWidth;
	        actualX = "inner-right";
	    }
	    else {
	        left = swappedLeft;
	        actualX = "inner-right";
	    }
	    return { actualX: actualX, left: left };
	}
	/**
	 * Attempts to position the fixed element so that it will appear at the center
	 * of the container element but also within the viewport boundaries. If the
	 * centered element can't fit within the viewport, it will use the vwMargin
	 * value if it overflowed to the left, it'll position to the screen right
	 * boundary.
	 *
	 * @internal
	 */
	function createAnchoredCenter$1(config) {
	    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth;
	    var left = getCenterXCoord(config);
	    if (left < vwMargin) {
	        left = vwMargin;
	    }
	    else if (left + elWidth > screenRight || left < vwMargin) {
	        left = screenRight - elWidth;
	    }
	    return { actualX: "center", left: left };
	}
	/**
	 * Attempts to position the fixed element so that it will appear to the
	 * inner-right of the container element but also within the viewport boundaries.
	 * When swapping is enabled, it will attempt to swap to the inner-left position
	 * if it can't fit within the viewport to the right. If it can't fit in the
	 * viewport even after being swapped to the left or swapping is disabled, it
	 * will be positioned to the viewport right boundary.
	 *
	 * @internal
	 */
	function createAnchoredInnerRight(config) {
	    var screenRight = config.screenRight, vwMargin = config.vwMargin, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
	    var left = getInnerRightCoord(config);
	    var actualX = "inner-right";
	    if (left >= vwMargin) {
	        return { actualX: actualX, left: Math.min(left, screenRight - elWidth) };
	    }
	    var swappedLeft = getInnerLeftCoord(config);
	    if (disableSwapping || swappedLeft + elWidth > screenRight) {
	        left = vwMargin;
	    }
	    else {
	        left = Math.max(swappedLeft, vwMargin);
	        actualX = "inner-left";
	    }
	    return { actualX: actualX, left: left };
	}
	/**
	 * Attempts to position the fixed element so that it will appear to the right of
	 * the container element but also within the viewport boundaries. When swapping
	 * is enabled, it will attempt to swap to the left position if it can't fit
	 * within the viewport to the right. If it can't fit in the viewport even after
	 * being swapped to the left or swapping is disabled, it will be positioned to
	 * the viewport right boundary.
	 *
	 * @internal
	 */
	function createAnchoredRight(config) {
	    var screenRight = config.screenRight, vwMargin = config.vwMargin, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
	    var left = getRightCoord(config);
	    var actualX = "right";
	    if (left + elWidth <= screenRight) {
	        return { actualX: actualX, left: left };
	    }
	    var swappedLeft = getLeftCoord(config);
	    if (disableSwapping || swappedLeft < vwMargin) {
	        left = screenRight - elWidth;
	    }
	    else {
	        left = swappedLeft;
	        actualX = "left";
	    }
	    return { actualX: actualX, left: left };
	}
	/**
	 * @internal
	 */
	function createEqualWidth(_a) {
	    var x = _a.x, vw = _a.vw, elWidth = _a.elWidth, xMargin = _a.xMargin, vwMargin = _a.vwMargin, initialX = _a.initialX, containerRect = _a.containerRect, isMinWidth = _a.isMinWidth;
	    var left = initialX !== null && initialX !== void 0 ? initialX : containerRect.left + xMargin;
	    var width = containerRect.width - xMargin * 2;
	    var minWidth;
	    var right;
	    if (isMinWidth) {
	        minWidth = width;
	        width = undefined;
	        if (left + elWidth > vw - vwMargin) {
	            right = vwMargin;
	        }
	    }
	    // going to assume that the container element is visible in the DOM and just
	    // make the fixed element have the same left and right corners
	    return {
	        left: left,
	        right: right,
	        width: width,
	        minWidth: minWidth,
	        actualX: x,
	    };
	}
	/**
	 * Creates the horizontal position for a fixed element with the provided
	 * options.
	 * @internal
	 */
	function createHorizontalPosition(_a) {
	    var x = _a.x, vw = _a.vw, vwMargin = _a.vwMargin, xMargin = _a.xMargin, width = _a.width, elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect, disableSwapping = _a.disableSwapping;
	    if (width === "min" || width === "equal") {
	        return createEqualWidth({
	            x: x,
	            vw: vw,
	            vwMargin: vwMargin,
	            xMargin: xMargin,
	            elWidth: elWidth,
	            initialX: initialX,
	            containerRect: containerRect,
	            isMinWidth: width === "min",
	        });
	    }
	    if (elWidth > vw - vwMargin * 2) {
	        // if the element's width is greater than the viewport's width minus the
	        // margin on both sides, just make the element span the entire viewport with
	        // the margin
	        return {
	            left: vwMargin,
	            right: vwMargin,
	            actualX: x,
	        };
	    }
	    var config = {
	        vwMargin: vwMargin,
	        xMargin: xMargin,
	        elWidth: elWidth,
	        initialX: initialX,
	        screenRight: vw - vwMargin,
	        containerRect: containerRect,
	        disableSwapping: disableSwapping,
	    };
	    switch (x) {
	        case "left":
	            return createAnchoredLeft(config);
	        case "inner-left":
	            return createAnchoredInnerLeft(config);
	        case "center":
	            return createAnchoredCenter$1(config);
	        case "inner-right":
	            return createAnchoredInnerRight(config);
	        case "right":
	            return createAnchoredRight(config);
	    }
	}

	/**
	 * Attempts to position the fixed element so that it will appear completely
	 * above the container element but also within the viewport boundaries. When
	 * swapping is enabled, it will attempt to swap to the below position if it
	 * can't fit within the viewport above the container element. If it can't fit in
	 * the viewport even after being swapped below or swapping is disabled, it will
	 * be positioned to the top viewport boundary.
	 *
	 * @internal
	 */
	function createAnchoredAbove(config) {
	    var yMargin = config.yMargin, vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, containerRect = config.containerRect, preventOverlap = config.preventOverlap, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;
	    var top = getAboveCoord(config);
	    var actualY = "above";
	    if (disableVHBounds) {
	        // can't actually allow a top value as a negative number since browsers
	        // won't scroll upwards pas the normal page top
	        return { actualY: actualY, top: Math.max(0, top) };
	    }
	    if (top > vhMargin) {
	        // don't need to do anything else since the top is still in the viewport and
	        // since it's positioned above, we already know it can't overlap the
	        // container element
	        return { actualY: actualY, top: top };
	    }
	    var swappedTop = getBelowCoord(config);
	    if (disableSwapping || swappedTop + elHeight > screenBottom) {
	        top = Math.min(top, vhMargin);
	    }
	    else {
	        actualY = "below";
	        top = swappedTop;
	    }
	    var bottom;
	    if (preventOverlap &&
	        // can't overlap if it's positioned below
	        actualY === "above" &&
	        top + elHeight > containerRect.top) {
	        bottom = window.innerHeight - containerRect.top + yMargin;
	    }
	    return { actualY: actualY, top: top, bottom: bottom };
	}
	/**
	 * Attempts to position the fixed element so that it will appear fixed to the
	 * top of the container element but also within the viewport boundaries. When
	 * swapping is enabled, it will attempt to swap to the bottom position if it
	 * can't fit within the viewport. If it can't fit in the viewport even after
	 * being swapped to the bottom position or swapping is disabled, it will be
	 * positioned to the top viewport boundary.
	 *
	 * @internal
	 */
	function createAnchoredTop(config) {
	    var vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;
	    var top = getTopCoord(config);
	    var actualY = "top";
	    if (disableVHBounds || top + elHeight <= screenBottom) {
	        return { actualY: actualY, top: top };
	    }
	    var swappedTop = getBottomCoord(config);
	    if (disableSwapping || swappedTop < vhMargin) {
	        top = Math.max(top, vhMargin);
	    }
	    else {
	        actualY = "bottom";
	        top = swappedTop;
	    }
	    return { actualY: actualY, top: top };
	}
	/**
	 * Attempts to position the fixed element so that it will appear at the center
	 * of the container element but also within the viewport boundaries. If the
	 * entered element can't fit within the viewport, it'll update the top value
	 * to either be the vhMargin or position to the screen bottom boundary
	 *
	 * @internal
	 */
	function createAnchoredCenter(config) {
	    var vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, disableVHBounds = config.disableVHBounds;
	    var top = getCenterYCoord(config);
	    var actualY = "center";
	    if (disableVHBounds) {
	        return { actualY: actualY, top: Math.max(0, top) };
	    }
	    top = Math.max(vhMargin, top);
	    if (top + elHeight > screenBottom) {
	        top = screenBottom - elHeight;
	    }
	    return { actualY: actualY, top: top };
	}
	/**
	 * Attempts to position the fixed element so that it will appear fixed to the
	 * bottom of the container element but also within the viewport boundaries. When
	 * swapping is enabled, it will attempt to swap to the top position if it can't
	 * fit within the viewport. If it can't fit in the viewport even after being
	 * swapped to the top position or swapping is disabled, it will be positioned to
	 * the bottom viewport boundary.
	 *
	 * @internal
	 */
	function createAnchoredBottom(config) {
	    var vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;
	    var top = getBottomCoord(config);
	    var actualY = "bottom";
	    if (disableVHBounds || top > vhMargin) {
	        return { actualY: actualY, top: top };
	    }
	    var swappedTop = getTopCoord(config);
	    if (disableSwapping || swappedTop + elHeight > screenBottom) {
	        top = Math.min(top, screenBottom - elHeight);
	    }
	    else {
	        actualY = "top";
	        top = swappedTop;
	    }
	    return { actualY: actualY, top: top };
	}
	/**
	 * Attempts to position the fixed element so that it will appear completely
	 * below the container element but also within the viewport boundaries. When
	 * swapping is enabled, it will attempt to swap to the above position if it
	 * can't fit within the viewport below the container element. If it can't fit in
	 * the viewport even after being swapped above or swapping is disabled, it will
	 * be positioned to the bottom viewport boundary.
	 *
	 * @internal
	 */
	function createAnchoredBelow(config) {
	    var yMargin = config.yMargin, vhMargin = config.vhMargin, elHeight = config.elHeight, screenBottom = config.screenBottom, containerRect = config.containerRect, preventOverlap = config.preventOverlap, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;
	    var top = getBelowCoord(config);
	    var actualY = "below";
	    if (disableVHBounds || top + elHeight <= screenBottom) {
	        return { actualY: actualY, top: top };
	    }
	    if (preventOverlap) {
	        var availableTop = containerRect.top - yMargin;
	        if (disableSwapping || availableTop < screenBottom - top) {
	            return {
	                actualY: actualY,
	                top: top,
	                bottom: vhMargin,
	            };
	        }
	        return {
	            actualY: "above",
	            top: Math.max(vhMargin, availableTop - elHeight),
	            // this makes it so that the bottom of the fixed element is the top of the container
	            // element. this ensures that it won't ever overlap the container element
	            bottom: getViewportSize("height") - availableTop,
	        };
	    }
	    var swappedTop = getAboveCoord(config);
	    if (disableSwapping || swappedTop < vhMargin) {
	        top = Math.max(top, screenBottom - elHeight);
	    }
	    else {
	        actualY = "above";
	        top = swappedTop;
	    }
	    return { actualY: actualY, top: top };
	}
	/**
	 * Creates the vertical position for a fixed element with the provided options.
	 *
	 * @internal
	 */
	function createVerticalPosition(_a) {
	    var y = _a.y, vh = _a.vh, vhMargin = _a.vhMargin, yMargin = _a.yMargin, elHeight = _a.elHeight, initialY = _a.initialY, containerRect = _a.containerRect, disableSwapping = _a.disableSwapping, preventOverlap = _a.preventOverlap, disableVHBounds = _a.disableVHBounds;
	    if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {
	        // the element is too big to be displayed in the viewport, so just span the
	        // full viewport excluding margins
	        return {
	            top: vhMargin,
	            bottom: vhMargin,
	            actualY: "center",
	        };
	    }
	    var config = {
	        vhMargin: vhMargin,
	        yMargin: yMargin,
	        elHeight: elHeight,
	        initialY: initialY,
	        containerRect: containerRect,
	        screenBottom: vh - vhMargin,
	        preventOverlap: preventOverlap,
	        disableSwapping: disableSwapping,
	        disableVHBounds: disableVHBounds,
	    };
	    switch (y) {
	        case "above":
	            return createAnchoredAbove(config);
	        case "top":
	            return createAnchoredTop(config);
	        case "center":
	            return createAnchoredCenter(config);
	        case "bottom":
	            return createAnchoredBottom(config);
	        case "below":
	            return createAnchoredBelow(config);
	    }
	}

	/**
	 * This is a simple util that'll generate a css `transform-origin` string so
	 * that the fixed element can animate from the correct point based on the
	 * provided anchor.
	 *
	 * @param anchor - The anchor that should be used to create the transform origin
	 * for.
	 * @returns the transform origin string
	 * @internal
	 */
	function getTransformOrigin(anchor) {
	    var x = "0";
	    switch (anchor.x) {
	        case "right":
	        case "inner-left":
	            x = "0";
	            break;
	        case "center":
	            x = "50%";
	            break;
	        case "left":
	        case "inner-right":
	            x = "100%";
	            break;
	        default:
	            x = "0";
	    }
	    var y = "0";
	    switch (anchor.y) {
	        case "above":
	        case "bottom":
	            y = "100%";
	            break;
	        case "center":
	            y = "50%";
	            break;
	        case "below":
	        case "top":
	            y = "0";
	            break;
	        default:
	            y = "0";
	    }
	    return "".concat(x, " ").concat(y);
	}

	/**
	 * This is used when there is no `container` element so that some styles can
	 * still be created. The main use-case for this is context menus and when the
	 * `initialX` and `initialY` options have been provided.
	 *
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var FALLBACK_DOM_RECT = {
	    x: 0,
	    y: 0,
	    height: 0,
	    width: 0,
	    left: 0,
	    right: 0,
	    top: 0,
	    bottom: 0,
	    toJSON: function () {
	        // do nothing
	    },
	};
	/**
	 * One of the most complicated functions in this project that will attempt to
	 * position an element relative to another container element while still being
	 * visible within the viewport. Below is the logical flow for attempting to fix
	 * the element to the container:
	 *
	 * No Container: If there is no container element, return the provided x and y
	 * positions and no styles since there's nothing we can use to calculate the
	 * position.
	 *
	 * No Element: If the container was provided but the element to position does
	 * not exist, return an style object containing the `left` and `top` values for
	 * the container and apply as many of the positioning options as possible so
	 * that the styles are "as close as possible" before the fixed element is added
	 * to the DOM. This will also return the provided x and y positions since
	 * nothing could be swapped around yet.
	 *
	 * Container and Element: If both the container and fixed element were provided,
	 * apply all the positioning options to the `left` and `top` values of the
	 * container based on the sizes of both elements.
	 *
	 * Now that the `left` and `top` values were applied, check to see if the
	 * element is fully visible within the viewport with the provided positioning
	 * options. If it is fully visible, do nothing else. If it isn't... follow the
	 * next flow:
	 *
	 * First, check the horizontal sizes and make sure that the element is still
	 * within the viewport with the provided viewwidth margin. If it isn't, first
	 * try to swap only to a `right` style instead of left to see if that fixes it,
	 * otherwise keep both the `left` and `right` styles.
	 */
	function getFixedPosition(_a) {
	    var _b;
	    var container = _a.container, element = _a.element, _c = _a.anchor, anchor = _c === void 0 ? BELOW_CENTER_ANCHOR : _c, initialX = _a.initialX, initialY = _a.initialY, _d = _a.vwMargin, vwMargin = _d === void 0 ? 16 : _d, _e = _a.vhMargin, vhMargin = _e === void 0 ? 16 : _e, _f = _a.xMargin, xMargin = _f === void 0 ? 0 : _f, _g = _a.yMargin, yMargin = _g === void 0 ? 0 : _g, _h = _a.width, widthType = _h === void 0 ? "auto" : _h, _j = _a.preventOverlap, preventOverlap = _j === void 0 ? false : _j, _k = _a.transformOrigin, transformOrigin = _k === void 0 ? false : _k, _l = _a.disableSwapping, propDisableSwapping = _l === void 0 ? false : _l, _m = _a.disableVHBounds, disableVHBounds = _m === void 0 ? false : _m;
	    container = findSizingContainer(container);
	    if (!element) {
	        return {
	            actualX: anchor.x,
	            actualY: anchor.y,
	        };
	    }
	    var containerRect = (_b = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _b !== void 0 ? _b : FALLBACK_DOM_RECT;
	    var vh = getViewportSize("height");
	    var vw = getViewportSize("width");
	    var _o = getElementRect(element), height = _o.height, elWidth = _o.width;
	    if (disableVHBounds) {
	        var dialog = element.closest("[role='dialog']");
	        if (!dialog) {
	            initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;
	        }
	    }
	    var disableSwapping = propDisableSwapping || !container;
	    var _p = createHorizontalPosition({
	        x: anchor.x,
	        vw: vw,
	        vwMargin: vwMargin,
	        xMargin: xMargin,
	        width: widthType,
	        elWidth: elWidth,
	        initialX: initialX,
	        containerRect: containerRect,
	        disableSwapping: disableSwapping,
	    }), left = _p.left, right = _p.right, width = _p.width, minWidth = _p.minWidth, actualX = _p.actualX;
	    var _q = createVerticalPosition({
	        y: anchor.y,
	        vh: vh,
	        vhMargin: vhMargin,
	        yMargin: yMargin,
	        initialY: initialY,
	        elHeight: height,
	        containerRect: containerRect,
	        disableSwapping: disableSwapping,
	        preventOverlap: preventOverlap,
	        disableVHBounds: disableVHBounds,
	    }), top = _q.top, bottom = _q.bottom, actualY = _q.actualY;
	    return {
	        actualX: actualX,
	        actualY: actualY,
	        style: {
	            left: left,
	            top: top,
	            right: right,
	            bottom: bottom,
	            width: width,
	            minWidth: minWidth,
	            position: disableVHBounds ? "absolute" : "fixed",
	            transformOrigin: transformOrigin
	                ? getTransformOrigin({ x: actualX, y: actualY })
	                : undefined,
	        },
	    };
	}

	/**
	 * Attempts to scroll an element into view within another container element if
	 * needed.  If either the container or element are `null`, nothing will happen.
	 *
	 * @param container - The container element that should be scrolled if the child
	 * element is not within view.
	 * @param element - The element that should be visible within the container
	 * element's scroll area.
	 */
	function scrollIntoView(container, element) {
	    element = findSizingContainer(element);
	    if (!container || !element) {
	        return;
	    }
	    var offsetTop = element.offsetTop;
	    if (element.offsetParent !== container) {
	        offsetTop -= container.offsetTop;
	    }
	    var elementBottom = offsetTop + element.offsetHeight;
	    var containerBottom = container.offsetHeight + container.scrollTop;
	    if (elementBottom > containerBottom) {
	        container.scrollTop = elementBottom - container.offsetHeight;
	    }
	    else if (offsetTop < container.scrollTop) {
	        container.scrollTop = offsetTop;
	    }
	}

	/**
	 * This is a small util that is used to transform a search string with common
	 * patterns.
	 *
	 * @param value - The string to transform
	 * @param lowercase - Boolean if the value should be lowercased for
	 * case-insensitive searches
	 * @param trim - Boolean if the leading and trailing whitespace should be
	 * trimmed
	 * @param ignoreWhitespace - Boolean if all whitespace should be ignored. This
	 * will take precedence over the `trim` parameter if set to true.
	 * @returns The transformed search string
	 * @internal
	 */
	function getSearchString(value, lowercase, trim, ignoreWhitespace) {
	    if (lowercase === void 0) { lowercase = false; }
	    if (trim === void 0) { trim = false; }
	    if (ignoreWhitespace === void 0) { ignoreWhitespace = false; }
	    if (lowercase) {
	        value = value.toLowerCase();
	    }
	    if (ignoreWhitespace) {
	        value = value.replace(/\s/g, "");
	    }
	    else if (trim) {
	        value = value.trim();
	    }
	    return value;
	}
	/**
	 * The default implementation of the getItemValue search option that will
	 * attempt to "stringify" any unknown item as a string.
	 *
	 * @param item - The current item to transform
	 * @param valueKey - The key to use that should hold the value if the item is an
	 * object
	 * @returns the item as a string
	 * @internal
	 */
	function getItemValue(item, valueKey) {
	    if (valueKey === void 0) { valueKey = "value"; }
	    switch (typeof item) {
	        case "string":
	            return item;
	        case "number":
	            return Number.isNaN(item) ? "" : "".concat(item);
	        case "function":
	            return getItemValue(item(), valueKey);
	        case "object":
	            return item
	                ? getItemValue(item[valueKey], valueKey)
	                : "";
	        default:
	            return "";
	    }
	}
	var DEFAULT_GET_ITEM_VALUE = getItemValue;
	var DEFAULT_VALUE_KEY = "value";
	var DEFAULT_TRIM = true;
	var DEFAULT_IGNORE_WHITESPACE = false;
	var DEFAULT_SEARCH_RESET_TIME = 500;
	var DEFAULT_SEARCH_OPTIONS = {
	    getItemValue: DEFAULT_GET_ITEM_VALUE,
	    valueKey: DEFAULT_VALUE_KEY,
	    trim: DEFAULT_TRIM,
	    ignoreWhitespace: DEFAULT_IGNORE_WHITESPACE,
	};

	/**
	 * Filters a list by ensuring that all items contain the query string in order
	 * anywhere in it's own value.
	 *
	 * @param query - The current query string
	 * @param searchable - The list of searchable items that should be filtered
	 * @param options - All the search options to use
	 * @returns A filtered list of all the searchable items based on the query
	 * string.
	 */
	function caseInsensitiveFilter(query, searchable, options) {
	    if (options === void 0) { options = {}; }
	    var _a = defaults(options, DEFAULT_SEARCH_OPTIONS), getItemValue = _a.getItemValue, valueKey = _a.valueKey, trim = _a.trim, ignoreWhitespace = _a.ignoreWhitespace, _b = _a.startsWith, startsWith = _b === void 0 ? false : _b;
	    query = getSearchString(query, true, trim, ignoreWhitespace);
	    if (!query || !searchable.length) {
	        return searchable;
	    }
	    return searchable.filter(function (item) {
	        var value = getSearchString(getItemValue(item, valueKey), true, trim, ignoreWhitespace);
	        if (startsWith) {
	            return value.indexOf(query) === 0;
	        }
	        return value.indexOf(query) !== -1;
	    });
	}

	/**
	 * Creates an "amazing" regular expression that matches the letters in order and
	 * escapes any letters that could be part of a regex. This should normally be
	 * used in fuzzy filters or determining fuzzy matches.
	 *
	 * @param query - The query string to convert into a "fuzzy" regular expression
	 * @returns The "fuzzy" regular expression that can be used to determine
	 * matches.
	 */
	function getFuzzyRegExp(query) {
	    return new RegExp("".concat(query)
	        .split("")
	        .join("\\w*")
	        .replace(/(\(|\||\)|\\(?!w\*)|\[|\|-|\.|\^|\+|\$|\?|^(?!w)\*)/g, "\\$1")
	        // Couldn't get the matching of two '*' working, so replace them here..
	        .replace(/\*\*/g, "*\\*"), "i");
	}

	/**
	 * Filters a list by using a fuzzy search "algorithm" (huge double quotes on
	 * algorithm). The fuzzy search will just ensure that all the letters in the
	 * query string appear in-order for all the remaining items. However, the
	 * letters *do not need to be consecutive*.
	 *
	 * @param query - The current query string
	 * @param searchable - The list of searchable items that should be filtered
	 * @param options - All the search options to use
	 * @returns A filtered list of all the searchable items based on the query
	 * string.
	 */
	function fuzzyFilter(query, searchable, options) {
	    if (options === void 0) { options = {}; }
	    var _a = defaults(options, DEFAULT_SEARCH_OPTIONS), getItemValue = _a.getItemValue, valueKey = _a.valueKey, trim = _a.trim, ignoreWhitespace = _a.ignoreWhitespace;
	    query = getSearchString(query, false, trim, ignoreWhitespace);
	    if (!searchable.length || !query) {
	        return searchable;
	    }
	    var queryRegExp = getFuzzyRegExp(query);
	    return searchable.filter(function (item) {
	        var value = getSearchString(getItemValue(item, valueKey), false, trim, ignoreWhitespace);
	        return value.length && value.match(queryRegExp);
	    });
	}

	/**
	 * This is a simple `array.find` implementation that will work for any
	 * searchable item type and return the first item that starts with the current
	 * query string ignoring case.
	 *
	 * @param query - The current query string to use to match with
	 * @param searchable - The list of searchable items
	 * @param options - The additional search options available.
	 * @returns the found item in the searchable list or null
	 */
	function findIgnoreCase(query, searchable, options) {
	    if (options === void 0) { options = {}; }
	    var _a = defaults(options, DEFAULT_SEARCH_OPTIONS), getItemValue = _a.getItemValue, valueKey = _a.valueKey, trim = _a.trim, ignoreWhitespace = _a.ignoreWhitespace;
	    query = getSearchString(query, true, trim, ignoreWhitespace);
	    if (!query.length || !searchable.length) {
	        return null;
	    }
	    var found = searchable.find(function (item) {
	        var value = getSearchString(getItemValue(item, valueKey), true, trim, ignoreWhitespace);
	        return value.indexOf(query) === 0;
	    });
	    return typeof found === "number" ? found : found || null;
	}

	/**
	 * Creates a temporary value that gets reset every `x`ms back to the provided
	 * default value. This is useful when doing keyboard searching or other
	 * interactions.
	 *
	 * NOTE: This does not force a re-render when the value changes and instead uses
	 * a ref value instead.
	 *
	 * @typeParam T - the type for the value
	 * @param defaultValue - The default value to use. Each time the reset timeout
	 * is triggered, this value will be set again.
	 * @param resetTime - The amount of time before the value is reset back to the
	 * default value
	 */
	function useTempValue(defaultValue, resetTime) {
	    if (resetTime === void 0) { resetTime = 500; }
	    var value = require$$1.useRef(defaultValue);
	    var timeout = require$$1.useRef();
	    var resetValue = require$$1.useCallback(function () {
	        window.clearTimeout(timeout.current);
	        value.current = defaultValue;
	    }, [defaultValue]);
	    var setValue = require$$1.useCallback(function (nextValue) {
	        value.current = nextValue;
	        window.clearTimeout(timeout.current);
	        timeout.current = window.setTimeout(resetValue, resetTime);
	    }, [resetTime, resetValue]);
	    return [value, setValue, resetValue];
	}

	var __read$$ = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * Adds the accessibility functionality to search a list of items as the user
	 * types to trigger `aria-activedescendant` focus or manual DOM focus events.
	 */
	function useKeyboardSearch(_a) {
	    var items = _a.items, onChange = _a.onChange, onKeyDown = _a.onKeyDown, _b = _a.resetTime, resetTime = _b === void 0 ? DEFAULT_SEARCH_RESET_TIME : _b, searchIndex = _a.searchIndex, _c = _a.valueKey, valueKey = _c === void 0 ? DEFAULT_VALUE_KEY : _c, _d = _a.getItemValue, getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d, _e = _a.findMatchIndex, findMatchIndex$1 = _e === void 0 ? findMatchIndex : _e;
	    var _f = __read$$(useTempValue("", resetTime), 2), value = _f[0], setValue = _f[1];
	    var values = require$$1.useMemo(function () { return items.map(function (item) { return getItemValue(item, valueKey); }); }, [items, getItemValue, valueKey]);
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        var key = event.key, altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey;
	        if (altKey ||
	            ctrlKey ||
	            metaKey ||
	            key.length > 1 ||
	            (!value.current && key === " ")) {
	            // might need to change this later if other languages have non-meta keys
	            // that are more than 1 letter
	            return;
	        }
	        var nextValue = key;
	        if (value.current !== key) {
	            nextValue = "".concat(value.current).concat(key);
	        }
	        setValue(nextValue);
	        var index = findMatchIndex$1(nextValue, values, searchIndex, true);
	        // don't want to trigger change events if the search didn't match anything
	        // since you normally don't really care about failed matches
	        if (index === searchIndex || index === -1) {
	            return;
	        }
	        var data = {
	            index: index,
	            item: items[index],
	            items: items,
	            query: nextValue,
	            target: event.currentTarget,
	        };
	        onChange(data);
	    }, [
	        searchIndex,
	        findMatchIndex$1,
	        items,
	        onChange,
	        onKeyDown,
	        setValue,
	        value,
	        values,
	    ]);
	    return handleKeyDown;
	}

	var __assign$2$ = (undefined && undefined.__assign) || function () {
	    __assign$2$ = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2$.apply(this, arguments);
	};
	/**
	 * This component should be mounted near the top of your app as it will keep
	 * track of the current app size based on the provided breakpoint widths.
	 */
	function AppSizeListener(_a) {
	    var children = _a.children, onChange = _a.onChange, _b = _a.phoneMaxWidth, phoneMaxWidth = _b === void 0 ? DEFAULT_PHONE_MAX_WIDTH : _b, _c = _a.tabletMinWidth, tabletMinWidth = _c === void 0 ? DEFAULT_TABLET_MIN_WIDTH : _c, _d = _a.tabletMaxWidth, tabletMaxWidth = _d === void 0 ? DEFAULT_TABLET_MAX_WIDTH : _d, _e = _a.desktopMinWidth, desktopMinWidth = _e === void 0 ? DEFAULT_DESKTOP_MIN_WIDTH : _e, _f = _a.desktopLargeMinWidth, desktopLargeMinWidth = _f === void 0 ? DEFAULT_DESKTOP_LARGE_MIN_WIDTH : _f, _g = _a.defaultSize, defaultSize = _g === void 0 ? DEFAULT_APP_SIZE : _g;
	    var appSize = useAppSizeMedia({
	        phoneMaxWidth: phoneMaxWidth,
	        tabletMaxWidth: tabletMaxWidth,
	        tabletMinWidth: tabletMinWidth,
	        desktopMinWidth: desktopMinWidth,
	        desktopLargeMinWidth: desktopLargeMinWidth,
	        defaultSize: defaultSize,
	    });
	    var lastValue = require$$1.useRef(appSize);
	    require$$1.useEffect(function () {
	        // trigger the onChange prop on mount only if there is a difference between
	        // the defaultSize and the mounted size.
	        if (onChange &&
	            (defaultSize.isPhone !== appSize.isPhone ||
	                defaultSize.isTablet !== appSize.isTablet ||
	                defaultSize.isDesktop !== appSize.isDesktop ||
	                defaultSize.isLargeDesktop !== appSize.isLargeDesktop ||
	                defaultSize.isLandscape !== appSize.isLandscape)) {
	            onChange(appSize, defaultSize);
	        }
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    require$$1.useEffect(function () {
	        if (lastValue.current !== appSize) {
	            if (onChange) {
	                onChange(appSize, lastValue.current);
	            }
	            lastValue.current = appSize;
	        }
	    });
	    var value = require$$1.useMemo(function () { return (__assign$2$(__assign$2$({}, appSize), { __initialized: true })); }, [appSize]);
	    return (jsxRuntime.exports.jsx(AppSizeContext.Provider, __assign$2$({ value: value }, { children: children })));
	}

	/**
	 * This is a simple hook that will attach a throttled resize event listener when
	 * mounted, and detach when it unmounts.
	 *
	 * This hook only works for entire app resize events. If you are looking for
	 * specific element resize events, check out the `ResizeObserver` component or
	 * `useResizeObserver` hook instead.
	 */
	function useResizeListener(_a) {
	    var onResize = _a.onResize, options = _a.options, immediate = _a.immediate, _b = _a.enabled, enabled = _b === void 0 ? true : _b;
	    var callback = useRefCache(onResize);
	    require$$1.useEffect(function () {
	        if (!enabled) {
	            return;
	        }
	        var eventHandler = delegateEvent("resize", window, true, options);
	        var handler = function (event) { return callback.current(event); };
	        eventHandler.add(handler);
	        if (immediate && typeof window !== "undefined") {
	            window.dispatchEvent(new UIEvent("resize"));
	        }
	        return function () {
	            eventHandler.remove(handler);
	        };
	        // disabled since useRefCache for callback and don't want immediate to
	        // re-trigger it.
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [options, enabled]);
	}

	/**
	 * This is a simple component that will attach a throttled resize event listener
	 * when mounted, and detach when it unmounts.
	 *
	 * This component only works for entire app resize events. If you are looking
	 * for specific element resize events, check out the `ResizeObserver` component
	 * instead.
	 */
	function ResizeListener(_a) {
	    var onResize = _a.onResize, options = _a.options, _b = _a.immediate, immediate = _b === void 0 ? typeof window !== "undefined" : _b;
	    useResizeListener({ onResize: onResize, options: options, immediate: immediate, enabled: true });
	    return null;
	}

	/**
	 * A simple component that will render the children only when the app is
	 * considered in mobile mode via the `AppSizeContext`. A mobile view will be
	 * true for both phones and tablets.
	 */
	function MobileOnly(_a) {
	    var children = _a.children, _b = _a.fallback, fallback = _b === void 0 ? null : _b;
	    var _c = useAppSize(), isPhone = _c.isPhone, isTablet = _c.isTablet;
	    if (isPhone || isTablet) {
	        return children;
	    }
	    return fallback;
	}
	/**
	 * A simple component that will render the children only when the app is
	 * considered in phone mode via the `AppSizeContext`.
	 */
	function PhoneOnly(_a) {
	    var children = _a.children, _b = _a.fallback, fallback = _b === void 0 ? null : _b;
	    var isPhone = useAppSize().isPhone;
	    if (isPhone) {
	        return children;
	    }
	    return fallback;
	}
	/**
	 * A simple component that will render the children only when the app is
	 * considered in tablet mode via the `AppSizeContext`.
	 */
	function TabletOnly(_a) {
	    var children = _a.children, _b = _a.fallback, fallback = _b === void 0 ? null : _b;
	    var isTablet = useAppSize().isTablet;
	    if (isTablet) {
	        return children;
	    }
	    return fallback;
	}
	/**
	 * A simple component that will render the children only when the app is
	 * considered in desktop mode via the `AppSizeContext`.
	 */
	function DesktopOnly(_a) {
	    var children = _a.children, _b = _a.fallback, fallback = _b === void 0 ? null : _b;
	    var isDesktop = useAppSize().isDesktop;
	    if (isDesktop) {
	        return children;
	    }
	    return fallback;
	}

	var __read$_ = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$c = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * Creates a throttled version of a function so that it'll be called with
	 * trailing and leading calls. Since I always get this confused with `debounce`,
	 * here's a quick summary of the differences:
	 *
	 * - debounce will wait to call the function until it hasn't been called again
	 *   for the wait duration without trailing or leading calls. If it has the
	 *   trailing and leading calls, I can't figure out how it's different than
	 *   throttle.
	 * - throttle will be called each time it is available to be called.
	 *
	 * So debounce is great for things like auto-save features if you want to save
	 * whenever the user stops typing for a few seconds while throttle is good for
	 * things like sending an API request when the user is typing so that it isn't
	 * sent every keystroke, but every few letters. You _could_ also do debounce
	 * here, but it'll feel more "responsive" to the user when throttled.
	 *
	 * @param fn - The function that should be throttled
	 * @param wait - The number of milliseconds to wait before calling the function
	 * again
	 * @returns a throttled version of the function that'll return the last computed
	 * value if it was called again during the "wait" period.
	 */
	function throttle(fn, wait) {
	    var lastCalledTime = 0;
	    var timeout;
	    var result;
	    var args;
	    function trailingCall() {
	        lastCalledTime = Date.now();
	        timeout = undefined;
	        result = fn.apply(void 0, __spreadArray$c([], __read$_(args), false));
	    }
	    return function throttled() {
	        var nextArgs = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            nextArgs[_i] = arguments[_i];
	        }
	        args = nextArgs;
	        var now = Date.now();
	        var remaining = wait - (now - lastCalledTime);
	        if (remaining <= 0 || remaining > wait) {
	            lastCalledTime = now;
	            result = fn.apply(void 0, __spreadArray$c([], __read$_(args), false));
	        }
	        else if (!timeout) {
	            timeout = window.setTimeout(trailingCall, remaining);
	        }
	        return result;
	    };
	}

	/**
	 * A simple util to convert a unit that is using `px`, `em`, or `rem` to a
	 * number so that calculations can be made on that unit.
	 *
	 * @param unit - The unit to convert to a number
	 * @param element - The element to use to use for calculating `em`
	 * @returns the unit as a number
	 */
	function unitToNumber(unit, options) {
	    if (options === void 0) { options = {}; }
	    var _a = options.fontSizeFallback, fontSizeFallback = _a === void 0 ? 16 : _a, element = options.element;
	    if (typeof unit === "number") {
	        return unit;
	    }
	    var parsed = parseFloat(unit);
	    if (/px$/.test(unit)) {
	        return parsed;
	    }
	    if (typeof document === "undefined") {
	        return parsed * fontSizeFallback;
	    }
	    var rem = /rem$/.test(unit);
	    var el = document.documentElement;
	    if (!rem && element) {
	        el = element.parentElement || element;
	    }
	    var fontSize = parseFloat(window.getComputedStyle(el).fontSize || "".concat(fontSizeFallback, "px"));
	    return parsed * fontSize;
	}

	/**
	 * Gets the HTMLElement or null from a provided RefObject or HTMLElement/null
	 * @internal
	 */
	function getElement(element) {
	    if (!element) {
	        return null;
	    }
	    if (typeof element.current !== "undefined") {
	        return element.current;
	    }
	    return element;
	}
	/**
	 * Triggers a callback function when another element in the page is clicked that
	 * is outside of the provided element. This is generally used for closing
	 * temporary elements when something else within the page has been clicked.
	 *
	 * The callback will be provided the current `element` as well as the click
	 * target if additional logic should be applied before closing.
	 *
	 * @typeParam E - The type of element
	 */
	function useCloseOnOutsideClick(_a) {
	    var enabled = _a.enabled, element = _a.element, onOutsideClick = _a.onOutsideClick;
	    require$$1.useEffect(function () {
	        if (!enabled) {
	            return;
	        }
	        function handleClick(event) {
	            var target = event.target;
	            var el = getElement(element);
	            if (!containsElement(el, target)) {
	                onOutsideClick(el, target, containsElement);
	            }
	        }
	        window.addEventListener("click", handleClick);
	        return function () {
	            window.removeEventListener("click", handleClick);
	        };
	    }, [enabled, element, onOutsideClick]);
	}

	var __read$Z = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook can be used to implement simple drag-and-drop behavior for file
	 * uploads or special styles while dragging an element over a part of a page.
	 *
	 * @example
	 * Simple File
	 * ```ts
	 * const style: CSSProperties = {
	 *   border: '1px solid blue',
	 * };
	 *
	 * function Example(): ReactElement {
	 *   const { onDrop } = useFileUpload()
	 *   const [isOver, handlers] = useDropzone({
	 *     onDrop: (event) => {
	 *       // normally use the `onDrop` behavior from `useFileUpload` to upload
	 *       // files:
	 *       // onDrop(event);
	 *     }
	 *   });
	 *
	 *   return (
	 *     <div {...handlers} style={isOver ? style : {}}>
	 *       Drag and drop some files!
	 *       {isOver && <UploadSVGIcon />}
	 *     </div>
	 *   );
	 * }
	 * ```
	 *
	 * @see {@link useFileUpload} for a more complex example
	 * @param options - The {@link DropzoneHandlers} that can be merged with the
	 * default functionality.
	 * @returns the {@link DropzoneHookReturnValue}
	 * @remarks \@since 2.9.0
	 */
	function useDropzone(options) {
	    var propOnDragEnter = options.onDragEnter, propOnDragOver = options.onDragOver, propOnDragLeave = options.onDragLeave, propOnDrop = options.onDrop;
	    var _a = __read$Z(require$$1.useState(false), 2), isOver = _a[0], setOver = _a[1];
	    var onDragOver = require$$1.useCallback(function (event) {
	        propOnDragOver === null || propOnDragOver === void 0 ? void 0 : propOnDragOver(event);
	        event.preventDefault();
	        event.stopPropagation();
	        setOver(true);
	    }, [propOnDragOver]);
	    var onDragEnter = require$$1.useCallback(function (event) {
	        propOnDragEnter === null || propOnDragEnter === void 0 ? void 0 : propOnDragEnter(event);
	        event.preventDefault();
	        event.stopPropagation();
	        setOver(true);
	    }, [propOnDragEnter]);
	    var onDrop = require$$1.useCallback(function (event) {
	        propOnDrop === null || propOnDrop === void 0 ? void 0 : propOnDrop(event);
	        event.preventDefault();
	        event.stopPropagation();
	        setOver(false);
	    }, [propOnDrop]);
	    var onDragLeave = require$$1.useCallback(function (event) {
	        propOnDragLeave === null || propOnDragLeave === void 0 ? void 0 : propOnDragLeave(event);
	        event.preventDefault();
	        event.stopPropagation();
	        if (!event.target ||
	            event.currentTarget === event.target ||
	            !event.currentTarget.contains(event.target)) {
	            setOver(false);
	        }
	    }, [propOnDragLeave]);
	    return [
	        isOver,
	        {
	            onDragOver: onDragOver,
	            onDragEnter: onDragEnter,
	            onDrop: onDrop,
	            onDragLeave: onDragLeave,
	        },
	    ];
	}

	var __read$Y = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hooks provides an easy way to toggle a boolean flag for React
	 * components.  The main use case for this will be toggling the visibility of
	 * something. All the provided actions are guaranteed to never change.
	 *
	 * @param defaultToggled - Boolean if the visibility should be enabled first
	 * render.
	 * @returns an array containing the toggled state, an enable function, a disable
	 * function, a toggle function, and then a manual set toggle function.
	 */
	function useToggle(defaultToggled) {
	    var _a = __read$Y(require$$1.useState(defaultToggled), 2), toggled = _a[0], setToggled = _a[1];
	    var previous = useRefCache(toggled);
	    var enable = require$$1.useCallback(function () {
	        if (!previous.current) {
	            setToggled(true);
	        }
	        // disabled since useRefCache
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var disable = require$$1.useCallback(function () {
	        if (previous.current) {
	            setToggled(false);
	        }
	        // disabled since useRefCache
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var toggle = require$$1.useCallback(function () {
	        setToggled(function (prevVisible) { return !prevVisible; });
	    }, []);
	    return [toggled, enable, disable, toggle, setToggled];
	}

	var __read$X = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * Simple hook to use an interval with auto setup and teardown. The provided
	 * functions will be guaranteed to not change and are memoized.
	 *
	 * @param callback - The callback function to call
	 * @param delay - The time in milliseconds the timer should delay between
	 * executions of the callback function
	 * @param defaultRunning - Boolean if the interval should be started immediately
	 * @returns a list containing a boolean if the interval is running, function to
	 * start the interval, and a function to stop the interval.
	 */
	function useInterval(callback, delay, defaultRunning) {
	    if (defaultRunning === void 0) { defaultRunning = false; }
	    var ref = useRefCache(callback);
	    var _a = __read$X(useToggle(defaultRunning), 3), running = _a[0], start = _a[1], stop = _a[2];
	    require$$1.useEffect(function () {
	        if (!running) {
	            return;
	        }
	        var interval = window.setInterval(function () {
	            ref.current(stop);
	        }, delay);
	        return function () {
	            window.clearInterval(interval);
	        };
	        // disabled since useRefCache for the callback
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [delay, running, stop]);
	    return [running, start, stop];
	}

	var __read$W = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * Simple hook to use an timeout with auto setup and teardown. The provided
	 * functions will be guaranteed to not change and are memoized.
	 *
	 * @param cb - The callback function to call
	 * @param delay - The time in milliseconds the timer should delay between
	 * executions of the callback function
	 * @param defaultStarted - Boolean if the timeout should be started immediately.
	 * @returns a list containing a function to start the timeout, a function to
	 * stop the timeout, and a function to restart the timeout.
	 */
	function useTimeout(cb, delay, defaultStarted) {
	    if (defaultStarted === void 0) { defaultStarted = false; }
	    var cbRef = useRefCache(cb);
	    var delayRef = useRefCache(delay);
	    var timeoutRef = require$$1.useRef();
	    var _a = __read$W(useToggle(defaultStarted), 3), enabled = _a[0], start = _a[1], disable = _a[2];
	    var clearTimeout = require$$1.useCallback(function () {
	        window.clearTimeout(timeoutRef.current);
	        timeoutRef.current = undefined;
	    }, []);
	    /* eslint-disable react-hooks/exhaustive-deps */
	    // these are all guaranteed to not change since using refs or non-updating
	    // callbacks
	    var restart = require$$1.useCallback(function () {
	        clearTimeout();
	        timeoutRef.current = window.setTimeout(function () {
	            cbRef.current();
	            disable();
	        }, delayRef.current);
	    }, []);
	    var stop = require$$1.useCallback(function () {
	        clearTimeout();
	        disable();
	    }, []);
	    require$$1.useEffect(function () {
	        if (!enabled) {
	            return;
	        }
	        timeoutRef.current = window.setTimeout(function () {
	            cbRef.current();
	            disable();
	        }, delay);
	        return function () {
	            clearTimeout();
	        };
	    }, [enabled, delay, disable]);
	    return [start, stop, restart];
	}

	var FOCUSABLE_ELEMENTS = ["BUTTON", "TEXTAREA", "SELECT"];
	var BASE_FOCUSABLE_ELEMENTS = 'a[href],area[href],input:not([disabled]):not([type="hidden"])';
	var BASE_FOCUSABLE_QUERY = FOCUSABLE_ELEMENTS.reduce(function (queryString, element) { return "".concat(queryString, ",").concat(element, ":not([disabled])"); }, BASE_FOCUSABLE_ELEMENTS);
	/**
	 * A query selector to find elements that are programmatically focusable.
	 *
	 * Example:
	 *
	 * ```ts
	 * const focusableElements = document.querySelectorAll(PROGRAMATICALLY_FOCUSABLE);
	 * // do something with elements
	 * ```
	 */
	var PROGRAMATICALLY_FOCUSABLE = "".concat(BASE_FOCUSABLE_QUERY, ",[tabindex]");
	/**
	 * A query selector to find elements that are focusable only with tab and shift+tab.
	 *
	 * Example:
	 *
	 * ```ts
	 * const focusableElements = document.querySelectorAll(TAB_FOCUSABLE);
	 * // do something with elements
	 * ```
	 */
	var TAB_FOCUSABLE = "".concat(PROGRAMATICALLY_FOCUSABLE, ":not([tabindex=\"-1\"])");

	var removeWhitespace = function (s) { return s.replace(/\s/g, ""); };
	/**
	 * The default function used to extract the text from nodes. This will just
	 * return the textContent by default unless the node has a react-md FontIcon as
	 * a child. If there is a FontIcon child, the node will be cloned without the
	 * FontIcon to return the textContent instead. This is because the FontIcon's
	 * text content would also be returned from the node's text content.
	 *
	 * @param stringOrElement - Either a string or an element element to convert
	 * @param fontIconQuerySelector - A string to use for finding font icons in the
	 * HTML Element. When this is set to the empty string, the element will not be
	 * checked for font icons which _might_ be a slight performance boost if you are
	 * guaranteed to not use font icons
	 */
	function extractTextContent(stringOrElement, fontIconQuerySelector) {
	    if (fontIconQuerySelector === void 0) { fontIconQuerySelector = ".rmd-icon--font"; }
	    if (typeof stringOrElement === "string") {
	        return removeWhitespace(stringOrElement);
	    }
	    if (fontIconQuerySelector) {
	        var fontIcons = Array.from(stringOrElement.querySelectorAll(fontIconQuerySelector));
	        if (fontIcons.some(function (i) { return !!i.textContent; })) {
	            var cloned = stringOrElement.cloneNode(true);
	            var icon = void 0;
	            do {
	                icon = cloned.querySelector(fontIconQuerySelector);
	                if (icon && icon.parentNode) {
	                    icon.parentNode.removeChild(icon);
	                }
	            } while (icon);
	            return removeWhitespace(cloned.textContent || "");
	        }
	    }
	    return removeWhitespace(stringOrElement.textContent || "");
	}

	/**
	 * A simple util that will find all the tab focusable elements within a
	 * container element.  The container should normally be a specific HTMLElement,
	 * but it can also be the entire document if you want to find **all** focusable
	 * elements within your page.
	 *
	 * @param container - The container element/document to find focusable elements
	 * within.
	 * @param programatic - Boolean if programatically focusable elements should be
	 * included instead of only tab focusable.
	 * @returns A list of HTMLElements that are focusable within the container.
	 */
	function getFocusableElements(container, programatic) {
	    if (programatic === void 0) { programatic = false; }
	    return Array.from(container.querySelectorAll(programatic ? PROGRAMATICALLY_FOCUSABLE : TAB_FOCUSABLE));
	}

	/**
	 * Checks if an element is focusable.
	 *
	 * @see {@link ElementFocusType}
	 * @remarks \@since 2.8.0
	 * @param element - The element to check
	 * @param type - The focus type to compare against
	 * @returns true if the element is focusable
	 */
	function isFocusable(element, type) {
	    if (type === void 0) { type = "programmatic"; }
	    return ("matches" in element &&
	        element.matches(type === "programmatic" ? PROGRAMATICALLY_FOCUSABLE : TAB_FOCUSABLE));
	}

	var __read$V = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * A function that is used to focus an element within the provided node.  This
	 * can either focus the first, last, or a querySelector found element.
	 *
	 * @param container - Either an HTMLElement or the document to focus an element
	 * within.
	 * @param focus - Either the "first" or "last" string to focus the first or last
	 * focusable element within the container or a query selector string to find a
	 * focusable element within the container.
	 * @param programmatic - Boolean if programmatically focusable elements should be
	 * included as well.
	 * @param preventScroll - Boolean if the focus event should not scroll the
	 * element into view. This should normally remain `false`, but can be useful if
	 * the element gets focused while offscreen during a transition.
	 * @param elements - Optional child elements to search
	 * @remarks \@since 2.8.0 Supports focusing the container element if it is
	 * focusable
	 */
	function focusElementWithin(container, focus, programmatic, preventScroll, elements) {
	    var _a;
	    if (programmatic === void 0) { programmatic = false; }
	    if (preventScroll === void 0) { preventScroll = false; }
	    if (!elements || !elements.length) {
	        elements = getFocusableElements(container, programmatic);
	    }
	    var el;
	    switch (focus) {
	        case "first":
	            _a = __read$V(elements, 1), el = _a[0];
	            break;
	        case "last":
	            el = elements[elements.length - 1];
	            break;
	        default:
	            el = container.querySelector(focus);
	    }
	    // just allow any focusable-type element
	    if (!el && isFocusable(container, "programmatic")) {
	        el = container;
	    }
	    if (!el) {
	        throw new Error("Unable to find a focusable element");
	    }
	    el.focus({ preventScroll: preventScroll });
	    if (!preventScroll && container !== document) {
	        scrollIntoView(container, el);
	    }
	}

	/**
	 * Simple private util to get the DOM "instance" from either a ref object or an
	 * HTMLElement.
	 *
	 * @param refOrInstance - The ref or instance to get an HTMLElement from
	 * @returns The HTMLElement or null.
	 * @internal
	 */
	function getInstance(refOrInstance) {
	    var instance = null;
	    if (refOrInstance) {
	        if (refOrInstance instanceof HTMLElement) {
	            instance = refOrInstance;
	        }
	        else {
	            instance = refOrInstance.current;
	        }
	    }
	    return instance;
	}

	/**
	 * This hook is used to focus an element once a component has mounted. To help
	 * with keyboard click events, it will actually wait for an animation frame
	 * before attempting to focus as an enter key might click both elements at the
	 * same time.
	 *
	 * This hook will first focus the HTMLElement (if it is focusable) and then
	 * focus an element based on the defaultFocus prop.
	 *
	 * @param refOrInstance - This is either a ref object containing the element to
	 * focus or the element itself.
	 * @param defaultFocus - The element to focus within the containing element once
	 * it has been mounted. This can either be "first" or "last" to focus the first
	 * or last focusable elements or a query selector string to find an element to
	 * focus.
	 * @param preventScroll - Boolean if the focus events should try to prevent the
	 * default scroll-into-view behavior. This is generally recommended to be kept
	 * as `false`, but can be useful to enable if the component mounts offscreen
	 * during a transition.
	 * @param programmatic - Boolean if programmatically focusable elements should be
	 * included instead of only tab focusable.
	 * @param disabled - Boolean if the focus behavior should be disabled.
	 */
	function useFocusOnMount(refOrInstance, defaultFocus, preventScroll, programmatic, disabled) {
	    if (preventScroll === void 0) { preventScroll = false; }
	    if (programmatic === void 0) { programmatic = false; }
	    if (disabled === void 0) { disabled = false; }
	    require$$1.useEffect(function () {
	        if (disabled) {
	            return;
	        }
	        var frame = window.requestAnimationFrame(function () {
	            var instance = getInstance(refOrInstance);
	            if (!instance) {
	                return;
	            }
	            instance.focus({ preventScroll: preventScroll });
	            focusElementWithin(instance, defaultFocus, programmatic, preventScroll);
	        });
	        return function () {
	            window.cancelAnimationFrame(frame);
	        };
	    }, [defaultFocus, disabled, refOrInstance, programmatic, preventScroll]);
	}

	/**
	 * This hook is used to focus the previous element when a component unmounts.
	 * The default behavior is to store the current activeElement within the
	 * document when the component mounts and then try to focus it again when the
	 * component unmounts.  You can also provide your own HTMLElement to focus when
	 * unmounting.
	 *
	 * During the unmount phase, it will wait for an animation frame before checking
	 * if the fallback element still exists within the page. If it doesn't, it will
	 * use the fallback query/element/function to attempt to find another element to
	 * focus. If the element exists within the page, it will then finally be
	 * focused.
	 *
	 * The animation frame is unfortunately required for keyboard users as pressing
	 * enter key will click the previous element immediately on focus as well.
	 *
	 * @param disabled - Boolean if the focus behavior should be disabled.
	 * @param fallback - The fallback query, element, or function to use if the
	 * previous element no longer exists in the DOM.
	 * @param previousElement - An optional previous element to focus. If this is
	 * omitted, the `document.activeElement` will be used instead.
	 */
	function usePreviousFocus(disabled, fallback, previousElement) {
	    if (fallback === void 0) { fallback = undefined; }
	    if (previousElement === void 0) { previousElement = null; }
	    var options = require$$1.useRef({
	        disabled: disabled,
	        fallback: fallback,
	    });
	    require$$1.useEffect(function () {
	        options.current = {
	            disabled: disabled,
	            fallback: fallback,
	        };
	    });
	    require$$1.useEffect(function () {
	        if (disabled) {
	            return;
	        }
	        var element = previousElement || document.activeElement;
	        // i'll need to think of a better way to handle this flow. There's just a
	        // weird one where if going from a menu to a dialog, we get lost without
	        // specifying a fallback. So if we are in a menu, try to find the
	        // corresponding menu button for this flow to fallback to.
	        var menu = element.closest('[role="menu"]');
	        var menuButton = null;
	        if (menu) {
	            // first try to get the button by using the menu's id minus the trailing
	            // -menu since that's the normal pattern within react-md.
	            menuButton = document.getElementById(menu.id.replace(/-menu$/, ""));
	            if (!menuButton) {
	                // if no menu button, try to see if the `aria-labelledby` points to the
	                // button... but since the `aria-labelledby` is a space-delimitated
	                // string of ids, have to check each one
	                var labelledBy = menu.getAttribute("aria-labelledby") || "";
	                var query = labelledBy
	                    .split(" ")
	                    .map(function (id) { return "#".concat(id, "[tabindex]"); })
	                    .join(",");
	                menuButton = query ? document.querySelector(query) : null;
	            }
	        }
	        return function () {
	            var _a = options.current, fallback = _a.fallback, disabled = _a.disabled;
	            if (disabled) {
	                // this has been added just for support for scrolling menus out of view.
	                // It is not ideal since keyboard focus is lost at this point, but
	                // _technically_ shouldn't be able to reach this flow with keyboard
	                // movement
	                return;
	            }
	            if (menu &&
	                menuButton &&
	                !previousElement &&
	                !fallback &&
	                !document.contains(element) &&
	                document.contains(menuButton)) {
	                menuButton.focus();
	                return;
	            }
	            var el = element;
	            if (!document.contains(el)) {
	                el =
	                    previousElement && document.contains(previousElement)
	                        ? previousElement
	                        : null;
	            }
	            if (!el && fallback) {
	                switch (typeof fallback) {
	                    case "string":
	                        el = document.querySelector(fallback);
	                        break;
	                    case "function":
	                        el = fallback();
	                        break;
	                    default:
	                        el = fallback;
	                }
	            }
	            if (el && !document.contains(el)) {
	                el = null;
	            }
	            if (el) {
	                el.focus();
	            }
	        };
	        // disabled since useRefCache and don't wnt to update on disabled change
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	}

	/**
	 * Creates an `onKeyDown` event handler to trap keyboard focus within a
	 * container element.
	 *
	 * @typeParam E - The HTMLElement type that has the keydown event listener
	 * attached.
	 * @param options - All the options for handling tab focus wrapping.
	 * @returns The keydown event handler to enforce focus wrapping or the onKeyDown
	 * prop if this functionality is disabled.
	 */
	function useTabFocusWrap(_a) {
	    var _b = _a.disabled, disabled = _b === void 0 ? false : _b, _c = _a.disableFocusCache, disableFocusCache = _c === void 0 ? false : _c, onKeyDown = _a.onKeyDown;
	    var focusables = require$$1.useRef([]);
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        if (event.key !== "Tab") {
	            return;
	        }
	        if (disableFocusCache || !focusables.current.length) {
	            focusables.current = getFocusableElements(event.currentTarget);
	        }
	        var elements = focusables.current;
	        var l = elements.length;
	        if (l === 0) {
	            return;
	        }
	        if (l === 1) {
	            event.preventDefault();
	            elements[0].focus();
	        }
	        else if (elements[0] === event.target && event.shiftKey) {
	            event.preventDefault();
	            elements[l - 1].focus();
	        }
	        else if (elements[l - 1] === event.target && !event.shiftKey) {
	            event.preventDefault();
	            elements[0].focus();
	        }
	    }, [onKeyDown, disableFocusCache]);
	    return disabled ? onKeyDown : handleKeyDown;
	}

	var __assign$2_ = (undefined && undefined.__assign) || function () {
	    __assign$2_ = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2_.apply(this, arguments);
	};
	var __rest$2u = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$U = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * The `FocusContainer` is a wrapper for a few of the accessibility hooks to
	 * maintain focus within an element.
	 */
	var FocusContainer = require$$1.forwardRef(function FocusContainer(_a, forwardedRef) {
	    var children = _a.children, onKeyDown = _a.onKeyDown, _b = _a.component, Component = _b === void 0 ? "div" : _b, _c = _a.defaultFocus, defaultFocus = _c === void 0 ? "first" : _c, _d = _a.disableFocusCache, disableFocusCache = _d === void 0 ? false : _d, _e = _a.disableFocusOnMount, disableFocusOnMount = _e === void 0 ? false : _e, _f = _a.disableFocusOnMountScroll, disableFocusOnMountScroll = _f === void 0 ? false : _f, _g = _a.disableFocusOnUnmount, disableFocusOnUnmount = _g === void 0 ? false : _g, _h = _a.disableTabFocusWrap, disableTabFocusWrap = _h === void 0 ? false : _h, _j = _a.unmountFocusFallback, unmountFocusFallback = _j === void 0 ? "" : _j, props = __rest$2u(_a, ["children", "onKeyDown", "component", "defaultFocus", "disableFocusCache", "disableFocusOnMount", "disableFocusOnMountScroll", "disableFocusOnUnmount", "disableTabFocusWrap", "unmountFocusFallback"]);
	    var _k = __read$U(useEnsuredRef(forwardedRef), 2), ref = _k[0], refHandler = _k[1];
	    usePreviousFocus(disableFocusOnUnmount, unmountFocusFallback);
	    useFocusOnMount(ref, defaultFocus, disableFocusOnMountScroll, false, disableFocusOnMount);
	    var handleKeyDown = useTabFocusWrap({
	        disabled: disableTabFocusWrap,
	        disableFocusCache: disableFocusCache,
	        onKeyDown: onKeyDown,
	    });
	    return (jsxRuntime.exports.jsx(Component, __assign$2_({}, props, { onKeyDown: handleKeyDown, ref: refHandler }, { children: children })));
	});

	/**
	 * The currently supported keyboard movement key combinations that increment or
	 * decrement within a list. This was extracted from the w3.org website about
	 * wia-aria best practices.
	 *
	 * @see https://www.w3.org/TR/wai-aria-practices/
	 */
	exports.IncrementMovementKey = void 0;
	(function (IncrementMovementKey) {
	    IncrementMovementKey["ArrowUp"] = "ArrowUp";
	    IncrementMovementKey["ArrowDown"] = "ArrowDown";
	    IncrementMovementKey["ArrowLeft"] = "ArrowLeft";
	    IncrementMovementKey["ArrowRight"] = "ArrowRight";
	    IncrementMovementKey["PageDown"] = "PageDown";
	    IncrementMovementKey["PageUp"] = "PageUp";
	    IncrementMovementKey["ShiftArrowUp"] = "Shift+ArrowUp";
	    IncrementMovementKey["ShiftArrowDown"] = "Shift+ArrowDown";
	    IncrementMovementKey["ShiftArrowLeft"] = "Shift+ArrowLeft";
	    IncrementMovementKey["ShiftArrowRight"] = "Shift+ArrowRight";
	    IncrementMovementKey["AltArrowDown"] = "Alt+ArrowDown";
	    IncrementMovementKey["AltArrowUp"] = "Alt+ArrowUp";
	    IncrementMovementKey["AltArrowLeft"] = "Alt+ArrowLeft";
	    IncrementMovementKey["AltArrowRight"] = "Alt+ArrowRight";
	    IncrementMovementKey["AltPageDown"] = "Alt+PageDown";
	    IncrementMovementKey["AltPageUp"] = "Alt+PageUp";
	    IncrementMovementKey["ControlArrowDown"] = "Control+ArrowDown";
	    IncrementMovementKey["ControlArrowUp"] = "Control+ArrowUp";
	})(exports.IncrementMovementKey || (exports.IncrementMovementKey = {}));
	/**
	 * The currently supported keyboard movement key combinations that jump to the
	 * start or end of a list.  This was extracted from the w3.org website about
	 * wai-aria best practices.
	 *
	 * @see https://www.w3.org/TR/wai-aria-practices/
	 */
	exports.JumpMovementKey = void 0;
	(function (JumpMovementKey) {
	    JumpMovementKey["Home"] = "Home";
	    JumpMovementKey["End"] = "End";
	    JumpMovementKey["AltHome"] = "Alt+Home";
	    JumpMovementKey["AltEnd"] = "Alt+End";
	    JumpMovementKey["ControlHome"] = "Control+Home";
	    JumpMovementKey["ControlEnd"] = "Control+End";
	    JumpMovementKey["ControlShiftHome"] = "Control+Shift+Home";
	    JumpMovementKey["ControlShiftEnd"] = "Control+Shift+End";
	})(exports.JumpMovementKey || (exports.JumpMovementKey = {}));

	var __assign$2Z = (undefined && undefined.__assign) || function () {
	    __assign$2Z = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2Z.apply(this, arguments);
	};
	/**
	 * A keyboard movement configuration preset for handling vertical menu
	 * movements.
	 */
	var VERTICAL_MENU = {
	    loopable: true,
	    searchable: true,
	    incrementKeys: [exports.IncrementMovementKey.ArrowDown],
	    decrementKeys: [exports.IncrementMovementKey.ArrowUp],
	    jumpToFirstKeys: [exports.JumpMovementKey.Home],
	    jumpToLastKeys: [exports.JumpMovementKey.End],
	};
	/**
	 * A keyboard movement configuration preset for handling horizontal menu
	 * movements.
	 */
	var HORIZONTAL_MENU = __assign$2Z(__assign$2Z({}, VERTICAL_MENU), { incrementKeys: [exports.IncrementMovementKey.ArrowRight], decrementKeys: [exports.IncrementMovementKey.ArrowLeft] });
	/**
	 * A keyboard movement configuration preset for handling vertical listbox
	 * movements.
	 */
	var VERTICAL_LISTBOX = __assign$2Z(__assign$2Z({}, VERTICAL_MENU), { loopable: false });
	/**
	 * A keyboard movement configuration preset for handling horizontal listbox
	 * movements.
	 */
	var HORIZONTAL_LISTBOX = __assign$2Z(__assign$2Z({}, HORIZONTAL_MENU), { loopable: false });
	/**
	 * A keyboard movement configuration preset for handling vertical combobox
	 * movements.
	 */
	var VERTICAL_COMBOBOX = {
	    incrementKeys: [exports.IncrementMovementKey.ArrowDown],
	    decrementKeys: [exports.IncrementMovementKey.ArrowUp],
	    // don't want to be able to jump since home and end should do default behavior
	    // in text field
	    jumpToFirstKeys: [],
	    jumpToLastKeys: [],
	    searchable: false,
	};
	/**
	 * A keyboard movement configuration preset for handling horizontal combobox
	 * movements.
	 */
	var HORIZONTAL_COMBOBOX = {
	    incrementKeys: [exports.IncrementMovementKey.ArrowRight],
	    decrementKeys: [exports.IncrementMovementKey.ArrowLeft],
	    // don't want to be able to jump since home and end should do default behavior
	    // in text field
	    jumpToFirstKeys: [],
	    jumpToLastKeys: [],
	    searchable: false,
	};
	var VERTICAL_TREE = {
	    incrementKeys: [exports.IncrementMovementKey.ArrowDown],
	    decrementKeys: [exports.IncrementMovementKey.ArrowUp],
	    jumpToFirstKeys: [exports.JumpMovementKey.Home, exports.JumpMovementKey.ControlShiftHome],
	    jumpToLastKeys: [exports.JumpMovementKey.End, exports.JumpMovementKey.ControlShiftEnd],
	    loopable: true,
	    searchable: true,
	};
	var HORIZONTAL_TREE = {
	    incrementKeys: [exports.IncrementMovementKey.ArrowRight],
	    decrementKeys: [exports.IncrementMovementKey.ArrowLeft],
	    jumpToFirstKeys: [exports.JumpMovementKey.Home, exports.JumpMovementKey.ControlShiftHome],
	    jumpToLastKeys: [exports.JumpMovementKey.End, exports.JumpMovementKey.ControlShiftEnd],
	    loopable: true,
	    searchable: true,
	};
	var HORIZONTAL_TABS = {
	    incrementKeys: [exports.IncrementMovementKey.ArrowRight],
	    decrementKeys: [exports.IncrementMovementKey.ArrowLeft],
	    jumpToFirstKeys: [exports.JumpMovementKey.Home],
	    jumpToLastKeys: [exports.JumpMovementKey.End],
	    loopable: true,
	    searchable: false,
	};
	var VERTICAL_TABS = {
	    incrementKeys: [exports.IncrementMovementKey.ArrowDown],
	    decrementKeys: [exports.IncrementMovementKey.ArrowUp],
	    jumpToFirstKeys: [exports.JumpMovementKey.Home],
	    jumpToLastKeys: [exports.JumpMovementKey.End],
	    loopable: true,
	    searchable: false,
	};

	var presets = /*#__PURE__*/Object.freeze({
		__proto__: null,
		VERTICAL_MENU: VERTICAL_MENU,
		HORIZONTAL_MENU: HORIZONTAL_MENU,
		VERTICAL_LISTBOX: VERTICAL_LISTBOX,
		HORIZONTAL_LISTBOX: HORIZONTAL_LISTBOX,
		VERTICAL_COMBOBOX: VERTICAL_COMBOBOX,
		HORIZONTAL_COMBOBOX: HORIZONTAL_COMBOBOX,
		VERTICAL_TREE: VERTICAL_TREE,
		HORIZONTAL_TREE: HORIZONTAL_TREE,
		HORIZONTAL_TABS: HORIZONTAL_TABS,
		VERTICAL_TABS: VERTICAL_TABS
	});

	/**
	 * An extremely simple function that is used to generate an id for an item
	 * within a list of other items.  This is generally used with list of items that
	 * should have custom focus with the `aria-activedescendant` flow instead of
	 * native focus.
	 *
	 * @param id - The base id for the container element of all the items.
	 * @param i - The index of the item within the list. This number will be
	 * incremented by 1 as an id to start from 1 instead of 0.
	 */
	function getItemId(id, i) {
	    if (!id) {
	        throw new Error("The id must be a string with a length greater than 0");
	    }
	    if (i < 0) {
	        throw new RangeError("The provided index must be greater than 0");
	    }
	    return "".concat(id, "-item-").concat(i + 1);
	}
	/**
	 * A small util function to transform a list of key codes into a list of
	 * `KeyConfig` objects. This is useful for how I determine what behavior to
	 * implement after a keydown event.
	 *
	 * @param keys - A list of key mappings to convert to a key object. These should
	 * be things like: "Tab", "Alt+Home", "A", "Shift+Alt+ArrowUp"
	 * @param type - The keyboard focus type this key should be mapped to
	 * @internal
	 */
	function transformKeys(keys, type) {
	    return keys.map(function (key) { return ({
	        shiftKey: key.includes("Shift+"),
	        metaKey: key.includes("Meta+"),
	        ctrlKey: key.includes("Control+"),
	        altKey: key.includes("Alt+"),
	        key: key.replace(/(Shift|Meta|Alt|Control)\+/g, ""),
	        type: type,
	    }); });
	}
	/**
	 * A small util get the `KeyConfig` based on the provided keys and keyboard
	 * event. This ensures that the key, altKey, metaKey, and shiftKey values all
	 * match.
	 *
	 * If a key is not found, `null` will be returned instead.
	 *
	 * @param event - The event to get a key mapping type for
	 * @param keys - A list of key mappings to attempt to find a valid key event
	 * type from.
	 * @internal
	 */
	function getKeyboardConfig(event, keys) {
	    var key = event.key, altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey, shiftKey = event.shiftKey;
	    return (keys.find(function (k) {
	        return k.key === key &&
	            k.altKey === altKey &&
	            k.ctrlKey === ctrlKey &&
	            k.metaKey === metaKey &&
	            k.shiftKey === shiftKey;
	    }) || null);
	}
	/**
	 * Creates a stringified representation of the configuration so that the config
	 * can be checked in the `onChange` callback for keyboard movement. This is used
	 * as the `query` attribute on the change data.
	 *
	 * @param config - The key config to stringify
	 * @internal
	 */
	function getStringifiedKeyConfig(config) {
	    var key = config.key, altKey = config.altKey, ctrlKey = config.ctrlKey, metaKey = config.metaKey, shiftKey = config.shiftKey, type = config.type;
	    var suffix = [
	        metaKey && "Meta",
	        ctrlKey && "Control",
	        shiftKey && "Shift",
	        altKey && "Alt",
	        key,
	    ]
	        .filter(Boolean)
	        .join("+");
	    return "".concat(type, "-").concat(suffix);
	}

	var __read$T = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$b = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * This is a low-level hook for providing custom keyboard movement based on key
	 * configurations.  This normally shouldn't really be used externally since
	 * you'll most likely want to use the "presets" of `useFocusMovement` and
	 * `useActiveDescendantMovement` that implement the main movement types already
	 * for you.
	 *
	 * The way this works is that it will general a list of mutable item refs that
	 * should be applied to each DOM node for the corresponding `item` within the
	 * `items` list. This list will change and regenerate itself each time the
	 * `items` array changes so it'll always be in-sync with the DOM nodes. This
	 * means that if you have some items that **should not be rendered**, they
	 * should not be included within the items list. The main reason these item refs
	 * are required is so that the `aria-activedescendant` movement can scroll the
	 * new "focused" element into view if needed while the "true" focus movement can
	 * trigger a `ref.current.focus()` on the new item as needed.
	 *
	 * Finally, this will create a keydown event handler that will merge in the
	 * optionally provided `onKeyDown` prop and check if the pressed key should
	 * trigger a custom keyboard movement event.  If it does, an `onChange` event
	 * will be fired with the matching data and allows for custom movement with
	 * `target.focus()` or updating the `aria-activedescendant` attribute as needed.
	 *
	 * @typeParam D - The type of each data item within the items list.
	 * @typeParam CE - The HTMLElement type of the container element that handles
	 * the custom keyboard movement.
	 * @typeParam IE - The HTMLElement type of each item within the container
	 * element that can be focusable.
	 */
	function useKeyboardMovement(_a) {
	    var onKeyDown = _a.onKeyDown, incrementKeys = _a.incrementKeys, decrementKeys = _a.decrementKeys, jumpToFirstKeys = _a.jumpToFirstKeys, jumpToLastKeys = _a.jumpToLastKeys, _b = _a.stopPropagation, stopPropagation = _b === void 0 ? true : _b, onChange = _a.onChange, items = _a.items, resetTime = _a.resetTime, findMatchIndex = _a.findMatchIndex, focusedIndex = _a.focusedIndex, _c = _a.loopable, loopable = _c === void 0 ? true : _c, _d = _a.searchable, searchable = _d === void 0 ? true : _d, _e = _a.valueKey, valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e, _f = _a.getItemValue, getItemValue = _f === void 0 ? DEFAULT_GET_ITEM_VALUE : _f;
	    var keys = require$$1.useMemo(function () { return __spreadArray$b(__spreadArray$b(__spreadArray$b(__spreadArray$b([], __read$T(transformKeys(incrementKeys, "increment")), false), __read$T(transformKeys(decrementKeys, "decrement")), false), __read$T(transformKeys(jumpToFirstKeys, "first")), false), __read$T(transformKeys(jumpToLastKeys, "last")), false); }, [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]);
	    var itemRefs = require$$1.useMemo(function () { return Array.from(items, function () { return ({ current: null }); }); }, [items]);
	    var handleSearch = useKeyboardSearch({
	        items: items,
	        valueKey: valueKey,
	        getItemValue: getItemValue,
	        onChange: function (data) {
	            onChange(data, itemRefs);
	        },
	        searchIndex: focusedIndex,
	        resetTime: resetTime,
	        findMatchIndex: findMatchIndex,
	    });
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        if (searchable) {
	            handleSearch(event);
	        }
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        var target = event.target;
	        var keyConfig = getKeyboardConfig(event, keys);
	        if (!keyConfig || !target) {
	            return;
	        }
	        // implementing custom behavior, so prevent default of scrolling or other
	        // things
	        event.preventDefault();
	        if (stopPropagation) {
	            event.stopPropagation();
	        }
	        var type = keyConfig.type;
	        var lastIndex = items.length - 1;
	        var index;
	        switch (type) {
	            case "first":
	                index = 0;
	                break;
	            case "last":
	                index = lastIndex;
	                break;
	            default:
	                index = loop({
	                    value: focusedIndex,
	                    max: lastIndex,
	                    increment: type === "increment",
	                    minmax: !loopable,
	                });
	        }
	        if (index === focusedIndex) {
	            return;
	        }
	        var data = {
	            index: index,
	            item: items[index],
	            items: items,
	            query: getStringifiedKeyConfig(keyConfig),
	            target: event.currentTarget,
	        };
	        onChange(data, itemRefs);
	    }, [
	        onKeyDown,
	        stopPropagation,
	        focusedIndex,
	        keys,
	        items,
	        handleSearch,
	        loopable,
	        searchable,
	        onChange,
	        itemRefs,
	    ]);
	    return [itemRefs, handleKeyDown];
	}

	var __assign$2Y = (undefined && undefined.__assign) || function () {
	    __assign$2Y = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2Y.apply(this, arguments);
	};
	var __rest$2t = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$S = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook allows for custom keyboard "focus" movement using the
	 * `aria-activedescendant` movement pattern. This is generally used when the DOM
	 * focus shouldn't actually change from the container element (like listboxes)
	 * but you still need to indicate that another element is "focused" due to a key
	 * press.
	 *
	 * To use this hook, you'll want to update the container element of all the
	 * items to have an `aria-activedescendant={activeId}` attribute and
	 * `onKeyDown={onKeyDown}` that are provided by this hook. The
	 * `aria-activedescendant` will help screen readers known what element is
	 * "focused" since the container element should never really lose focus during
	 * these keyboard movement events.  Finally, you'll want to update each item
	 * have an id that is the result of `getItem(baseId, index)` so that it matches
	 * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.
	 * Unfortunately, this means that all the child items **must** either be an
	 * HTMLElement or the ref is forwarded down to the HTMLElement.
	 *
	 * The `itemRefs` **must** be applied so that a new "focused" item can be
	 * scrolled into view as needed.
	 *
	 * @typeParam D - The type of each data item within the items list.
	 * @typeParam CE - The HTMLElement type of the container element that handles
	 * the custom keyboard movement.
	 * @typeParam IE - The HTMLElement type of each item within the container
	 * element that can be focusable.
	 */
	function useActiveDescendantMovement(_a) {
	    var baseId = _a.baseId, _b = _a.getId, getId = _b === void 0 ? getItemId : _b, _c = _a.defaultFocusedIndex, defaultFocusedIndex = _c === void 0 ? -1 : _c, items = _a.items, onChange = _a.onChange, _d = _a.getItemValue, getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d, _e = _a.valueKey, valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e, onKeyDown = _a.onKeyDown, onEnter = _a.onEnter, onSpace = _a.onSpace, options = __rest$2t(_a, ["baseId", "getId", "defaultFocusedIndex", "items", "onChange", "getItemValue", "valueKey", "onKeyDown", "onEnter", "onSpace"]);
	    var _f = __read$S(require$$1.useState(defaultFocusedIndex), 2), focusedIndex = _f[0], setFocusedIndex = _f[1];
	    var activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : "";
	    var _g = __read$S(useKeyboardMovement(__assign$2Y(__assign$2Y({}, options), { valueKey: valueKey, getItemValue: getItemValue, focusedIndex: focusedIndex, items: items, onChange: function (data, itemRefs) {
	            if (onChange) {
	                onChange(data, itemRefs);
	            }
	            var index = data.index, target = data.target;
	            var item = itemRefs[index] && itemRefs[index].current;
	            if (item && target && target.scrollHeight > target.offsetHeight) {
	                scrollIntoView(target, item);
	            }
	            setFocusedIndex(index);
	        }, onKeyDown: function (event) {
	            if (onKeyDown) {
	                onKeyDown(event);
	            }
	            var ref = (itemRefs[focusedIndex] && itemRefs[focusedIndex].current) || null;
	            if (onEnter && event.key === "Enter") {
	                onEnter(focusedIndex, ref);
	            }
	            else if (onSpace && event.key === " ") {
	                event.preventDefault();
	                onSpace(focusedIndex, ref);
	            }
	        } })), 2), itemRefs = _g[0], handleKeyDown = _g[1];
	    return {
	        activeId: activeId,
	        itemRefs: itemRefs,
	        onKeyDown: handleKeyDown,
	        focusedIndex: focusedIndex,
	        setFocusedIndex: setFocusedIndex,
	    };
	}

	var __assign$2X = (undefined && undefined.__assign) || function () {
	    __assign$2X = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2X.apply(this, arguments);
	};
	var __rest$2s = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$R = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook allows for custom keyboard focus movement using DOM focus behavior
	 * by actually focusing each DOM node.
	 *
	 * To use this hook, you'll want to update the container element of all the
	 * items to have a correct `role` applied as well as the `onKeyDown` event
	 * handler provided by this hook. Then, you'll want to applied a
	 * `ref={itemRefs[i]}` for each item within the items list so that the DOM nodes
	 * can be focused as needed. Unfortunately, this means that all the child items
	 * **must** either be an HTMLElement or the ref is forwarded down to the
	 * HTMLElement.
	 *
	 * @typeParam D - The type of each data item within the items list.
	 * @typeParam CE - The HTMLElement type of the container element that handles
	 * the custom keyboard movement.
	 * @typeParam IE - The HTMLElement type of each item within the container
	 * element that can be focusable.
	 */
	function useFocusMovement(_a) {
	    var _b = _a.defaultFocusedIndex, defaultFocusedIndex = _b === void 0 ? -1 : _b, onChange = _a.onChange, options = __rest$2s(_a, ["defaultFocusedIndex", "onChange"]);
	    var _c = __read$R(require$$1.useState(defaultFocusedIndex), 2), focusedIndex = _c[0], setFocusedIndex = _c[1];
	    var _d = __read$R(useKeyboardMovement(__assign$2X(__assign$2X({}, options), { focusedIndex: focusedIndex, onChange: function (data, itemRefs) {
	            if (onChange) {
	                onChange(data, itemRefs);
	            }
	            var index = data.index;
	            if (index === -1) {
	                return;
	            }
	            var item = itemRefs[index] && itemRefs[index].current;
	            if (item) {
	                item.focus();
	            }
	            setFocusedIndex(index);
	        } })), 2), itemRefs = _d[0], handleKeyDown = _d[1];
	    require$$1.useEffect(function () {
	        if (defaultFocusedIndex === -1) {
	            return;
	        }
	        var item = itemRefs[defaultFocusedIndex] && itemRefs[defaultFocusedIndex].current;
	        if (item) {
	            item.focus();
	        }
	        // only want to trigger on mount
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    return [itemRefs, handleKeyDown];
	}

	/**
	 * The default  behavior when pressing the `"Enter"` key on a form control
	 * (`input`, `textarea`, `select`) is to submit the form that the form control
	 * is in. This util will try to polyfill this behavior for custom widgets that
	 * use are using a role to act as a form control.
	 *
	 * The way this works is:
	 * - Check if the `event.key` is the `"Enter"` key. Do nothing if it is not.
	 * - Call `event.preventDefault()` and `event.stopPropagation()` to prevent
	 *   other unwanted keyboard behavior
	 * - Check the event target to see if it is contained in a `<form>`
	 * - Try to find a submit button and click it by:
	 *   - First check with `form.querySelector('[type="submit"]')`
	 *   - Fallback to `document.querySelector('[type="submit"][form="{{FORM_ID}}"]')`
	 *     - submit buttons can be placed outside of the form and link it back using
	 *       the `form` attribute pointing to the id of the form
	 *
	 *
	 * The reason the submit button has to be found and clicked is because calling
	 * `form.submit()` won't actually fire any attached `form.onsubmit` event
	 * handlers. If you click the submit button though, the `form.onsubmit` handlers
	 * will be called correctly.
	 *
	 * @param event - The keyboard event that should attempt to submit the form when
	 * the enter key is pressed.
	 * @returns `true` if the `event.key` was the `"Enter"` key so that other
	 * keydown logic can be ignored.
	 * @remarks \@since 2.7.0
	 */
	function tryToSubmitRelatedForm(event) {
	    var _a, _b;
	    if (event.key !== "Enter") {
	        return false;
	    }
	    event.preventDefault();
	    event.stopPropagation();
	    /* istanbul ignore next */
	    var form = (_b = (_a = event.currentTarget) === null || _a === void 0 ? void 0 : _a.closest) === null || _b === void 0 ? void 0 : _b.call(_a, "form");
	    var submit = form === null || form === void 0 ? void 0 : form.querySelector('[type="submit"]');
	    if (!submit && (form === null || form === void 0 ? void 0 : form.id)) {
	        submit = document.querySelector("[type=\"submit\"][form=\"".concat(form.id, "\"]"));
	    }
	    submit === null || submit === void 0 ? void 0 : submit.click();
	    return true;
	}

	var __assign$2W = (undefined && undefined.__assign) || function () {
	    __assign$2W = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2W.apply(this, arguments);
	};
	var __rest$2r = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component offers no styles and probably shouldn't be used externally
	 * since it is just rendered by the `RadioGroup` component.
	 *
	 * @remarks \@since 2.7.0
	 */
	var RadioWidget = require$$1.forwardRef(function RadioGroupRadio(_a, ref) {
	    var checked = _a.checked, children = _a.children, props = __rest$2r(_a, ["checked", "children"]);
	    return (jsxRuntime.exports.jsx("span", __assign$2W({}, props, { "aria-checked": checked, ref: ref, role: "radio" }, { children: children })));
	});

	/**
	 * Small util to get the value from a {@link RadioItem}.
	 *
	 * @param value - {@link RadioItem}
	 * @returns the current string value of the radio item
	 * @remarks \@since 2.7.0
	 */
	function getRadioItemValue(value) {
	    return typeof value === "string" ? value : value.value;
	}
	/**
	 * This util will return the `style` object only if the `RadioItemValue` had a
	 * `style` property.
	 *
	 * @param item - {@link RadioItemStyleObject}
	 * @returns an optional style object to provide to the radio.
	 * @remarks \@since 2.7.0
	 */
	var defaultGetRadioStyle = function (item) { return item.style; };
	/**
	 * This util will return the `className` string only if the `RadioItemValue`
	 * had a `className` property.
	 *
	 * @param item - {@link RadioItemStyleObject}
	 * @returns an optional className to provide to the radio
	 * @remarks \@since 2.7.0
	 */
	var defaultGetRadioClassName = function (item) { return item.className; };

	var __assign$2V = (undefined && undefined.__assign) || function () {
	    __assign$2V = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2V.apply(this, arguments);
	};
	var __rest$2q = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$Q = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * The `RadioGroup` is a low-level component that does not provide any styles
	 * and instead only provides the accessibility required for a
	 * `role="radiogroup"` and rendering each `role="radio"` item.
	 *
	 * @remarks \@since 2.7.0
	 */
	var RadioGroup = require$$1.forwardRef(function RadioGroup(_a, ref) {
	    var id = _a.id, _b = _a.getRadioStyle, getRadioStyle = _b === void 0 ? defaultGetRadioStyle : _b, _c = _a.getRadioClassName, getRadioClassName = _c === void 0 ? defaultGetRadioClassName : _c, items = _a.items, currentValue = _a.value, onBlur = _a.onBlur, onFocus = _a.onFocus, onClick = _a.onClick, onChange = _a.onChange, onKeyDown = _a.onKeyDown, props = __rest$2q(_a, ["id", "getRadioStyle", "getRadioClassName", "items", "value", "onBlur", "onFocus", "onClick", "onChange", "onKeyDown"]);
	    var refs = items.map(function () { return require$$1.createRef(); });
	    var _d = __read$Q(require$$1.useState(false), 2), focused = _d[0], setFocused = _d[1];
	    var handleBlur = require$$1.useCallback(function (event) {
	        onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
	        setFocused(false);
	    }, [onBlur]);
	    var handleFocus = require$$1.useCallback(function (event) {
	        onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
	        setFocused(true);
	    }, [onFocus]);
	    var handleClick = require$$1.useCallback(function (event) {
	        var _a, _b;
	        onClick === null || onClick === void 0 ? void 0 : onClick(event);
	        /* istanbul ignore next: can't really happen */
	        var radio = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('[role="radio"]');
	        var index = radio
	            ? refs.findIndex(function (_a) {
	                var current = _a.current;
	                return radio === current;
	            })
	            : -1;
	        if (index !== -1) {
	            onChange(getRadioItemValue(items[index]));
	            /* istanbul ignore next: can't really happen */
	            (_b = refs[index].current) === null || _b === void 0 ? void 0 : _b.focus();
	        }
	    }, [onChange, onClick, refs, items]);
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        var _a, _b;
	        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
	        if (tryToSubmitRelatedForm(event)) {
	            return;
	        }
	        if (![" ", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
	            return;
	        }
	        /* istanbul ignore next: can't really happen */
	        var radio = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('[role="radio"]');
	        if (!radio) {
	            return;
	        }
	        event.preventDefault();
	        event.stopPropagation();
	        if (event.key === " ") {
	            radio.click();
	            return;
	        }
	        var increment = event.key === "ArrowRight" || event.key === "ArrowDown";
	        var index = refs.findIndex(function (_a) {
	            var current = _a.current;
	            return current === radio;
	        });
	        /* istanbul ignore next: can't really happen */
	        if (index !== -1) {
	            var nextIndex = loop({
	                value: index,
	                max: items.length - 1,
	                increment: increment,
	            });
	            (_b = refs[nextIndex].current) === null || _b === void 0 ? void 0 : _b.focus();
	            onChange(getRadioItemValue(items[nextIndex]));
	        }
	    }, [onChange, onKeyDown, refs, items]);
	    var focusable = require$$1.useMemo(function () { return items.some(function (value) { return getRadioItemValue(value) === currentValue; }); }, [currentValue, items]);
	    return (jsxRuntime.exports.jsx("span", __assign$2V({}, props, { id: id, ref: ref, role: "radiogroup", onBlur: handleBlur, onFocus: handleFocus, onClick: handleClick, onKeyDown: handleKeyDown, tabIndex: -1 }, { children: items.map(function (item, i) {
	            var props;
	            var value;
	            var checked = false;
	            var children;
	            var itemStyle;
	            var itemClassName;
	            if (typeof item === "string") {
	                value = item;
	                checked = currentValue === value;
	                children = value;
	                itemStyle = getRadioStyle({ index: i, checked: checked, value: item });
	                itemClassName = getRadioClassName({
	                    index: i,
	                    checked: checked,
	                    value: item,
	                });
	            }
	            else {
	                (value = item.value, children = item.children, props = __rest$2q(item, ["value", "children"]));
	                checked = currentValue === value;
	                itemStyle = getRadioStyle(__assign$2V({ index: i, checked: checked }, item));
	                itemClassName =
	                    getRadioClassName(__assign$2V({ index: i, checked: checked }, item)) || undefined;
	                if (typeof children === "undefined") {
	                    children = value;
	                }
	            }
	            return (require$$1.createElement(RadioWidget, __assign$2V({}, props, { key: value, id: "".concat(id, "-").concat(i + 1), ref: refs[i], style: itemStyle, className: itemClassName, checked: checked, tabIndex: checked || (!focused && !focusable) ? 0 : -1 }), children));
	        }) })));
	});

	/**
	 * This will conditionally close the dialog when the escape key is pressed.
	 *
	 * @param onRequestClose - The function to call to close the dialog.
	 * @param disabled - Boolean if the escape key functionality should be disabled
	 * @param onKeyDown - An optional keydown event handler to also call.
	 * @returns A keydown event handler
	 */
	function useCloseOnEscape(onRequestClose, disabled, onKeyDown) {
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        if (event.key === "Escape") {
	            onRequestClose();
	        }
	    }, [onKeyDown, onRequestClose]);
	    return disabled ? onKeyDown : handleKeyDown;
	}

	/**
	 * This is used with the `useScrollLock` effect to determine if the styles were
	 * applied by scroll locking or not in the cleanup stage.
	 */
	var DATA_RMD_NOSCROLL = "data-rmd-noscroll";
	/**
	 * This will enable scroll locking for the provided element. Scroll locking
	 * works by fixing the element within the page and hiding overflow for that
	 * element.
	 *
	 * @param element - Either the `<body>` tag or an element within the page to
	 * disable scroll for.
	 * @internal
	 * @remarks \@since 5.0.0 Renamed from `enable` to `enableScrollLock`.
	 */
	function enableScrollLock(element) {
	    element.style.overflow = "hidden";
	    element.setAttribute(DATA_RMD_NOSCROLL, "");
	}
	/**
	 * Attempts to disable the scroll locking behavior for an element. If the
	 * element does not have `data-rmd-noscroll`, it will not be modified. This is
	 * really just a safety catch to ensure that pre-existing styles aren't removed
	 * on accident.
	 *
	 * If the `data-rmd-noscroll` attribute exists, overflow style and the
	 * `data-rmd-noscroll` attribute will be removed.
	 *
	 * @param element - Either the `<body>` tag or an element within the page to
	 * disable scroll locking for.
	 * @internal
	 * @remarks \@since 5.0.0 Renamed from `disable` to `disableScrollLock`.
	 */
	function disableScrollLock(element) {
	    if (element.getAttribute(DATA_RMD_NOSCROLL) === null) {
	        return;
	    }
	    element.style.overflow = "";
	    element.removeAttribute(DATA_RMD_NOSCROLL);
	}
	/**
	 * A hook that is used to dynamically add scroll locking to an element. By
	 * default, this will use the main `<body>` tag for scroll locking, but a query
	 * selector string or an HTML element can also be used instead.
	 *
	 * @param enabled - Boolean if the scroll locking behavior should be enabled
	 * @param selectorOrElement - Either a query selector string, HTMLElement, or a
	 * function that returns an HTMLElement to apply scroll locking to.
	 */
	function useScrollLock(enabled, selectorOrElement) {
	    require$$1.useEffect(function () {
	        if (!enabled || typeof document === "undefined") {
	            return;
	        }
	        var element = null;
	        if (typeof selectorOrElement === "string") {
	            element = document.querySelector(selectorOrElement);
	        }
	        else if (typeof selectorOrElement === "function") {
	            element = selectorOrElement();
	        }
	        else if (selectorOrElement) {
	            element = selectorOrElement;
	        }
	        else {
	            element = document.body;
	        }
	        if (!element || element.getAttribute(DATA_RMD_NOSCROLL) !== null) {
	            return;
	        }
	        enableScrollLock(element);
	        return function () {
	            disableScrollLock(element);
	        };
	    }, [enabled, selectorOrElement]);
	}

	/**
	 * A simple util that will ensure that a number is within the optional min and
	 * max values.
	 *
	 * @param value - The number to ensure that is within the range
	 * @param min - The optional min value
	 * @param max - The optional max value
	 * @returns the updated value
	 * @remarks \@since 2.5.0
	 */
	function withinRange(value, min, max) {
	    var nextValue = value;
	    if (typeof min === "number") {
	        nextValue = Math.max(min, nextValue);
	    }
	    if (typeof max === "number") {
	        nextValue = Math.min(max, nextValue);
	    }
	    return nextValue;
	}

	var __assign$2U = (undefined && undefined.__assign) || function () {
	    __assign$2U = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2U.apply(this, arguments);
	};
	var __rest$2p = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$17 = bem("rmd-snackbar");
	var Snackbar = require$$1.forwardRef(function Snackbar(_a, ref) {
	    var _b;
	    var className = _a.className, children = _a.children, _c = _a.portal, portal = _c === void 0 ? false : _c, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, _d = _a.position, position = _d === void 0 ? "bottom" : _d, props = __rest$2p(_a, ["className", "children", "portal", "portalInto", "portalIntoId", "position"]);
	    return (jsxRuntime.exports.jsx(ConditionalPortal, __assign$2U({ portal: portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: jsxRuntime.exports.jsx("div", __assign$2U({}, props, { role: "status", ref: ref, className: cn(block$17((_b = {}, _b[position] = true, _b)), className) }, { children: children })) })));
	});

	var __rest$2o = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * @remarks \@since 4.0.0
	 * @internal
	 */
	function getTransitionTimeout(_a) {
	    var _b;
	    var timeout = _a.timeout, appear = _a.appear, enter = _a.enter, exit = _a.exit;
	    if (typeof timeout === "number") {
	        return {
	            appear: appear ? timeout : 0,
	            enter: enter ? timeout : 0,
	            exit: exit ? timeout : 0,
	        };
	    }
	    return {
	        appear: (appear && ((_b = timeout.appear) !== null && _b !== void 0 ? _b : timeout.enter)) || 0,
	        enter: (enter && timeout.enter) || 0,
	        exit: (exit && timeout.exit) || 0,
	    };
	}
	/**
	 * A small util that will find the max-height, padding-top, and padding-bottom
	 * for the provided element. This is really used to be able to transition the
	 * max-height value since `max-height: auto` does not transition. The only way
	 * to get transition is to change max-height values manually.
	 *
	 * @remarks \@since 4.0.0
	 * @internal
	 */
	function getElementSizing(element) {
	    var maxHeight;
	    var paddingTop;
	    var paddingBottom;
	    if (element) {
	        maxHeight = element.scrollHeight;
	        // clone the element (not deep) just to figure out it's padding without the
	        // inline styles applied
	        var cloned = element.cloneNode(false);
	        cloned.style.maxHeight = "";
	        cloned.style.padding = "";
	        cloned.style.paddingLeft = element.style.paddingLeft;
	        cloned.style.paddingRight = element.style.paddingRight;
	        cloned.style.visibility = "hidden";
	        var container = element.parentElement || document.body;
	        container.appendChild(cloned);
	        var style = window.getComputedStyle(cloned);
	        if (style.paddingTop) {
	            paddingTop = parseFloat(style.paddingTop);
	        }
	        if (style.paddingBottom) {
	            paddingBottom = parseFloat(style.paddingBottom);
	        }
	        container.removeChild(cloned);
	    }
	    return { maxHeight: maxHeight, paddingTop: paddingTop, paddingBottom: paddingBottom };
	}
	/**
	 * @remarks \@since 4.0.0
	 * @internal
	 */
	function getTransitionClassNames(_a) {
	    var classNames = _a.classNames, timeoutOptions = __rest$2o(_a, ["classNames"]);
	    var timeout = getTransitionTimeout(timeoutOptions);
	    if (typeof classNames === "string") {
	        var appear_1 = timeout.appear, enter_1 = timeout.enter, exit_1 = timeout.exit;
	        return {
	            appear: appear_1 ? "".concat(classNames, "--appear") : "",
	            appearActive: appear_1 ? "".concat(classNames, "--appear-active") : "",
	            appearDone: "",
	            enter: enter_1 ? "".concat(classNames, "--enter") : "",
	            enterActive: enter_1 ? "".concat(classNames, "--enter-active") : "",
	            enterDone: "",
	            exit: exit_1 ? "".concat(classNames, "--exit") : "",
	            exitActive: exit_1 ? "".concat(classNames, "--exit-active") : "",
	            exitDone: "",
	        };
	    }
	    var _b = classNames.enter, enter = _b === void 0 ? "" : _b, _c = classNames.enterActive, enterActive = _c === void 0 ? "" : _c, _d = classNames.enterDone, enterDone = _d === void 0 ? "" : _d, _e = classNames.exit, exit = _e === void 0 ? "" : _e, _f = classNames.exitActive, exitActive = _f === void 0 ? "" : _f, _g = classNames.exitDone, exitDone = _g === void 0 ? "" : _g, _h = classNames.appear, appear = _h === void 0 ? (timeout.appear && enter) || "" : _h, _j = classNames.appearActive, appearActive = _j === void 0 ? (timeout.appear && enterActive) || "" : _j, _k = classNames.appearDone, appearDone = _k === void 0 ? (timeout.appear && enterDone) || "" : _k;
	    return {
	        appear: appear,
	        appearActive: appearActive,
	        appearDone: appearDone,
	        enter: enter,
	        enterActive: enterActive,
	        enterDone: enterDone,
	        exit: exit,
	        exitActive: exitActive,
	        exitDone: exitDone,
	    };
	}
	/**
	 * @remarks \@since 4.0.0
	 * @internal
	 */
	function isWithinViewport(_a) {
	    var fixedElement = _a.fixedElement, fixedToElement = _a.fixedToElement;
	    var fixedElementRect = fixedElement.getBoundingClientRect();
	    var fixedToElementRect = fixedToElement.getBoundingClientRect();
	    var vh = getViewportSize("height");
	    var vw = getViewportSize("width");
	    var top = Math.min(fixedElementRect.top, fixedToElementRect.top);
	    var right = Math.max(fixedElementRect.right, fixedToElementRect.right);
	    var bottom = Math.max(fixedElementRect.bottom, fixedToElementRect.bottom);
	    var left = Math.min(fixedElementRect.left, fixedToElementRect.left);
	    return bottom >= 0 && top <= vh && right >= 0 && left <= vw;
	}

	var __read$P = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var INITIAL_STATE = {
	    appearing: false,
	    rendered: true,
	    stage: "exited",
	};
	/**
	 * You'll most likely want to use the {@link useCSSTransition} hook instead
	 * since this is just a low-level hook that can be used to transition using
	 * timeouts.
	 *
	 * @typeParam E - The HTMLElement type used or the ref required for the
	 * transition.
	 * @remarks \@since 4.0.0
	 */
	function useTransition(_a) {
	    var nodeRef = _a.nodeRef, timeout = _a.timeout, transitionIn = _a.transitionIn, _b = _a.reflow, reflow = _b === void 0 ? false : _b, _c = _a.temporary, temporary = _c === void 0 ? false : _c, _d = _a.appear, appear = _d === void 0 ? false : _d, _e = _a.enter, enter = _e === void 0 ? true : _e, _f = _a.exit, exit = _f === void 0 ? true : _f, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited;
	    var configuration = {
	        appear: appear,
	        timeout: getTransitionTimeout({ timeout: timeout, appear: appear, enter: enter, exit: exit }),
	        reflow: reflow,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExit: onExit,
	        onExiting: onExiting,
	        onExited: onExited,
	    };
	    var configurationRef = require$$1.useRef(configuration);
	    configurationRef.current = configuration;
	    var _g = __read$P(useEnsuredRef(nodeRef), 2), ref = _g[0], refCallback = _g[1];
	    var _h = __read$P(require$$1.useReducer(function reducer(state, action) {
	        var _a = configuration.timeout, appear = _a.appear, enter = _a.enter, exit = _a.exit;
	        var appearing = state.appearing;
	        switch (action) {
	            case "enter": {
	                var duration = appearing ? appear : enter;
	                return {
	                    stage: duration > 0 ? "enter" : "entered",
	                    rendered: true,
	                    appearing: appearing,
	                };
	            }
	            case "entering":
	            case "entered":
	                return {
	                    stage: action,
	                    rendered: true,
	                    appearing: appearing,
	                };
	            case "exit": {
	                var stage_1 = exit > 0 ? "exit" : "exited";
	                return {
	                    stage: stage_1,
	                    rendered: !temporary || stage_1 !== "exited",
	                    appearing: false,
	                };
	            }
	            case "exiting":
	            case "exited":
	                return {
	                    stage: action,
	                    rendered: true,
	                    appearing: false,
	                };
	            case "unmount":
	                return {
	                    stage: "exited",
	                    rendered: false,
	                    appearing: false,
	                };
	        }
	    }, INITIAL_STATE, function () {
	        return ({
	            appearing: appear && transitionIn,
	            rendered: !temporary || transitionIn,
	            stage: transitionIn && !appear ? "entered" : "exited",
	        });
	    }), 2), state = _h[0], dispatch = _h[1];
	    var appearing = state.appearing, rendered = state.rendered, stage = state.stage;
	    var isFirstRender = require$$1.useRef(true);
	    useIsomorphicLayoutEffect(function () {
	        var _a = configurationRef.current, appear = _a.appear, timeout = _a.timeout, reflow = _a.reflow, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited;
	        if (isFirstRender.current) {
	            isFirstRender.current = false;
	            if (appear && transitionIn) {
	                dispatch("enter");
	            }
	            return;
	        }
	        // Cancel any exiting/exited transitions and instead immediately start the
	        // enter transition
	        if (transitionIn && stage.startsWith("exit")) {
	            dispatch("enter");
	            return;
	        }
	        // Cancel any entering/entered transitions and instead immediately start the
	        // exit transition
	        if (!transitionIn && stage.startsWith("enter")) {
	            dispatch("exit");
	            return;
	        }
	        if (reflow && ref.current && stage !== "exited" && stage !== "entered") {
	            // force reflow by accessing scrollTop
	            ref.current.scrollTop;
	        }
	        var duration = 0;
	        var nextStage = stage;
	        switch (stage) {
	            case "enter":
	                onEnter === null || onEnter === void 0 ? void 0 : onEnter(appearing);
	                nextStage = "entering";
	                break;
	            case "entering":
	                onEntering === null || onEntering === void 0 ? void 0 : onEntering(appearing);
	                duration = timeout.enter;
	                nextStage = "entered";
	                break;
	            case "entered":
	                onEntered === null || onEntered === void 0 ? void 0 : onEntered(appearing);
	                break;
	            case "exit":
	                onExit === null || onExit === void 0 ? void 0 : onExit();
	                nextStage = "exiting";
	                break;
	            case "exiting":
	                onExiting === null || onExiting === void 0 ? void 0 : onExiting();
	                duration = timeout.exit;
	                nextStage = "exited";
	                break;
	            case "exited":
	                onExited === null || onExited === void 0 ? void 0 : onExited();
	                break;
	        }
	        if (stage === nextStage) {
	            if (stage === "exited" && temporary) {
	                dispatch("unmount");
	            }
	            return;
	        }
	        if (duration <= 0) {
	            dispatch(nextStage);
	            return;
	        }
	        var timer = window.setTimeout(function () {
	            dispatch(nextStage);
	        }, duration);
	        return function () {
	            window.clearTimeout(timer);
	        };
	    }, [appearing, ref, stage, temporary, transitionIn]);
	    return {
	        ref: refCallback,
	        stage: stage,
	        rendered: rendered,
	        appearing: appearing,
	        transitionTo: dispatch,
	    };
	}

	var __assign$2T = (undefined && undefined.__assign) || function () {
	    __assign$2T = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2T.apply(this, arguments);
	};
	var __read$O = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @remarks \@since 2.0.0
	 */
	var DEFAULT_COLLAPSE_MIN_HEIGHT = 0;
	/**
	 * @remarks \@since 2.0.0
	 */
	var DEFAULT_COLLAPSE_MIN_PADDING_TOP = 0;
	/**
	 * @remarks \@since 2.0.0
	 */
	var DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM = 0;
	/**
	 * @remarks \@since 2.0.0
	 */
	var DEFAULT_COLLAPSE_TIMEOUT = {
	    enter: 250,
	    exit: 200,
	};
	/**
	 * This hook is used to create a transition to collapse and expand an element
	 * **inline** with other content like an accordion by animating the
	 * `max-height`, `padding-top`, and `padding-bottom` CSS properties. The default
	 * behavior is to hide the element completely while collapsed, but providing the
	 * `minHeight`, `minPaddingTop`, and `minPaddingBottom` options can make this
	 * work like a "See More"/"Preview" type of element
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import { useCollapseTransition } from "@react-md/transition";
	 * import { Typography } from "@react-md/typography";
	 *
	 * function Example(): ReactElement {
	 *   const [collapsed, setCollapsed] = useState(true);
	 *   const { elementProps, rendered } =
	 *     useCollapseTransition({
	 *       transitionIn: !collapsed,
	 *       // If the collapsible element should maintain state by not unmounting
	 *       // while collapsed, uncomment this next line
	 *       // temporary: false,
	 *     });
	 *
	 *   return (
	 *     <>
	 *       <Button onClick={() => setCollapsed(!collapsed)}>
	 *         Toggle
	 *       </Button>
	 *       {rendered && (
	 *         <div {...elementProps}>
	 *           <Typography>Stuff that should be collapsed</Typography>
	 *           <div>Whatever content...</div>
	 *         </div>
	 *       )}
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @example
	 * See More Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import { IconRotator } from "@react-md/icon";
	 * import { KeyboardArrowDownSVGIcon } from "@react-md/material-icons";
	 * import { useCollapseTransition } from "@react-md/transition";
	 * import { Typography } from "@react-md/typography";
	 *
	 * import styles from "./Example.module.scss";
	 * // pretend styles:
	 * //
	 * // .container {
	 * //   padding: 1rem;
	 * //   position: relative;
	 * // }
	 * //
	 * // .button {
	 * //   position: absolute;
	 * //   right: 0;
	 * //   top: 0;
	 * // }
	 *
	 *
	 * function Example(): ReactElement {
	 *   const [collapsed, setCollapsed] = useState(true);
	 *   const { elementProps } =
	 *     useCollapseTransition({
	 *       transitionIn: !collapsed,
	 *       minHeight: 120,
	 *       minPaddingTop: 16,
	 *       className: styles.container,
	 *     });
	 *
	 *   return (
	 *     <div {...elementProps}>
	 *       <Button
	 *         aria-expanded={!collapsed}
	 *         aria-label="Expand"
	 *         onClick={() => setCollapsed(!collapsed)}
	 *         buttonType="icon"
	 *         className={styles.button}
	 *       >
	 *         <IconRotator rotated={!collapsed}>
	 *           <KeyboardArrowDownSVGIcon />
	 *         </IconRotator>
	 *       </Button>
	 *       <SomeComponentWithALotOfContent />
	 *     </div>
	 *   );
	 * }
	 * ```
	 *
	 * @typeParam E - An HTMLElement type used for the ref required for the
	 * transition.
	 * @remarks \@since 4.0.0
	 */
	function useCollapseTransition(_a) {
	    var propNodeRef = _a.nodeRef, propStyle = _a.style, className = _a.className, transitionIn = _a.transitionIn, _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_COLLAPSE_TIMEOUT : _b, _c = _a.minHeight, minHeight = _c === void 0 ? DEFAULT_COLLAPSE_MIN_HEIGHT : _c, _d = _a.minPaddingTop, minPaddingTop = _d === void 0 ? DEFAULT_COLLAPSE_MIN_PADDING_TOP : _d, _e = _a.minPaddingBottom, minPaddingBottom = _e === void 0 ? DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM : _e, _f = _a.temporary, temporary = _f === void 0 ? minHeight === 0 && minPaddingTop === 0 && minPaddingBottom === 0 : _f, _g = _a.appear, appear = _g === void 0 ? false : _g, _h = _a.enter, enter = _h === void 0 ? true : _h, _j = _a.exit, exit = _j === void 0 ? true : _j, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited;
	    var _k = __read$O(useEnsuredRef(propNodeRef), 2), nodeRef = _k[0], refCallback = _k[1];
	    var _l = __read$O(require$$1.useState(function () {
	        if (transitionIn) {
	            return undefined;
	        }
	        return {
	            maxHeight: minHeight,
	            paddingTop: minPaddingTop,
	            paddingBottom: minPaddingBottom,
	        };
	    }), 2), style = _l[0], setStyle = _l[1];
	    var transitionTimeout = getTransitionTimeout({
	        timeout: timeout,
	        appear: appear,
	        enter: enter,
	        exit: exit,
	    });
	    var _m = useTransition({
	        nodeRef: refCallback,
	        timeout: timeout,
	        transitionIn: transitionIn,
	        reflow: true,
	        appear: appear,
	        enter: enter,
	        exit: exit,
	        temporary: temporary,
	        onEnter: function (appearing) {
	            onEnter === null || onEnter === void 0 ? void 0 : onEnter(appearing);
	            setStyle({
	                maxHeight: minHeight,
	                paddingTop: minPaddingTop,
	                paddingBottom: minPaddingBottom,
	            });
	        },
	        onEntering: function (appearing) {
	            onEntering === null || onEntering === void 0 ? void 0 : onEntering(appearing);
	            var _a = getElementSizing(nodeRef.current), maxHeight = _a.maxHeight, paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
	            var duration = appearing
	                ? transitionTimeout.appear
	                : transitionTimeout.enter;
	            setStyle({
	                maxHeight: maxHeight,
	                paddingTop: paddingTop,
	                paddingBottom: paddingBottom,
	                transitionDuration: "".concat(duration, "ms"),
	            });
	        },
	        onEntered: function (appearing) {
	            onEntered === null || onEntered === void 0 ? void 0 : onEntered(appearing);
	            setStyle(undefined);
	        },
	        onExit: function () {
	            onExit === null || onExit === void 0 ? void 0 : onExit();
	            var _a = getElementSizing(nodeRef.current), maxHeight = _a.maxHeight, paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
	            setStyle({
	                maxHeight: maxHeight,
	                paddingTop: paddingTop,
	                paddingBottom: paddingBottom,
	                transitionDuration: "".concat(transitionTimeout.exit, "ms"),
	            });
	        },
	        onExiting: function () {
	            onExiting === null || onExiting === void 0 ? void 0 : onExiting();
	            setStyle({
	                maxHeight: minHeight,
	                paddingTop: minPaddingTop,
	                paddingBottom: minPaddingBottom,
	                transitionDuration: "".concat(transitionTimeout.exit, "ms"),
	            });
	        },
	        onExited: function () {
	            onExited === null || onExited === void 0 ? void 0 : onExited();
	            setStyle({
	                maxHeight: minHeight,
	                paddingTop: minPaddingTop,
	                paddingBottom: minPaddingBottom,
	            });
	        },
	    }), appearing = _m.appearing, rendered = _m.rendered, ref = _m.ref, stage = _m.stage, transitionTo = _m.transitionTo;
	    var entering = stage === "enter" || stage === "entering";
	    var exiting = stage === "exit" || stage === "exiting";
	    var collapsible = transitionTimeout.enter !== 0 || transitionTimeout.exit !== 0;
	    var elementProps = {
	        ref: ref,
	        style: __assign$2T(__assign$2T({}, style), propStyle),
	        className: cn({
	            "rmd-collapse": collapsible,
	            "rmd-collapse--enter": entering,
	            "rmd-collapse--leave": exiting,
	            "rmd-collapse--no-overflow": !transitionIn || style,
	        }, className) || undefined,
	        hidden: !transitionIn &&
	            rendered &&
	            stage === "exited" &&
	            !temporary &&
	            minHeight === 0 &&
	            minPaddingTop === 0 &&
	            minPaddingBottom === 0,
	    };
	    return __assign$2T(__assign$2T({}, elementProps), { stage: stage, rendered: rendered, appearing: appearing, elementProps: elementProps, transitionTo: transitionTo });
	}

	var __assign$2S = (undefined && undefined.__assign) || function () {
	    __assign$2S = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2S.apply(this, arguments);
	};
	var __rest$2n = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a component implementation of the {@link useCollapseTransition} hook
	 * that implements the `temporary` behavior. Since this component uses the
	 * `React.cloneElement` to inject the `ref` and `className` into the `children`,
	 * it is recommended to use the hook instead.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * function Example(): ReactElement {
	 *   const [collapsed, setCollapsed] = useState(true);
	 *
	 *   return (
	 *     <>
	 *       <Button onClick={() => setCollapsed(!collapsed)}>
	 *         Toggle
	 *       </Button>
	 *       <Collapse collapsed={collapsed}>
	 *         <div>
	 *           Some content that should only be visible while not collapsed.
	 *         </div>
	 *       </Collapse>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @see {@link useCollapseTransition} for additional examples
	 * @typeParam E - An HTMLElement type used for the ref required for the
	 * transition.
	 * @remarks \@since 2.0.0
	 * @remarks \@since 4.0.0 Updated for the new CSS Transition API.
	 */
	function Collapse(_a) {
	    var children = _a.children, collapsed = _a.collapsed, className = _a.className, options = __rest$2n(_a, ["children", "collapsed", "className"]);
	    var child = require$$1.Children.only(children);
	    var _b = useCollapseTransition(__assign$2S(__assign$2S({}, options), { className: cn(child.props.className, className), transitionIn: !collapsed })), elementProps = _b.elementProps, rendered = _b.rendered;
	    if (!rendered) {
	        return null;
	    }
	    return require$$1.cloneElement(children, elementProps);
	}

	var __assign$2R = (undefined && undefined.__assign) || function () {
	    __assign$2R = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2R.apply(this, arguments);
	};
	var __rest$2m = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This hook is used to create CSS transitions for different components whenever
	 * a {@link TransitionHookOptions.transitionIn} flag is changed.
	 *
	 * @example
	 * Simple Transition
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import { useCSSTransition } from "@react-md/transition";
	 * import { Typography } from "@react-md/typography";
	 *
	 * // Pretend styles
	 * // .enter {
	 * //   opacity: 0.5;
	 * //   transition: opacity .15s;
	 * // }
	 * //
	 * // .enter--active {
	 * //   opacity: 1;
	 * // }
	 * //
	 * // .exit {
	 * //   opacity: 1;
	 * //   transition: opacity .15s;
	 * // }
	 * //
	 * // .exit--active {
	 * //   opacity: 0.5;
	 * // }
	 *
	 * function Example(): ReactElement {
	 *   const [transitionIn, setTransitionIn] = useState(false);
	 *   const { elementProps } = useCSSTransition({
	 *     timeout: 150,
	 *     classNames: {
	 *       enter: "enter",
	 *       enterActive: "enter--active",
	 *       exit: "exit",
	 *       exitActive: "exit--active",
	 *     },
	 *     transitionIn,
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <Button onClick={() => setTransitionIn(!transitionIn)}>
	 *         Toggle
	 *       </Button>
	 *       <Typography {...elementProps}>
	 *         Some Opacity Changing Text
	 *       </Typography>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @example
	 * Visibility Transition
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import { useCSSTransition } from "@react-md/transition";
	 * import { Typography } from "@react-md/typography";
	 *
	 * // Pretend styles
	 * // .enter {
	 * //   opacity: 0;
	 * //   transition: opacity .2s;
	 * // }
	 * //
	 * // .enter--active {
	 * //   opacity: 1;
	 * // }
	 * //
	 * // .exit {
	 * //   opacity: 1;
	 * //   transition: opacity .15s;
	 * // }
	 * //
	 * // .exit--active {
	 * //   opacity: 0;
	 * // }
	 *
	 * function Example(): ReactElement {
	 *   const [transitionIn, setTransitionIn] = useState(false);
	 *   const { elementProps, rendered } = useCSSTransition({
	 *     timeout: {
	 *       enter: 200,
	 *       exit: 150,
	 *     },
	 *     classNames: {
	 *       enter: "enter",
	 *       enterActive: "enter--active",
	 *       exit: "exit",
	 *       exitActive: "exit--active",
	 *     },
	 *     transitionIn,
	 *     temporary: true,
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <Button onClick={() => setTransitionIn(!transitionIn)}>
	 *         Toggle
	 *       </Button>
	 *       {rendered && (
	 *         <Typography {...elementProps}>
	 *           Some Opacity Changing Text
	 *         </Typography>
	 *       )}
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @example
	 * Mount Transition
	 * ```tsx
	 * import type { ReactElement } from "react";
	 * import { useCSSTransition } from "@react-md/transition";
	 *
	 * // Pretend styles
	 * // .opacity {
	 * //   opacity: 0;
	 * //   transition: opacity .3s;
	 * // }
	 * //
	 * // .opacity--active {
	 * //   opacity: 1;
	 * // }
	 * //
	 *
	 * function Example(): ReactElement {
	 *   const { elementProps } = useCSSTransition({
	 *     appear: true,
	 *     transitionIn: true,
	 *     timeout: 300,
	 *     classNames: "opacity",
	 *   })
	 *
	 *   return <div {...elementProps}>Some Content!</div>;
	 * }
	 * ```
	 *
	 * @typeParam E - An HTMLElement type used for the ref required for the
	 * transition.
	 * @remarks \@since 4.0.0
	 */
	function useCSSTransition(_a) {
	    var className = _a.className, classNames = _a.classNames, _b = _a.appear, appear = _b === void 0 ? false : _b, _c = _a.enter, enter = _c === void 0 ? true : _c, _d = _a.exit, exit = _d === void 0 ? true : _d, timeout = _a.timeout, options = __rest$2m(_a, ["className", "classNames", "appear", "enter", "exit", "timeout"]);
	    var _e = useTransition(__assign$2R(__assign$2R({}, options), { appear: appear, enter: enter, exit: exit, timeout: timeout, reflow: true })), ref = _e.ref, stage = _e.stage, rendered = _e.rendered, appearing = _e.appearing, transitionTo = _e.transitionTo;
	    var isEntering = stage === "entering";
	    var isEnter = isEntering || stage === "enter";
	    var isEntered = stage === "entered";
	    var isExiting = stage === "exiting";
	    var isExit = isExiting || stage === "exit";
	    var isExited = stage === "exited";
	    var transitionClassNames = getTransitionClassNames({
	        timeout: timeout,
	        appear: appear,
	        enter: enter,
	        exit: exit,
	        classNames: classNames,
	    });
	    var elementProps = {
	        ref: ref,
	        className: cn(
	        // always apply the provided className first since it makes snapshot
	        // tests easier to parse if dynamic classes come afterwards
	        className, appearing && isEnter && transitionClassNames.appear, appearing && isEntering && transitionClassNames.appearActive, appearing && isEntered && transitionClassNames.appearDone, !appearing && isEnter && transitionClassNames.enter, !appearing && isEntering && transitionClassNames.enterActive, !appearing && isEntered && transitionClassNames.enterDone, isExit && transitionClassNames.exit, isExiting && transitionClassNames.exitActive, isExited && transitionClassNames.exitDone) || undefined,
	    };
	    return __assign$2R(__assign$2R({}, elementProps), { stage: stage, rendered: rendered, appearing: appearing, elementProps: elementProps, transitionTo: transitionTo });
	}

	var __assign$2Q = (undefined && undefined.__assign) || function () {
	    __assign$2Q = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2Q.apply(this, arguments);
	};
	var __rest$2l = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The default cross fade transition classes to use.
	 *
	 * @remarks \@since 2.0.0
	 */
	var CROSS_FADE_CLASSNAMES = {
	    appear: "rmd-cross-fade",
	    appearActive: "rmd-cross-fade--active",
	    enter: "rmd-cross-fade",
	    enterActive: "rmd-cross-fade--active",
	};
	/**
	 * The default cross fade transition timeout.
	 *
	 * @remarks \@since 2.0.0
	 */
	var CROSS_FADE_TIMEOUT = {
	    appear: 300,
	    enter: 300,
	    exit: 0,
	};
	/**
	 * This hook is used to create a "cross fade" transition -- a transition that
	 * gradually increases the opacity and transforms the element vertically a short
	 * distance. This is generally used for full page transitions when a route
	 * changes.
	 *
	 * @example
	 * New Page Transition with `@react-md/layout`
	 * ```tsx
	 * import { ReactElement, ReactNode, useLayoutEffect } from "react";
	 * import { useLocation } from "react-router-dom":
	 * import { Layout, useLayoutNavigation } from "@react-md/layout";
	 * import { useCrossFadeTransition } from "@react-md/transition";
	 *
	 * import { navItems } from "./navItems";
	 *
	 * interface ExampleProps {
	 *   children: ReactNode;
	 * }
	 *
	 * function Example({ children }: ExampleProps): ReactElement {
	 *   const { pathname } = useLocation();
	 *   const { elementProps, transitionTo } = useCrossFadeTransition();
	 *
	 *   const prevPathname = useRef(pathname);
	 *   useLayoutEffect(() => {
	 *     if (prevPathname.current === pathname) {
	 *       return
	 *     }
	 *
	 *     prevPathname.current = pathname;
	 *     transitionTo('enter');
	 *   }, [pathname, transitionTo])
	 *
	 *   return (
	 *     <Layout
	 *       {...useLayoutNavigation(navItems, pathname)}
	 *       appBarTitle="My App"
	 *       mainProps={elementProps}
	 *     >
	 *       {children}
	 *     </Layout>
	 *   );
	 * }
	 * ```
	 *
	 * @typeParam E - An HTMLElement type used for the ref required for the
	 * transition.
	 * @remarks \@since 4.0.0
	 */
	function useCrossFadeTransition(_a) {
	    if (_a === void 0) { _a = {}; }
	    var _b = _a.transitionIn, transitionIn = _b === void 0 ? true : _b, _c = _a.timeout, timeout = _c === void 0 ? CROSS_FADE_TIMEOUT : _c, _d = _a.classNames, classNames = _d === void 0 ? CROSS_FADE_CLASSNAMES : _d, options = __rest$2l(_a, ["transitionIn", "timeout", "classNames"]);
	    return useCSSTransition(__assign$2Q(__assign$2Q({}, options), { timeout: timeout, classNames: classNames, transitionIn: transitionIn }));
	}

	var __assign$2P = (undefined && undefined.__assign) || function () {
	    __assign$2P = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2P.apply(this, arguments);
	};
	var __rest$2k = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a component implementation of the {@link useCrossFadeTransition} hook
	 * that implements the `temporary` behavior. Since this component uses the
	 * `React.cloneElement` to inject the `ref` and `className` into the `children`,
	 * it is recommended to use the hook instead.
	 *
	 * @example
	 * Appear transitions with a React `key`
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { CrossFade } from "@react-md/transition";
	 *
	 * import Page1 from "./Page1";
	 * import Page2 from "./Page2";
	 * import Page3 from "./Page3";
	 *
	 * function Example(): ReactElement {
	 *   const [page, setPage] = useState(0):
	 *
	 *   let content: ReactNode;
	 *   switch (page) {
	 *     case 0:
	 *       content = <Page1 />
	 *       break:
	 *     case 1:
	 *       content = <Page2 />
	 *       break;
	 *     case 2:
	 *       content = <Page3 />
	 *       break;
	 *     default:
	 *       content = null;
	 *   }
	 *
	 *   return (
	 *     <>
	 *       <Button
	 *         onClick={() => {
	 *           setPage(prevPage => {
	 *             const nextPage = prevPage + 1;
	 *             if (nextPage > 2) {
	 *               return 0;
	 *             }
	 *
	 *             return nextPage;
	 *           })
	 *         }}
	 *       >
	 *         Change Page
	 *       </Button>
	 *       <CrossFade key={page}>
	 *         <div>{content}</div>
	 *       </CrossFade>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @typeParam E - An HTMLElement type used for the ref required for the
	 * transition.
	 * @remarks \@since 2.0.0
	 * @remarks \@since 4.0.0 Updated for the new CSS Transition API and no longer
	 * supports wrapping children in a `<div>`.
	 */
	function CrossFade(_a) {
	    var _b = _a.appear, appear = _b === void 0 ? true : _b, _c = _a.transitionIn, transitionIn = _c === void 0 ? appear : _c, children = _a.children, className = _a.className, options = __rest$2k(_a, ["appear", "transitionIn", "children", "className"]);
	    var child = require$$1.Children.only(children);
	    var _d = useCrossFadeTransition(__assign$2P(__assign$2P({}, options), { appear: appear, className: cn(child.props.className, className), transitionIn: transitionIn })), elementProps = _d.elementProps, rendered = _d.rendered;
	    if (!rendered) {
	        return null;
	    }
	    return require$$1.cloneElement(children, elementProps);
	}

	var __assign$2O = (undefined && undefined.__assign) || function () {
	    __assign$2O = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2O.apply(this, arguments);
	};
	var __rest$2j = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a component implementation of the {@link useCSSTransition} hook that
	 * implements the `temporary` behavior. Since this component uses the
	 * `React.cloneElement` to inject the `ref` and `className` into the `children`,
	 * it is recommended to use the hook instead.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { Button } from "@react-md/button":
	 * import { CSSTransition } from "@react-md/transition";
	 *
	 * // pretend global styles:
	 * //
	 * // .opacity--enter {
	 * //   opacity: 0;
	 * //   transition: opacity .3s;
	 * // }
	 * //
	 * // .opacity--enter-active {
	 * //   opacity: 1;
	 * // }
	 * //
	 * // .opacity--exit {
	 * //   opacity: 1;
	 * // }
	 * //
	 * // .opacity--exit-active {
	 * //   opacity: 0;
	 * //   transition: opacity .3s;
	 * // }
	 *
	 * function Example(): ReactElement {
	 *   const [transitionIn, setTransitionIn] = useState(false);
	 *
	 *   return (
	 *     <>
	 *       <Button onClick={() => setTransitionIn(!transitionIn)}>
	 *         Toggle
	 *       </Button>
	 *       <CSSTransition
	 *         timeout={300}
	 *         className="opacity"
	 *         temporary
	 *         transitionIn={transitionIn}
	 *       >
	 *         <div>
	 *           This is some content that will animate!
	 *         </div>
	 *       </CSSTransition>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @typeParam E - An HTMLElement type used for the ref required for the
	 * transition.
	 * @remarks \@since 4.0.0
	 */
	function CSSTransition(_a) {
	    var children = _a.children, className = _a.className, options = __rest$2j(_a, ["children", "className"]);
	    var child = require$$1.Children.only(children);
	    var _b = useCSSTransition(__assign$2O(__assign$2O({}, options), { className: cn(child.props.className, className) })), elementProps = _b.elementProps, rendered = _b.rendered;
	    if (!rendered) {
	        return null;
	    }
	    return require$$1.cloneElement(children, elementProps);
	}

	var __assign$2N = (undefined && undefined.__assign) || function () {
	    __assign$2N = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2N.apply(this, arguments);
	};
	var __rest$2i = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The default {@link CSSTransitionClassNames} for a horizontal scale
	 * transition.
	 *
	 * @remarks \@since 2.0.0
	 */
	var SCALE_CLASSNAMES = {
	    appear: "rmd-transition--scale-enter",
	    appearActive: "rmd-transition--scale-enter-active",
	    enter: "rmd-transition--scale-enter",
	    enterActive: "rmd-transition--scale-enter-active",
	    enterDone: "",
	    exit: "rmd-transition--scale-exit",
	    exitActive: "rmd-transition--scale-exit-active",
	};
	/**
	 * The default {@link CSSTransitionClassNames} for a vertical scale transition.
	 *
	 * @remarks \@since 2.0.0
	 */
	var SCALE_Y_CLASSNAMES = {
	    appear: "rmd-transition--scale-y-enter",
	    appearActive: "rmd-transition--scale-y-enter-active",
	    enter: "rmd-transition--scale-y-enter",
	    enterActive: "rmd-transition--scale-y-enter-active",
	    enterDone: "",
	    exit: "rmd-transition--scale-y-exit",
	    exitActive: "rmd-transition--scale-y-exit-active",
	};
	/**
	 * The default {@link TransitionTimeout} to use for horizontal and vertical
	 * scale transitions.
	 *
	 * @remarks \@since 2.0.0
	 */
	var SCALE_TIMEOUT = {
	    enter: 200,
	    exit: 150,
	};
	/**
	 * Implements a scale transition that should generally be used for temporary
	 * elements that are positioned via `position: absolute` or `position: fixed`.
	 *
	 * @example
	 * Dropdown Menu Example
	 * ```tsx
	 * import { ReactElement, useRef, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import { useFixedPositioning, useScaleTransition } from "@react-md/transition";
	 *
	 * function Example(): ReactElement {
	 *   const buttonRef = useRef<HTMLButtonElement>(null);
	 *   const [transitionIn, setTransitionIn] = useState(false);
	 *   const { style, transitionOptions } = useFixedPositioning({
	 *     fixedTo: buttonRef,
	 *   });
	 *   const { elementProps, rendered } = useScaleTransition({
	 *     ...transitionOptions,
	 *     transitionIn,
	 *     vertical: true,
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <Button ref={buttonRef} onClick={() => setTransitionIn(!transitionIn)}>
	 *         Toggle
	 *       </Button>
	 *       {rendered && (
	 *         <div {...elementProps} style={style}>
	 *           Some content within a menu
	 *         </div>
	 *       )}
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @typeParam E - The HTMLElement type used or the ref required for the
	 * transition.
	 * @remarks \@since 4.0.0
	 */
	function useScaleTransition(_a) {
	    var _b = _a.timeout, timeout = _b === void 0 ? SCALE_TIMEOUT : _b, _c = _a.vertical, vertical = _c === void 0 ? false : _c, _d = _a.temporary, temporary = _d === void 0 ? true : _d, _e = _a.classNames, classNames = _e === void 0 ? vertical ? SCALE_Y_CLASSNAMES : SCALE_CLASSNAMES : _e, options = __rest$2i(_a, ["timeout", "vertical", "temporary", "classNames"]);
	    return useCSSTransition(__assign$2N(__assign$2N({}, options), { timeout: timeout, temporary: temporary, classNames: classNames }));
	}

	var __assign$2M = (undefined && undefined.__assign) || function () {
	    __assign$2M = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2M.apply(this, arguments);
	};
	var __rest$2h = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * A component implementation of the {@link useScaleTransition} hook that just
	 * has some reasonable defaults and supports portalling the children. Since this
	 * component uses the `React.cloneElement` to inject the `ref` and `className`
	 * into the `children`, it is recommended to use the hook instead.
	 *
	 * @example
	 * Dropdown Menu Example
	 * ```tsx
	 * import { ReactElement, useRef, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import { useFixedPositioning, useScaleTransition } from "@react-md/transition";
	 *
	 * function Example(): ReactElement {
	 *   const buttonRef = useRef<HTMLButtonElement>(null);
	 *   const [transitionIn, setTransitionIn] = useState(false);
	 *   const { style, transitionOptions } = useFixedPositioning({
	 *     fixedTo: buttonRef,
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <Button ref={buttonRef} onClick={() => setTransitionIn(!transitionIn)}>
	 *         Toggle
	 *       </Button>
	 *       <ScaleTransition
	 *         {...transitionOptions}
	 *         vertical
	 *         transitionIn={transitionIn}
	 *       >
	 *         <div style={style}>
	 *           Some content within a menu
	 *         </div>
	 *       </ScaleTransition>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @typeParam E - The HTMLElement type used or the ref required for the
	 * transition.
	 * @remarks \@since 2.0.0
	 * @remarks \@since 4.0.0 The typeParam was added and the API was updated.
	 */
	function ScaleTransition(_a) {
	    var portal = _a.portal, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, children = _a.children, className = _a.className, options = __rest$2h(_a, ["portal", "portalInto", "portalIntoId", "children", "className"]);
	    var child = require$$1.Children.only(children);
	    var _b = useScaleTransition(__assign$2M(__assign$2M({}, options), { className: cn(child.props.className, className) })), elementProps = _b.elementProps, rendered = _b.rendered;
	    return (jsxRuntime.exports.jsx(ConditionalPortal, __assign$2M({ portal: portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: rendered && require$$1.cloneElement(children, elementProps) })));
	}

	var __assign$2L = (undefined && undefined.__assign) || function () {
	    __assign$2L = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2L.apply(this, arguments);
	};
	var __read$N = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook is used to attach a temporary (fixed) element to another element
	 * within the page. In other words, this is a way to have an element with
	 * `position: fixed` as if it were `position: absolute` to a parent element that
	 * had `position: relative`.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useRef, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import { useCSSTransition, useFixedPositioning } from "@react-md/transition";
	 *
	 * function Example(): ReactElement {
	 *   const fixedTo = useRef<HTMLButtonElement>(null);
	 *   const [transitionIn, setTransitionIn] = useState(false);
	 *   const { style, transitionOptions } = useFixedPositioning({
	 *     fixedTo,
	 *   });
	 *   const { elementProps, rendered } = useCSSTransition({
	 *     ...transitionOptions,
	 *     transitionIn,
	 *     temporary: true,
	 *     timeout: {
	 *       enter: 200,
	 *       exit: 150,
	 *     },
	 *     classNames: {
	 *       enter: "enter",
	 *       enterActive: "enter--active",
	 *       exit: "exit",
	 *       exitActive: "exit--active",
	 *     },
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <Button
	 *         ref={fixedTo}
	 *         onClick={() => setTransitionIn(!transitionIn)}
	 *       >
	 *         Toggle
	 *       </Button>
	 *       {rendered && (
	 *         <div {...elementProps} style={style}>
	 *           Fixed Temporary Element
	 *         </div>
	 *       )}
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @typeParam FixedToElement - An HTMLElement type for the static element.
	 * @typeParam FixedElement - An HTMLElement type for the fixed element.
	 * @remarks \@since 4.0.0
	 */
	function useFixedPositioning(_a) {
	    var propStyle = _a.style, nodeRef = _a.nodeRef, fixedTo = _a.fixedTo, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, _b = _a.anchor, anchor = _b === void 0 ? BELOW_CENTER_ANCHOR : _b, disableSwapping = _a.disableSwapping, disableVHBounds = _a.disableVHBounds, initialX = _a.initialX, initialY = _a.initialY, preventOverlap = _a.preventOverlap, transformOrigin = _a.transformOrigin, vhMargin = _a.vhMargin, vwMargin = _a.vwMargin, width = _a.width, xMargin = _a.xMargin, yMargin = _a.yMargin, getFixedPositionOptions = _a.getFixedPositionOptions, onScroll = _a.onScroll, onResize = _a.onResize;
	    var _c = __read$N(require$$1.useState(), 2), style = _c[0], setStyle = _c[1];
	    var _d = __read$N(require$$1.useState(false), 2), active = _d[0], setActive = _d[1];
	    var _e = __read$N(useEnsuredRef(nodeRef), 2), ref = _e[0], refHandler = _e[1];
	    var options = {
	        ref: ref,
	        fixedTo: fixedTo,
	        anchor: anchor,
	        disableSwapping: disableSwapping,
	        disableVHBounds: disableVHBounds,
	        preventOverlap: preventOverlap,
	        transformOrigin: transformOrigin,
	        vhMargin: vhMargin,
	        vwMargin: vwMargin,
	        width: width,
	        xMargin: xMargin,
	        yMargin: yMargin,
	        getFixedPositionOptions: getFixedPositionOptions,
	    };
	    var optionsRef = require$$1.useRef(options);
	    optionsRef.current = options;
	    var updateStyle = require$$1.useCallback(function () {
	        var _a = optionsRef.current, ref = _a.ref, fixedTo = _a.fixedTo, anchor = _a.anchor, disableSwapping = _a.disableSwapping, disableVHBounds = _a.disableVHBounds, preventOverlap = _a.preventOverlap, transformOrigin = _a.transformOrigin, vhMargin = _a.vhMargin, vwMargin = _a.vwMargin, width = _a.width, xMargin = _a.xMargin, yMargin = _a.yMargin, getFixedPositionOptions = _a.getFixedPositionOptions;
	        var element = ref.current;
	        var container = fixedTo.current;
	        var style = getFixedPosition(__assign$2L({ container: container, element: element, anchor: anchor, disableSwapping: disableSwapping, disableVHBounds: disableVHBounds, initialX: initialX, initialY: initialY, preventOverlap: preventOverlap, transformOrigin: transformOrigin, vhMargin: vhMargin, vwMargin: vwMargin, width: width, xMargin: xMargin, yMargin: yMargin }, getFixedPositionOptions === null || getFixedPositionOptions === void 0 ? void 0 : getFixedPositionOptions())).style;
	        setStyle(style);
	        setActive(!!element && !element.hidden);
	        // Only changing the initialX and initialY should cause the useEffect below
	        // to trigger, which is why everything else is set in a ref.
	    }, [initialX, initialY]);
	    useResizeListener({
	        enabled: active,
	        onResize: function (event) {
	            onResize === null || onResize === void 0 ? void 0 : onResize(event);
	            updateStyle();
	        },
	    });
	    useScrollListener({
	        enabled: active,
	        onScroll: function (event) {
	            var fixedElement = ref.current;
	            var fixedToElement = fixedTo.current;
	            if (onScroll && fixedElement && fixedToElement) {
	                onScroll(event, {
	                    visible: isWithinViewport({ fixedElement: fixedElement, fixedToElement: fixedToElement }),
	                    fixedElement: fixedElement,
	                    fixedToElement: fixedToElement,
	                });
	            }
	            updateStyle();
	        },
	    });
	    require$$1.useEffect(function () {
	        if (!ref.current || !ref.current.hidden) {
	            updateStyle();
	        }
	    }, [ref, updateStyle]);
	    var callbacks = {
	        onEnter: function (appearing) {
	            onEnter === null || onEnter === void 0 ? void 0 : onEnter(appearing);
	            updateStyle();
	        },
	        onEntering: function (appearing) {
	            onEntering === null || onEntering === void 0 ? void 0 : onEntering(appearing);
	            updateStyle();
	        },
	        onEntered: function (appearing) {
	            onEntered === null || onEntered === void 0 ? void 0 : onEntered(appearing);
	            updateStyle();
	        },
	        onExited: function () {
	            onExited === null || onExited === void 0 ? void 0 : onExited();
	            setActive(false);
	        },
	    };
	    return {
	        ref: refHandler,
	        style: __assign$2L(__assign$2L({}, style), propStyle),
	        callbacks: callbacks,
	        updateStyle: updateStyle,
	        transitionOptions: __assign$2L(__assign$2L({}, callbacks), { nodeRef: refHandler }),
	    };
	}

	/**
	 * @remarks \@since 2.4.0
	 */
	var DEFAULT_TOAST_TIMEOUT = 150;
	/**
	 * @remarks \@since 2.4.0
	 */
	var DEFAULT_TOAST_CLASSNAMES = {
	    appear: "rmd-toast--enter",
	    appearActive: "rmd-toast--enter-active",
	    enter: "rmd-toast--enter",
	    enterActive: "rmd-toast--enter-active",
	    exit: "rmd-toast--exit",
	    exitActive: "rmd-toast--exit-active",
	};

	var __assign$2K = (undefined && undefined.__assign) || function () {
	    __assign$2K = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2K.apply(this, arguments);
	};
	var __rest$2g = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$16 = bem("rmd-toast");
	/**
	 * This is a very low-level component that can be used to animate a new toast in
	 * to a `Snackbar` as it is mainly just a wrapper of the `CSSTransition`
	 * component. If you are using this component, it is generally recommended to
	 * provide the `onEntered` callback as a function to start the hide visibility
	 * timer and the `onExited` callback to remove the current toast from your
	 * queue.
	 */
	var Toast = require$$1.forwardRef(function Toast(_a, nodeRef) {
	    var className = _a.className, children = _a.children, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_TOAST_TIMEOUT : _b, _c = _a.classNames, classNames = _c === void 0 ? DEFAULT_TOAST_CLASSNAMES : _c, _d = _a.action, action = _d === void 0 ? null : _d, _e = _a.stacked, stacked = _e === void 0 ? false : _e, _f = _a.twoLines, twoLines = _f === void 0 ? false : _f, visible = _a.visible, props = __rest$2g(_a, ["className", "children", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "timeout", "classNames", "action", "stacked", "twoLines", "visible"]);
	    return (jsxRuntime.exports.jsx(CSSTransition, __assign$2K({ appear: true, nodeRef: nodeRef, temporary: true, transitionIn: visible, onEnter: onEnter, onEntering: onEntering, onEntered: onEntered, onExit: onExit, onExiting: onExiting, onExited: onExited, timeout: timeout, classNames: classNames }, { children: jsxRuntime.exports.jsxs("div", __assign$2K({}, props, { className: cn(block$16({
	                stacked: stacked,
	                padded: !action || twoLines,
	                "two-lines": twoLines,
	                action: action,
	                "action-2": action && twoLines,
	            }), className) }, { children: [jsxRuntime.exports.jsx("span", __assign$2K({ className: block$16("message", { action: action }) }, { children: children })), action && (jsxRuntime.exports.jsx("span", __assign$2K({ className: block$16("action", { stacked: stacked }) }, { children: action })))] })) })));
	});

	var DEFAULT_MESSAGE_QUEUE_TIMEOUT = 5000;
	/**
	 * @internal
	 */
	var AddMessageContext = require$$1.createContext(function () {
	    throw new Error("Attempted to create a message without initializing the MessageQueue component.");
	});
	/**
	 * @internal
	 */
	var MessageVisibilityContext = require$$1.createContext(false);
	/**
	 * This hook is used to add a message to the queue from anywhere in your app.
	 * This should normally be used from click event handlers, but can also be
	 * triggered with custom logic within components.
	 */
	function useAddMessage() {
	    return require$$1.useContext(AddMessageContext);
	}
	/**
	 * Gets the current message visibility to provide to the toast.
	 *
	 * @internal
	 */
	function useMessageVisibility() {
	    return require$$1.useContext(MessageVisibilityContext);
	}
	/**
	 * @internal
	 */
	var MessageQueueActionsContext = require$$1.createContext({
	    popMessage: function () {
	        throw new Error("Attempted to pop a message without initializing the MessageQueue component.");
	    },
	    hideMessage: function () {
	        throw new Error("Attempted to hide a message within initializing the MessageQueue component.");
	    },
	    startTimer: function () {
	        throw new Error("Attempted to start a message queue timer without initializing the MessageQueue component.");
	    },
	    stopTimer: function () {
	        throw new Error("Attempted to stop a message queue timer without initializing the MessageQueue component.");
	    },
	    restartTimer: function () {
	        throw new Error("Attempted to restart a message queue timer without initializing the MessageQueue component.");
	    },
	    resetQueue: function () {
	        throw new Error("Attempted to reset the message queue timer without initializing the MessageQueue component.");
	    },
	});
	/**
	 * This hook exposes some of the lower level actions for handling a message
	 * queue if advanced behavior is desired.
	 */
	function useMessageQueueActions() {
	    // I don't know how to type the createContext for a generic
	    return require$$1.useContext(MessageQueueActionsContext);
	}
	/**
	 * @internal
	 */
	var MessageQueueContext = require$$1.createContext([]);
	/**
	 * This hook will allow you to get the current queue. This probably shouldn't be
	 * used that much.
	 */
	function useQueue() {
	    return require$$1.useContext(MessageQueueContext);
	}

	var block$15 = bem("rmd-button");
	/**
	 * Creates a button theme based on the button theming props. This is really just
	 * used so that other elements like clickable `<div>`s or `<input type="file">`
	 * can look like buttons.
	 *
	 * @param props - An object containing the themeable button props to generate a
	 * button theme className.
	 * @returns a string of class names to create an element with a button theme.
	 */
	function buttonThemeClassNames(_a) {
	    var _b;
	    var _c = _a.theme, propTheme = _c === void 0 ? "clear" : _c, _d = _a.themeType, themeType = _d === void 0 ? "flat" : _d, _e = _a.buttonType, buttonType = _e === void 0 ? "text" : _e, _f = _a.disabled, propDisabled = _f === void 0 ? false : _f, className = _a.className;
	    var theme = propTheme === "disabled" ? "clear" : propTheme;
	    var disabled = propDisabled || propTheme === "disabled";
	    var text = buttonType === "text";
	    var icon = buttonType === "icon";
	    var outline = themeType === "outline";
	    var contained = themeType === "contained";
	    var clear = theme === "clear";
	    return cn(block$15((_b = {
	            text: text,
	            icon: icon,
	            disabled: disabled,
	            contained: !disabled && contained,
	            outline: outline
	        },
	        _b[theme] = !disabled && !clear && contained,
	        _b["text-".concat(theme)] = !disabled && !clear && !contained,
	        _b["outline-".concat(theme)] = !disabled && !clear && outline,
	        _b)), className);
	}

	/**
	 * Checks if the ripple event should be ignored since it was bubbled
	 * up from a child treeitem. I should find a better way to handle
	 * this at some point.
	 */
	function isBubbled(event) {
	    return Array.from(event.currentTarget.querySelectorAll('[role="treeitem"]')).some(function (item) { return item.contains(event.target); });
	}
	/**
	 * Gets the ripple event type based on the provided event.
	 */
	function getType(event) {
	    switch (event.type) {
	        case "mousedown":
	        case "mouseup":
	        case "mouseleave":
	            return "mouse";
	        case "touchstart":
	        case "touchmove":
	        case "touchend":
	            return "touch";
	        case "keydown":
	        case "keyup":
	            return "keyboard";
	        default:
	            return "programmatic";
	    }
	}
	/**
	 * Checks if the provided event type is actually rippleable by ensuring:
	 * - it is a mousedown event while not in touch mode and the left mouse was
	 *   clicked.
	 * - it was a keydown event for either tab or space when spacebar clicks have not
	 *   been disabled
	 * - it was a touchstart event
	 */
	function isRippleable(event, disableSpacebarClick) {
	    switch (event.type) {
	        case "mousedown":
	            return (document.querySelector(".rmd-states--touch") === null &&
	                event.button === 0);
	        case "keydown":
	            return ((!disableSpacebarClick && event.key === " ") ||
	                (event.key === "Enter" &&
	                    !/checkbox|radio/i.test(event.currentTarget.getAttribute("type") || "")));
	        case "touchstart":
	        case "click":
	            return true;
	        default:
	            return false;
	    }
	}
	function calcHypotenuse(a, b) {
	    return Math.sqrt(a * a + b * b);
	}
	/**
	 * Gets the current radius for a ripple based on the x and y page dimensions
	 * as well as the size of the element.
	 *
	 * This is really just in a separate file so I can easily mock this and write
	 * tests.
	 */
	function getRadius(x, y, offsetWidth, offsetHeight) {
	    return Math.max(calcHypotenuse(x, y), calcHypotenuse(offsetWidth - x, y), calcHypotenuse(offsetWidth - x, offsetHeight - y), calcHypotenuse(x, offsetHeight - y));
	}
	/**
	 * Gets the ripple creation origin base on the provided event. When the event
	 * type is for keyboards or triggered programmatically, the origin will
	 * be the center of the target element. When the event is for touch or mouse,
	 * the origin will be the location within the viewport where the user touched
	 * or clicked the target element.
	 */
	function getOrigin(event, element) {
	    var _a;
	    var type = getType(event);
	    var offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;
	    var x;
	    var y;
	    if (type === "programmatic" || type === "keyboard") {
	        x = offsetWidth / 2;
	        y = offsetHeight / 2;
	    }
	    else {
	        // if the event type is not programmatic, want to figure out exactly where in
	        // the element to trigger the animation from. this can be determined by:
	        // - getting the pageX and pageY of the mouse or touch event
	        // - getting element's current position in the page
	        var pageX = void 0;
	        var pageY = void 0;
	        if (type === "mouse") {
	            (_a = event, pageX = _a.pageX, pageY = _a.pageY);
	        }
	        else {
	            var touch = event.touches.item(0);
	            (pageX = touch.pageX, pageY = touch.pageY);
	        }
	        var rect = element.getBoundingClientRect();
	        // have to include the current page's scroll offset to the element's
	        // bounding rect since the pageX and pageY from Events include the scroll
	        // offset while the bounding rect is only based on viewport.
	        x = pageX - (rect.left + window.pageXOffset);
	        y = pageY - (rect.top + window.pageYOffset);
	    }
	    return { x: x, y: y };
	}
	/**
	 * Creates a new ripple state based off the provided event type.
	 */
	function createRippleState(event) {
	    var element = findSizingContainer(event.currentTarget) || event.currentTarget;
	    var offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;
	    var type = getType(event);
	    var _a = getOrigin(event, element), x = _a.x, y = _a.y;
	    var radius = getRadius(x, y, offsetWidth, offsetHeight);
	    var size = radius * 2;
	    return {
	        startTime: Date.now(),
	        style: {
	            left: x - radius,
	            top: y - radius,
	            height: size,
	            width: size,
	        },
	        type: type,
	        holding: type !== "programmatic",
	        exiting: false,
	        entered: false,
	    };
	}

	var __assign$2J = (undefined && undefined.__assign) || function () {
	    __assign$2J = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2J.apply(this, arguments);
	};
	var __read$M = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$a = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var CREATE = "CREATE";
	var CANCEL = "CANCEL";
	var RELEASE = "RELEASE";
	var ENTERED = "ENTERED";
	var REMOVE = "REMOVE";
	/**
	 * This function will create a simplified version of the create event
	 * that only includes the parts that are needed to trigger a ripple.
	 * This is really only required since `event.persist()` crashed a lot
	 * when spamming the trigger events and it threw warnings when not
	 * persisting the event.
	 */
	function createRippleAction(event, disableSpacebarClick) {
	    var _a = event, type = _a.type, target = _a.target, currentTarget = _a.currentTarget, touches = _a.touches, pageX = _a.pageX, pageY = _a.pageY, button = _a.button, key = _a.key;
	    return {
	        type: CREATE,
	        disableSpacebarClick: disableSpacebarClick,
	        event: {
	            type: type,
	            key: key,
	            target: target,
	            button: button,
	            currentTarget: currentTarget,
	            touches: touches,
	            pageX: pageX,
	            pageY: pageY,
	        },
	    };
	}
	function createRipple(state, event, disableSpacebarClick) {
	    if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {
	        return state;
	    }
	    if (state.find(function (r) { return r.holding; }) ||
	        (getType(event) !== "touch" && state.find(function (r) { return r.type === "touch"; }))) {
	        // keyboard events are a bit different than the others since it is actually
	        // spammable since the space or enter key can be held down which triggers click
	        // events infinitely until they release. There's also the fun fact that mouse
	        // events are triggered after touch events, so we need to make sure duplicate
	        // ripples aren't created for these
	        return state;
	    }
	    var ripple = createRippleState(event);
	    return __spreadArray$a(__spreadArray$a([], __read$M(state), false), [ripple], false);
	}
	function enteredRipple(state, ripple) {
	    var i = state.findIndex(function (r) { return r === ripple; });
	    if (i === -1 || ripple.exiting) {
	        return state;
	    }
	    var nextState = state.slice();
	    var exiting = !ripple.holding || Date.now() - ripple.startTime > 300;
	    nextState[i] = __assign$2J(__assign$2J({}, ripple), { exiting: exiting, entered: true });
	    return nextState;
	}
	function releaseRipple(state) {
	    var i = state.findIndex(function (r) { return r.holding && !r.exiting; });
	    if (i === -1) {
	        return state;
	    }
	    var ripple = state[i];
	    var exiting = ripple.entered || Date.now() - ripple.startTime > 300;
	    var nextState = state.slice();
	    nextState[i] = __assign$2J(__assign$2J({}, ripple), { exiting: exiting, holding: false });
	    return nextState;
	}
	function removeRipple(state, ripple) {
	    var i = state.findIndex(function (r) { return r.startTime === ripple.startTime; });
	    if (i === -1) {
	        return state;
	    }
	    var nextState = state.slice();
	    nextState.splice(i, 1);
	    return nextState;
	}
	function cancelRipples(state, ease) {
	    if (ease) {
	        return state.map(function (r) { return (__assign$2J(__assign$2J({}, r), { exiting: true, mounted: true, holding: false })); });
	    }
	    return [];
	}
	function reducer$1(state, action) {
	    if (state === void 0) { state = []; }
	    switch (action.type) {
	        case CREATE:
	            return createRipple(state, action.event, action.disableSpacebarClick);
	        case RELEASE:
	            return releaseRipple(state);
	        case CANCEL:
	            return cancelRipples(state, action.ease);
	        case ENTERED:
	            return enteredRipple(state, action.ripple);
	        case REMOVE:
	            return removeRipple(state, action.ripple);
	        default:
	            return state;
	    }
	}
	/**
	 * This hook creates memoized callbacks for each part of the ripple transition
	 * as well as returning the current list of ripples.
	 */
	function useRippleTransition(disableSpacebarClick) {
	    if (disableSpacebarClick === void 0) { disableSpacebarClick = false; }
	    var _a = __read$M(require$$1.useReducer(reducer$1, []), 2), state = _a[0], dispatch = _a[1];
	    var spacebarRef = useRefCache(disableSpacebarClick);
	    var create = require$$1.useCallback(function (event) {
	        var disableSpacebarClick = spacebarRef.current;
	        dispatch(createRippleAction(event, disableSpacebarClick));
	        // disabled since useRefCache
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var release = require$$1.useCallback(function (event) {
	        dispatch({ type: RELEASE, event: event });
	    }, []);
	    var entered = require$$1.useCallback(function (ripple) {
	        dispatch({ type: ENTERED, ripple: ripple });
	    }, []);
	    var cancel = require$$1.useCallback(function (ease) {
	        if (ease === void 0) { ease = false; }
	        dispatch({ type: CANCEL, ease: ease });
	    }, []);
	    var remove = require$$1.useCallback(function (ripple) {
	        dispatch({ type: REMOVE, ripple: ripple });
	    }, []);
	    return { state: state, create: create, release: release, entered: entered, remove: remove, cancel: cancel };
	}

	var DEFAULT_RIPPLE_CLASSNAMES = {
	    enter: "rmd-ripple--animating",
	    enterActive: "rmd-ripple--scaling",
	    enterDone: "rmd-ripple--animating rmd-ripple--scaling",
	    exit: "rmd-ripple--animating rmd-ripple--scaling",
	    exitActive: "rmd-ripple--fading",
	};
	var DEFAULT_RIPPLE_TIMEOUT = {
	    enter: 150,
	    exit: 300,
	};

	var __assign$2I = (undefined && undefined.__assign) || function () {
	    __assign$2I = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2I.apply(this, arguments);
	};
	var StatesConfigContext = require$$1.createContext({
	    rippleTimeout: DEFAULT_RIPPLE_TIMEOUT,
	    rippleClassNames: DEFAULT_RIPPLE_CLASSNAMES,
	    disableRipple: false,
	    disableProgrammaticRipple: false,
	});
	/**
	 * A simple hook that can be used to get the Ripple context. This is used behind
	 * the scenes for the Ripple component and _probably_ shouldn't be used anywhere
	 * else. It's mostly used to just use the context defaults when the timeout or
	 * classNames are undefined.
	 */
	function useStatesConfigContext() {
	    return require$$1.useContext(StatesConfigContext);
	}
	/**
	 * The `StatesConfig` component is a top-level context provider for the states
	 * context configuration. It'll keep track of:
	 *
	 * - the current interaction mode of your user
	 * - configuration for ripple effects
	 * - disabling or enabling the ripple effects
	 * - disabling or enabling the fix for color pollution
	 */
	function StatesConfig(_a) {
	    var _b = _a.rippleTimeout, rippleTimeout = _b === void 0 ? DEFAULT_RIPPLE_TIMEOUT : _b, _c = _a.rippleClassNames, rippleClassNames = _c === void 0 ? DEFAULT_RIPPLE_CLASSNAMES : _c, _d = _a.disableRipple, disableRipple = _d === void 0 ? false : _d, _e = _a.disableProgrammaticRipple, disableProgrammaticRipple = _e === void 0 ? false : _e, children = _a.children;
	    var value = require$$1.useMemo(function () { return ({
	        rippleTimeout: rippleTimeout,
	        rippleClassNames: rippleClassNames,
	        disableRipple: disableRipple,
	        disableProgrammaticRipple: disableProgrammaticRipple,
	    }); }, [rippleTimeout, rippleClassNames, disableRipple, disableProgrammaticRipple]);
	    return (jsxRuntime.exports.jsx(StatesConfigContext.Provider, __assign$2I({ value: value }, { children: children })));
	}

	var __assign$2H = (undefined && undefined.__assign) || function () {
	    __assign$2H = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2H.apply(this, arguments);
	};
	function Ripple(_a) {
	    var className = _a.className, propClassNames = _a.classNames, propTimeout = _a.timeout, ripple = _a.ripple, entered = _a.entered, exited = _a.exited;
	    var exiting = ripple.exiting, style = ripple.style;
	    var timeout = propTimeout;
	    var classNames = propClassNames;
	    var context = useStatesConfigContext();
	    if (typeof timeout === "undefined" || typeof classNames === "undefined") {
	        if (typeof timeout === "undefined") {
	            timeout = context.rippleTimeout;
	        }
	        if (typeof classNames === "undefined") {
	            classNames = context.rippleClassNames;
	        }
	    }
	    var _b = useCSSTransition({
	        appear: true,
	        transitionIn: !exiting,
	        timeout: timeout,
	        className: cn("rmd-ripple", className),
	        classNames: classNames,
	        onEntered: function () {
	            entered(ripple);
	        },
	        onExited: function () {
	            exited(ripple);
	        },
	    }), elementProps = _b.elementProps, rendered = _b.rendered;
	    if (!rendered) {
	        return null;
	    }
	    return jsxRuntime.exports.jsx("span", __assign$2H({}, elementProps, { style: style }));
	}

	var __assign$2G = (undefined && undefined.__assign) || function () {
	    __assign$2G = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2G.apply(this, arguments);
	};
	function RippleContainer(_a) {
	    var ripples = _a.ripples, className = _a.className, rippleClassName = _a.rippleClassName, timeout = _a.timeout, classNames = _a.classNames, entered = _a.entered, exited = _a.exited;
	    return (jsxRuntime.exports.jsx("span", __assign$2G({ className: cn("rmd-ripple-container", className) }, { children: ripples.map(function (ripple) { return (jsxRuntime.exports.jsx(Ripple, { ripple: ripple, className: rippleClassName, entered: entered, exited: exited, timeout: timeout, classNames: classNames }, ripple.startTime)); }) })));
	}

	var __assign$2F = (undefined && undefined.__assign) || function () {
	    __assign$2F = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2F.apply(this, arguments);
	};
	/**
	 * This hook is used to create all the event handlers required for
	 * creating ripples on an element. Each handler will be memoized and
	 * merged with any provided event handlers of the same type. If the
	 * ripple effect is disabled, the provided event handlers will be
	 * returned instead.
	 */
	function useRippleHandlers(_a) {
	    var create = _a.create, release = _a.release, cancel = _a.cancel, _b = _a.handlers, handlers = _b === void 0 ? {} : _b, _c = _a.disabled, propDisabled = _c === void 0 ? false : _c, _d = _a.disableRipple, disableRipple = _d === void 0 ? false : _d, _e = _a.disableProgrammaticRipple, disableProgrammaticRipple = _e === void 0 ? false : _e;
	    var disabled = propDisabled || disableRipple;
	    var ref = useRefCache(__assign$2F(__assign$2F({}, handlers), { disableProgrammaticRipple: disableProgrammaticRipple }));
	    // some OS/browser don't actually focus buttons/elements that are focusable after a click
	    // event which causes a double ripple effect. This ref is used to disable the programmatic
	    // ripple in these cases.
	    var disableProgrammatic = require$$1.useRef(false);
	    var onKeyDown = require$$1.useCallback(function (event) {
	        var callback = ref.current.onKeyDown;
	        if (callback) {
	            callback(event);
	        }
	        create(event);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [create]);
	    var onKeyUp = require$$1.useCallback(function (event) {
	        var callback = ref.current.onKeyUp;
	        if (callback) {
	            callback(event);
	        }
	        release(event);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [release]);
	    var onMouseDown = require$$1.useCallback(function (event) {
	        var callback = ref.current.onMouseDown;
	        if (callback) {
	            callback(event);
	        }
	        create(event);
	        disableProgrammatic.current = true;
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [create]);
	    var onMouseUp = require$$1.useCallback(function (event) {
	        var callback = ref.current.onMouseUp;
	        if (callback) {
	            callback(event);
	        }
	        release(event);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [release]);
	    var onMouseLeave = require$$1.useCallback(function (event) {
	        var callback = ref.current.onMouseLeave;
	        if (callback) {
	            callback(event);
	        }
	        cancel(true);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [cancel]);
	    var onTouchStart = require$$1.useCallback(function (event) {
	        var callback = ref.current.onTouchStart;
	        if (callback) {
	            callback(event);
	        }
	        create(event);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [create]);
	    var onTouchMove = require$$1.useCallback(function (event) {
	        var callback = ref.current.onTouchMove;
	        if (callback) {
	            callback(event);
	        }
	        cancel(false);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [cancel]);
	    var onTouchEnd = require$$1.useCallback(function (event) {
	        var callback = ref.current.onTouchEnd;
	        if (callback) {
	            callback(event);
	        }
	        release(event);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [release]);
	    var onClick = require$$1.useCallback(function (event) {
	        var _a = ref.current, callback = _a.onClick, disableProgrammaticRipple = _a.disableProgrammaticRipple;
	        if (callback) {
	            callback(event);
	        }
	        // when a click event is triggered and the current active element is not
	        // the event target, we know it was a true programmatic event and should
	        // trigger a ripple for it.
	        if (disableProgrammaticRipple ||
	            document.activeElement === event.currentTarget ||
	            disableProgrammatic.current) {
	            disableProgrammatic.current = false;
	            return;
	        }
	        create(event);
	    }, 
	    // disabled since useRefCache
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [create]);
	    return {
	        onKeyDown: disabled ? handlers.onKeyDown : onKeyDown,
	        onKeyUp: disabled ? handlers.onKeyUp : onKeyUp,
	        onMouseDown: disabled ? handlers.onMouseDown : onMouseDown,
	        onMouseUp: disabled ? handlers.onMouseUp : onMouseUp,
	        onMouseLeave: disabled ? handlers.onMouseLeave : onMouseLeave,
	        onTouchStart: disabled ? handlers.onTouchStart : onTouchStart,
	        onTouchMove: disabled ? handlers.onTouchMove : onTouchMove,
	        onTouchEnd: disabled ? handlers.onTouchEnd : onTouchEnd,
	        onClick: disabled || disableProgrammaticRipple ? handlers.onClick : onClick,
	    };
	}

	var __assign$2E = (undefined && undefined.__assign) || function () {
	    __assign$2E = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2E.apply(this, arguments);
	};
	var __rest$2f = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * A hook that will return an object containing the ripples element
	 * and an object of event handlers to apply to an element to trigger
	 * the ripple effects.
	 */
	function useRipples(_a) {
	    var rippleTimeout = _a.rippleTimeout, rippleClassNames = _a.rippleClassNames, rippleContainerClassName = _a.rippleContainerClassName, rippleClassName = _a.rippleClassName, disableRipple = _a.disableRipple, disableSpacebarClick = _a.disableSpacebarClick, options = __rest$2f(_a, ["rippleTimeout", "rippleClassNames", "rippleContainerClassName", "rippleClassName", "disableRipple", "disableSpacebarClick"]);
	    var _b = useRippleTransition(disableSpacebarClick), create = _b.create, state = _b.state, release = _b.release, entered = _b.entered, remove = _b.remove, cancel = _b.cancel;
	    var handlers = useRippleHandlers(__assign$2E({ create: create, release: release, cancel: cancel, disableRipple: disableRipple }, options));
	    return {
	        handlers: handlers,
	        ripples: disableRipple ? null : (jsxRuntime.exports.jsx(RippleContainer, { ripples: state, className: rippleContainerClassName, rippleClassName: rippleClassName, timeout: rippleTimeout, classNames: rippleClassNames, entered: entered, exited: remove }, "ripples")),
	    };
	}

	/**
	 * This small utility function will create an onKeyDown handler that allows the
	 * user to "click" an element with the keyboard via Enter or Space.
	 */
	function useKeyboardClickPolyfill(_a) {
	    var _b = _a === void 0 ? {} : _a, onKeyDown = _b.onKeyDown, _c = _b.disabled, disabled = _c === void 0 ? false : _c, _d = _b.disableEnterClick, disableEnterClick = _d === void 0 ? false : _d, _e = _b.disableSpacebarClick, disableSpacebarClick = _e === void 0 ? false : _e;
	    var ref = useRefCache({
	        onKeyDown: onKeyDown,
	        disableSpacebarClick: disableSpacebarClick,
	        disableEnterClick: disableEnterClick,
	    });
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        var _a = ref.current, onKeyDown = _a.onKeyDown, disableSpacebarClick = _a.disableSpacebarClick, disableEnterClick = _a.disableEnterClick;
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        var isSpace = event.key === " ";
	        var isEnter = event.key === "Enter";
	        var currentTarget = event.currentTarget;
	        var tagName = currentTarget.tagName;
	        if ((!isSpace && !isEnter) ||
	            (isSpace && disableSpacebarClick) ||
	            (isEnter && disableEnterClick) ||
	            // buttons and textareas, and inputs shouldn't be polyfilled
	            /BUTTON|TEXTAREA|INPUT/.test(tagName) ||
	            // native links don't click on space
	            (isSpace && tagName === "A")) {
	            return;
	        }
	        if (isSpace) {
	            // prevent default behavior of page scrolling
	            event.preventDefault();
	        }
	        // don't want parent keydown events to be triggered since this should now
	        // be a "click" event instead.
	        event.stopPropagation();
	        event.currentTarget.click();
	        // disabled since useRefCache
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    return disabled ? onKeyDown : handleKeyDown;
	}

	var __assign$2D = (undefined && undefined.__assign) || function () {
	    __assign$2D = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2D.apply(this, arguments);
	};
	var __read$L = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This is a different version of the useRippleStates that will allow you to
	 * know when a component is being pressed by the user. This is really just a
	 * fallback for when the ripples are disabled.
	 *
	 * This will return an object containing the current pressed state of the
	 * element as well as all the merged eventHandlers required to trigger the
	 * different states.
	 *
	 * NOTE: Unlike the ripple effect, this pressed states will not be triggered
	 * from a programmatic click event.
	 */
	function usePressedStates(_a) {
	    var _b = _a === void 0 ? {} : _a, _c = _b.handlers, handlers = _c === void 0 ? {} : _c, _d = _b.disableSpacebarClick, disableSpacebarClick = _d === void 0 ? false : _d;
	    var _e = __read$L(require$$1.useState(false), 2), pressed = _e[0], setPressed = _e[1];
	    var ref = useRefCache(__assign$2D(__assign$2D({}, handlers), { pressed: pressed }));
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        var _a = ref.current, onKeyDown = _a.onKeyDown, pressed = _a.pressed;
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        var key = event.key;
	        if (!pressed &&
	            (key === "Enter" || (!disableSpacebarClick && key === " "))) {
	            setPressed(true);
	        }
	    }, 
	    // disabled since useRefCache for ref
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [disableSpacebarClick]);
	    var handleKeyUp = require$$1.useCallback(function (event) {
	        var _a = ref.current, onKeyUp = _a.onKeyUp, pressed = _a.pressed;
	        if (onKeyUp) {
	            onKeyUp(event);
	        }
	        if (pressed) {
	            setPressed(false);
	        }
	        // disabled since useRefCache for ref
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var handleMouseDown = require$$1.useCallback(function (event) {
	        var _a = ref.current, onMouseDown = _a.onMouseDown, pressed = _a.pressed;
	        if (onMouseDown) {
	            onMouseDown(event);
	        }
	        if (!pressed && event.button === 0 && !isBubbled(event)) {
	            setPressed(true);
	        }
	        // disabled since useRefCache for ref
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var handleMouseUp = require$$1.useCallback(function (event) {
	        var _a = ref.current, onMouseUp = _a.onMouseUp, pressed = _a.pressed;
	        if (onMouseUp) {
	            onMouseUp(event);
	        }
	        if (pressed) {
	            setPressed(false);
	        }
	        // disabled since useRefCache for ref
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var handleMouseLeave = require$$1.useCallback(function (event) {
	        var _a = ref.current, onMouseLeave = _a.onMouseLeave, pressed = _a.pressed;
	        if (onMouseLeave) {
	            onMouseLeave(event);
	        }
	        if (pressed) {
	            setPressed(false);
	        }
	        // disabled since useRefCache for ref
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var handleTouchStart = require$$1.useCallback(function (event) {
	        var _a = ref.current, onTouchStart = _a.onTouchStart, pressed = _a.pressed;
	        if (onTouchStart) {
	            onTouchStart(event);
	        }
	        if (!pressed && !isBubbled(event)) {
	            setPressed(true);
	        }
	        // disabled since useRefCache for ref
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var handleTouchMove = require$$1.useCallback(function (event) {
	        var _a = ref.current, onTouchMove = _a.onTouchMove, pressed = _a.pressed;
	        if (onTouchMove) {
	            onTouchMove(event);
	        }
	        if (pressed) {
	            setPressed(false);
	        }
	        // disabled since useRefCache for ref
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    var handleTouchEnd = require$$1.useCallback(function (event) {
	        var _a = ref.current, onTouchEnd = _a.onTouchEnd, pressed = _a.pressed;
	        if (onTouchEnd) {
	            onTouchEnd(event);
	        }
	        if (pressed) {
	            setPressed(false);
	        }
	        // disabled since useRefCache for ref
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, []);
	    return {
	        pressed: pressed,
	        handlers: {
	            onClick: handlers.onClick,
	            onKeyDown: handleKeyDown,
	            onKeyUp: handleKeyUp,
	            onMouseDown: handleMouseDown,
	            onMouseUp: handleMouseUp,
	            onMouseLeave: handleMouseLeave,
	            onTouchStart: handleTouchStart,
	            onTouchMove: handleTouchMove,
	            onTouchEnd: handleTouchEnd,
	        },
	    };
	}

	var __assign$2C = (undefined && undefined.__assign) || function () {
	    __assign$2C = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2C.apply(this, arguments);
	};
	/**
	 * This is probably one of the most useful hook in react-md. Any functional
	 * component component that uses this will gain all the different interaction
	 * states based on the states context or any custom overrides.
	 *
	 * The main interaction state is the "ripple" effect when an element has been
	 * clicked either via keyboard, mouse, or touch.
	 *
	 * If the ripple effect is disabled, it will fallback to "polyfilling"/fixing
	 * the `:pressed` pseudo-selector state for items so that a different
	 * background-color opacity is applied instead of the entire ripple effect. This
	 * is polyfilled since the `:pressed` state does not work on anything other than
	 * buttons and links by default and it is not triggered on "valid" keyboard
	 * clicks with a spacebar.
	 *
	 * Finally, the element that uses this hook will gain a focused className
	 * whenever it gains keyboard focus only.
	 *
	 * To get all these interaction states to work correctly, this hook returns an
	 * object containing:
	 *
	 * - `handlers`- an object of event handlers that must be passed down to your
	 *   component to get the different interaction states. All the event handlers
	 *   are automatically merged with any `handlers` that are provided to this hook
	 *   so they can all be called if needed.
	 * - `className` - the current class name for the element
	 * - `ripples` - a renderable element that displays the ripple effects. This
	 *   will be `null` when ripples are disabled.
	 *
	 * @typeParam E - The element type for the component being wrapped. This is
	 * really just used to "better type" the event handlers.
	 */
	function useInteractionStates(options) {
	    if (options === void 0) { options = {}; }
	    var disabled = options.disabled, rippleClassName = options.rippleClassName, rippleContainerClassName = options.rippleContainerClassName, _a = options.disableSpacebarClick, disableSpacebarClick = _a === void 0 ? false : _a, _b = options.disablePressedFallback, disablePressedFallback = _b === void 0 ? false : _b, _c = options.enablePressedAndRipple, enablePressedAndRipple = _c === void 0 ? false : _c, _d = options.disableEnterClick, disableEnterClick = _d === void 0 ? false : _d;
	    var className = options.className, disableRipple = options.disableRipple, disableProgrammaticRipple = options.disableProgrammaticRipple, rippleTimeout = options.rippleTimeout; options.rippleClassNames;
	    // populate undefined props from their context values
	    var context = useStatesConfigContext();
	    if (typeof disableRipple === "undefined") {
	        (disableRipple = context.disableRipple);
	    }
	    if (typeof disableProgrammaticRipple === "undefined") {
	        (disableProgrammaticRipple = context.disableProgrammaticRipple);
	    }
	    if (typeof rippleTimeout === "undefined") {
	        (rippleTimeout = context.rippleTimeout);
	    }
	    var handlers = null;
	    var ripples = null;
	    var ripplesResult = useRipples(__assign$2C(__assign$2C({}, options), { disableSpacebarClick: disableSpacebarClick, disableRipple: disableRipple, disableProgrammaticRipple: disableProgrammaticRipple, rippleTimeout: rippleTimeout, rippleClassName: rippleClassName, rippleContainerClassName: rippleContainerClassName }));
	    if (!disableRipple) {
	        (ripples = ripplesResult.ripples, handlers = ripplesResult.handlers);
	    }
	    var pressedResult = usePressedStates(__assign$2C(__assign$2C({}, options), { handlers: handlers || options.handlers, disableSpacebarClick: disableSpacebarClick }));
	    if (enablePressedAndRipple || (disableRipple && !disablePressedFallback)) {
	        (handlers = pressedResult.handlers);
	        className = cn(className, { "rmd-states--pressed": pressedResult.pressed });
	    }
	    handlers = handlers || options.handlers || {};
	    handlers.onKeyDown = useKeyboardClickPolyfill({
	        disabled: disabled,
	        disableEnterClick: disableEnterClick,
	        disableSpacebarClick: disableSpacebarClick,
	        onKeyDown: handlers.onKeyDown,
	    });
	    return {
	        ripples: ripples,
	        className: className,
	        handlers: handlers,
	    };
	}

	var __assign$2B = (undefined && undefined.__assign) || function () {
	    __assign$2B = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2B.apply(this, arguments);
	};
	var __rest$2e = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$h = bem("rmd-fab");
	/**
	 * This is a simple wrapper for the `Button` component that will conditionally
	 * render the `Button` in a `<span>` to render as a floating action button.
	 *
	 * Note: You probably don't really want to use this externally since this is
	 * really just required so that the click and focus states behavior will still
	 * be contained within the button. The states behavior requires
	 * `position: relative` to work while changing into a floating action button
	 * makes it `position: fixed`.
	 */
	var FAB = require$$1.forwardRef(function FAB(_a, ref) {
	    var _b = _a.position, position = _b === void 0 ? null : _b, children = _a.children, className = _a.className, props = __rest$2e(_a, ["position", "children", "className"]);
	    if (!position) {
	        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children });
	    }
	    return (jsxRuntime.exports.jsx("span", __assign$2B({}, props, { ref: ref, className: cn(styles$h({
	            tl: position === "top-left",
	            tr: position === "top-right",
	            bl: position === "bottom-left",
	            br: position === "bottom-right",
	        }), className) }, { children: children })));
	});

	var __assign$2A = (undefined && undefined.__assign) || function () {
	    __assign$2A = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2A.apply(this, arguments);
	};
	var __rest$2d = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `Button` component is a simple wrapper for the `<button>` element that
	 * defaults the `type` attribute to `"button"` so that it does not automatically
	 * submit forms by default. It also supports multiple themes, rendering as an
	 * icon button, or even as a floating action button.
	 *
	 * The default theme will be a clear text button unless the `floating` prop has
	 * been provided where it will render as an icon button by default instead.
	 */
	var Button = require$$1.forwardRef(function Button(_a, ref) {
	    var _b = _a.type, type = _b === void 0 ? "button" : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, _d = _a.floating, floating = _d === void 0 ? null : _d, floatingProps = _a.floatingProps, _e = _a.theme, theme = _e === void 0 ? floating ? "secondary" : "clear" : _e, _f = _a.themeType, themeType = _f === void 0 ? floating ? "contained" : "flat" : _f, _g = _a.buttonType, buttonType = _g === void 0 ? floating ? "icon" : "text" : _g, propClassName = _a.className, children = _a.children, disableRipple = _a.disableRipple, disableProgrammaticRipple = _a.disableProgrammaticRipple, rippleTimeout = _a.rippleTimeout, rippleClassNames = _a.rippleClassNames, rippleClassName = _a.rippleClassName, rippleContainerClassName = _a.rippleContainerClassName, propEnablePressedAndRipple = _a.enablePressedAndRipple, disablePressedFallback = _a.disablePressedFallback, onClick = _a.onClick, onKeyUp = _a.onKeyUp, onKeyDown = _a.onKeyDown, onMouseUp = _a.onMouseUp, onMouseDown = _a.onMouseDown, onMouseLeave = _a.onMouseLeave, onTouchStart = _a.onTouchStart, onTouchMove = _a.onTouchMove, onTouchEnd = _a.onTouchEnd, props = __rest$2d(_a, ["type", "disabled", "floating", "floatingProps", "theme", "themeType", "buttonType", "className", "children", "disableRipple", "disableProgrammaticRipple", "rippleTimeout", "rippleClassNames", "rippleClassName", "rippleContainerClassName", "enablePressedAndRipple", "disablePressedFallback", "onClick", "onKeyUp", "onKeyDown", "onMouseUp", "onMouseDown", "onMouseLeave", "onTouchStart", "onTouchMove", "onTouchEnd"]);
	    var enablePressedAndRipple = typeof propEnablePressedAndRipple === "boolean"
	        ? propEnablePressedAndRipple
	        : themeType === "contained";
	    var propHandlers = {
	        onClick: onClick,
	        onKeyUp: onKeyUp,
	        onKeyDown: onKeyDown,
	        onMouseUp: onMouseUp,
	        onMouseDown: onMouseDown,
	        onMouseLeave: onMouseLeave,
	        onTouchStart: onTouchStart,
	        onTouchMove: onTouchMove,
	        onTouchEnd: onTouchEnd,
	    };
	    var isDisabledTheme = theme === "disabled";
	    var _h = useInteractionStates({
	        handlers: propHandlers,
	        className: buttonThemeClassNames({
	            theme: theme,
	            themeType: themeType,
	            buttonType: buttonType,
	            disabled: disabled,
	            className: propClassName,
	        }),
	        disabled: disabled || isDisabledTheme,
	        disableRipple: disableRipple,
	        disableProgrammaticRipple: disableProgrammaticRipple,
	        disablePressedFallback: disablePressedFallback,
	        rippleTimeout: rippleTimeout,
	        rippleClassNames: rippleClassNames,
	        rippleClassName: rippleClassName,
	        rippleContainerClassName: rippleContainerClassName,
	        enablePressedAndRipple: enablePressedAndRipple,
	    }), ripples = _h.ripples, className = _h.className, handlers = _h.handlers;
	    return (jsxRuntime.exports.jsx(FAB, __assign$2A({ position: floating }, floatingProps, { children: jsxRuntime.exports.jsxs("button", __assign$2A({ "aria-disabled": isDisabledTheme || undefined }, props, (isDisabledTheme ? undefined : handlers), { ref: ref, type: type, className: className, disabled: disabled }, { children: [children, ripples] })) })));
	});

	var __assign$2z = (undefined && undefined.__assign) || function () {
	    __assign$2z = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2z.apply(this, arguments);
	};
	var __rest$2c = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The unstyled button is a really simple button element that resets the default
	 * browser button styles into a clear clickable element.
	 */
	var UnstyledButton = require$$1.forwardRef(function UnstyledButton(_a, ref) {
	    var className = _a.className, children = _a.children, props = __rest$2c(_a, ["className", "children"]);
	    return (jsxRuntime.exports.jsx("button", __assign$2z({}, props, { type: "button", ref: ref, className: cn("rmd-button-unstyled", className) }, { children: children })));
	});

	var __assign$2y = (undefined && undefined.__assign) || function () {
	    __assign$2y = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2y.apply(this, arguments);
	};
	var __rest$2b = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$K = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	function getId(snackbarId, toastId, actionId) {
	    if (actionId) {
	        return actionId;
	    }
	    if (toastId) {
	        return "".concat(toastId, "-action");
	    }
	    return "".concat(snackbarId, "-action");
	}
	/**
	 * Because the toast renderer is a callback function instead of a React
	 * component, it's actually required to create a separate component instance so
	 * that the context API can be
	 *
	 * @internal
	 */
	function SnackbarQueueT(_a, ref) {
	    var queue = _a.queue, onActionClick = _a.onActionClick, props = __rest$2b(_a, ["queue", "onActionClick"]);
	    var _b = __read$K(queue, 1), toast = _b[0];
	    var visible = useMessageVisibility();
	    var _c = useMessageQueueActions(), popMessage = _c.popMessage, hideMessage = _c.hideMessage, startTimer = _c.startTimer;
	    var content = null;
	    if (toast) {
	        var snackbarId = props.id;
	        var toastId = toast.id;
	        toast.messageId; toast.messagePriority; var _d = toast.disableAutohide, disableAutohide = _d === void 0 ? false : _d, _e = toast.disableActionHide, disableActionHide_1 = _e === void 0 ? false : _e, providedAction = toast.action, toastProps = __rest$2b(toast, ["messageId", "messagePriority", "disableAutohide", "disableActionHide", "action"]);
	        var action = null;
	        if (providedAction) {
	            var actionProps_1 = providedAction;
	            var onClick = function (event) {
	                if (onActionClick) {
	                    onActionClick(toast, event);
	                }
	                if (actionProps_1.onClick) {
	                    actionProps_1.onClick(event);
	                }
	                if (!disableActionHide_1) {
	                    hideMessage();
	                }
	            };
	            var t = typeof providedAction;
	            if (require$$1.isValidElement(providedAction) || t !== "object") {
	                action = (jsxRuntime.exports.jsx(Button, __assign$2y({ id: getId(snackbarId, toastId, undefined), onClick: onClick, theme: "secondary" }, { children: providedAction })));
	            }
	            else {
	                action = (jsxRuntime.exports.jsx(Button, __assign$2y({ id: getId(snackbarId, toastId, actionProps_1.id), theme: "secondary" }, actionProps_1, { onClick: onClick })));
	            }
	        }
	        content = (jsxRuntime.exports.jsx(Toast, __assign$2y({}, toastProps, { action: action, visible: visible, onEntered: disableAutohide ? undefined : startTimer, onExited: popMessage })));
	    }
	    return (jsxRuntime.exports.jsx(Snackbar, __assign$2y({}, props, { ref: ref }, { children: content })));
	}
	var SnackbarQueue = require$$1.forwardRef(SnackbarQueueT);

	/**
	 * This hook is used to pause the exit timeout if the user blurs the window
	 * while a toast is visible and the autohide functionality is not disabled. If
	 * this functionality is not added, messages and alerts might be missed by the
	 * user since they minimized the browser or viewing something on a second
	 * screen.
	 *
	 * @internal
	 */
	function useWindowBlurPause(_a) {
	    var startTimer = _a.startTimer, stopTimer = _a.stopTimer, visible = _a.visible, message = _a.message, _b = _a.disabled, disabled = _b === void 0 ? false : _b;
	    require$$1.useEffect(function () {
	        if (disabled || !visible || !message || message.disableAutohide) {
	            return;
	        }
	        var handleFocusEvent = function (event) {
	            if (event.type === "focus") {
	                startTimer();
	            }
	            else {
	                stopTimer();
	            }
	        };
	        window.addEventListener("blur", handleFocusEvent);
	        window.addEventListener("focus", handleFocusEvent);
	        return function () {
	            window.removeEventListener("blur", handleFocusEvent);
	            window.removeEventListener("focus", handleFocusEvent);
	        };
	    }, [disabled, startTimer, stopTimer, visible, message]);
	}

	var __read$J = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$9 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var ADD_MESSAGE = "ADD_MESSAGE";
	var POP_MESSAGE = "POP_MESSAGE";
	var RESET_QUEUE = "RESET_QUEUE";
	/**
	 * @internal
	 */
	var popMessage = function () { return ({ type: POP_MESSAGE }); };
	/**
	 * @internal
	 */
	var resetQueue = function () { return ({ type: RESET_QUEUE }); };
	/**
	 * This function is used to update the message queue state by adding a new
	 * message when needed.
	 *
	 * @internal
	 */
	function handleAddMessage(state, message, duplicates) {
	    if (state.length === 0) {
	        return [message];
	    }
	    var messageId = message.messageId, _a = message.messagePriority, messagePriority = _a === void 0 ? "normal" : _a;
	    var i = state.findIndex(function (mes) { return mes.messageId === messageId; });
	    var isNext = messagePriority === "next";
	    var isNormal = messagePriority === "normal";
	    var isReplace = messagePriority === "replace";
	    var isImmediate = messagePriority === "immediate";
	    var isDuplicable = duplicates === "allow";
	    var isRestart = duplicates === "restart";
	    if (isNext || isImmediate) {
	        var nextState = state.slice();
	        // remove the existing message if duplicated messages aren't allowed. This
	        // will kind of act like a replace + next behavior
	        if (!isDuplicable && i > 0) {
	            nextState.splice(i, 1);
	        }
	        var _b = __read$J(nextState), current = _b[0], remaining = _b.slice(1);
	        if (isImmediate && current.messagePriority !== "immediate") {
	            return __spreadArray$9([current, message, current], __read$J(remaining), false);
	        }
	        return __spreadArray$9([current, message], __read$J(remaining), false);
	    }
	    if (i === -1 || (isDuplicable && isNormal)) {
	        return __spreadArray$9(__spreadArray$9([], __read$J(state), false), [message], false);
	    }
	    if (isNormal) {
	        if (isRestart) {
	            // creating a new state so that the queue visibility hook can still be
	            // triggered which will restart the timer
	            return state.slice();
	        }
	        return state;
	    }
	    if (isReplace) {
	        var nextState = state.slice();
	        nextState[i] = message;
	        return nextState;
	    }
	    return __spreadArray$9(__spreadArray$9([], __read$J(state), false), [message], false);
	}
	/**
	 * @internal
	 */
	function reducer(state, action) {
	    switch (action.type) {
	        case ADD_MESSAGE:
	            return handleAddMessage(state, action.message, action.duplicates);
	        case POP_MESSAGE:
	            return state.length ? state.slice(1) : state;
	        case RESET_QUEUE:
	            return state.length ? [] : state;
	        default:
	            return state;
	    }
	}
	/**
	 * This is the main logic for the message queue behavior that will handle:
	 *
	 * - creating timeouts as needed to show/hide toasts within the `SnackbarQueue`
	 *   component
	 * - create a way to push messages with optional priority onto the queue
	 *
	 * @internal
	 */
	function useMessageQueue(_a) {
	    var _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b, _c = _a.duplicates, duplicates = _c === void 0 ? "allow" : _c, _d = _a.defaultQueue, defaultQueue = _d === void 0 ? [] : _d;
	    var _e = __read$J(require$$1.useReducer(function (state, action) { return reducer(state, action); }, defaultQueue), 2), queue = _e[0], dispatch = _e[1];
	    var queueRef = require$$1.useRef(queue);
	    var addMessageDispatch = require$$1.useCallback(function (message) {
	        if (duplicates !== "allow" && !message.messageId) {
	            throw new Error("A messageId is required when the \"".concat(duplicates, "\" duplicate behavior is enabled but it was not provided in the current message."));
	        }
	        dispatch({ type: ADD_MESSAGE, message: message, duplicates: duplicates });
	    }, [duplicates]);
	    var popMessageDispatch = require$$1.useCallback(function () {
	        dispatch(popMessage());
	    }, []);
	    var resetQueueDispatch = require$$1.useCallback(function () {
	        dispatch(resetQueue());
	        return queueRef.current;
	    }, []);
	    var _f = __read$J(useToggle(defaultQueue.length > 0), 3), visible = _f[0], showMessage = _f[1], hideMessage = _f[2];
	    var _g = __read$J(useTimeout(hideMessage, timeout), 3), startTimer = _g[0], stopTimer = _g[1], restartTimer = _g[2];
	    require$$1.useEffect(function () {
	        // this effect will handle all the "logic" for transitioning between each
	        // message along with the message priority updates.
	        var _a = __read$J(queue, 2), message = _a[0], nextMessage = _a[1];
	        if (!message) {
	            return;
	        }
	        var prevQueue = queueRef.current;
	        var _b = __read$J(prevQueue, 1), prevMessage = _b[0];
	        if (message.messagePriority !== "immediate" &&
	            nextMessage &&
	            nextMessage.messagePriority === "immediate") {
	            stopTimer();
	            if (!visible) {
	                popMessageDispatch();
	                return;
	            }
	            hideMessage();
	            return;
	        }
	        if (!visible) {
	            showMessage();
	        }
	        if (queue.length === prevQueue.length && message === prevMessage) {
	            restartTimer();
	        }
	        // only want to run this on queue changes
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [queue]);
	    useWindowBlurPause({
	        startTimer: startTimer,
	        stopTimer: stopTimer,
	        visible: visible,
	        message: queue[0],
	    });
	    require$$1.useEffect(function () {
	        queueRef.current = queue;
	    });
	    return {
	        queue: queue,
	        resetQueue: resetQueueDispatch,
	        visible: visible,
	        hideMessage: hideMessage,
	        addMessage: addMessageDispatch,
	        popMessage: popMessageDispatch,
	        startTimer: startTimer,
	        stopTimer: stopTimer,
	        restartTimer: restartTimer,
	    };
	}

	var __assign$2x = (undefined && undefined.__assign) || function () {
	    __assign$2x = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2x.apply(this, arguments);
	};
	var __rest$2a = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is used to be able to create a queue of messages with the
	 * `Snackbar` and `Toast` components with a _fairly_ decent API out of the box.
	 */
	function MessageQueue(_a) {
	    var _b = _a.timeout, timeout = _b === void 0 ? 5000 : _b, _c = _a.duplicates, duplicates = _c === void 0 ? "allow" : _c, _d = _a.defaultQueue, defaultQueue = _d === void 0 ? [] : _d, children = _a.children, props = __rest$2a(_a, ["timeout", "duplicates", "defaultQueue", "children"]);
	    var _e = useMessageQueue({ timeout: timeout, duplicates: duplicates, defaultQueue: defaultQueue }), queue = _e.queue, visible = _e.visible, hideMessage = _e.hideMessage, startTimer = _e.startTimer, stopTimer = _e.stopTimer, restartTimer = _e.restartTimer, addMessage = _e.addMessage, popMessage = _e.popMessage, resetQueue = _e.resetQueue;
	    var actions = require$$1.useMemo(function () { return ({
	        popMessage: popMessage,
	        hideMessage: hideMessage,
	        startTimer: startTimer,
	        stopTimer: stopTimer,
	        resetQueue: resetQueue,
	        restartTimer: restartTimer,
	    }); }, [popMessage, hideMessage, startTimer, stopTimer, restartTimer, resetQueue]);
	    return (jsxRuntime.exports.jsx(AddMessageContext.Provider, __assign$2x({ value: addMessage }, { children: jsxRuntime.exports.jsx(MessageQueueActionsContext.Provider, __assign$2x({ value: actions }, { children: jsxRuntime.exports.jsxs(MessageVisibilityContext.Provider, __assign$2x({ value: visible }, { children: [jsxRuntime.exports.jsx(MessageQueueContext.Provider, __assign$2x({ value: queue }, { children: children })), jsxRuntime.exports.jsx(SnackbarQueue, __assign$2x({}, props, { queue: queue }))] })) })) })));
	}

	/**
	 * Boolean if the child components should inherit the color of the app bar.
	 * @internal
	 */
	var InheritContext = require$$1.createContext(false);
	/**
	 * This is probably a bit overkill... but this is used so that all the AppBar
	 * child components can automatically inherit the base color as needed within an
	 * AppBar. If the `inheritColor` prop was provided to the component, that value
	 * will be used instead.
	 *
	 * @param inheritColor - The prop inheritColor for the component
	 * @returns true if the color should be inherited.
	 * @internal
	 */
	function useInheritContext(inheritColor) {
	    var inheritContext = require$$1.useContext(InheritContext);
	    return typeof inheritColor === "boolean" ? inheritColor : inheritContext;
	}
	/**
	 * Boolean if there is a parent app bar. The theme colors will be inherited from
	 * the parent app bar instead of the current app bar for these cases since
	 * nested app bars usually happen with prominent toolbars and the root app bar
	 * defines the theme.
	 *
	 * @internal
	 */
	var ParentContext = require$$1.createContext(false);
	/**
	 *
	 * @internal
	 */
	function useParentContext() {
	    return require$$1.useContext(ParentContext);
	}

	var __assign$2w = (undefined && undefined.__assign) || function () {
	    __assign$2w = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2w.apply(this, arguments);
	};
	var __rest$29 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$14 = bem("rmd-app-bar");
	/**
	 * This component is used to create a top-level app bar in your application that
	 * can be used to contain a navigation menu toggle button, the app's logo and/or
	 * title, as well as any top-level actions that will be reused throughout your
	 * app. When using this component with the `fixed` prop, it is recommended to
	 * also use one of the "offset class names" so that your content will not be
	 * converted by the app bar. You can also use any of the exposed mixins to add
	 * these offsets as well.
	 */
	var AppBar = require$$1.forwardRef(function AppBar(_a, ref) {
	    var _b;
	    var className = _a.className, children = _a.children, _c = _a.theme, propTheme = _c === void 0 ? "primary" : _c, _d = _a.component, propComponent = _d === void 0 ? "header" : _d, _e = _a.height, height = _e === void 0 ? "normal" : _e, _f = _a.fixed, fixed = _f === void 0 ? false : _f, _g = _a.fixedPosition, fixedPosition = _g === void 0 ? "top" : _g, _h = _a.fixedElevation, fixedElevation = _h === void 0 ? true : _h, inheritColor = _a.inheritColor, _j = _a.flexWrap, flexWrap = _j === void 0 ? height === "none" ||
	        height === "prominent" ||
	        height === "prominent-dense" : _j, remaining = __rest$29(_a, ["className", "children", "theme", "component", "height", "fixed", "fixedPosition", "fixedElevation", "inheritColor", "flexWrap"]);
	    var parentContext = useParentContext();
	    var inheritContext = useInheritContext(undefined);
	    var inherit;
	    var theme = propTheme;
	    var Component = propComponent;
	    if (typeof inheritColor === "boolean") {
	        inherit = inheritColor;
	    }
	    else if (parentContext) {
	        inherit = inheritContext;
	        theme = "clear";
	        Component = "div";
	    }
	    else {
	        inherit = theme !== "clear" && theme !== "default";
	    }
	    return (jsxRuntime.exports.jsx(ParentContext.Provider, __assign$2w({ value: true }, { children: jsxRuntime.exports.jsx(InheritContext.Provider, __assign$2w({ value: inherit }, { children: jsxRuntime.exports.jsx(Component, __assign$2w({}, remaining, { className: cn(block$14((_b = {},
	                    _b[theme] = theme !== "clear",
	                    _b[height] = height !== "none",
	                    _b.wrap = flexWrap,
	                    _b.fixed = fixed,
	                    _b[fixedPosition] = fixed,
	                    _b["fixed-elevation"] = fixed && fixedElevation,
	                    _b)), className), ref: ref }, { children: children })) })) })));
	});

	var __assign$2v = (undefined && undefined.__assign) || function () {
	    __assign$2v = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2v.apply(this, arguments);
	};
	var __rest$28 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$13 = bem("rmd-app-bar");
	/**
	 * This component is used to create a title for your application. If your app is
	 * not using the `AppBarNav` component, you can enable the `keyline` prop to
	 * ensure that your title aligns with the keyline of your navigation element.
	 */
	var AppBarTitle = require$$1.forwardRef(function AppBarTitle(_a, ref) {
	    var _b = _a.noWrap, noWrap = _b === void 0 ? true : _b, _c = _a.keyline, keyline = _c === void 0 ? false : _c, className = _a.className, children = _a.children, inheritColor = _a.inheritColor, props = __rest$28(_a, ["noWrap", "keyline", "className", "children", "inheritColor"]);
	    return (jsxRuntime.exports.jsx("h6", __assign$2v({}, props, { ref: ref, className: cn(block$13("title", {
	            "no-wrap": noWrap,
	            keyline: keyline,
	            inherit: useInheritContext(inheritColor),
	        }), className) }, { children: children })));
	});

	var __assign$2u = (undefined && undefined.__assign) || function () {
	    __assign$2u = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2u.apply(this, arguments);
	};
	var __rest$27 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$12 = bem("rmd-app-bar");
	/**
	 * This component is really just a simple wrapper for the `Button` component
	 * that adds some additional styles for adding spacing before and after this
	 * button so that it aligns to the main "keyline" of your application's
	 * navigation. In simpler terms, it will make the left side of the icon in this
	 * button aligns with all the other icons that appear in `ListItem`s in your
	 * main navigation.
	 *
	 * This component is generally really only used when you want to have a
	 * temporary navigation element like a hamburger menu.
	 */
	var AppBarNav = require$$1.forwardRef(function AppBarNav(_a, ref) {
	    var className = _a.className, children = _a.children, inheritColor = _a.inheritColor, floating = _a.floating, _b = _a.theme, theme = _b === void 0 ? floating ? "secondary" : "clear" : _b, _c = _a.buttonType, buttonType = _c === void 0 ? "icon" : _c, props = __rest$27(_a, ["className", "children", "inheritColor", "floating", "theme", "buttonType"]);
	    return (jsxRuntime.exports.jsx(Button, __assign$2u({}, props, { theme: theme, floating: floating, buttonType: buttonType, ref: ref, className: cn(block$12("nav", {
	            inherit: useInheritContext(inheritColor),
	        }), className) }, { children: children })));
	});

	var block$11 = bem("rmd-app-bar");
	/**
	 * This is a hook that will apply the nav classnames to an element. This should
	 * really not be used externally and is really just for creating dropdown menus
	 * within app bars that have the action styles.
	 *
	 * @internal
	 */
	function useActionClassName(_a) {
	    var _b = _a === void 0 ? {} : _a, first = _b.first, last = _b.last, inheritColor = _b.inheritColor, className = _b.className;
	    return cn(block$11("action", {
	        first: first,
	        last: last,
	        inherit: useInheritContext(inheritColor),
	    }), className);
	}

	var __assign$2t = (undefined && undefined.__assign) || function () {
	    __assign$2t = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2t.apply(this, arguments);
	};
	var __rest$26 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is really just a simple wrapper for the `Button` component
	 * that adds a few additional styles to prevent the button from shrinking when
	 * an `AppBar` has a lot of content.  It also will automatically add spacing
	 * either before or after this button when the `first` or `last` props are
	 * provided.
	 */
	var AppBarAction = require$$1.forwardRef(function AppBarAction(_a, ref) {
	    var className = _a.className, _b = _a.first, first = _b === void 0 ? false : _b, _c = _a.last, last = _c === void 0 ? false : _c, children = _a.children, inheritColor = _a.inheritColor, floating = _a.floating, _d = _a.theme, theme = _d === void 0 ? floating ? "secondary" : "clear" : _d, _e = _a.buttonType, buttonType = _e === void 0 ? "icon" : _e, props = __rest$26(_a, ["className", "first", "last", "children", "inheritColor", "floating", "theme", "buttonType"]);
	    return (jsxRuntime.exports.jsx(Button, __assign$2t({}, props, { theme: theme, buttonType: buttonType, floating: floating, ref: ref, className: useActionClassName({ first: first, last: last, inheritColor: inheritColor, className: className }) }, { children: children })));
	});

	/**
	 * A classname to apply to an element that should be offset either with padding
	 * or margin by the height of a normal App Bar.
	 */
	var APP_BAR_OFFSET_CLASSNAME = "rmd-app-bar-offset";
	/**
	 * A classname to apply to an element that should be offset either with padding
	 * or margin by the height of a dense App Bar.
	 */
	var APP_BAR_OFFSET_DENSE_CLASSNAME = "rmd-app-bar-offset--dense";
	/**
	 * A classname to apply to an element that should be offset either with padding
	 * or margin by the height of a prominent App Bar.
	 */
	var APP_BAR_OFFSET_PROMINENT_CLASSNAME = "rmd-app-bar-offset--prominent";
	/**
	 * A classname to apply to an element that should be offset either with padding
	 * or margin by the height of a prominent and dense App Bar.
	 */
	var APP_BAR_OFFSET_PROMINENT_DENSE_CLASSNAME = "rmd-app-bar-offset--prominent-dense";

	var __assign$2s = (undefined && undefined.__assign) || function () {
	    __assign$2s = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2s.apply(this, arguments);
	};
	var __rest$25 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is probably one of the least useful components available as it doesn't
	 * do much styling or logic. All this form component will do is add basic flex
	 * behavior and prevent the default form submit behavior.
	 */
	var Form = require$$1.forwardRef(function Form(_a, ref) {
	    var children = _a.children, _b = _a.disablePreventDefault, disablePreventDefault = _b === void 0 ? false : _b, onSubmit = _a.onSubmit, props = __rest$25(_a, ["children", "disablePreventDefault", "onSubmit"]);
	    var handleOnSubmit = require$$1.useCallback(function (event) {
	        if (!disablePreventDefault) {
	            event.preventDefault();
	        }
	        if (onSubmit) {
	            onSubmit(event);
	        }
	    }, [disablePreventDefault, onSubmit]);
	    return (jsxRuntime.exports.jsx("form", __assign$2s({}, props, { onSubmit: handleOnSubmit, ref: ref }, { children: children })));
	});

	var __assign$2r = (undefined && undefined.__assign) || function () {
	    __assign$2r = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2r.apply(this, arguments);
	};
	var __rest$24 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$10 = bem("rmd-fieldset");
	/**
	 * This is a simple wrapper for the `<fieldset>` that defaults to removing
	 * the default styles of a border, padding, and margin and having a screen-reader
	 * visible only legend element for added accessibility.
	 */
	var Fieldset = require$$1.forwardRef(function Fieldset(_a, ref) {
	    var className = _a.className, legend = _a.legend, legendStyle = _a.legendStyle, legendClassName = _a.legendClassName, _b = _a.legendSROnly, legendSROnly = _b === void 0 ? false : _b, _c = _a.unstyled, unstyled = _c === void 0 ? true : _c, children = _a.children, props = __rest$24(_a, ["className", "legend", "legendStyle", "legendClassName", "legendSROnly", "unstyled", "children"]);
	    return (jsxRuntime.exports.jsxs("fieldset", __assign$2r({}, props, { ref: ref, className: cn(block$10({ unstyled: unstyled }), className) }, { children: [jsxRuntime.exports.jsx("legend", __assign$2r({ style: legendStyle, className: cn(block$10("legend", { "sr-only": legendSROnly }), legendClassName) }, { children: legend })), children] })));
	});

	var __assign$2q = (undefined && undefined.__assign) || function () {
	    __assign$2q = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2q.apply(this, arguments);
	};
	var context$b = require$$1.createContext({
	    theme: "outline",
	    underlineDirection: "left",
	});
	/**
	 * Gets the current theme values for a form component by inheriting the current
	 * form theme via context. If you provide an object of theme props, the returned
	 * value will use any defined values from the theme props and fallback to the
	 * context value.
	 *
	 * Example:
	 * ```ts
	 * // everything is inherited
	 * const formTheme = useFormTheme();
	 *
	 * // theme will be set to "underline" while the others will be inherited
	 * const formTheme = useFormTheme({ theme: "underline" });
	 * ```
	 */
	function useFormTheme(options) {
	    if (options === void 0) { options = {}; }
	    var formTheme = require$$1.useContext(context$b);
	    var theme = options.theme, underlineDirection = options.underlineDirection;
	    theme = theme !== null && theme !== void 0 ? theme : formTheme.theme;
	    underlineDirection = underlineDirection !== null && underlineDirection !== void 0 ? underlineDirection : formTheme.underlineDirection;
	    return {
	        theme: theme,
	        underlineDirection: underlineDirection,
	    };
	}
	var Provider$8 = context$b.Provider;
	/**
	 * Since you'll normally want all of your form components to use the same theme,
	 * this is a simple way to provide the same theme to all components without
	 * needing all the prop-drilling/copying.
	 */
	function FormThemeProvider(_a) {
	    var _b = _a.theme, theme = _b === void 0 ? "outline" : _b, _c = _a.underlineDirection, underlineDirection = _c === void 0 ? "left" : _c, children = _a.children;
	    var value = require$$1.useMemo(function () { return ({ theme: theme, underlineDirection: underlineDirection }); }, [theme, underlineDirection]);
	    return jsxRuntime.exports.jsx(Provider$8, __assign$2q({ value: value }, { children: children }));
	}

	var __assign$2p = (undefined && undefined.__assign) || function () {
	    __assign$2p = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2p.apply(this, arguments);
	};
	var __rest$23 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$$ = bem("rmd-form-message");
	/**
	 * This component can be used to create a "counter" within the
	 * {@link FormMessage} component.
	 *
	 * Note: This is really only useful when using the {@link FormMessage} component
	 * without a {@link TextField}.
	 *
	 * @example
	 * Example Usage
	 * ```ts
	 * interface ExampleProps {
	 *   min: number;
	 *   max: number;
	 * }
	 *
	 * function Example({ min, max }: ExampleProps) {
	 *   return (
	 *     <FormMessage disableWrap>
	 *       <FormMessageCounter>
	 *         {`${min} / ${max}`}
	 *       </FormMessageCounter>
	 *     </FormMessage>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 2.9.0
	 */
	function FormMessageCounter(_a) {
	    var children = _a.children, className = _a.className, props = __rest$23(_a, ["children", "className"]);
	    return (jsxRuntime.exports.jsx("span", __assign$2p({}, props, { className: cn(block$$("counter"), className) }, { children: children })));
	}

	var __assign$2o = (undefined && undefined.__assign) || function () {
	    __assign$2o = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2o.apply(this, arguments);
	};
	var __rest$22 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$_ = bem("rmd-form-message");
	/**
	 * The `FormMessage` component is used to create additional helper messages or
	 * error messages and generally placed below the related `TextField`. If a
	 * `length` (of the `value`) and `maxLength` are provided, a counter will also
	 * be displayed to the right of the `children`.
	 *
	 * This component can also be used to create form-level validation messages by
	 * setting the `role` prop to `"alert"`.
	 */
	var FormMessage = require$$1.forwardRef(function FormMessage(_a, ref) {
	    var _b;
	    var id = _a.id, role = _a.role, className = _a.className, counterStyle = _a.counterStyle, counterClassName = _a.counterClassName, messageStyle = _a.messageStyle, messageClassName = _a.messageClassName, _c = _a.error, error = _c === void 0 ? false : _c, _d = _a.disableWrap, disableWrap = _d === void 0 ? false : _d, propTheme = _a.theme, children = _a.children, length = _a.length, maxLength = _a.maxLength, props = __rest$22(_a, ["id", "role", "className", "counterStyle", "counterClassName", "messageStyle", "messageClassName", "error", "disableWrap", "theme", "children", "length", "maxLength"]);
	    var theme = useFormTheme({ theme: propTheme }).theme;
	    var message = children;
	    if (!disableWrap && children) {
	        message = (jsxRuntime.exports.jsx("p", __assign$2o({ id: "".concat(id, "-message"), style: messageStyle, className: cn(block$_("message"), messageClassName) }, { children: children })));
	    }
	    return (jsxRuntime.exports.jsxs("div", __assign$2o({}, props, { id: id, ref: ref, "aria-live": role !== "alert" ? "polite" : undefined, role: role, className: cn(block$_((_b = {
	                error: error
	            },
	            _b[theme] = theme !== "none",
	            _b)), className) }, { children: [message, typeof length === "number" && typeof maxLength === "number" && (jsxRuntime.exports.jsx(FormMessageCounter, __assign$2o({ id: "".concat(id, "-counter"), style: counterStyle, className: counterClassName }, { children: "".concat(length, " / ").concat(maxLength) })))] })));
	});

	var __assign$2n = (undefined && undefined.__assign) || function () {
	    __assign$2n = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2n.apply(this, arguments);
	};
	var __rest$21 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * A wrapper component that can be used to display a `TextField` related
	 * component or `TextArea` along with the `FormMessage` component.
	 *
	 * @remarks \@since 2.5.0
	 */
	var FormMessageContainer = require$$1.forwardRef(function FormMessageContainer(_a, ref) {
	    var className = _a.className, children = _a.children, messageProps = _a.messageProps, props = __rest$21(_a, ["className", "children", "messageProps"]);
	    if (!messageProps) {
	        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children });
	    }
	    return (jsxRuntime.exports.jsxs("div", __assign$2n({}, props, { ref: ref, className: cn("rmd-field-message-container", className) }, { children: [children, jsxRuntime.exports.jsx(FormMessage, __assign$2n({}, messageProps))] })));
	});

	var __assign$2m = (undefined && undefined.__assign) || function () {
	    __assign$2m = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2m.apply(this, arguments);
	};
	var __rest$20 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$Z = bem("rmd-icon");
	/**
	 * The `FontIcon` component is used for rendering a font-icon library's icon.
	 * The default is to use the `material-icons` library, but others can be used as
	 * well.
	 *
	 * If you are using another font icon library that does not always create icons
	 * with a perfect 1:1 scale (such as font awesome), it is recommended to use the
	 * `forceSize` and `forceFontSize` props to fix the sizing issues.
	 */
	var FontIcon = require$$1.forwardRef(function FontIcon(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a["aria-hidden"], ariaHidden = _b === void 0 ? true : _b, _c = _a.dense, dense = _c === void 0 ? false : _c, _d = _a.iconClassName, iconClassName = _d === void 0 ? "material-icons" : _d, _e = _a.forceSize, forceSize = _e === void 0 ? false : _e, _f = _a.forceFontSize, forceFontSize = _f === void 0 ? false : _f, props = __rest$20(_a, ["className", "children", "aria-hidden", "dense", "iconClassName", "forceSize", "forceFontSize"]);
	    return (jsxRuntime.exports.jsx("i", __assign$2m({}, props, { "aria-hidden": ariaHidden, ref: ref, className: cn(block$Z({
	            font: true,
	            dense: dense,
	            "forced-font": forceFontSize,
	            "forced-size": forceSize,
	        }), iconClassName, className) }, { children: children })));
	});

	var __assign$2l = (undefined && undefined.__assign) || function () {
	    __assign$2l = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2l.apply(this, arguments);
	};
	var __rest$1$ = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$Y = bem("rmd-icon");
	/**
	 * The `SVGIcon` component is used to render inline SVG icons or SVG icons in a
	 * sprite map as an icon.
	 */
	var SVGIcon = require$$1.forwardRef(function SVGIcon(_a, ref) {
	    var _b = _a["aria-hidden"], ariaHidden = _b === void 0 ? true : _b, _c = _a.focusable, focusable = _c === void 0 ? "false" : _c, _d = _a.xmlns, xmlns = _d === void 0 ? "http://www.w3.org/2000/svg" : _d, _e = _a.viewBox, viewBox = _e === void 0 ? "0 0 24 24" : _e, _f = _a.dense, dense = _f === void 0 ? false : _f, className = _a.className, use = _a.use, propChildren = _a.children, props = __rest$1$(_a, ["aria-hidden", "focusable", "xmlns", "viewBox", "dense", "className", "use", "children"]);
	    var children = propChildren;
	    if (!children && use) {
	        children = jsxRuntime.exports.jsx("use", { xlinkHref: use });
	    }
	    return (jsxRuntime.exports.jsx("svg", __assign$2l({}, props, { "aria-hidden": ariaHidden, ref: ref, className: cn(block$Y({ svg: true, dense: dense }), className), focusable: focusable, xmlns: xmlns, viewBox: viewBox }, { children: children })));
	});

	var __assign$2k = (undefined && undefined.__assign) || function () {
	    __assign$2k = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2k.apply(this, arguments);
	};
	function TextIconSpacing(_a) {
	    var _b;
	    var className = _a.className, propIcon = _a.icon, _c = _a.children, children = _c === void 0 ? null : _c, _d = _a.stacked, stacked = _d === void 0 ? false : _d, _e = _a.iconAfter, iconAfter = _e === void 0 ? false : _e, _f = _a.flexReverse, flexReverse = _f === void 0 ? false : _f, _g = _a.forceIconWrap, forceIconWrap = _g === void 0 ? false : _g, _h = _a.beforeClassName, beforeClassName = _h === void 0 ? "rmd-icon--before" : _h, _j = _a.afterClassName, afterClassName = _j === void 0 ? "rmd-icon--after" : _j, _k = _a.aboveClassName, aboveClassName = _k === void 0 ? "rmd-icon--above" : _k, _l = _a.belowClassName, belowClassName = _l === void 0 ? "rmd-icon--below" : _l;
	    if (!propIcon) {
	        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children });
	    }
	    var isAfter = flexReverse ? !iconAfter : iconAfter;
	    var baseClassName = cn((_b = {},
	        _b[beforeClassName] = !stacked && !isAfter,
	        _b[afterClassName] = !stacked && isAfter,
	        _b[aboveClassName] = stacked && !isAfter,
	        _b[belowClassName] = stacked && isAfter,
	        _b), className);
	    var iconEl = propIcon;
	    var content = children;
	    if (!forceIconWrap && require$$1.isValidElement(propIcon)) {
	        var icon = require$$1.Children.only(propIcon);
	        iconEl = require$$1.cloneElement(icon, {
	            className: cn(baseClassName, icon.props.className),
	        });
	    }
	    else if (propIcon) {
	        iconEl = (jsxRuntime.exports.jsx("span", __assign$2k({ className: cn("rmd-text-icon-spacing", baseClassName) }, { children: propIcon })));
	    }
	    if (iconEl) {
	        content = (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [!iconAfter && iconEl, children, iconAfter && iconEl] }));
	    }
	    return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: content });
	}

	var __assign$2j = (undefined && undefined.__assign) || function () {
	    __assign$2j = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2j.apply(this, arguments);
	};
	var __rest$1_ = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$X = bem("rmd-icon-rotator");
	/**
	 * The `IconRotator` is a simple component that is used to rotate an icon from a
	 * one degrees to another.
	 */
	var IconRotator = require$$1.forwardRef(function IconRotator(_a, ref) {
	    var style = _a.style, propClassName = _a.className, _b = _a.animate, animate = _b === void 0 ? true : _b, rotated = _a.rotated, children = _a.children, _c = _a.forceIconWrap, forceIconWrap = _c === void 0 ? false : _c, props = __rest$1_(_a, ["style", "className", "animate", "rotated", "children", "forceIconWrap"]);
	    var className = cn(block$X({ animate: animate, rotated: rotated }), propClassName);
	    if (!forceIconWrap && require$$1.isValidElement(children)) {
	        var child = require$$1.Children.only(children);
	        return require$$1.cloneElement(child, {
	            className: cn(className, child.props.className),
	        });
	    }
	    return (jsxRuntime.exports.jsx("span", __assign$2j({}, props, { style: style, className: className, ref: ref }, { children: children })));
	});

	var __assign$2i = (undefined && undefined.__assign) || function () {
	    __assign$2i = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2i.apply(this, arguments);
	};
	var DEFAULT_ICONS = {
	    back: jsxRuntime.exports.jsx(FontIcon, { children: "keyboard_arrow_left" }),
	    checkbox: jsxRuntime.exports.jsx(FontIcon, { children: "check_box" }),
	    upload: jsxRuntime.exports.jsx(FontIcon, { children: "file_upload" }),
	    dropdown: jsxRuntime.exports.jsx(FontIcon, { children: "arrow_drop_down" }),
	    error: jsxRuntime.exports.jsx(FontIcon, { children: "error_outline" }),
	    expander: jsxRuntime.exports.jsx(FontIcon, { children: "keyboard_arrow_down" }),
	    forward: jsxRuntime.exports.jsx(FontIcon, { children: "keyboard_arrow_right" }),
	    menu: jsxRuntime.exports.jsx(FontIcon, { children: "menu" }),
	    notification: jsxRuntime.exports.jsx(FontIcon, { children: "notifications" }),
	    password: jsxRuntime.exports.jsx(FontIcon, { children: "remove_red_eye" }),
	    radio: jsxRuntime.exports.jsx(FontIcon, { children: "radio_button_checked" }),
	    selected: jsxRuntime.exports.jsx(FontIcon, { children: "check" }),
	    sort: jsxRuntime.exports.jsx(FontIcon, { children: "arrow_upward" }),
	};
	var context$a = require$$1.createContext(DEFAULT_ICONS);
	var Provider$7 = context$a.Provider;
	/**
	 * Gets one of the configured icons from the `IconProvider`. This is probably
	 * just for use within `react-md`, but might be helpful outside if you want to
	 * reuse the existing icon configuration for other custom components.
	 *
	 * If te second argument is provided and it is not `undefined`, that value will
	 * be used instead of the inherited icon type.
	 *
	 * @param name - The name of the icon you want to use.
	 * @param override - An optional override to use instead of the inherited icon.
	 * @returns The overridden icon value or the inherited icon.
	 */
	function useIcon(name, override) {
	    var icons = require$$1.useContext(context$a);
	    if (typeof override !== "undefined") {
	        return override;
	    }
	    return icons[name];
	}
	/**
	 * The `IconProvider` component is used to override all the default icons within
	 * `react-md` with a newly defined set of icons. This is super nice since you
	 * won't need to create new component wrappers for all the components within
	 * `react-md` if you want to switch to SVG icons instead of the default font
	 * icons.
	 */
	function IconProvider(_a) {
	    var children = _a.children, _b = _a.back, back = _b === void 0 ? DEFAULT_ICONS.back : _b, _c = _a.checkbox, checkbox = _c === void 0 ? DEFAULT_ICONS.checkbox : _c, _d = _a.dropdown, dropdown = _d === void 0 ? DEFAULT_ICONS.dropdown : _d, _e = _a.expander, expander = _e === void 0 ? DEFAULT_ICONS.expander : _e, _f = _a.error, error = _f === void 0 ? DEFAULT_ICONS.error : _f, _g = _a.forward, forward = _g === void 0 ? DEFAULT_ICONS.forward : _g, _h = _a.menu, menu = _h === void 0 ? DEFAULT_ICONS.menu : _h, _j = _a.notification, notification = _j === void 0 ? DEFAULT_ICONS.notification : _j, _k = _a.password, password = _k === void 0 ? DEFAULT_ICONS.password : _k, _l = _a.radio, radio = _l === void 0 ? DEFAULT_ICONS.radio : _l, _m = _a.selected, selected = _m === void 0 ? DEFAULT_ICONS.selected : _m, _o = _a.sort, sort = _o === void 0 ? DEFAULT_ICONS.sort : _o, _p = _a.upload, upload = _p === void 0 ? DEFAULT_ICONS.upload : _p;
	    var value = require$$1.useMemo(function () { return ({
	        back: back,
	        checkbox: checkbox,
	        dropdown: dropdown,
	        error: error,
	        expander: expander,
	        forward: forward,
	        menu: menu,
	        notification: notification,
	        password: password,
	        radio: radio,
	        selected: selected,
	        sort: sort,
	        upload: upload,
	    }); }, [
	        back,
	        checkbox,
	        dropdown,
	        error,
	        expander,
	        forward,
	        menu,
	        notification,
	        password,
	        radio,
	        selected,
	        sort,
	        upload,
	    ]);
	    return jsxRuntime.exports.jsx(Provider$7, __assign$2i({ value: value }, { children: children }));
	}

	var __assign$2h = (undefined && undefined.__assign) || function () {
	    __assign$2h = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2h.apply(this, arguments);
	};
	var __rest$1Z = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	function getComponent(component, type) {
	    if (component) {
	        return component;
	    }
	    switch (type) {
	        case "headline-1":
	            return "h1";
	        case "headline-2":
	            return "h2";
	        case "headline-3":
	            return "h3";
	        case "headline-4":
	            return "h4";
	        case "headline-5":
	            return "h5";
	        case "headline-6":
	        case "subtitle-1":
	        case "subtitle-2":
	            return "h6";
	        case "body-1":
	        case "body-2":
	            return "p";
	        case "caption":
	            return "caption";
	        case "button":
	            return "button";
	        default:
	            return "span";
	    }
	}
	var block$W = bem("rmd-typography");
	/**
	 * The `Typography` component is used to render text with the material design
	 * typography styles applied.  By default, everything will be rendered in a
	 * `<p>` tag with the normal paragraph styles.
	 *
	 * When the `type` prop is changed to another typography style, this component
	 * will determine the "best" element to render the text in *unless* the
	 * `component` prop is provided. The default mapping is:
	 *
	 * - `"headline-1" -> <h1>`
	 * - `"headline-2" -> <h2>`
	 * - `"headline-3" -> <h3>`
	 * - `"headline-4" -> <h4>`
	 * - `"headline-5" -> <h5>`
	 * - `"headline-6" -> <h6>`
	 * - `"subtitle-1" -> <h5>`
	 * - `"subtitle-2" -> <h6>`
	 * - `"body-1"     -> <p>`
	 * - `"body-2"     -> <p>`
	 * - `"caption"    -> <caption>`
	 * - `"overline"   -> <span>`
	 * - `"button"     -> <button>`
	 *
	 * NOTE: if the `component` prop is not `null`, this logic will be ignored and
	 * the provided `component` will be used instead.
	 */
	var Typography = require$$1.forwardRef(function Typography(_a, ref) {
	    var _b;
	    var propClassName = _a.className, children = _a.children, _c = _a.type, type = _c === void 0 ? "body-1" : _c, _d = _a.component, component = _d === void 0 ? null : _d, align = _a.align, color = _a.color, decoration = _a.decoration, transform = _a.transform, weight = _a.weight, fontStyle = _a.fontStyle, _e = _a.margin, margin = _e === void 0 ? "initial" : _e, props = __rest$1Z(_a, ["className", "children", "type", "component", "align", "color", "decoration", "transform", "weight", "fontStyle", "margin"]);
	    var className = cn(block$W((_b = {},
	        _b[type] = true,
	        _b["no-margin"] = margin === "none",
	        _b["no-margin-top"] = margin === "bottom",
	        _b["no-margin-bottom"] = margin === "top",
	        _b[align || ""] = align,
	        _b[decoration || ""] = decoration && decoration !== "overline",
	        _b[color || ""] = color,
	        // only because "overline" is technically one of the valid material design types :/
	        _b["overline-decoration"] = decoration === "overline",
	        _b[transform || ""] = transform,
	        _b[weight || ""] = weight,
	        _b[fontStyle || ""] = fontStyle,
	        _b)), propClassName);
	    if (typeof children === "function") {
	        return children({ className: className });
	    }
	    return require$$1.createElement(getComponent(component, type), __assign$2h(__assign$2h({}, props), { className: className, ref: ref }), children);
	});

	var __assign$2g = (undefined && undefined.__assign) || function () {
	    __assign$2g = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2g.apply(this, arguments);
	};
	var __rest$1Y = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$V = bem("rmd-sr-only");
	/**
	 * This component is used to create text that is only visible to screen readers.
	 * If you enable the `focusable` prop, the text will become visible to all users
	 * while focused.
	 */
	var SrOnly = require$$1.forwardRef(function SrOnly(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a.focusable, focusable = _b === void 0 ? false : _b, propTabIndex = _a.tabIndex, _c = _a.component, component = _c === void 0 ? "span" : _c, props = __rest$1Y(_a, ["className", "children", "focusable", "tabIndex", "component"]);
	    var tabIndex = propTabIndex;
	    if (focusable && typeof tabIndex === "undefined") {
	        tabIndex = 0;
	    }
	    return (jsxRuntime.exports.jsx(Typography, __assign$2g({}, props, { ref: ref, tabIndex: tabIndex, component: component, className: cn(block$V({ focusable: focusable }), className) }, { children: children })));
	});

	var __assign$2f = (undefined && undefined.__assign) || function () {
	    __assign$2f = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2f.apply(this, arguments);
	};
	var __rest$1X = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var TextContainer = require$$1.forwardRef(function TextContainer(_a, ref) {
	    var propClassName = _a.className, _b = _a.component, Component = _b === void 0 ? "div" : _b, _c = _a.size, size = _c === void 0 ? "auto" : _c, children = _a.children, clone = _a.clone, props = __rest$1X(_a, ["className", "component", "size", "children", "clone"]);
	    var className = cn("rmd-text-container rmd-text-container--".concat(size), propClassName);
	    if (clone && require$$1.isValidElement(children)) {
	        var child = require$$1.Children.only(children);
	        return require$$1.cloneElement(child, {
	            className: cn(child.props.className, className),
	        });
	    }
	    if (typeof children === "function") {
	        return children({ className: className });
	    }
	    return (jsxRuntime.exports.jsx(Component, __assign$2f({}, props, { className: className, ref: ref }, { children: children })));
	});

	var __assign$2e = (undefined && undefined.__assign) || function () {
	    __assign$2e = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2e.apply(this, arguments);
	};
	var __rest$1W = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$U = bem("rmd-file-input");
	/**
	 * This component is a wrapper for the `<input type="file" />` that can be themed
	 * like a button.
	 */
	var FileInput = require$$1.forwardRef(function FileInput(_a, ref) {
	    var style = _a.style, propClassName = _a.className, propIcon = _a.icon, _b = _a.iconAfter, iconAfter = _b === void 0 ? false : _b, propChildren = _a.children, _c = _a.theme, theme = _c === void 0 ? "primary" : _c, _d = _a.themeType, themeType = _d === void 0 ? "contained" : _d, _e = _a.buttonType, buttonType = _e === void 0 ? propChildren ? "text" : "icon" : _e, _f = _a.multiple, multiple = _f === void 0 ? false : _f, propDisableIconSpacing = _a.disableIconSpacing, _g = _a.disableRepeatableFiles, disableRepeatableFiles = _g === void 0 ? false : _g, onKeyDown = _a.onKeyDown, onKeyUp = _a.onKeyUp, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, onMouseLeave = _a.onMouseLeave, onClick = _a.onClick, onTouchStart = _a.onTouchStart, onTouchMove = _a.onTouchMove, onTouchEnd = _a.onTouchEnd, onChange = _a.onChange, props = __rest$1W(_a, ["style", "className", "icon", "iconAfter", "children", "theme", "themeType", "buttonType", "multiple", "disableIconSpacing", "disableRepeatableFiles", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseUp", "onMouseLeave", "onClick", "onTouchStart", "onTouchMove", "onTouchEnd", "onChange"]);
	    var id = props.id, disabled = props.disabled;
	    var icon = useIcon("upload", propIcon);
	    var disableIconSpacing = propDisableIconSpacing !== null && propDisableIconSpacing !== void 0 ? propDisableIconSpacing : typeof propChildren === "undefined";
	    var children = propChildren;
	    if (typeof propChildren === "undefined") {
	        children = jsxRuntime.exports.jsx(SrOnly, { children: "Upload" });
	    }
	    var _h = useInteractionStates({
	        handlers: {
	            onKeyDown: onKeyDown,
	            onKeyUp: onKeyUp,
	            onMouseDown: onMouseDown,
	            onMouseUp: onMouseUp,
	            onMouseLeave: onMouseLeave,
	            onClick: onClick,
	            onTouchStart: onTouchStart,
	            onTouchMove: onTouchMove,
	            onTouchEnd: onTouchEnd,
	        },
	        className: buttonThemeClassNames({
	            theme: theme,
	            themeType: themeType,
	            buttonType: buttonType,
	            disabled: disabled,
	            className: propClassName,
	        }),
	        // pressing enter or space would trigger two click events otherwise.
	        disableEnterClick: true,
	    }), ripples = _h.ripples, className = _h.className, handlers = _h.handlers;
	    var content = icon;
	    if (disableIconSpacing || (children && !icon)) {
	        content = (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [!iconAfter && icon, children, iconAfter && icon] }));
	    }
	    else if (children) {
	        content = (jsxRuntime.exports.jsx(TextIconSpacing, __assign$2e({ icon: icon, iconAfter: iconAfter }, { children: children })));
	    }
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsx("input", __assign$2e({}, props, handlers, { ref: ref, onChange: onChange, value: disableRepeatableFiles ? undefined : "", type: "file", className: block$U(), multiple: multiple })), jsxRuntime.exports.jsxs("label", __assign$2e({ htmlFor: id, style: style, className: cn("rmd-file-input-label", className) }, { children: [content, ripples] }))] }));
	});

	let urlAlphabet =
	  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';

	const POOL_SIZE_MULTIPLIER = 128;
	let pool, poolOffset;
	let fillPool = bytes => {
	  if (!pool || pool.length < bytes) {
	    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
	    crypto__default["default"].randomFillSync(pool);
	    poolOffset = 0;
	  } else if (poolOffset + bytes > pool.length) {
	    crypto__default["default"].randomFillSync(pool);
	    poolOffset = 0;
	  }
	  poolOffset += bytes;
	};
	let nanoid = (size = 21) => {
	  fillPool((size -= 0));
	  let id = '';
	  for (let i = poolOffset - size; i < poolOffset; i++) {
	    id += urlAlphabet[pool[i] & 63];
	  }
	  return id
	};

	var __extends = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * An error that will be created if a user tries dragging and dropping files
	 * from a shared directory that they do not have access to. This error will not
	 * occur much.
	 *
	 * @remarks \@since 2.9.0
	 */
	var FileAccessError = /** @class */ (function (_super) {
	    __extends(FileAccessError, _super);
	    /**
	     *
	     * @param message - An optional message for the error.
	     */
	    function FileAccessError(message) {
	        var _this = _super.call(this, message) || this;
	        _this.key = nanoid();
	        _this.name = "FileAccessError";
	        return _this;
	    }
	    return FileAccessError;
	}(Error));
	/**
	 * An error that just requires a `File` to be passed as the first argument.
	 *
	 * @remarks \@since 2.9.0
	 */
	var GenericFileError = /** @class */ (function (_super) {
	    __extends(GenericFileError, _super);
	    /**
	     *
	     * @param files - A list of files that caused the error.
	     * @param reason - An optional reason for the error
	     */
	    function GenericFileError(files, reason) {
	        var _this = _super.call(this, "Invalid files") || this;
	        _this.files = files;
	        _this.reason = reason;
	        _this.key = nanoid();
	        _this.name = "GenericFileError";
	        return _this;
	    }
	    return GenericFileError;
	}(Error));
	/**
	 * An error that is created during the upload process if the number of files
	 * exceeds the {@link FileUploadOptions.maxFiles} amount.
	 *
	 * @remarks \@since 2.9.0
	 */
	var TooManyFilesError = /** @class */ (function (_super) {
	    __extends(TooManyFilesError, _super);
	    /**
	     *
	     * @param files - The list of files that could not be uploaded due to the file
	     * limit defined.
	     * @param limit - The max limit of files allowed.
	     */
	    function TooManyFilesError(files, limit) {
	        var _this = _super.call(this, files, "file limit") || this;
	        _this.limit = limit;
	        _this.name = "TooManyFilesError";
	        return _this;
	    }
	    return TooManyFilesError;
	}(GenericFileError));
	/**
	 * An error that will be created if a user tries to upload a file that
	 * is either:
	 * - less than the {@link FileValidationOptions.minFileSize}
	 * - greater than the {@link FileValidationOptions.maxFileSize}
	 * - including the file would be greater than the {@link FileValidationOptions.totalFileSize}
	 *
	 * @remarks \@since 2.9.0
	 */
	var FileSizeError = /** @class */ (function (_super) {
	    __extends(FileSizeError, _super);
	    /**
	     *
	     * @param files - The list of files that have the file size error
	     * @param type - The file size error type
	     * @param limit - The number of bytes allowed based on the type
	     */
	    function FileSizeError(files, type, limit) {
	        var _this = _super.call(this, files, "file size") || this;
	        _this.type = type;
	        _this.limit = limit;
	        _this.name = "FileSizeError";
	        return _this;
	    }
	    return FileSizeError;
	}(GenericFileError));
	/**
	 * An error that will be created if a user tries to upload a file that does not
	 * end with one of the {@link FileValidationOptions.extensions}.
	 *
	 * @remarks \@since 2.9.0
	 */
	var FileExtensionError = /** @class */ (function (_super) {
	    __extends(FileExtensionError, _super);
	    /**
	     *
	     * @param files - The file that caused the error
	     * @param extensions - The allowed list of file extensions
	     */
	    function FileExtensionError(files, extensions) {
	        var _this = _super.call(this, files, "extension") || this;
	        _this.extensions = extensions;
	        _this.name = "FileExtensionError";
	        return _this;
	    }
	    return FileExtensionError;
	}(GenericFileError));
	/**
	 * A simple type-guard that can be used to check if the
	 * {@link FileValidationError} is the {@link GenericFileError} which can be
	 * useful when displaying the errors to the user.
	 *
	 * @param error - The error to check
	 * @returns true if the error is a {@link FileAccessError}
	 */
	function isGenericFileError(error) {
	    return "name" in error && error.name === "GenericFileError";
	}
	/**
	 * A simple type-guard that can be used to check if the
	 * {@link FileValidationError} is the {@link FileAccessError} which can be
	 * useful when displaying the errors to the user.
	 *
	 * @param error - The error to check
	 * @returns true if the error is a {@link FileAccessError}
	 */
	function isFileAccessError(error) {
	    return "name" in error && error.name === "FileAccessError";
	}
	/**
	 * A simple type-guard that can be used to check if the
	 * {@link FileValidationError} is the {@link TooManyFilesError} which can be
	 * useful when displaying the errors to the user.
	 *
	 * @param error - The error to check
	 * @returns true if the error is a {@link TooManyFilesError}
	 */
	function isTooManyFilesError(error) {
	    return "name" in error && error.name === "TooManyFilesError";
	}
	/**
	 * A simple type-guard that can be used to check if the
	 * {@link FileValidationError} is the {@link FileSizeError} which can be
	 * useful when displaying the errors to the user.
	 *
	 * @param error - The error to check
	 * @returns true if the error is a {@link FileSizeError}
	 */
	function isFileSizeError(error) {
	    return "name" in error && error.name === "FileSizeError";
	}
	/**
	 * A simple type-guard that can be used to check if the
	 * {@link FileValidationError} is the {@link FileExtensionError} which can be
	 * useful when displaying the errors to the user.
	 *
	 * @param error - The error to check
	 * @returns true if the error is a {@link FileExtensionError}
	 */
	function isFileExtensionError(error) {
	    return "name" in error && error.name === "FileExtensionError";
	}
	/**
	 *
	 * @defaultValue `matcher?.test(file.name) ?? true`
	 * @remarks \@since 3.1.0
	 */
	var isValidFileName = function (file, matcher) { var _a; return (_a = matcher === null || matcher === void 0 ? void 0 : matcher.test(file.name)) !== null && _a !== void 0 ? _a : true; };
	/**
	 * A pretty decent default implementation for validating files with the
	 * {@link useFileUpload} that ensures the {@link FilesValidationOptions} are
	 * enforced before allowing a file to be uploaded.
	 *
	 * @typeparam E - An optional custom file validation error.
	 * @param files - The list of files to check
	 * @param options - The {@link FilesValidationOptions}
	 * @returns the {@link ValidatedFilesResult}
	 * @remarks \@since 2.9.0
	 */
	function validateFiles(files, _a) {
	    var maxFiles = _a.maxFiles, extensions = _a.extensions, minFileSize = _a.minFileSize, maxFileSize = _a.maxFileSize, totalBytes = _a.totalBytes, totalFiles = _a.totalFiles, totalFileSize = _a.totalFileSize, isValidFileName = _a.isValidFileName;
	    var errors = [];
	    var pending = [];
	    var extraFiles = [];
	    var extensionRegExp = extensions.length > 0
	        ? new RegExp("\\.(".concat(extensions.join("|"), ")$"), "i")
	        : undefined;
	    var maxFilesReached = maxFiles > 0 && totalFiles >= maxFiles;
	    var remainingBytes = totalFileSize - totalBytes;
	    var extensionErrors = [];
	    var minErrors = [];
	    var maxErrors = [];
	    var totalSizeErrors = [];
	    for (var i = 0; i < files.length; i += 1) {
	        var file = files[i];
	        var valid = true;
	        var size = file.size;
	        if (!isValidFileName(file, extensionRegExp, extensions)) {
	            valid = false;
	            extensionErrors.push(file);
	        }
	        if (minFileSize > 0 && size < minFileSize) {
	            valid = false;
	            minErrors.push(file);
	        }
	        if (maxFileSize > 0 && size > maxFileSize) {
	            valid = false;
	            maxErrors.push(file);
	        }
	        else if (totalFileSize > 0 && remainingBytes - file.size < 0) {
	            // don't want both errors displaying
	            valid = false;
	            totalSizeErrors.push(file);
	        }
	        if (maxFilesReached && valid) {
	            extraFiles.push(file);
	        }
	        else if (!maxFilesReached && valid) {
	            pending.push(file);
	            remainingBytes -= file.size;
	            maxFilesReached =
	                maxFilesReached ||
	                    (maxFiles > 0 && totalFiles + pending.length >= maxFiles);
	        }
	    }
	    if (extensionErrors.length) {
	        errors.push(new FileExtensionError(extensionErrors, extensions));
	    }
	    if (minErrors.length) {
	        errors.push(new FileSizeError(minErrors, "min", minFileSize));
	    }
	    if (maxErrors.length) {
	        errors.push(new FileSizeError(maxErrors, "max", maxFileSize));
	    }
	    if (totalSizeErrors.length) {
	        errors.push(new FileSizeError(totalSizeErrors, "total", totalFileSize));
	    }
	    if (extraFiles.length) {
	        errors.push(new TooManyFilesError(extraFiles, maxFiles));
	    }
	    return { pending: pending, errors: errors };
	}
	/**
	 * This will first check if the mime-type of the file starts with `text/` and
	 * fallback to checking a few file names or extensions that should be considered
	 * text.
	 *
	 * This function is not guaranteed to be 100% correct and is only useful if
	 * trying to generate a preview of files uploaded to the browser.
	 *
	 * @param file - The file to check
	 * @returns `true` if the file should be considered as a text-content file.
	 * @remarks \@since 2.9.0
	 */
	function isTextFile(file) {
	    return /\.((j|t)sx?|json|lock|hbs|ya?ml|log|txt|md)$/i.test(file.name);
	}
	/**
	 * This will first check if the mime-type of the file starts with `text\/` and
	 * fallback to checking a few file names or extensions that should be considered
	 * text.
	 *
	 * This function is not guaranteed to be 100% correct and is only useful if
	 * trying to generate a preview of files uploaded to the browser.
	 *
	 * @param file - The file to check
	 * @returns `true` if the file should be considered as a text content file.
	 * @remarks \@since 2.9.0
	 */
	function isImageFile(file) {
	    return /\.(a?png|avif|svg|tiff|gifv?|jpe?g)/i.test(file.name);
	}
	/**
	 * This will first check if the mime-type of the file starts with `audio/` and
	 * fallback to checking a few file names or extensions that should be considered
	 * audio.
	 *
	 * This function is not guaranteed to be 100% correct and is only useful if
	 * trying to generate a preview of files uploaded to the browser.
	 *
	 * @param file - The file to check
	 * @returns `true` if the file should be considered as a audio content file.
	 * @remarks \@since 2.9.0
	 */
	function isAudioFile(file) {
	    return /\.(mp3|wav|ogg|m4p|flac)$/i.test(file.name);
	}
	/**
	 * This will first check if the mime-type of the file starts with `video/` and
	 * fallback to checking a few file names or extensions that should be considered
	 * video.
	 *
	 * This function is not guaranteed to be 100% correct and is only useful if
	 * trying to generate a preview of files uploaded to the browser.
	 *
	 * @param file - The file to check
	 * @returns `true` if the file should be considered as a video content file.
	 * @remarks \@since 2.9.0
	 */
	function isVideoFile(file) {
	    return /\.(mkv|mpe?g|mov|avi|flv|webm|mp4)$/i.test(file.name);
	}
	/**
	 * This function is not guaranteed to be 100% correct and is only useful if
	 * trying to generate a preview of files uploaded to the browser.
	 *
	 * @param file - The file to check
	 * @returns `true` if the file matches an image, audio, or video file.
	 * @remarks \@since 2.9.0
	 */
	function isMediaFile(file) {
	    return isImageFile(file) || isAudioFile(file) || isVideoFile(file);
	}
	/**
	 * This function will attempt to read:
	 * - media (image, audio, and video) files as a data url so they can be
	 *   previewed in `<img>`, `<audio>`, and `<video>` tags
	 * - text files as plain text
	 * - everything else as an `ArrayBuffer` which can be manually converted into a
	 *   data url if needed with `URL.createObjectURL`
	 *
	 * @remarks \@since 2.9.0
	 */
	var getFileParser = function (file) {
	    if (isMediaFile(file)) {
	        return "readAsDataURL";
	    }
	    if (isTextFile(file)) {
	        return "readAsText";
	    }
	    return "readAsArrayBuffer";
	};
	/**
	 * This util will split all the current upload stats by status.
	 *
	 * @param stats - The {@link FileUploadStats} list generally returned by the
	 * {@link useFileUpload} hook.
	 * @returns the {@link SplitFileUploads}.
	 * @remarks \@since 2.9.0
	 */
	function getSplitFileUploads(stats) {
	    var pending = [];
	    var uploading = [];
	    var complete = [];
	    stats.forEach(function (stat) {
	        if (stat.status === "pending") {
	            pending.push(stat);
	        }
	        else if (stat.status === "uploading") {
	            uploading.push(stat);
	        }
	        else if (stat.status === "complete") {
	            complete.push(stat);
	        }
	        else {
	            /* istanbul ignore next */
	            throw new Error("Invalid upload stat");
	        }
	    });
	    return { pending: pending, uploading: uploading, complete: complete };
	}

	var __assign$2d = (undefined && undefined.__assign) || function () {
	    __assign$2d = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2d.apply(this, arguments);
	};
	var __rest$1V = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$I = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$8 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/** @internal */
	var EMPTY_LIST$1 = [];
	/** @internal */
	var EMPTY_OBJECT = {};
	/**
	 * This hook is generally used to upload files **to the browser** in different
	 * formats to be previewed `<img>`, `<video>`, `<embed>`, etc tags. However, it
	 * can also be used to upload the files as an `ArrayBuffer` and then uploaded to
	 * a server.
	 *
	 * Note: If using the `aws-sdk` to upload files directly to S3, **do not use
	 * this hook** since it uses its own upload process.
	 *
	 * @typeParam E - An optional HTMLElement type that is used for the
	 * {@link FileUploadHandlers}.
	 * @typeParam CustomError - An optional error type that gets returned from the
	 * {@link FilesValidator}.
	 * @param options - All the {@link FileUploadOptions}
	 * @returns the {@link FileUploadHookReturnValue}
	 * @remarks \@since 2.9.0
	 */
	function useFileUpload(_a) {
	    var _b = _a === void 0 ? {} : _a, _c = _b.maxFiles, maxFiles = _c === void 0 ? -1 : _c, _d = _b.extensions, extensions = _d === void 0 ? EMPTY_LIST$1 : _d, _e = _b.minFileSize, minFileSize = _e === void 0 ? -1 : _e, _f = _b.maxFileSize, maxFileSize = _f === void 0 ? -1 : _f, _g = _b.totalFileSize, totalFileSize = _g === void 0 ? -1 : _g, _h = _b.concurrency, concurrency = _h === void 0 ? -1 : _h, propOnDrop = _b.onDrop, propOnChange = _b.onChange, _j = _b.validateFiles, validateFiles$1 = _j === void 0 ? validateFiles : _j, _k = _b.getFileParser, getFileParser$1 = _k === void 0 ? getFileParser : _k, _l = _b.isValidFileName, isValidFileName$1 = _l === void 0 ? isValidFileName : _l;
	    var _m = __read$I(require$$1.useReducer(function reducer(state, action) {
	        var _a, _b, _c, _d;
	        switch (action.type) {
	            case "reset":
	                // need to reuse constants so that calling reset doesn't cause an
	                // infinite loop in an effect
	                return {
	                    stats: EMPTY_OBJECT,
	                    errors: EMPTY_LIST$1,
	                    readers: EMPTY_OBJECT,
	                };
	            case "remove":
	                return __assign$2d(__assign$2d({}, state), { stats: omit(state.stats, action.files) });
	            case "queue":
	                return __assign$2d(__assign$2d({}, state), { stats: __assign$2d(__assign$2d({}, state.stats), action.files.reduce(function (files, file) {
	                        var key = nanoid();
	                        files[key] = {
	                            key: key,
	                            file: file,
	                            progress: 0,
	                            status: "pending",
	                        };
	                        return files;
	                    }, {})), errors: __spreadArray$8(__spreadArray$8([], __read$I(state.errors), false), __read$I(action.errors), false) });
	            case "start": {
	                var key = action.key, reader = action.reader;
	                /* istanbul ignore next */
	                if (!state.stats[key]) {
	                    throw new Error("Missing file with key \"".concat(key, "\""));
	                }
	                var fileStats = {
	                    key: key,
	                    file: state.stats[key].file,
	                    progress: 0,
	                    status: "uploading",
	                };
	                return __assign$2d(__assign$2d({}, state), { readers: __assign$2d(__assign$2d({}, state.readers), (_a = {}, _a[key] = reader, _a)), stats: __assign$2d(__assign$2d({}, state.stats), (_b = {}, _b[key] = fileStats, _b)) });
	            }
	            case "progress": {
	                var key = action.key, progress = action.progress;
	                /* istanbul ignore next */
	                if (!state.stats[key]) {
	                    throw new Error("Missing file with key \"".concat(key, "\""));
	                }
	                return __assign$2d(__assign$2d({}, state), { stats: __assign$2d(__assign$2d({}, state.stats), (_c = {}, _c[key] = __assign$2d(__assign$2d({}, state.stats[key]), { progress: progress }), _c)) });
	            }
	            case "complete": {
	                var key = action.key, result = action.result;
	                /* istanbul ignore next */
	                if (!state.stats[key]) {
	                    throw new Error("Missing file with key \"".concat(key, "\""));
	                }
	                var file = {
	                    key: key,
	                    file: state.stats[key].file,
	                    status: "complete",
	                    result: result,
	                    progress: 100,
	                };
	                var _e = state.readers, _f = key; _e[_f]; var readers_1 = __rest$1V(_e, [typeof _f === "symbol" ? _f : _f + ""]);
	                return __assign$2d(__assign$2d({}, state), { readers: readers_1, stats: __assign$2d(__assign$2d({}, state.stats), (_d = {}, _d[key] = file, _d)) });
	            }
	            case "clearErrors":
	                return __assign$2d(__assign$2d({}, state), { errors: [] });
	            default:
	                /* istanbul ignore next */
	                return state;
	        }
	    }, {
	        stats: EMPTY_OBJECT,
	        errors: EMPTY_LIST$1,
	        readers: EMPTY_OBJECT,
	    }), 2), state = _m[0], dispatch = _m[1];
	    var stats = state.stats, errors = state.errors, readers = state.readers;
	    var statsList = Object.values(stats);
	    var totalFiles = statsList.length;
	    var totalBytes = statsList.reduce(function (result, _a) {
	        var size = _a.file.size;
	        return result + size;
	    }, 0);
	    var queueFiles = require$$1.useCallback(function (files) {
	        var _a = validateFiles$1(files, {
	            maxFiles: maxFiles,
	            extensions: extensions,
	            minFileSize: minFileSize,
	            maxFileSize: maxFileSize,
	            totalBytes: totalBytes,
	            totalFiles: totalFiles,
	            totalFileSize: totalFileSize,
	            isValidFileName: isValidFileName$1,
	        }), pending = _a.pending, errors = _a.errors;
	        dispatch({ type: "queue", errors: errors, files: pending });
	    }, [
	        validateFiles$1,
	        maxFiles,
	        extensions,
	        minFileSize,
	        maxFileSize,
	        totalBytes,
	        totalFiles,
	        totalFileSize,
	        isValidFileName$1,
	    ]);
	    var onDrop = require$$1.useCallback(function (event) {
	        propOnDrop === null || propOnDrop === void 0 ? void 0 : propOnDrop(event);
	        event.preventDefault();
	        event.stopPropagation();
	        try {
	            var files = event.dataTransfer.files;
	            if (files) {
	                queueFiles(Array.from(files));
	            }
	        }
	        catch (e) {
	            dispatch({
	                type: "queue",
	                files: [],
	                errors: [
	                    new FileAccessError(e instanceof Error ? e.message : undefined),
	                ],
	            });
	        }
	    }, [queueFiles, propOnDrop]);
	    var onChange = require$$1.useCallback(function (event) {
	        propOnChange === null || propOnChange === void 0 ? void 0 : propOnChange(event);
	        try {
	            var files = event.currentTarget.files;
	            if (files) {
	                queueFiles(Array.from(files));
	            }
	            else {
	                throw new Error();
	            }
	        }
	        catch (e) {
	            dispatch({
	                type: "queue",
	                files: [],
	                errors: [
	                    new FileAccessError(e instanceof Error ? e.message : undefined),
	                ],
	            });
	        }
	    }, [queueFiles, propOnChange]);
	    var remove = require$$1.useCallback(function (keyOrKeys) {
	        var files = typeof keyOrKeys === "string" ? [keyOrKeys] : keyOrKeys;
	        files.forEach(function (fileKey) {
	            var _a;
	            (_a = readers[fileKey]) === null || _a === void 0 ? void 0 : _a.abort();
	        });
	        dispatch({ type: "remove", files: files });
	    }, [readers]);
	    var reset = require$$1.useCallback(function () {
	        Object.values(readers).forEach(function (reader) {
	            reader.abort();
	        });
	        dispatch({ type: "reset" });
	    }, [readers]);
	    var clearErrors = require$$1.useCallback(function () {
	        dispatch({ type: "clearErrors" });
	    }, []);
	    var start = require$$1.useCallback(function (key, reader) {
	        dispatch({ type: "start", key: key, reader: reader });
	    }, []);
	    var complete = require$$1.useCallback(function (key, result) {
	        if (result === void 0) { result = null; }
	        dispatch({ type: "complete", key: key, result: result });
	    }, []);
	    var createProgressEventHandler = require$$1.useCallback(function (key) { return function (event) {
	        if (event.lengthComputable) {
	            var percentage = Math.round((event.loaded * 100) / event.total);
	            dispatch({ type: "progress", key: key, progress: percentage });
	        }
	    }; }, []);
	    require$$1.useEffect(function () {
	        var pending = [];
	        var uploading = [];
	        Object.values(stats).forEach(function (file) {
	            if (file.status === "pending") {
	                pending.push(file);
	            }
	            else if (file.status === "uploading") {
	                uploading.push(file);
	            }
	        });
	        var lastIndex = concurrency === -1
	            ? pending.length
	            : Math.max(0, concurrency - uploading.length);
	        var queue = pending.slice(0, lastIndex);
	        if (!queue.length) {
	            return;
	        }
	        queue.forEach(function (stats) {
	            var key = stats.key, file = stats.file;
	            var reader = new FileReader();
	            // using `addEventListener` instead of directly setting to
	            // `reader.progress`/`reader.load` so it's easier to test
	            reader.addEventListener("progress", createProgressEventHandler(key));
	            reader.addEventListener("load", function () {
	                complete(key, reader.result);
	            });
	            start(key, reader);
	            var parser = getFileParser$1(file);
	            reader[parser](file);
	        });
	    }, [
	        concurrency,
	        stats,
	        getFileParser$1,
	        createProgressEventHandler,
	        start,
	        complete,
	    ]);
	    var accept = "";
	    if (extensions.length) {
	        accept = extensions.reduce(function (s, ext) { return "".concat(s ? "".concat(s, ",") : "", ".").concat(ext); }, "");
	    }
	    return {
	        stats: statsList,
	        errors: errors,
	        accept: accept,
	        totalBytes: totalBytes,
	        totalFiles: totalFiles,
	        onDrop: onDrop,
	        onChange: onChange,
	        reset: reset,
	        remove: remove,
	        clearErrors: clearErrors,
	    };
	}

	var __assign$2c = (undefined && undefined.__assign) || function () {
	    __assign$2c = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2c.apply(this, arguments);
	};
	var __rest$1U = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$g = bem("rmd-label");
	/**
	 * A simple util that can generate all the "valid" styles for a label. This
	 * shouldn't really be used, but it's useful if you want the label styles
	 * without rendering a `<label>` element.
	 *
	 * @remarks \@since 2.5.0
	 * @internal
	 */
	var labelStyles = function (_a) {
	    var _b = _a === void 0 ? {} : _a, _c = _b.error, error = _c === void 0 ? false : _c, _d = _b.active, active = _d === void 0 ? false : _d, _e = _b.disabled, disabled = _e === void 0 ? false : _e;
	    return styles$g({ error: error, active: active, disabled: disabled });
	};
	/**
	 * The `Label` component should be used alongside any form elements but is
	 * already built in to the majority of the `react-md` components by default.
	 */
	var Label = require$$1.forwardRef(function Label(_a, ref) {
	    var htmlFor = _a.htmlFor, className = _a.className, _b = _a.error, error = _b === void 0 ? false : _b, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, _e = _a.component, Component = _e === void 0 ? "label" : _e, children = _a.children, props = __rest$1U(_a, ["htmlFor", "className", "error", "active", "disabled", "component", "children"]);
	    if (!children) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx(Component, __assign$2c({}, props, { ref: ref, className: cn(labelStyles({ error: error, active: active, disabled: disabled }), className), htmlFor: Component === "label" ? htmlFor : undefined }, { children: children })));
	});

	var __assign$2b = (undefined && undefined.__assign) || function () {
	    __assign$2b = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2b.apply(this, arguments);
	};
	var __rest$1T = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$T = bem("rmd-list");
	/**
	 * The `List` component creates an unstyled ordered or unordered list that
	 * should be used with the `ListItem`, `ListItemLink`, and `SimpleListItem`
	 * components.
	 */
	var List = require$$1.forwardRef(function List(_a, ref) {
	    var _b = _a.role, role = _b === void 0 ? "none" : _b, _c = _a.dense, dense = _c === void 0 ? false : _c, _d = _a.ordered, ordered = _d === void 0 ? false : _d, _e = _a.horizontal, horizontal = _e === void 0 ? false : _e, className = _a.className, children = _a.children, props = __rest$1T(_a, ["role", "dense", "ordered", "horizontal", "className", "children"]);
	    var Component = (ordered ? "ol" : "ul");
	    return (jsxRuntime.exports.jsx(Component, __assign$2b({}, props, { ref: ref, role: role, className: cn(block$T({ dense: dense, horizontal: horizontal }), className) }, { children: children })));
	});

	/**
	 * Gets the expected height for the `ListItem` or `SimpleListItem` based on the
	 * addons and `secondaryText` props.
	 *
	 * Conversions:
	 *
	 * - height !== "auto" -&gt; height
	 * - secondaryText or left/right addon is media/media-large  -&gt; "extra-large"
	 * - left/right addon is avatar -&gt; "large"
	 * - left/right addon is icon -&gt; "medium"
	 * - no addons and no secondary text -&gt; "normal"
	 *
	 * @internal
	 */
	function getListItemHeight(_a) {
	    var _b = _a.height, height = _b === void 0 ? "auto" : _b, leftAddon = _a.leftAddon, _c = _a.leftAddonType, leftAddonType = _c === void 0 ? "icon" : _c, rightAddon = _a.rightAddon, _d = _a.rightAddonType, rightAddonType = _d === void 0 ? "icon" : _d, secondaryText = _a.secondaryText;
	    if (height !== "auto") {
	        return height;
	    }
	    var isIcon = (leftAddon && leftAddonType === "icon") ||
	        (rightAddon && rightAddonType === "icon");
	    var isAvatar = (leftAddon && leftAddonType === "avatar") ||
	        (rightAddon && rightAddonType === "avatar");
	    var isGraphic = (leftAddon &&
	        (leftAddonType === "media" || leftAddonType === "large-media")) ||
	        (rightAddon &&
	            (rightAddonType === "media" || rightAddonType === "large-media"));
	    // secondary text will always be extra large due to the default `line-height`
	    if (isGraphic || secondaryText) {
	        return "extra-large";
	    }
	    if (isAvatar) {
	        return "large";
	    }
	    if (isIcon) {
	        return "medium";
	    }
	    return "normal";
	}

	var __assign$2a = (undefined && undefined.__assign) || function () {
	    __assign$2a = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2a.apply(this, arguments);
	};
	var __rest$1S = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var base = bem("rmd-list-item");
	/**
	 * The `ListItemAddon` is used to create an addon to the left or right of the
	 * text/children of a `ListItem`.
	 */
	function ListItemAddon(_a) {
	    var _b;
	    var className = _a.className, children = _a.children, addon = _a.addon, _c = _a.addonAfter, addonAfter = _c === void 0 ? false : _c, _d = _a.type, type = _d === void 0 ? "icon" : _d, _e = _a.position, position = _e === void 0 ? "middle" : _e, forceAddonWrap = _a.forceAddonWrap, props = __rest$1S(_a, ["className", "children", "addon", "addonAfter", "type", "position", "forceAddonWrap"]);
	    var isMedia = type === "media" || type === "large-media";
	    var isAvatar = type === "avatar";
	    return (jsxRuntime.exports.jsx(TextIconSpacing, __assign$2a({}, props, { icon: addon, forceIconWrap: forceAddonWrap !== null && forceAddonWrap !== void 0 ? forceAddonWrap : isMedia, className: cn(base("addon", (_b = {},
	            _b[position] = position !== "middle",
	            _b.before = !addonAfter,
	            _b["avatar-before"] = !addonAfter && isAvatar,
	            _b.media = isMedia,
	            _b["media-large"] = type === "large-media",
	            _b)), className), iconAfter: addonAfter }, { children: children })));
	}

	var __assign$29 = (undefined && undefined.__assign) || function () {
	    __assign$29 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$29.apply(this, arguments);
	};
	var block$S = bem("rmd-list-item");
	/**
	 * This component us used to create the one to three lines of text within a
	 * `ListItem` or `SimpleListItem`.
	 */
	function ListItemText(_a) {
	    var className = _a.className, secondaryTextClassName = _a.secondaryTextClassName, secondaryText = _a.secondaryText, children = _a.children;
	    var secondaryContent;
	    if (secondaryText) {
	        secondaryContent = (jsxRuntime.exports.jsx("span", __assign$29({ className: cn(block$S("text", { secondary: true }), secondaryTextClassName) }, { children: secondaryText })));
	    }
	    return (jsxRuntime.exports.jsxs("span", __assign$29({ className: cn(block$S("text"), className) }, { children: [children, secondaryContent] })));
	}

	var __assign$28 = (undefined && undefined.__assign) || function () {
	    __assign$28 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$28.apply(this, arguments);
	};
	/**
	 * The `ListItemChildren` component is used to create a styled list item that
	 * can have optional addons to the left or right of the children in the form of
	 * icons, avatars, or media. The `children` can be replaced by the `primaryText`
	 * and `secondaryText` props to create stacked text spanning two or more lines
	 * with the default behavior of using `line-clamp` at three lines.
	 *
	 * Note: This will return a `React.Fragment` of the children and does not wrap
	 * in a DOM node for styling. The parent component should normally have
	 * `display: flex` for the styling to work.
	 */
	function ListItemChildren(_a) {
	    var textClassName = _a.textClassName, secondaryTextClassName = _a.secondaryTextClassName, textChildren = _a.textChildren, primaryText = _a.primaryText, secondaryText = _a.secondaryText, leftAddon = _a.leftAddon, _b = _a.leftAddonType, leftAddonType = _b === void 0 ? "icon" : _b, _c = _a.leftAddonPosition, leftAddonPosition = _c === void 0 ? "middle" : _c, rightAddon = _a.rightAddon, _d = _a.rightAddonType, rightAddonType = _d === void 0 ? "icon" : _d, _e = _a.rightAddonPosition, rightAddonPosition = _e === void 0 ? "middle" : _e, forceAddonWrap = _a.forceAddonWrap, propChildren = _a.children;
	    var stringifiedChildren = typeof propChildren === "number" ? "".concat(propChildren) : propChildren;
	    var children = stringifiedChildren;
	    if (primaryText || secondaryText || textChildren) {
	        children = (jsxRuntime.exports.jsx(ListItemText, __assign$28({ className: textClassName, secondaryText: secondaryText, secondaryTextClassName: secondaryTextClassName }, { children: (textChildren && children) || primaryText })));
	    }
	    children = (jsxRuntime.exports.jsx(ListItemAddon, __assign$28({ addon: leftAddon, type: leftAddonType, position: leftAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })));
	    children = (jsxRuntime.exports.jsx(ListItemAddon, __assign$28({ addon: rightAddon, addonAfter: true, type: rightAddonType, position: rightAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })));
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [children, (primaryText && stringifiedChildren) || null] }));
	}

	var __assign$27 = (undefined && undefined.__assign) || function () {
	    __assign$27 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$27.apply(this, arguments);
	};
	var __rest$1R = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$R = bem("rmd-list-item");
	/**
	 * The `SimpleListItem` component is used to create a non-clickable item within
	 * a `List`. This is really just useful since it allows for the `ListItem`
	 * styling behavior of left and right icons, avatars, and media.
	 *
	 * Note: Even though this component exists, it is recommended to use the
	 * `ListItemChildren` component instead if you want the "addon" styling/behavior
	 * since screen readers read `li` items within lists differently.
	 */
	var SimpleListItem = require$$1.forwardRef(function SimpleListItem(_a, ref) {
	    var _b;
	    var className = _a.className, textClassName = _a.textClassName, secondaryTextClassName = _a.secondaryTextClassName, textChildren = _a.textChildren, primaryText = _a.primaryText, secondaryText = _a.secondaryText, leftAddon = _a.leftAddon, _c = _a.leftAddonType, leftAddonType = _c === void 0 ? "icon" : _c, _d = _a.leftAddonPosition, leftAddonPosition = _d === void 0 ? "middle" : _d, rightAddon = _a.rightAddon, _e = _a.rightAddonType, rightAddonType = _e === void 0 ? "icon" : _e, _f = _a.rightAddonPosition, rightAddonPosition = _f === void 0 ? "middle" : _f, forceAddonWrap = _a.forceAddonWrap, children = _a.children, _g = _a.height, propHeight = _g === void 0 ? "auto" : _g, _h = _a.threeLines, threeLines = _h === void 0 ? false : _h, _j = _a.clickable, clickable = _j === void 0 ? false : _j, onClick = _a.onClick, _k = _a.disabled, disabled = _k === void 0 ? false : _k, _l = _a.disabledOpacity, disabledOpacity = _l === void 0 ? false : _l, props = __rest$1R(_a, ["className", "textClassName", "secondaryTextClassName", "textChildren", "primaryText", "secondaryText", "leftAddon", "leftAddonType", "leftAddonPosition", "rightAddon", "rightAddonType", "rightAddonPosition", "forceAddonWrap", "children", "height", "threeLines", "clickable", "onClick", "disabled", "disabledOpacity"]);
	    var height = getListItemHeight({
	        height: propHeight,
	        leftAddon: leftAddon,
	        leftAddonType: leftAddonType,
	        rightAddon: rightAddon,
	        rightAddonType: rightAddonType,
	        secondaryText: secondaryText,
	    });
	    var ariaDisabled = props["aria-disabled"];
	    var isDisabled = disabled || ariaDisabled === "true" || ariaDisabled === true;
	    return (jsxRuntime.exports.jsx("li", __assign$27({}, props, { "aria-disabled": isDisabled || undefined, ref: ref, className: cn(block$R((_b = {},
	            _b[height] = height !== "auto" && height !== "normal",
	            _b["three-lines"] = threeLines,
	            _b.clickable = clickable,
	            _b.disabled = isDisabled,
	            _b["disabled-color"] = isDisabled && !disabledOpacity,
	            _b["disabled-opacity"] = isDisabled && disabledOpacity,
	            _b)), className), onClick: isDisabled ? undefined : onClick }, { children: jsxRuntime.exports.jsx(ListItemChildren, __assign$27({ textClassName: textClassName, secondaryTextClassName: secondaryTextClassName, textChildren: textChildren, primaryText: primaryText, secondaryText: secondaryText, leftAddon: leftAddon, leftAddonType: leftAddonType, leftAddonPosition: leftAddonPosition, rightAddon: rightAddon, rightAddonType: rightAddonType, rightAddonPosition: rightAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })) })));
	});

	var __assign$26 = (undefined && undefined.__assign) || function () {
	    __assign$26 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$26.apply(this, arguments);
	};
	var __rest$1Q = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `ListItem` creates a clickable and focusable `<li>` within a `List` that
	 * can optionally render addons to the left and right of the `children` or text.
	 */
	var ListItem = require$$1.forwardRef(function ListItem(_a, ref) {
	    var propClassName = _a.className, textClassName = _a.textClassName, secondaryTextClassName = _a.secondaryTextClassName, _b = _a.textChildren, textChildren = _b === void 0 ? true : _b, primaryText = _a.primaryText, secondaryText = _a.secondaryText, children = _a.children, leftAddon = _a.leftAddon, _c = _a.leftAddonType, leftAddonType = _c === void 0 ? "icon" : _c, _d = _a.leftAddonPosition, leftAddonPosition = _d === void 0 ? "middle" : _d, rightAddon = _a.rightAddon, _e = _a.rightAddonType, rightAddonType = _e === void 0 ? "icon" : _e, _f = _a.rightAddonPosition, rightAddonPosition = _f === void 0 ? "middle" : _f, forceAddonWrap = _a.forceAddonWrap, _g = _a.height, propHeight = _g === void 0 ? "auto" : _g, _h = _a.disableSpacebarClick, disableSpacebarClick = _h === void 0 ? false : _h, _j = _a.disableRipple, disableRipple = _j === void 0 ? false : _j, _k = _a.disableProgrammaticRipple, disableProgrammaticRipple = _k === void 0 ? false : _k, _l = _a.disablePressedFallback, disablePressedFallback = _l === void 0 ? false : _l, disableEnterClick = _a.disableEnterClick, rippleTimeout = _a.rippleTimeout, rippleClassNames = _a.rippleClassNames, rippleClassName = _a.rippleClassName, rippleContainerClassName = _a.rippleContainerClassName, _m = _a.role, role = _m === void 0 ? "button" : _m, _o = _a.disabled, disabled = _o === void 0 ? false : _o, _p = _a.tabIndex, tabIndex = _p === void 0 ? disabled ? -1 : 0 : _p, props = __rest$1Q(_a, ["className", "textClassName", "secondaryTextClassName", "textChildren", "primaryText", "secondaryText", "children", "leftAddon", "leftAddonType", "leftAddonPosition", "rightAddon", "rightAddonType", "rightAddonPosition", "forceAddonWrap", "height", "disableSpacebarClick", "disableRipple", "disableProgrammaticRipple", "disablePressedFallback", "disableEnterClick", "rippleTimeout", "rippleClassNames", "rippleClassName", "rippleContainerClassName", "role", "disabled", "tabIndex"]);
	    var _q = useInteractionStates({
	        className: propClassName,
	        handlers: props,
	        disabled: disabled,
	        disableRipple: disableRipple,
	        disableProgrammaticRipple: disableProgrammaticRipple,
	        rippleTimeout: rippleTimeout,
	        rippleClassNames: rippleClassNames,
	        rippleClassName: rippleClassName,
	        rippleContainerClassName: rippleContainerClassName,
	        disableSpacebarClick: disableSpacebarClick,
	        disablePressedFallback: disablePressedFallback,
	        disableEnterClick: disableEnterClick,
	    }), ripples = _q.ripples, className = _q.className, handlers = _q.handlers;
	    var height = getListItemHeight({
	        height: propHeight,
	        leftAddon: leftAddon,
	        leftAddonType: leftAddonType,
	        rightAddon: rightAddon,
	        rightAddonType: rightAddonType,
	        secondaryText: secondaryText,
	    });
	    return (jsxRuntime.exports.jsxs(SimpleListItem, __assign$26({}, props, handlers, { ref: ref, tabIndex: tabIndex, disabled: disabled, role: role, className: className, clickable: true, height: height }, { children: [jsxRuntime.exports.jsx(ListItemChildren, __assign$26({ textClassName: textClassName, secondaryTextClassName: secondaryTextClassName, textChildren: textChildren, primaryText: primaryText, secondaryText: secondaryText, leftAddon: leftAddon, leftAddonType: leftAddonType, leftAddonPosition: leftAddonPosition, rightAddon: rightAddon, rightAddonType: rightAddonType, rightAddonPosition: rightAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })), ripples] })));
	});

	var __assign$25 = (undefined && undefined.__assign) || function () {
	    __assign$25 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$25.apply(this, arguments);
	};
	var __rest$1P = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is a really bad attempt at creating a `Link` within a `List`
	 * that has the main `ListItem` styles. It will probably be better to just use
	 * the `ListItemChildren` within your `Link` component instead.
	 */
	var ListItemLink = require$$1.forwardRef(function ListItemLink(_a, ref) {
	    var _b;
	    var propClassName = _a.className, textClassName = _a.textClassName, secondaryTextClassName = _a.secondaryTextClassName, textChildren = _a.textChildren, primaryText = _a.primaryText, secondaryText = _a.secondaryText, children = _a.children, leftAddon = _a.leftAddon, _c = _a.leftAddonType, leftAddonType = _c === void 0 ? "icon" : _c, _d = _a.leftAddonPosition, leftAddonPosition = _d === void 0 ? "middle" : _d, rightAddon = _a.rightAddon, _e = _a.rightAddonType, rightAddonType = _e === void 0 ? "icon" : _e, _f = _a.rightAddonPosition, rightAddonPosition = _f === void 0 ? "middle" : _f, forceAddonWrap = _a.forceAddonWrap, _g = _a.height, propHeight = _g === void 0 ? "auto" : _g, _h = _a.threeLines, threeLines = _h === void 0 ? false : _h, _j = _a.component, Component = _j === void 0 ? "a" : _j, disableSpacebarClick = _a.disableSpacebarClick, disableRipple = _a.disableRipple, disableProgrammaticRipple = _a.disableProgrammaticRipple, disablePressedFallback = _a.disablePressedFallback, rippleTimeout = _a.rippleTimeout, rippleClassNames = _a.rippleClassNames, rippleClassName = _a.rippleClassName, rippleContainerClassName = _a.rippleContainerClassName, props = __rest$1P(_a, ["className", "textClassName", "secondaryTextClassName", "textChildren", "primaryText", "secondaryText", "children", "leftAddon", "leftAddonType", "leftAddonPosition", "rightAddon", "rightAddonType", "rightAddonPosition", "forceAddonWrap", "height", "threeLines", "component", "disableSpacebarClick", "disableRipple", "disableProgrammaticRipple", "disablePressedFallback", "rippleTimeout", "rippleClassNames", "rippleClassName", "rippleContainerClassName"]);
	    var height = getListItemHeight({
	        height: propHeight,
	        leftAddon: leftAddon,
	        leftAddonType: leftAddonType,
	        rightAddon: rightAddon,
	        rightAddonType: rightAddonType,
	        secondaryText: secondaryText,
	    });
	    var _k = useInteractionStates({
	        className: propClassName,
	        handlers: props,
	        disableRipple: disableRipple,
	        disableProgrammaticRipple: disableProgrammaticRipple,
	        rippleTimeout: rippleTimeout,
	        rippleClassNames: rippleClassNames,
	        rippleClassName: rippleClassName,
	        rippleContainerClassName: rippleContainerClassName,
	        disableSpacebarClick: disableSpacebarClick,
	        disablePressedFallback: disablePressedFallback,
	    }), ripples = _k.ripples, className = _k.className, handlers = _k.handlers;
	    return (jsxRuntime.exports.jsxs(Component, __assign$25({}, props, handlers, { ref: ref, className: cn("rmd-list-item rmd-list-item--clickable rmd-list-item--link", (_b = {},
	            _b["rmd-list-item--".concat(height)] = height !== "auto" && height !== "normal",
	            _b["rmd-list-item--three-lines"] = !!secondaryText && threeLines,
	            _b), className) }, { children: [jsxRuntime.exports.jsx(ListItemChildren, __assign$25({ textClassName: textClassName, secondaryTextClassName: secondaryTextClassName, textChildren: textChildren, primaryText: primaryText, secondaryText: secondaryText, leftAddon: leftAddon, leftAddonType: leftAddonType, leftAddonPosition: leftAddonPosition, rightAddon: rightAddon, rightAddonType: rightAddonType, rightAddonPosition: rightAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })), ripples] })));
	});

	var __assign$24 = (undefined && undefined.__assign) || function () {
	    __assign$24 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$24.apply(this, arguments);
	};
	var __rest$1O = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$Q = bem("rmd-list-subheader");
	/**
	 * This is a simple component that will render a `<li>` with the subheader
	 * typography styles. It also supports an `inset` variant that adds some spacing
	 * to the left of the text to align with other `ListItem` that have left addons.
	 */
	var ListSubheader = require$$1.forwardRef(function ListSubheader(_a, ref) {
	    var className = _a.className, _b = _a.inset, inset = _b === void 0 ? false : _b, props = __rest$1O(_a, ["className", "inset"]);
	    return (jsxRuntime.exports.jsx("li", __assign$24({}, props, { ref: ref, className: cn(block$Q({ inset: inset }), className) })));
	});

	var __assign$23 = (undefined && undefined.__assign) || function () {
	    __assign$23 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$23.apply(this, arguments);
	};
	var __rest$1N = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$f = bem("rmd-toggle");
	/**
	 * @remarks \@since 2.8.0
	 */
	var InputToggleIcon = require$$1.forwardRef(function InputToggleIcon(_a, ref) {
	    var _b = _a.circle, circle = _b === void 0 ? false : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, _d = _a.overlay, overlay = _d === void 0 ? false : _d, _e = _a.checked, checked = _e === void 0 ? false : _e, _f = _a.indeterminate, indeterminate = _f === void 0 ? false : _f, className = _a.className, children = _a.children, props = __rest$1N(_a, ["circle", "disabled", "overlay", "checked", "indeterminate", "className", "children"]);
	    return (jsxRuntime.exports.jsx("span", __assign$23({}, props, { ref: ref, className: cn(styles$f("icon", {
	            circle: circle,
	            disabled: disabled,
	            overlay: overlay,
	            checked: !indeterminate && checked,
	            indeterminate: indeterminate,
	            "indeterminate-checked": checked && indeterminate,
	        }), className) }, { children: children })));
	});

	var __assign$22 = (undefined && undefined.__assign) || function () {
	    __assign$22 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$22.apply(this, arguments);
	};
	var __rest$1M = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$e = bem("rmd-switch");
	/**
	 * This is most likely an internal only component that is used to render the
	 * switch element either as a checkbox or in the `MenuItemSwitch` component.
	 *
	 * @remarks \@since 2.8.0
	 */
	var SwitchTrack = require$$1.forwardRef(function SwitchTrack(_a, ref) {
	    var id = _a.id, _b = _a.disabled, disabled = _b === void 0 ? false : _b, className = _a.className, ballStyle = _a.ballStyle, ballClassName = _a.ballClassName, containerProps = _a.containerProps, children = _a.children, props = __rest$1M(_a, ["id", "disabled", "className", "ballStyle", "ballClassName", "containerProps", "children"]);
	    var _c = props.checked, checked = _c === void 0 ? false : _c;
	    return (jsxRuntime.exports.jsxs("span", __assign$22({}, containerProps, { className: cn(styles$e(), className, containerProps === null || containerProps === void 0 ? void 0 : containerProps.className) }, { children: [id && (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsx("input", __assign$22({}, props, { id: id, ref: ref, type: "checkbox", className: cn(styles$e("input")), disabled: disabled })), jsxRuntime.exports.jsx("label", __assign$22({ htmlFor: id, "aria-hidden": true, style: ballStyle, className: cn(styles$e("ball"), ballClassName) }, { children: children }))] })), !id && (jsxRuntime.exports.jsx("span", { style: ballStyle, className: cn(styles$e("ball", { checked: checked }), ballClassName) }))] })));
	});

	var __assign$21 = (undefined && undefined.__assign) || function () {
	    __assign$21 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$21.apply(this, arguments);
	};
	var __rest$1L = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$d = bem("rmd-input-toggle-menu-item");
	/**
	 * This is a low-level component that should probably not be used externally and
	 * instead the `MenuItemCheckbox`, `MenuItemRadio`, or `MenuItemSwitch` should
	 * be used instead.
	 *
	 * @see {@link MenuItemCheckbox} for checkbox examples
	 * @see {@link MenuItemRadio} for radio examples
	 * @see {@link MenuItemSwitch} for switch examples
	 * @remarks \@since 2.8.0
	 */
	var MenuItemInputToggle = require$$1.forwardRef(function MenuItemInputToggle(_a, nodeRef) {
	    var children = _a.children, _b = _a.tabIndex, tabIndex = _b === void 0 ? -1 : _b, checked = _a.checked, type = _a.type, propIcon = _a.icon, _c = _a.iconAfter, iconAfter = _c === void 0 ? false : _c, addon = _a.addon, addonType = _a.addonType, addonPosition = _a.addonPosition, onClick = _a.onClick, onCheckedChange = _a.onCheckedChange, _d = _a.disabled, disabled = _d === void 0 ? false : _d, className = _a.className, _e = _a.indeterminate, indeterminate = _e === void 0 ? false : _e, props = __rest$1L(_a, ["children", "tabIndex", "checked", "type", "icon", "iconAfter", "addon", "addonType", "addonPosition", "onClick", "onCheckedChange", "disabled", "className", "indeterminate"]);
	    var ref = useKeyboardFocusableElement(nodeRef);
	    var icon = useIcon(type === "radio" ? "radio" : "checkbox", propIcon);
	    if (type === "switch" && typeof propIcon === "undefined") {
	        icon = jsxRuntime.exports.jsx(SwitchTrack, { checked: checked });
	    }
	    else if (icon && type !== "switch") {
	        icon = (jsxRuntime.exports.jsx("span", __assign$21({ className: cn("rmd-toggle", styles$d("toggle")) }, { children: jsxRuntime.exports.jsx(InputToggleIcon, __assign$21({ circle: type === "radio", disabled: disabled, overlay: true, checked: checked, indeterminate: indeterminate }, { children: icon })) })));
	    }
	    var leftAddon;
	    var leftAddonType;
	    var leftAddonPosition;
	    var rightAddon;
	    var rightAddonType;
	    var rightAddonPosition;
	    if (iconAfter) {
	        leftAddon = addon;
	        leftAddonType = addonType;
	        leftAddonPosition = addonPosition;
	        rightAddon = icon;
	    }
	    else {
	        leftAddon = icon;
	        rightAddon = addon;
	        rightAddonType = addonType;
	        rightAddonPosition = addonPosition;
	    }
	    return (jsxRuntime.exports.jsx(ListItem, __assign$21({}, props, { disableRipple: true, "aria-disabled": disabled || undefined, "aria-checked": checked, role: type === "radio" ? "menuitemradio" : "menuitemcheckbox", onClick: function (event) {
	            onClick === null || onClick === void 0 ? void 0 : onClick(event);
	            onCheckedChange(!checked, event);
	        }, ref: ref, className: cn(styles$d({ switch: type === "switch" }), className), tabIndex: tabIndex, leftAddon: leftAddon, leftAddonType: leftAddonType, leftAddonPosition: leftAddonPosition, rightAddon: rightAddon, rightAddonType: rightAddonType, rightAddonPosition: rightAddonPosition }, { children: children })));
	});

	var __assign$20 = (undefined && undefined.__assign) || function () {
	    __assign$20 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$20.apply(this, arguments);
	};
	var __rest$1K = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a simple wrapper for the {@link MenuItemInputToggle} component to
	 * render it as a checkbox and pulling the checkbox icon from the
	 * {@link IconProvider}.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { DropdownMenu } from "@react-md/menu";
	 * import { MenuItemCheckbox } from "@react-md/form";
	 *
	 * function Example(): ReactElement {
	 *   const [checked, setChecked] = useState(false);
	 *
	 *   return (
	 *     <DropdownMenu id="dropdown-menu-id" buttonChildren="Button">
	 *       <MenuItemCheckbox
	 *         id="checkbox-1"
	 *         checked={checked}
	 *         onCheckedChange={(nextChecked) => setChecked(nextChecked)}
	 *       >
	 *         Checkbox
	 *      </MenuItemCheckbox>
	 *     </DropdownMenu>
	 *   );
	 * }
	 * ```
	 */
	var MenuItemCheckbox = require$$1.forwardRef(function MenuItemCheckbox(_a, ref) {
	    var propIcon = _a.icon, props = __rest$1K(_a, ["icon"]);
	    var icon = useIcon("checkbox", propIcon);
	    return (jsxRuntime.exports.jsx(MenuItemInputToggle, __assign$20({}, props, { ref: ref, icon: icon, type: "checkbox" })));
	});

	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var noop$9 = function () {
	    // do nothing
	};
	/**
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	var getDefaultAnchor = function (_a) {
	    var menubar = _a.menubar, menuitem = _a.menuitem, floating = _a.floating, horizontal = _a.horizontal;
	    switch (floating) {
	        case "bottom-left":
	            return BOTTOM_INNER_LEFT_ANCHOR;
	        case "bottom-right":
	            return BOTTOM_INNER_RIGHT_ANCHOR;
	        case "top-left":
	            return TOP_INNER_LEFT_ANCHOR;
	        case "top-right":
	            return TOP_INNER_RIGHT_ANCHOR;
	    }
	    if (menubar) {
	        return menuitem ? CENTER_RIGHT_ANCHOR : BELOW_INNER_LEFT_ANCHOR;
	    }
	    if (horizontal) {
	        return BELOW_CENTER_ANCHOR;
	    }
	    if (menuitem) {
	        return TOP_RIGHT_ANCHOR;
	    }
	    return TOP_INNER_RIGHT_ANCHOR;
	};

	var __assign$1$ = (undefined && undefined.__assign) || function () {
	    __assign$1$ = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1$.apply(this, arguments);
	};
	var __read$H = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var context$9 = require$$1.createContext({
	    root: false,
	    menubar: false,
	    menuitem: false,
	    activeId: "",
	    setActiveId: noop$9,
	    animatedOnce: false,
	    setAnimatedOnce: noop$9,
	});
	context$9.displayName = "MenuBar";
	var Provider$6 = context$9.Provider;
	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	function useMenuBarContext() {
	    return require$$1.useContext(context$9);
	}
	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	function MenuBarProvider(_a) {
	    var children = _a.children, _b = _a.root, root = _b === void 0 ? true : _b, _c = _a.defaultActiveId, defaultActiveId = _c === void 0 ? "" : _c, hoverTimeout = _a.hoverTimeout;
	    var menubar = useMenuBarContext().menubar;
	    var _d = __read$H(require$$1.useState(defaultActiveId), 2), activeId = _d[0], setActiveId = _d[1];
	    var _e = __read$H(require$$1.useState(!!defaultActiveId), 2), animatedOnce = _e[0], setAnimatedOnce = _e[1];
	    var value = require$$1.useMemo(function () { return ({
	        root: root,
	        menubar: root || menubar,
	        menuitem: true,
	        activeId: activeId,
	        setActiveId: setActiveId,
	        hoverTimeout: hoverTimeout,
	        animatedOnce: animatedOnce,
	        setAnimatedOnce: setAnimatedOnce,
	    }); }, [activeId, animatedOnce, hoverTimeout, menubar, root]);
	    require$$1.useEffect(function () {
	        if (!activeId) {
	            setAnimatedOnce(false);
	        }
	    }, [activeId]);
	    return jsxRuntime.exports.jsx(Provider$6, __assign$1$({ value: value }, { children: children }));
	}

	var __assign$1_ = (undefined && undefined.__assign) || function () {
	    __assign$1_ = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1_.apply(this, arguments);
	};
	var __rest$1J = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is just an internal component that handles rendering the button for a
	 * `DropdownMenu` with a conditional dropdown icon.
	 *
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var MenuButton = require$$1.forwardRef(function MenuButton(_a, ref) {
	    var propIcon = _a.icon, _b = _a.iconAfter, iconAfter = _b === void 0 ? true : _b, iconRotatorProps = _a.iconRotatorProps, textIconSpacingProps = _a.textIconSpacingProps, floating = _a.floating, _c = _a.theme, theme = _c === void 0 ? floating ? "secondary" : "clear" : _c, _d = _a.themeType, themeType = _d === void 0 ? floating ? "contained" : "flat" : _d, _e = _a.buttonType, buttonType = _e === void 0 ? floating ? "icon" : "text" : _e, _f = _a.disableDropdownIcon, disableDropdownIcon = _f === void 0 ? buttonType === "icon" : _f, children = _a.children, visible = _a.visible, props = __rest$1J(_a, ["icon", "iconAfter", "iconRotatorProps", "textIconSpacingProps", "floating", "theme", "themeType", "buttonType", "disableDropdownIcon", "children", "visible"]);
	    var dropdownIcon = useIcon("dropdown", propIcon);
	    var icon = propIcon;
	    if (!disableDropdownIcon) {
	        icon = (jsxRuntime.exports.jsx(IconRotator, __assign$1_({}, iconRotatorProps, { rotated: visible }, { children: dropdownIcon })));
	    }
	    return (jsxRuntime.exports.jsx(Button, __assign$1_({}, props, { ref: ref, theme: theme, themeType: themeType, buttonType: buttonType, floating: floating }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$1_({ icon: icon, iconAfter: iconAfter }, textIconSpacingProps, { children: children })) })));
	});

	var __assign$1Z = (undefined && undefined.__assign) || function () {
	    __assign$1Z = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1Z.apply(this, arguments);
	};
	var __rest$1I = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/** @remarks \@since 5.0.0 */
	var DEFAULT_MENU_CONFIGURATION = {
	    horizontal: false,
	    renderAsSheet: false,
	    sheetHeader: null,
	    sheetFooter: null,
	    sheetPosition: "bottom",
	    sheetVerticalSize: "touch",
	};
	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var context$8 = require$$1.createContext(DEFAULT_MENU_CONFIGURATION);
	context$8.displayName = "MenuConfiguration";
	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var Provider$5 = context$8.Provider;
	/**
	 * This is probably just an internal only hook that allows you to get the
	 * {@link MenuConfigurationContext} with optional overrides.
	 *
	 * @param overrides - An object of {@link MenuConfiguration} that would override
	 * the inherited context values if they are not `undefined`.
	 * @returns the {@link MenuConfigurationContext} with any overrides that were
	 * provided.
	 * @remarks \@since 5.0.0
	 */
	function useMenuConfiguration(_a) {
	    var _b = _a === void 0 ? {} : _a, horizontal = _b.horizontal, renderAsSheet = _b.renderAsSheet, sheetHeader = _b.sheetHeader, sheetFooter = _b.sheetFooter, sheetPosition = _b.sheetPosition, sheetVerticalSize = _b.sheetVerticalSize;
	    var inherited = require$$1.useContext(context$8);
	    return {
	        horizontal: horizontal !== null && horizontal !== void 0 ? horizontal : inherited.horizontal,
	        renderAsSheet: renderAsSheet !== null && renderAsSheet !== void 0 ? renderAsSheet : inherited.renderAsSheet,
	        sheetHeader: sheetHeader === null ? null : sheetHeader !== null && sheetHeader !== void 0 ? sheetHeader : inherited.sheetHeader,
	        sheetFooter: sheetFooter === null ? null : sheetFooter !== null && sheetFooter !== void 0 ? sheetFooter : inherited.sheetFooter,
	        sheetPosition: sheetPosition !== null && sheetPosition !== void 0 ? sheetPosition : inherited.sheetPosition,
	        sheetVerticalSize: sheetVerticalSize !== null && sheetVerticalSize !== void 0 ? sheetVerticalSize : inherited.sheetVerticalSize,
	    };
	}
	/**
	 * Note: This will always merge values with any parent
	 * `MenuConfigurationProvider`s.
	 *
	 * @remarks \@since 5.0.0
	 */
	function MenuConfigurationProvider(_a) {
	    var children = _a.children, configuration = __rest$1I(_a, ["children"]);
	    var _b = useMenuConfiguration(configuration), horizontal = _b.horizontal, renderAsSheet = _b.renderAsSheet, sheetHeader = _b.sheetHeader, sheetFooter = _b.sheetFooter, sheetPosition = _b.sheetPosition, sheetVerticalSize = _b.sheetVerticalSize;
	    var value = require$$1.useMemo(function () { return ({
	        horizontal: horizontal,
	        renderAsSheet: renderAsSheet,
	        sheetHeader: sheetHeader,
	        sheetFooter: sheetFooter,
	        sheetPosition: sheetPosition,
	        sheetVerticalSize: sheetVerticalSize,
	    }); }, [
	        horizontal,
	        renderAsSheet,
	        sheetFooter,
	        sheetHeader,
	        sheetPosition,
	        sheetVerticalSize,
	    ]);
	    return jsxRuntime.exports.jsx(Provider$5, __assign$1Z({ value: value }, { children: children }));
	}

	var __assign$1Y = (undefined && undefined.__assign) || function () {
	    __assign$1Y = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1Y.apply(this, arguments);
	};
	var __rest$1H = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$G = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This context is used to implement the "roving tab index" behavior
	 *
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var context$7 = require$$1.createContext("");
	context$7.displayName = "MenuBarWidgetFocusId";
	var Provider$4 = context$7.Provider;
	/** @remarks \@since 5.0.0 */
	function useMenuBarWidgetFocusId() {
	    return require$$1.useContext(context$7);
	}
	/**
	 * This component implements the keyboard focus behavior for the `MenuBar`
	 * component and probably shouldn't be used externally.
	 *
	 * @remarks \@since 5.0.0
	 */
	function MenuBarWidget(_a) {
	    var children = _a.children, tabIndex = _a.tabIndex, propOnFocus = _a.onFocus, propOnKeyDown = _a.onKeyDown, props = __rest$1H(_a, ["children", "tabIndex", "onFocus", "onKeyDown"]);
	    var setActiveId = useMenuBarContext().setActiveId;
	    var _b = __read$G(require$$1.useState(""), 2), focusId = _b[0], setFocusId = _b[1];
	    var _c = useKeyboardFocus({
	        onFocus: propOnFocus,
	        onKeyDown: propOnKeyDown,
	        onFocusChange: function (element) {
	            element.focus();
	            setFocusId(element.id);
	            setActiveId(function (prevActiveId) { return (prevActiveId ? element.id : ""); });
	        },
	    }), onFocus = _c.onFocus, onKeyDown = _c.onKeyDown;
	    return (jsxRuntime.exports.jsx(Provider$4, __assign$1Y({ value: focusId }, { children: jsxRuntime.exports.jsx(List, __assign$1Y({}, props, { role: "menubar", horizontal: true, tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : (focusId ? -1 : 0), onFocus: onFocus, onKeyDown: onKeyDown }, { children: children })) })));
	}

	var __assign$1X = (undefined && undefined.__assign) || function () {
	    __assign$1X = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1X.apply(this, arguments);
	};
	var __rest$1G = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is used as an "action" within a `Menu`/`DropdownMenu` that
	 * implements some keyboard focus behavior. This component should generally have
	 * an `onClick` event handler.
	 *
	 * @remarks \@since 5.0.0
	 */
	var MenuItem = require$$1.forwardRef(function MenuItem(_a, nodeRef) {
	    var className = _a.className, children = _a.children, _b = _a.role, role = _b === void 0 ? "menuitem" : _b, _c = _a.tabIndex, tabIndex = _c === void 0 ? -1 : _c, props = __rest$1G(_a, ["className", "children", "role", "tabIndex"]);
	    var ref = useKeyboardFocusableElement(nodeRef);
	    return (jsxRuntime.exports.jsx(ListItem, __assign$1X({}, props, { ref: ref, role: role, tabIndex: tabIndex, className: cn("rmd-menu-item", className) }, { children: children })));
	});

	var __assign$1W = (undefined && undefined.__assign) || function () {
	    __assign$1W = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1W.apply(this, arguments);
	};
	var __rest$1F = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is just an internal component that handles rendering a submenu as a
	 * menuitem for a `DropdownMenu` with a conditional dropdown icon.
	 *
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var MenuItemButton = require$$1.forwardRef(function MenuItemButton(_a, ref) {
	    var id = _a.id, children = _a.children, propRightAddon = _a.rightAddon, _b = _a.disableDropdownIcon, disableDropdownIcon = _b === void 0 ? typeof propRightAddon !== "undefined" : _b, visible = _a.visible, tabIndex = _a.tabIndex, iconRotatorProps = _a.iconRotatorProps, props = __rest$1F(_a, ["id", "children", "rightAddon", "disableDropdownIcon", "visible", "tabIndex", "iconRotatorProps"]);
	    var root = useMenuBarContext().root;
	    var focusId = useMenuBarWidgetFocusId();
	    var dropdownIcon = useIcon(root ? "dropdown" : "forward");
	    var rightAddon = propRightAddon;
	    if (!disableDropdownIcon) {
	        rightAddon = (jsxRuntime.exports.jsx(IconRotator, __assign$1W({}, iconRotatorProps, { rotated: visible }, { children: dropdownIcon })));
	    }
	    return (jsxRuntime.exports.jsx(MenuItem, __assign$1W({}, props, { id: id, ref: ref, rightAddon: rightAddon, tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : (root && id === focusId ? 0 : -1) }, { children: children })));
	});

	var __assign$1V = (undefined && undefined.__assign) || function () {
	    __assign$1V = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1V.apply(this, arguments);
	};
	/** @remarks \@since 5.0.0 */
	function MenuKeyboardFocusProvider(_a) {
	    var _b = _a.horizontal, horizontal = _b === void 0 ? false : _b, children = _a.children;
	    return (jsxRuntime.exports.jsx(KeyboardMovementProvider, __assign$1V({ loopable: true, searchable: true, incrementKeys: horizontal ? ["ArrowRight"] : ["ArrowDown"], decrementKeys: horizontal ? ["ArrowLeft"] : ["ArrowUp"], 
	        // disabled menu items should be focusable, but not interactable for some
	        // reason
	        // https://www.w3.org/TR/wai-aria-practices/#menu
	        includeDisabled: true }, { children: children })));
	}

	var __assign$1U = (undefined && undefined.__assign) || function () {
	    __assign$1U = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1U.apply(this, arguments);
	};
	var __rest$1E = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$c = bem("rmd-menu");
	/**
	 * This component implements the custom keyboard movement for a
	 * [menu widget](https://www.w3.org/TR/wai-aria-practices/#menubutton). The
	 * {@link MenuKeyboardFocusProvider} must be a parent component for this custom
	 * focus behavior to work.
	 *
	 * Note: This is probably an internal only component since the {@link Menu} has
	 * more functionality and includes this component.
	 *
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var MenuWidget = require$$1.forwardRef(function MenuWidget(_a, ref) {
	    var children = _a.children, propOnFocus = _a.onFocus, propOnKeyDown = _a.onKeyDown, _b = _a.tabIndex, tabIndex = _b === void 0 ? -1 : _b, _c = _a.horizontal, horizontal = _c === void 0 ? false : _c, className = _a.className, getDefaultFocusIndex = _a.getDefaultFocusIndex, onSearch = _a.onSearch, onIncrement = _a.onIncrement, onDecrement = _a.onDecrement, onJumpToLast = _a.onJumpToLast, onJumpToFirst = _a.onJumpToFirst, _d = _a.disableElevation, disableElevation = _d === void 0 ? false : _d, props = __rest$1E(_a, ["children", "onFocus", "onKeyDown", "tabIndex", "horizontal", "className", "getDefaultFocusIndex", "onSearch", "onIncrement", "onDecrement", "onJumpToLast", "onJumpToFirst", "disableElevation"]);
	    var _e = useKeyboardFocus({
	        onFocus: propOnFocus,
	        onKeyDown: propOnKeyDown,
	        getDefaultFocusIndex: getDefaultFocusIndex,
	        onSearch: onSearch,
	        onIncrement: onIncrement,
	        onDecrement: onDecrement,
	        onJumpToLast: onJumpToLast,
	        onJumpToFirst: onJumpToFirst,
	    }), onFocus = _e.onFocus, onKeyDown = _e.onKeyDown;
	    return (jsxRuntime.exports.jsx(MenuBarProvider, __assign$1U({ root: false, defaultActiveId: props.id }, { children: jsxRuntime.exports.jsx("div", __assign$1U({ "aria-orientation": horizontal ? "horizontal" : undefined }, props, { ref: ref, role: "menu", onFocus: onFocus, onKeyDown: onKeyDown, tabIndex: tabIndex, className: cn(styles$c({ horizontal: horizontal, elevated: !disableElevation }), className) }, { children: children })) })));
	});

	var __assign$1T = (undefined && undefined.__assign) || function () {
	    __assign$1T = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1T.apply(this, arguments);
	};
	var __rest$1D = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component conditionally renders the {@link MenuWidget} with the
	 * {@link MenuKeyboardFocusProvider} based on the `visible` prop with a CSS
	 * transition that can be configured.
	 *
	 * @remarks \@since 5.0.0
	 */
	var Menu = require$$1.forwardRef(function Menu(_a, ref) {
	    var className = _a.className, listStyle = _a.listStyle, listClassName = _a.listClassName, listProps = _a.listProps, visible = _a.visible, _b = _a.temporary, temporary = _b === void 0 ? true : _b, _c = _a.horizontal, horizontal = _c === void 0 ? false : _c, _d = _a.portal, portal = _d === void 0 ? temporary : _d, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, appear = _a.appear, enter = _a.enter, exit = _a.exit, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, timeout = _a.timeout, classNames = _a.classNames, children = _a.children, props = __rest$1D(_a, ["className", "listStyle", "listClassName", "listProps", "visible", "temporary", "horizontal", "portal", "portalInto", "portalIntoId", "appear", "enter", "exit", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "timeout", "classNames", "children"]);
	    var _e = useScaleTransition({
	        nodeRef: ref,
	        className: className,
	        transitionIn: visible,
	        vertical: !horizontal,
	        temporary: temporary,
	        timeout: timeout,
	        classNames: classNames,
	        appear: appear,
	        enter: enter,
	        exit: exit,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExit: onExit,
	        onExiting: onExiting,
	        onExited: onExited,
	    }), elementProps = _e.elementProps, rendered = _e.rendered, stage = _e.stage;
	    return (jsxRuntime.exports.jsx(ConditionalPortal, __assign$1T({ portal: portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: rendered && (jsxRuntime.exports.jsx(MenuKeyboardFocusProvider, __assign$1T({ horizontal: horizontal }, { children: jsxRuntime.exports.jsx(MenuWidget, __assign$1T({ hidden: !temporary && stage === "exited" }, props, elementProps, { horizontal: horizontal }, { children: jsxRuntime.exports.jsx(List, __assign$1T({}, listProps, { style: listStyle !== null && listStyle !== void 0 ? listStyle : listProps === null || listProps === void 0 ? void 0 : listProps.style, className: listClassName !== null && listClassName !== void 0 ? listClassName : listProps === null || listProps === void 0 ? void 0 : listProps.className, horizontal: horizontal, onClick: function (event) {
	                        var _a;
	                        (_a = listProps === null || listProps === void 0 ? void 0 : listProps.onClick) === null || _a === void 0 ? void 0 : _a.call(listProps, event);
	                        // this makes it so you can click on the menu/list without
	                        // closing the menu
	                        if (event.target === event.currentTarget) {
	                            event.stopPropagation();
	                        }
	                    } }, { children: children })) })) }))) })));
	});

	/**
	 * @remarks \@since 2.4.0
	 */
	var DEFAULT_OVERLAY_TIMEOUT = 150;
	/**
	 * @remarks \@since 2.4.0
	 */
	var DEFAULT_OVERLAY_CLASSNAMES = {
	    appearActive: "rmd-overlay--active",
	    appearDone: "rmd-overlay--active",
	    enterActive: "rmd-overlay--active",
	    enterDone: "rmd-overlay--active",
	};

	var __assign$1S = (undefined && undefined.__assign) || function () {
	    __assign$1S = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1S.apply(this, arguments);
	};
	var __rest$1C = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$P = bem("rmd-overlay");
	/**
	 * The `Overlay` component is a simple component used to render a full page
	 * overlay in the page with an enter and exit animation. If there are overflow
	 * issues or you need to portal the overlay to a different area within your app,
	 * you should use the `OverlayPortal` component instead.
	 */
	var Overlay = require$$1.forwardRef(function Overlay(_a, nodeRef) {
	    var className = _a.className, visible = _a.visible, _b = _a.hidden, hidden = _b === void 0 ? false : _b, _c = _a.clickable, clickable = _c === void 0 ? true : _c, _d = _a.timeout, timeout = _d === void 0 ? DEFAULT_OVERLAY_TIMEOUT : _d, _e = _a.classNames, classNames = _e === void 0 ? DEFAULT_OVERLAY_CLASSNAMES : _e, children = _a.children, _f = _a.temporary, temporary = _f === void 0 ? true : _f, onRequestClose = _a.onRequestClose, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, portal = _a.portal, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, _g = _a.tabIndex, tabIndex = _g === void 0 ? -1 : _g, onClick = _a.onClick, props = __rest$1C(_a, ["className", "visible", "hidden", "clickable", "timeout", "classNames", "children", "temporary", "onRequestClose", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "portal", "portalInto", "portalIntoId", "tabIndex", "onClick"]);
	    return (jsxRuntime.exports.jsx(ConditionalPortal, __assign$1S({ portal: portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: jsxRuntime.exports.jsx(CSSTransition, __assign$1S({ appear: true, nodeRef: nodeRef, transitionIn: visible, classNames: hidden ? "" : classNames, timeout: hidden ? 0 : timeout, temporary: temporary, onEnter: onEnter, onEntering: onEntering, onEntered: onEntered, onExit: onExit, onExiting: onExiting, onExited: onExited }, { children: jsxRuntime.exports.jsx("span", __assign$1S({}, props, { className: cn(block$P({
	                    visible: visible,
	                    clickable: clickable,
	                }), className), onClick: function (event) {
	                    onClick === null || onClick === void 0 ? void 0 : onClick(event);
	                    if (event.isPropagationStopped()) {
	                        return;
	                    }
	                    onRequestClose();
	                }, tabIndex: tabIndex }, { children: children })) })) })));
	});

	var __assign$1R = (undefined && undefined.__assign) || function () {
	    __assign$1R = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1R.apply(this, arguments);
	};
	var __read$F = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var noop$8 = function () {
	    // do nothing
	};
	var context$6 = require$$1.createContext({
	    stack: [],
	    add: noop$8,
	    remove: noop$8,
	});
	var Provider$3 = context$6.Provider;
	/**
	 * This component is used to help with handling nested dialogs by:
	 * - preventing all dialogs to be closed when the escape key is pressed
	 * - hiding the overlays for dialogs that are not the top-most focus
	 *
	 * This should be added to the root of your app if you would like to enable this
	 * feature.
	 */
	function NestedDialogContextProvider(_a) {
	    var children = _a.children;
	    var _b = __read$F(require$$1.useState([]), 2), stack = _b[0], setStack = _b[1];
	    var add = require$$1.useCallback(function (dialogId) {
	        setStack(function (prevStack) {
	            return prevStack.concat(dialogId);
	        });
	    }, []);
	    var remove = require$$1.useCallback(function (dialogId) {
	        setStack(function (prevStack) { return prevStack.filter(function (id) { return id !== dialogId; }); });
	    }, []);
	    var value = require$$1.useMemo(function () { return ({ stack: stack, add: add, remove: remove }); }, [add, remove, stack]);
	    return jsxRuntime.exports.jsx(Provider$3, __assign$1R({ value: value }, { children: children }));
	}
	/**
	 * Gets the current nested dialog context. This shouldn't really be used
	 * externally and is a private context hook.
	 *
	 * @internal
	 */
	function useNestedDialogContext() {
	    return require$$1.useContext(context$6);
	}

	/**
	 * This hook is used to fix the nested overlays and the escape keypress when
	 * multiple dialogs are rendered at the same time on a page. All it really does
	 * is keep a stack of the dialog ids that are current visible. If there is more
	 * than 1 dialog visible and the dialog is not at the top of the stack, the
	 * overlay and escape keypress will be disabled.
	 *
	 * NOTE: This will not work if you nest dialogs together and have them become
	 * visible at the same time because the ids will get added from child to parent
	 * instead of parent -&gt; child. This flow shouldn't really happen though so it
	 * isn't planned on being fixed.
	 */
	function useNestedDialogFixes(_a) {
	    var id = _a.id, visible = _a.visible, disabled = _a.disabled, propDisableEscapeClose = _a.disableEscapeClose;
	    var _b = useNestedDialogContext(), add = _b.add, remove = _b.remove, stack = _b.stack;
	    require$$1.useEffect(function () {
	        if (disabled || !visible) {
	            return;
	        }
	        add(id);
	        return function () {
	            remove(id);
	        };
	    }, [visible, disabled, id, add, remove]);
	    return require$$1.useMemo(function () {
	        var disableOverlay = false;
	        var disableEscapeClose = propDisableEscapeClose;
	        if (!disabled && visible && stack.length > 1) {
	            var lastIndex = stack.length - 1;
	            var i = stack.findIndex(function (dialogId) { return id === dialogId; });
	            disableOverlay = i < lastIndex;
	            if (!propDisableEscapeClose) {
	                disableEscapeClose = i < lastIndex;
	            }
	        }
	        return {
	            disableOverlay: disableOverlay,
	            disableEscapeClose: disableEscapeClose,
	        };
	    }, [id, propDisableEscapeClose, disabled, visible, stack]);
	}

	var __assign$1Q = (undefined && undefined.__assign) || function () {
	    __assign$1Q = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1Q.apply(this, arguments);
	};
	var __rest$1B = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	// used to disable the overlay click-to-close functionality when the `modal` prop is enabled.
	var noop$7 = function () {
	    // do nothing
	};
	var block$O = bem("rmd-dialog");
	/** @remarks \@since 4.0.0 */
	var DEFAULT_DIALOG_CLASSNAMES = {
	    appear: "rmd-dialog--enter",
	    appearActive: "rmd-dialog--enter-active",
	    enter: "rmd-dialog--enter",
	    enterActive: "rmd-dialog--enter-active",
	    exit: "rmd-dialog--exit",
	    exitActive: "rmd-dialog--exit-active",
	};
	/** @remarks \@since 4.0.0 */
	var DEFAULT_DIALOG_TIMEOUT = {
	    enter: 200,
	    exit: 150,
	};
	/**
	 * A dialog is used to show important content above all other elements within
	 * the page. This is normally used for alerts, confirmations, or just temporary
	 * content. The dialog within react-md also has the additional features for
	 * accessibility:
	 *
	 * - automatically focus the dialog on mount for keyboard users
	 * - prevent elements outside of the dialog to be focused
	 * - close via the escape key
	 * - prevent the page outside of the dialog from being scrolled
	 *
	 * To complete the dialog accessibility requirements, every dialog **must**
	 * provide an `id` and either an `aria-label` describing the dialog or an
	 * `aria-labelledby` id that points to an element describing this dialog.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { Button } from "@react-md/button";
	 * import {
	 *   Dialog,
	 *   DialogHeader,
	 *   DialogTitle,
	 *   DialogContent,
	 *   DialogFooter,
	 * } from "@react-md/dialog";
	 * import { Typography } from "@react-md/typography";
	 *
	 * function Example(): ReactElement {
	 *   const [visible, setVisible] = useState(false);
	 *   const hide = (): void => {
	 *     setVisible(false);
	 *   };
	 *
	 *   return (
	 *     <>
	 *       <Button onClick={() => setVisible(!visible)}>
	 *         Show Dialog
	 *       </Button>
	 *       <Dialog
	 *         aria-labelledby="dialog-title"
	 *         id="simple-dialog"
	 *         visible={visible}
	 *         onRequestClose={hide}
	 *       >
	 *         <DialogHeader>
	 *           <DialogTitle id="dialog-title">Simple Dialog</DialogTitle>
	 *         </DialogHeader>
	 *         <DialogContent>
	 *           <Typography margin="none">This is some text in a dialog.</Typography>
	 *         </DialogContent>
	 *         <DialogFooter>
	 *           <Button onClick={hide}>
	 *             Close
	 *           </Button>
	 *         </DialogFooter>
	 *       </Dialog>
	 *     </>
	 *   );
	 * }
	 * ```
	 */
	var Dialog = require$$1.forwardRef(function Dialog(_a, nodeRef) {
	    var _b = _a.component, component = _b === void 0 ? "div" : _b, _c = _a.tabIndex, tabIndex = _c === void 0 ? -1 : _c, children = _a.children, className = _a.className, containerStyle = _a.containerStyle, containerClassName = _a.containerClassName, propOverlay = _a.overlay, overlayStyle = _a.overlayStyle, overlayClassName = _a.overlayClassName, _d = _a.overlayHidden, overlayHidden = _d === void 0 ? false : _d, visible = _a.visible, onRequestClose = _a.onRequestClose, _e = _a.forceContainer, forceContainer = _e === void 0 ? false : _e, _f = _a.defaultFocus, defaultFocus = _f === void 0 ? "first" : _f, _g = _a.portal, portal = _g === void 0 ? true : _g, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, _h = _a.appear, appear = _h === void 0 ? false : _h, _j = _a.enter, enter = _j === void 0 ? true : _j, _k = _a.exit, exit = _k === void 0 ? true : _k, _l = _a.disableTransition, disableTransition = _l === void 0 ? false : _l, _m = _a.classNames, classNames = _m === void 0 ? DEFAULT_DIALOG_CLASSNAMES : _m, _o = _a.timeout, timeout = _o === void 0 ? DEFAULT_DIALOG_TIMEOUT : _o, _p = _a.temporary, temporary = _p === void 0 ? true : _p, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, _q = _a.modal, modal = _q === void 0 ? false : _q, _r = _a.role, role = _r === void 0 ? "dialog" : _r, _s = _a.type, type = _s === void 0 ? "centered" : _s, _t = _a.disableScrollLock, disableScrollLock = _t === void 0 ? false : _t, _u = _a.disableEscapeClose, propDisableEscapeClose = _u === void 0 ? false : _u, _v = _a.disableFocusContainer, disableFocusContainer = _v === void 0 ? false : _v, _w = _a.disableTabFocusWrap, disableTabFocusWrap = _w === void 0 ? false : _w, _x = _a.disableFocusOnMount, disableFocusOnMount = _x === void 0 ? false : _x, _y = _a.disableFocusOnUnmount, disableFocusOnUnmount = _y === void 0 ? false : _y, _z = _a.disableNestedDialogFixes, disableNestedDialogFixes = _z === void 0 ? false : _z, onKeyDown = _a.onKeyDown, overlayProps = _a.overlayProps, props = __rest$1B(_a, ["component", "tabIndex", "children", "className", "containerStyle", "containerClassName", "overlay", "overlayStyle", "overlayClassName", "overlayHidden", "visible", "onRequestClose", "forceContainer", "defaultFocus", "portal", "portalInto", "portalIntoId", "appear", "enter", "exit", "disableTransition", "classNames", "timeout", "temporary", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "modal", "role", "type", "disableScrollLock", "disableEscapeClose", "disableFocusContainer", "disableTabFocusWrap", "disableFocusOnMount", "disableFocusOnUnmount", "disableNestedDialogFixes", "onKeyDown", "overlayProps"]);
	    var id = props.id;
	    var isNoneRole = role === "none";
	    var isFullPage = type === "full-page";
	    var isCentered = type === "centered";
	    var _0 = useNestedDialogFixes({
	        id: id,
	        visible: visible,
	        disabled: disableNestedDialogFixes,
	        disableEscapeClose: propDisableEscapeClose,
	    }), disableOverlay = _0.disableOverlay, disableEscapeClose = _0.disableEscapeClose;
	    useScrollLock(visible && !isNoneRole && !disableScrollLock);
	    var overlayEl = null;
	    if (typeof propOverlay === "boolean" ? propOverlay : !isFullPage) {
	        // do not add the portal props to the overlay element since the portalling
	        // is handled in here. With how portals work, this would be rendered **after**
	        // the dialog instead of before which breaks some dialog styles
	        overlayEl = (jsxRuntime.exports.jsx(Overlay, __assign$1Q({ id: "".concat(id, "-overlay") }, overlayProps, { style: overlayStyle, className: cn("rmd-dialog-overlay", overlayClassName), hidden: overlayHidden || disableOverlay, visible: visible, clickable: !modal, onRequestClose: modal ? noop$7 : onRequestClose })));
	    }
	    var _1 = useCSSTransition({
	        nodeRef: nodeRef,
	        transitionIn: visible,
	        timeout: timeout,
	        classNames: classNames,
	        className: cn(block$O({
	            centered: isCentered,
	            "full-page": isFullPage,
	        }), className),
	        appear: !disableTransition && appear,
	        enter: !disableTransition && enter,
	        exit: !disableTransition && exit,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExit: onExit,
	        onExiting: onExiting,
	        onExited: onExited,
	        temporary: temporary,
	    }), elementProps = _1.elementProps, rendered = _1.rendered;
	    var dialog = (jsxRuntime.exports.jsx(FocusContainer, __assign$1Q({}, props, elementProps, { role: isNoneRole ? undefined : role, "aria-modal": (!isNoneRole && !!overlayEl) || undefined, tabIndex: tabIndex, component: component, defaultFocus: defaultFocus, disableTabFocusWrap: isNoneRole || disableTabFocusWrap || disableFocusContainer, disableFocusOnMount: isNoneRole || disableFocusContainer || disableFocusOnMount, disableFocusOnMountScroll: true, disableFocusOnUnmount: isNoneRole || disableFocusContainer || disableFocusOnUnmount, onKeyDown: useCloseOnEscape(onRequestClose, disableEscapeClose || isNoneRole, onKeyDown) }, { children: children })));
	    if (isCentered || forceContainer) {
	        // the additional container is only required when we don't have a full page dialog. it's just
	        // used to apply flex center to the dialog and add some margin
	        dialog = (jsxRuntime.exports.jsx("span", __assign$1Q({ id: "".concat(id, "-container"), style: containerStyle, className: cn("rmd-dialog-container", containerClassName) }, { children: dialog })));
	    }
	    return (jsxRuntime.exports.jsxs(ConditionalPortal, __assign$1Q({ portal: !isNoneRole && portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: [overlayEl, rendered && dialog] })));
	});

	var __assign$1P = (undefined && undefined.__assign) || function () {
	    __assign$1P = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1P.apply(this, arguments);
	};
	var __rest$1A = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$N = bem("rmd-dialog");
	/**
	 * This component doesn't do anything to complex. It really just applies custom
	 * styles so that when the `DialogContent` component is used, the header will be
	 * "fixed" to the top of the dialog while the content scrolls. It also applies
	 * some minimal padding.
	 */
	var DialogHeader = require$$1.forwardRef(function DialogHeader(_a, ref) {
	    var children = _a.children, className = _a.className, props = __rest$1A(_a, ["children", "className"]);
	    return (jsxRuntime.exports.jsx("header", __assign$1P({}, props, { ref: ref, className: cn(block$N("header"), className) }, { children: children })));
	});

	var __assign$1O = (undefined && undefined.__assign) || function () {
	    __assign$1O = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1O.apply(this, arguments);
	};
	var __rest$1z = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$M = bem("rmd-dialog");
	/**
	 * This component adds some base styles to an `<h2>` element for a title within
	 * a `Dialog`.
	 */
	var DialogTitle = require$$1.forwardRef(function DialogTitle(_a, ref) {
	    var children = _a.children, className = _a.className, props = __rest$1z(_a, ["children", "className"]);
	    return (jsxRuntime.exports.jsx("h2", __assign$1O({}, props, { ref: ref, className: cn(block$M("title"), className) }, { children: children })));
	});

	var __assign$1N = (undefined && undefined.__assign) || function () {
	    __assign$1N = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1N.apply(this, arguments);
	};
	var __rest$1y = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$L = bem("rmd-dialog");
	/**
	 * This component is used to render the main content within a dialog. There are
	 * really only benefits when using the component alongside the `DialogHeader`
	 * and/or `DialogFooter` since it is set up so only the content will scroll
	 * while the header and footer will be "fixed".
	 */
	var DialogContent = require$$1.forwardRef(function DialogContent(_a, ref) {
	    var children = _a.children, className = _a.className, _b = _a.disablePadding, disablePadding = _b === void 0 ? false : _b, props = __rest$1y(_a, ["children", "className", "disablePadding"]);
	    return (jsxRuntime.exports.jsx("div", __assign$1N({}, props, { ref: ref, className: cn(block$L("content", {
	            padded: !disablePadding,
	        }), className) }, { children: children })));
	});

	var __assign$1M = (undefined && undefined.__assign) || function () {
	    __assign$1M = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1M.apply(this, arguments);
	};
	var __rest$1x = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$K = bem("rmd-dialog");
	var DialogFooter = require$$1.forwardRef(function DialogFooter(_a, ref) {
	    var children = _a.children, className = _a.className, _b = _a.align, align = _b === void 0 ? "end" : _b, props = __rest$1x(_a, ["children", "className", "align"]);
	    return (jsxRuntime.exports.jsx("footer", __assign$1M({}, props, { ref: ref, className: cn(block$K("footer", {
	            flex: align !== "none",
	            "flex-v": align === "stacked-start" || align === "stacked-end",
	            start: align === "start" || align === "stacked-start",
	            between: align === "between",
	            end: align === "end" || align === "stacked-end",
	        }), className) }, { children: children })));
	});

	var __assign$1L = (undefined && undefined.__assign) || function () {
	    __assign$1L = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1L.apply(this, arguments);
	};
	var __rest$1w = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var DEFAULT_CLASSNAMES = {
	    appear: "rmd-dialog--fixed-enter",
	    appearActive: "rmd-dialog--fixed-enter-active",
	    enter: "rmd-dialog--fixed-enter",
	    enterActive: "rmd-dialog--fixed-enter-active",
	    exit: "rmd-dialog--fixed-exit",
	    exitActive: "rmd-dialog--fixed-exit-active",
	};
	/**
	 * The `FixedDialog` is a wrapper for the `Dialog` component that can be used to
	 * be fix itself to another element. Another term for this component might be a
	 * "Pop out Dialog".
	 */
	var FixedDialog = require$$1.forwardRef(function FixedDialog(_a, nodeRef) {
	    var fixedTo = _a.fixedTo, propStyle = _a.style, _b = _a.anchor, anchor = _b === void 0 ? TOP_INNER_RIGHT_ANCHOR : _b, options = _a.options, getOptions = _a.getOptions, children = _a.children, className = _a.className, _c = _a.classNames, classNames = _c === void 0 ? DEFAULT_CLASSNAMES : _c, _d = _a.overlayHidden, overlayHidden = _d === void 0 ? true : _d, _e = _a.disableScrollLock, disableScrollLock = _e === void 0 ? true : _e, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, props = __rest$1w(_a, ["fixedTo", "style", "anchor", "options", "getOptions", "children", "className", "classNames", "overlayHidden", "disableScrollLock", "onEnter", "onEntering", "onEntered", "onExited"]);
	    var onRequestClose = props.onRequestClose;
	    var _f = useFixedPositioning(__assign$1L(__assign$1L({ nodeRef: nodeRef, style: propStyle, transformOrigin: true, onEnter: onEnter, onEntering: onEntering, onEntered: onEntered, onExited: onExited, anchor: anchor, fixedTo: fixedTo, onScroll: /* istanbul ignore next */ function (_event, _a) {
	            var visible = _a.visible;
	            if (!visible) {
	                onRequestClose();
	            }
	        } }, options), { getFixedPositionOptions: getOptions })), ref = _f.ref, style = _f.style, callbacks = _f.callbacks;
	    return (jsxRuntime.exports.jsx(Dialog, __assign$1L({}, props, callbacks, { ref: ref, type: "custom", style: style, className: cn("rmd-dialog--fixed", className), classNames: classNames, overlayHidden: overlayHidden, disableScrollLock: disableScrollLock }, { children: children })));
	});

	var DEFAULT_SHEET_TIMEOUT = {
	    enter: 200,
	    exit: 150,
	};
	var DEFAULT_SHEET_CLASSNAMES = {
	    appear: "rmd-sheet--offscreen",
	    appearActive: "rmd-sheet--enter rmd-sheet--visible",
	    enter: "rmd-sheet--offscreen",
	    enterActive: "rmd-sheet--enter rmd-sheet--visible",
	    exit: "rmd-sheet--exit",
	    exitActive: "rmd-sheet--offscreen",
	    exitDone: "rmd-sheet--offscreen rmd-sheet--hidden",
	};

	var __assign$1K = (undefined && undefined.__assign) || function () {
	    __assign$1K = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1K.apply(this, arguments);
	};
	var __rest$1v = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$E = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var block$J = bem("rmd-sheet");
	/**
	 * The Sheet component is an extension of the `Dialog` except that it is fixed
	 * to the edges of the viewport instead of centered or full page. This component
	 * is great for rendering a navigation tree or menus on mobile devices.
	 */
	var Sheet = require$$1.forwardRef(function Sheet(_a, ref) {
	    var _b;
	    var className = _a.className, children = _a.children, visible = _a.visible, _c = _a.position, position = _c === void 0 ? "left" : _c, _d = _a.horizontalSize, horizontalSize = _d === void 0 ? "media" : _d, _e = _a.verticalSize, verticalSize = _e === void 0 ? "recommended" : _e, _f = _a.overlay, propOverlay = _f === void 0 ? true : _f, overlayClassName = _a.overlayClassName, _g = _a.role, role = _g === void 0 ? "dialog" : _g, _h = _a.component, component = _h === void 0 ? "div" : _h, _j = _a.tabIndex, tabIndex = _j === void 0 ? -1 : _j, _k = _a.appear, appear = _k === void 0 ? false : _k, _l = _a.enter, enter = _l === void 0 ? true : _l, _m = _a.exit, exit = _m === void 0 ? true : _m, onExited = _a.onExited, propHidden = _a.hidden, _o = _a.timeout, timeout = _o === void 0 ? DEFAULT_SHEET_TIMEOUT : _o, _p = _a.classNames, classNames = _p === void 0 ? DEFAULT_SHEET_CLASSNAMES : _p, _q = _a.disableTransition, disableTransition = _q === void 0 ? false : _q, _r = _a.temporary, temporary = _r === void 0 ? true : _r, _s = _a.portal, portal = _s === void 0 ? true : _s, _t = _a.overlayHidden, overlayHidden = _t === void 0 ? false : _t, _u = _a.defaultFocus, defaultFocus = _u === void 0 ? "first" : _u, _v = _a.disableScrollLock, disableScrollLock = _v === void 0 ? false : _v, _w = _a.disableEscapeClose, disableEscapeClose = _w === void 0 ? false : _w, _x = _a.disableFocusContainer, disableFocusContainer = _x === void 0 ? false : _x, _y = _a.disableNestedDialogFixes, disableNestedDialogFixes = _y === void 0 ? false : _y, props = __rest$1v(_a, ["className", "children", "visible", "position", "horizontalSize", "verticalSize", "overlay", "overlayClassName", "role", "component", "tabIndex", "appear", "enter", "exit", "onExited", "hidden", "timeout", "classNames", "disableTransition", "temporary", "portal", "overlayHidden", "defaultFocus", "disableScrollLock", "disableEscapeClose", "disableFocusContainer", "disableNestedDialogFixes"]);
	    var horizontal = position === "left" || position === "right";
	    var overlay = role !== "none" && propOverlay;
	    // if the sheet mounts while not visible and the conditional mounting isn't
	    // enabled, need to default to the offscreen state which is normally handled
	    // by the CSSTransition's exit state.
	    var offscreen = require$$1.useRef(!visible && !temporary);
	    if (offscreen.current && visible) {
	        offscreen.current = false;
	    }
	    // when sheets are not unmounted on exit, need to set it to hidden so that
	    // tabbing no longer focuses any of the elements inside
	    var _z = __read$E(require$$1.useState(!visible && !temporary), 2), hidden = _z[0], setHidden = _z[1];
	    require$$1.useEffect(function () {
	        if (hidden && visible) {
	            setHidden(false);
	        }
	    }, [hidden, visible]);
	    return (jsxRuntime.exports.jsx(Dialog, __assign$1K({}, props, { ref: ref, type: "custom", role: role, visible: visible, className: cn(block$J((_b = {
	                horizontal: horizontal,
	                vertical: !horizontal,
	                raised: overlay,
	                offscreen: offscreen.current
	            },
	            _b[position] = true,
	            _b["".concat(horizontalSize, "-width")] = horizontal,
	            _b["viewport-height"] = !horizontal && verticalSize === "none",
	            _b["touchable-height"] = !horizontal && verticalSize === "touch",
	            _b["recommended-height"] = !horizontal && verticalSize === "recommended",
	            _b)), className), hidden: propHidden !== null && propHidden !== void 0 ? propHidden : hidden, overlay: overlay, overlayClassName: cn("rmd-sheet-overlay", overlayClassName), component: component, tabIndex: tabIndex, appear: appear, enter: enter, exit: exit, timeout: timeout, classNames: classNames, disableTransition: disableTransition, temporary: temporary, onExited: function () {
	            onExited === null || onExited === void 0 ? void 0 : onExited();
	            setHidden(!temporary);
	        }, portal: portal, overlayHidden: overlayHidden, defaultFocus: defaultFocus, disableScrollLock: disableScrollLock, disableEscapeClose: disableEscapeClose, disableFocusContainer: disableFocusContainer, disableNestedDialogFixes: disableNestedDialogFixes }, { children: children })));
	});

	var __assign$1J = (undefined && undefined.__assign) || function () {
	    __assign$1J = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1J.apply(this, arguments);
	};
	var __rest$1u = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$D = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * Implements a `Menu` using the `Sheet` component that probably shouldn't
	 * really be used externally.
	 *
	 * @remarks \@since 5.0.0
	 * @internal
	 */
	function MenuSheet(_a) {
	    var id = _a.id, children = _a.children, header = _a.header, footer = _a.footer, horizontal = _a.horizontal, menuRef = _a.menuRef, menuProps = _a.menuProps, listStyle = _a.listStyle, listClassName = _a.listClassName, listProps = _a.listProps, _b = _a.position, position = _b === void 0 ? "bottom" : _b, _c = _a.verticalSize, verticalSize = _c === void 0 ? "touch" : _c, onClick = _a.onClick, overlayProps = _a.overlayProps, onRequestClose = _a.onRequestClose, props = __rest$1u(_a, ["id", "children", "header", "footer", "horizontal", "menuRef", "menuProps", "listStyle", "listClassName", "listProps", "position", "verticalSize", "onClick", "overlayProps", "onRequestClose"]);
	    var ariaLabel = props["aria-label"], ariaLabelledBy = props["aria-labelledby"];
	    var listRef = require$$1.useRef(null);
	    // Since there is the possibility of other tab focusable elements within the
	    // sheet and the menu items are programmatically focused, the menu's tabIndex
	    // needs to be set to `-1` while one of the child menu items are focused. This
	    // allows Shift+Tab correctly focuses the previous focusable element within
	    // the sheet. Since `onFocus` and `onBlur` will be bubbled up to the menu
	    // widget each time a new MenuItem is focused, only disable the focused state
	    // if the blur event is fired without another focus event within an animation
	    // frame.
	    var _d = __read$D(require$$1.useState(false), 2), focused = _d[0], setFocused = _d[1];
	    var blurredFrame = require$$1.useRef(0);
	    useOnUnmount(function () {
	        window.cancelAnimationFrame(blurredFrame.current);
	    });
	    return (jsxRuntime.exports.jsxs(Sheet, __assign$1J({ id: "".concat(id, "-sheet") }, props, { onRequestClose: onRequestClose, overlayProps: __assign$1J(__assign$1J({}, overlayProps), { onClick: function (event) {
	                var _a;
	                (_a = overlayProps === null || overlayProps === void 0 ? void 0 : overlayProps.onClick) === null || _a === void 0 ? void 0 : _a.call(overlayProps, event);
	                // prevent closing parent menus if the overlay element is clicked.
	                event.stopPropagation();
	                onRequestClose();
	            } }), position: position, verticalSize: verticalSize, onClick: function (event) {
	            var _a;
	            onClick === null || onClick === void 0 ? void 0 : onClick(event);
	            // Prevent closing parent sheet/menus if an element in the header or
	            // footer is clicked
	            if (!(event.target instanceof HTMLElement) ||
	                !((_a = listRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {
	                event.stopPropagation();
	            }
	        } }, { children: [header, jsxRuntime.exports.jsx(MenuKeyboardFocusProvider, __assign$1J({ horizontal: horizontal }, { children: jsxRuntime.exports.jsx(MenuWidget, __assign$1J({ "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, id: id, ref: menuRef, tabIndex: focused ? -1 : 0 }, menuProps, { onFocus: function (event) {
	                        var _a;
	                        (_a = menuProps === null || menuProps === void 0 ? void 0 : menuProps.onFocus) === null || _a === void 0 ? void 0 : _a.call(menuProps, event);
	                        window.cancelAnimationFrame(blurredFrame.current);
	                        setFocused(true);
	                    }, onBlur: function (event) {
	                        var _a;
	                        (_a = menuProps === null || menuProps === void 0 ? void 0 : menuProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(menuProps, event);
	                        blurredFrame.current = window.requestAnimationFrame(function () {
	                            setFocused(false);
	                        });
	                    }, onKeyDown: function (event) {
	                        var _a;
	                        // the tab keypress should use the sheet's behavior instead of
	                        // closing the menus
	                        if (event.key === "Tab") {
	                            return;
	                        }
	                        (_a = menuProps === null || menuProps === void 0 ? void 0 : menuProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(menuProps, event);
	                    }, disableElevation: true }, { children: jsxRuntime.exports.jsx(List, __assign$1J({}, listProps, { style: listStyle !== null && listStyle !== void 0 ? listStyle : listProps === null || listProps === void 0 ? void 0 : listProps.style, className: listClassName !== null && listClassName !== void 0 ? listClassName : listProps === null || listProps === void 0 ? void 0 : listProps.className, ref: listRef, horizontal: horizontal, onClick: function (event) {
	                            var _a;
	                            (_a = listProps === null || listProps === void 0 ? void 0 : listProps.onClick) === null || _a === void 0 ? void 0 : _a.call(listProps, event);
	                            // this makes it so you can click on the menu/list without
	                            // closing the menu
	                            if (event.target === event.currentTarget) {
	                                event.stopPropagation();
	                            }
	                        } }, { children: children })) })) })), footer] })));
	}

	var __assign$1I = (undefined && undefined.__assign) || function () {
	    __assign$1I = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1I.apply(this, arguments);
	};
	var __rest$1t = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component conditionally renders either the `Menu` or `MenuSheet`
	 * component based on the current menu configuration.
	 *
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	function MenuRenderer(_a) {
	    var menuRef = _a.menuRef, menuProps = _a.menuProps, menuStyle = _a.menuStyle, menuClassName = _a.menuClassName, sheetProps = _a.sheetProps, propSheetHeader = _a.sheetHeader, propSheetFooter = _a.sheetFooter, sheetStyle = _a.sheetStyle, sheetClassName = _a.sheetClassName, sheetMenuProps = _a.sheetMenuProps, children = _a.children, propHorizontal = _a.horizontal, propRenderAsSheet = _a.renderAsSheet, propSheetPosition = _a.sheetPosition, propSheetVerticalSize = _a.sheetVerticalSize, onRequestClose = _a.onRequestClose, onClick = _a.onClick, onKeyDown = _a.onKeyDown, props = __rest$1t(_a, ["menuRef", "menuProps", "menuStyle", "menuClassName", "sheetProps", "sheetHeader", "sheetFooter", "sheetStyle", "sheetClassName", "sheetMenuProps", "children", "horizontal", "renderAsSheet", "sheetPosition", "sheetVerticalSize", "onRequestClose", "onClick", "onKeyDown"]);
	    var isPhone = useAppSize().isPhone;
	    var _b = useMenuConfiguration({
	        horizontal: propHorizontal,
	        renderAsSheet: propRenderAsSheet,
	        sheetHeader: propSheetHeader,
	        sheetFooter: propSheetFooter,
	        sheetPosition: propSheetPosition,
	        sheetVerticalSize: propSheetVerticalSize,
	    }), horizontal = _b.horizontal, renderAsSheet = _b.renderAsSheet, sheetHeader = _b.sheetHeader, sheetFooter = _b.sheetFooter, sheetPosition = _b.sheetPosition, sheetVerticalSize = _b.sheetVerticalSize;
	    var handlers = {
	        onClick: onClick,
	        onKeyDown: onKeyDown,
	    };
	    var sheet = renderAsSheet === true || (renderAsSheet === "phone" && isPhone);
	    return (jsxRuntime.exports.jsxs(MenuConfigurationProvider, __assign$1I({ horizontal: horizontal, renderAsSheet: renderAsSheet, sheetHeader: sheetHeader, sheetFooter: sheetFooter, sheetPosition: sheetPosition, sheetVerticalSize: sheetVerticalSize }, { children: [!sheet && (jsxRuntime.exports.jsx(Menu, __assign$1I({}, props, menuProps, handlers, { ref: menuRef, style: menuStyle, className: menuClassName, horizontal: horizontal }, { children: children }))), sheet && (jsxRuntime.exports.jsx(MenuSheet, __assign$1I({}, props, sheetProps, { style: sheetStyle, className: sheetClassName, horizontal: horizontal, onRequestClose: onRequestClose, header: sheetHeader, footer: sheetFooter, menuRef: menuRef, menuProps: __assign$1I(__assign$1I({}, sheetMenuProps), handlers), position: sheetPosition, verticalSize: sheetVerticalSize }, { children: children })))] })));
	}

	var __assign$1H = (undefined && undefined.__assign) || function () {
	    __assign$1H = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1H.apply(this, arguments);
	};
	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var context$5 = require$$1.createContext({
	    visible: false,
	    setVisible: function () {
	        throw new Error('"MenuVisibilityProvider" must be a parent component');
	    },
	});
	context$5.displayName = "MenuVisibility";
	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	var Provider$2 = context$5.Provider;
	/**
	 * This hook allows you control the visibility of a parent menu. The main
	 * use-case for this hook is adding a custom sheet header/footer.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * function SheetFooter(): ReactElement {
	 *   const { setVisible } = useMenuVisibility();
	 *
	 *   return (
	 *     <DialogFooter>
	 *       <Button onClick={() => setVisible(false)}>Cancel</Button>
	 *     </DialogFooter>
	 *   );
	 * }
	 * ```
	 *
	 * @returns the {@link MenuVisibilityContext}
	 * @remarks \@since 5.0.0
	 */
	function useMenuVisibility() {
	    return require$$1.useContext(context$5);
	}
	/**
	 * @internal
	 * @remarks \@since 5.0.0
	 */
	function MenuVisibilityProvider(_a) {
	    var visible = _a.visible, setVisible = _a.setVisible, children = _a.children;
	    var value = require$$1.useMemo(function () { return ({
	        visible: visible,
	        setVisible: setVisible,
	    }); }, [visible, setVisible]);
	    return jsxRuntime.exports.jsx(Provider$2, __assign$1H({ value: value }, { children: children }));
	}

	var __assign$1G = (undefined && undefined.__assign) || function () {
	    __assign$1G = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1G.apply(this, arguments);
	};
	var __rest$1s = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This hook provides all the functionality for a menu to:
	 * - toggle the `Menu`'s visibility when the `MenuButton` or `MenuItemButton`
	 *   has been clicked
	 * - hide the `Menu` when an element outside of the `Menu` has been clicked
	 * - hide the `Menu` when the `Escape` or `Tab` key has been pressed
	 * - focus the `Menu` element when it gains visibility
	 * - refocus the `MenuButton` or `MenuItemButton` when the menu loses visibility
	 * - position the menu within the viewport with {@link useFixedPositioning}
	 * - show the `Menu` when the `ArrowRight` key is pressed for a vertical
	 *   `MenuItemButton`
	 * - show the `Menu` when the `ArrowDown` key is pressed for a horizontal
	 *   `MenuItemButton`
	 * - hide the `Menu` when the `ArrowRight` key is pressed in a vertical submenu
	 * - hide the `Menu` when the `ArrowDown` key is pressed in a horizontal
	 *   submenu
	 * - conditionally hide the `Menu` if the page is scrolled while the `Menu` is
	 *   visible
	 * - conditionally hide the `Menu` if the page is resized while the `Menu` is
	 *   visible
	 * - conditionally move focus to the next `DropdownMenu` with keyboard movement
	 *   when inside of a `MenuBar`
	 * - conditionally enable the visibility for a `DropdownMenu` when the mouse
	 *   hovers over a `MenuItemButton` with a parent `MenuBar` that has been
	 *   activated
	 * - conditionally show/hide the `Menu` based on a parent `MenuBar`'s `activeId`
	 *
	 * This hook will probably never need to be used externally since it has been
	 * integrated into the `DropdownMenu` component and `useContextMenu` hook.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { useMenu, Menu, MenuButton, MenuItem } from "@react-md/menu";
	 *
	 * function Example(): ReactElement {
	 *   const [visible, setVisible] = useState(false);
	 *   const { menuRef, menuProps, toggleRef, toggleProps } = useMenu<
	 *     HTMLButtonElement
	 *   >({
	 *     baseId: "custom-menu-button",
	 *     visible,
	 *     setVisible,
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <MenuButton ref={toggleRef} {...toggleProps}>
	 *         Button
	 *       </MenuButton>
	 *       <Menu ref={menuRef} {...menuProps}>
	 *         <MenuItem>Item 1</MenuItem>
	 *         <MenuItem>Item 2</MenuItem>
	 *         <MenuItem>Item 3</MenuItem>
	 *       </Menu>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 5.0.0
	 */
	function useMenu(options) {
	    var baseId = options.baseId, _a = options.disabled, disabled = _a === void 0 ? false : _a, propStyle = options.style, menuLabel = options.menuLabel, visible = options.visible, setVisible = options.setVisible, _b = options.floating, floating = _b === void 0 ? null : _b, _c = options.onMenuClick, onMenuClick = _c === void 0 ? noop$9 : _c, _d = options.onMenuKeyDown, onMenuKeyDown = _d === void 0 ? noop$9 : _d, _e = options.onToggleClick, onToggleClick = _e === void 0 ? noop$9 : _e, _f = options.onToggleKeyDown, onToggleKeyDown = _f === void 0 ? noop$9 : _f, _g = options.onToggleMouseEnter, onToggleMouseEnter = _g === void 0 ? noop$9 : _g, _h = options.onToggleMouseLeave, onToggleMouseLeave = _h === void 0 ? noop$9 : _h, _j = options.menuitem, menuitem = _j === void 0 ? false : _j, _k = options.horizontal, horizontal = _k === void 0 ? false : _k, propAnchor = options.anchor, fixedPositionOptions = options.fixedPositionOptions, getFixedPositionOptions = options.getFixedPositionOptions, _l = options.closeOnResize, closeOnResize = _l === void 0 ? false : _l, _m = options.closeOnScroll, closeOnScroll = _m === void 0 ? false : _m, onEnter = options.onEnter, onEntering = options.onEntering, _o = options.onEntered, onEntered = _o === void 0 ? noop$9 : _o, _p = options.onExited, onExited = _p === void 0 ? noop$9 : _p, _q = options.onFixedPositionScroll, onFixedPositionScroll = _q === void 0 ? noop$9 : _q, _r = options.onFixedPositionResize, onFixedPositionResize = _r === void 0 ? noop$9 : _r, _s = options.preventScroll, preventScroll = _s === void 0 ? false : _s, _t = options.disableFocusOnMount, disableFocusOnMount = _t === void 0 ? false : _t, _u = options.disableFocusOnUnmount, disableFocusOnUnmount = _u === void 0 ? false : _u;
	    var _v = useMenuBarContext(), root = _v.root, menubar = _v.menubar, activeId = _v.activeId, setActiveId = _v.setActiveId, hoverTimeout = _v.hoverTimeout, setAnimatedOnce = _v.setAnimatedOnce;
	    var touch = useIsUserInteractionMode("touch");
	    var timeout = require$$1.useRef();
	    require$$1.useEffect(function () {
	        return function () {
	            window.clearTimeout(timeout.current);
	        };
	    }, []);
	    // if the menu hides because the user scrolls the page or the page is resized,
	    // the focus toggle behavior should be disabled since the user is no longer
	    // interacting with the menu
	    var cancelExitFocus = require$$1.useRef(false);
	    var anchor = propAnchor !== null && propAnchor !== void 0 ? propAnchor : getDefaultAnchor({ menubar: menubar, menuitem: menuitem, floating: floating, horizontal: horizontal });
	    var menuNodeRef = require$$1.useRef(null);
	    var toggleRef = require$$1.useRef(null);
	    var _w = useFixedPositioning(__assign$1G(__assign$1G({ nodeRef: menuNodeRef, style: propStyle, fixedTo: toggleRef, onEnter: onEnter, onEntering: onEntering, onEntered: function (appearing) {
	            var _a;
	            cancelExitFocus.current = false;
	            onEntered(appearing);
	            setAnimatedOnce(true);
	            if (!disableFocusOnMount) {
	                (_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.focus();
	            }
	        }, onExited: function () {
	            var _a;
	            onExited();
	            // this has to be done onExited or else the toggle component will be
	            // clicked if the user pressed the "Enter" key which makes it look like
	            // the menu never closes.
	            if (!disableFocusOnUnmount && !cancelExitFocus.current) {
	                (_a = toggleRef.current) === null || _a === void 0 ? void 0 : _a.focus();
	            }
	        }, anchor: anchor, transformOrigin: true }, fixedPositionOptions), { getFixedPositionOptions: getFixedPositionOptions, onScroll: function (event, data) {
	            onFixedPositionScroll(event, data);
	            if (!data.visible || closeOnScroll) {
	                cancelExitFocus.current = true;
	                setVisible(false);
	            }
	        }, onResize: function (event) {
	            onFixedPositionResize(event);
	            if (closeOnResize) {
	                cancelExitFocus.current = true;
	                setVisible(false);
	            }
	        } })), style = _w.style, _x = _w.transitionOptions, nodeRef = _x.nodeRef, transitionOptions = __rest$1s(_x, ["nodeRef"]);
	    useScrollLock(preventScroll && visible);
	    require$$1.useEffect(function () {
	        if (!visible) {
	            return;
	        }
	        var handler = function (_a) {
	            var _b, _c;
	            var target = _a.target;
	            if (!(target instanceof Element) ||
	                (!((_b = menuNodeRef.current) === null || _b === void 0 ? void 0 : _b.contains(target)) &&
	                    !((_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.contains(target)))) {
	                setVisible(false);
	            }
	        };
	        window.addEventListener("click", handler);
	        return function () {
	            window.removeEventListener("click", handler);
	        };
	    }, [menuNodeRef, setVisible, toggleRef, visible]);
	    require$$1.useEffect(function () {
	        var _a;
	        if (visible) {
	            return;
	        }
	        // this is to fix keyboard movement behavior when navigating between
	        // different root-level menuitems with the `ArrowLeft` and `ArrowRight` keys
	        // while menus are visible. If the exit focus behavior is not cancelled, the
	        // next menu's menu will be visible, but the current menu's menuitem would
	        // be the current focus which breaks everything
	        cancelExitFocus.current =
	            cancelExitFocus.current ||
	                !((_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement));
	        setActiveId(function (prevActiveId) {
	            return baseId === prevActiveId ? "" : prevActiveId;
	        });
	    }, [baseId, root, setActiveId, visible]);
	    require$$1.useEffect(function () {
	        setVisible(baseId === activeId);
	    }, [activeId, baseId, root, setVisible]);
	    return {
	        menuRef: nodeRef,
	        menuProps: __assign$1G(__assign$1G({ 
	            // typecast to string so that it passes the RequireAtLeastOne<LabelA11y>
	            // TS won't pass otherwise
	            "aria-label": menuLabel, "aria-labelledby": menuLabel ? undefined : baseId, id: "".concat(baseId, "-menu"), style: style }, transitionOptions), { visible: visible, onClick: function (event) {
	                onMenuClick(event);
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                // this makes it so you can click on the menu/list without closing the
	                // menu
	                if (event.currentTarget === event.target) {
	                    return;
	                }
	                // This might be a test only workaround since clicking links move focus
	                // somewhere else
	                if (event.target instanceof HTMLElement) {
	                    cancelExitFocus.current = containsElement(event.currentTarget, event.target.closest("a"));
	                }
	                setVisible(false);
	            }, onKeyDown: function (event) {
	                onMenuKeyDown(event);
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                switch (event.key) {
	                    case "Escape":
	                        // prevent parent components that have an "Escape" keypress event
	                        // from being triggered as well
	                        event.stopPropagation();
	                        setVisible(false);
	                        break;
	                    case "Tab":
	                        // since menus are portalled, tab index is kinda broke so just close
	                        // the menu instead of doing default tab behavior
	                        event.preventDefault();
	                        if (!menuitem) {
	                            // pressing the tab key should still cascade close all menus
	                            event.stopPropagation();
	                        }
	                        setVisible(false);
	                        break;
	                    case "ArrowUp":
	                        if (menuitem && horizontal) {
	                            event.stopPropagation();
	                            event.preventDefault();
	                            setVisible(false);
	                        }
	                        break;
	                    case "ArrowLeft":
	                        if (menuitem && !horizontal) {
	                            event.stopPropagation();
	                            event.preventDefault();
	                            setVisible(false);
	                        }
	                        break;
	                }
	            } }),
	        menuNodeRef: menuNodeRef,
	        toggleRef: toggleRef,
	        toggleProps: {
	            "aria-haspopup": "menu",
	            "aria-expanded": visible || undefined,
	            id: baseId,
	            onClick: function (event) {
	                onToggleClick(event);
	                if (event.isPropagationStopped()) {
	                    return;
	                }
	                if (menuitem || menubar) {
	                    // do not allow the default menu close behavior from
	                    // triggering for parent menus
	                    event.stopPropagation();
	                }
	                setVisible(function (prevVisible) { return !prevVisible; });
	                setActiveId(function (prevActiveId) { return (baseId === prevActiveId ? "" : baseId); });
	            },
	            onKeyDown: function (event) {
	                onToggleKeyDown(event);
	                if (event.isPropagationStopped() || disabled) {
	                    return;
	                }
	                if (menubar && !menuitem && event.key === "ArrowDown") {
	                    event.preventDefault();
	                    event.stopPropagation();
	                    setActiveId(baseId);
	                    return;
	                }
	                if (!menuitem) {
	                    return;
	                }
	                switch (event.key) {
	                    case "ArrowDown":
	                        if (horizontal) {
	                            event.stopPropagation();
	                            event.preventDefault();
	                            setVisible(true);
	                        }
	                        break;
	                    case "ArrowRight":
	                        if (!horizontal) {
	                            event.stopPropagation();
	                            event.preventDefault();
	                            setVisible(true);
	                        }
	                        break;
	                }
	            },
	            onMouseEnter: function (event) {
	                onToggleMouseEnter(event);
	                if (event.isPropagationStopped() ||
	                    disabled ||
	                    !menubar ||
	                    !activeId ||
	                    touch) {
	                    if (typeof hoverTimeout === "number") {
	                        timeout.current = window.setTimeout(function () {
	                            setActiveId(baseId);
	                        }, hoverTimeout);
	                    }
	                    return;
	                }
	                setActiveId(baseId);
	            },
	            onMouseLeave: function (event) {
	                onToggleMouseLeave(event);
	                window.clearTimeout(timeout.current);
	            },
	        },
	    };
	}

	var __assign$1F = (undefined && undefined.__assign) || function () {
	    __assign$1F = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1F.apply(this, arguments);
	};
	var __rest$1r = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$C = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This component is a preset for creating dropdown menus using the
	 * {@link useMenu} hook which provides the visibility behavior and other
	 * functionality for menus. This will render as a `<Button>` by default but can
	 * be rendered as a `<MenuItem>` by existing as a child of another
	 * `DropdownMenu`.
	 *
	 * Most of the top-level props will be passed directly to the `Button` or
	 * `MenuItem` components with the exception for the `children`. The children for
	 * the `Button` or `MenuItem` can be set with the `buttonChildren` prop since
	 * the main `children` should be the `Menu`'s children.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import type { ReactElement } from "react";
	 * import { DropdownMenu, MenuItem } from "@react-md/menu";
	 *
	 * function Example() {
	 *   return (
	 *     <DropdownMenu id="example-dropdown-menu" buttonChildren="Dropdown">
	 *       <MenuItem onClick={() => console.log('Clicked Item 1')}>
	 *         Item 1
	 *       </MenuItem>
	 *       <MenuItem onClick={() => console.log('Clicked Item 2')}>
	 *         Item 2
	 *       </MenuItem>
	 *     </DropdownMenu>
	 *   );
	 * }
	 * ```
	 *
	 * @example
	 * Nested Dropdown Menus
	 * ```tsx
	 * import type { ReactElement } from "react";
	 * import { DropdownMenu, MenuItem } from "@react-md/menu";
	 *
	 * function Example() {
	 *   return (
	 *     <DropdownMenu id="example-dropdown-menu" buttonChildren="Dropdown">
	 *       <MenuItem onClick={() => console.log('Clicked Item 1')}>
	 *         Item 1
	 *       </MenuItem>
	 *       <MenuItem onClick={() => console.log('Clicked Item 2')}>
	 *         Item 2
	 *       </MenuItem>
	 *       <DropdownMenu
	 *         id="nested-dropdown-menu"
	 *         buttonChildren="Nested Dropdown"
	 *       >
	 *         <MenuItem onClick={() => console.log('Clicked Item 1')}>
	 *           Nested Item 1
	 *         </MenuItem>
	 *         <MenuItem onClick={() => console.log('Clicked Item 2')}>
	 *           Nested Item 2
	 *         </MenuItem>
	 *       </DropdownMenu>
	 *     </DropdownMenu>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 5.0.0
	 */
	function DropdownMenu(_a) {
	    var _b;
	    var id = _a.id, onClick = _a.onClick, onKeyDown = _a.onKeyDown, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, menuLabel = _a.menuLabel, propMenuProps = _a.menuProps, menuStyle = _a.menuStyle, menuClassName = _a.menuClassName, sheetProps = _a.sheetProps, sheetMenuProps = _a.sheetMenuProps, sheetStyle = _a.sheetStyle, sheetClassName = _a.sheetClassName, propSheetHeader = _a.sheetHeader, propSheetFooter = _a.sheetFooter, propRenderAsSheet = _a.renderAsSheet, propSheetPosition = _a.sheetPosition, propSheetVerticalSize = _a.sheetVerticalSize, listStyle = _a.listStyle, listClassName = _a.listClassName, listProps = _a.listProps, appear = _a.appear, enter = _a.enter, exit = _a.exit, propTimeout = _a.timeout, classNames = _a.classNames, anchor = _a.anchor, fixedPositionOptions = _a.fixedPositionOptions, getFixedPositionOptions = _a.getFixedPositionOptions, temporary = _a.temporary, portal = _a.portal, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, propHorizontal = _a.horizontal, children = _a.children, preventScroll = _a.preventScroll, closeOnResize = _a.closeOnResize, closeOnScroll = _a.closeOnScroll, propIconRotatorProps = _a.iconRotatorProps, propDisableFocusOnMount = _a.disableFocusOnMount, propDisableFocusOnUnmount = _a.disableFocusOnUnmount, props = __rest$1r(_a, ["id", "onClick", "onKeyDown", "onMouseEnter", "onMouseLeave", "menuLabel", "menuProps", "menuStyle", "menuClassName", "sheetProps", "sheetMenuProps", "sheetStyle", "sheetClassName", "sheetHeader", "sheetFooter", "renderAsSheet", "sheetPosition", "sheetVerticalSize", "listStyle", "listClassName", "listProps", "appear", "enter", "exit", "timeout", "classNames", "anchor", "fixedPositionOptions", "getFixedPositionOptions", "temporary", "portal", "portalInto", "portalIntoId", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "horizontal", "children", "preventScroll", "closeOnResize", "closeOnScroll", "iconRotatorProps", "disableFocusOnMount", "disableFocusOnUnmount"]);
	    var disabled = props.disabled;
	    var _c = useMenuConfiguration({
	        horizontal: propHorizontal,
	        sheetFooter: propSheetFooter,
	        sheetHeader: propSheetHeader,
	        renderAsSheet: propRenderAsSheet,
	        sheetPosition: propSheetPosition,
	        sheetVerticalSize: propSheetVerticalSize,
	    }), horizontal = _c.horizontal, sheetHeader = _c.sheetHeader, sheetFooter = _c.sheetFooter, renderAsSheet = _c.renderAsSheet, sheetPosition = _c.sheetPosition, sheetVerticalSize = _c.sheetVerticalSize;
	    var mode = useUserInteractionMode();
	    var mouse = mode === "mouse";
	    var keyboard = mode === "keyboard";
	    var _d = useMenuBarContext(), root = _d.root, menubar = _d.menubar, menuitem = _d.menuitem, activeId = _d.activeId, animatedOnce = _d.animatedOnce;
	    var disableTransition = animatedOnce && menubar && !!activeId && (mouse || keyboard);
	    var timeout = propTimeout !== null && propTimeout !== void 0 ? propTimeout : (disableTransition ? 0 : undefined);
	    var disableFocusOnMount = propDisableFocusOnMount !== null && propDisableFocusOnMount !== void 0 ? propDisableFocusOnMount : (mouse && timeout === 0);
	    var disableFocusOnUnmount = propDisableFocusOnUnmount !== null && propDisableFocusOnUnmount !== void 0 ? propDisableFocusOnUnmount : (mouse && timeout === 0);
	    var iconRotatorProps = propIconRotatorProps;
	    if (disableTransition) {
	        iconRotatorProps = __assign$1F({ animate: false }, propIconRotatorProps);
	    }
	    var floating = null;
	    if (!menuitem) {
	        (_b = props.floating, floating = _b === void 0 ? null : _b);
	    }
	    var _e = __read$C(require$$1.useState(false), 2), visible = _e[0], setVisible = _e[1];
	    var _f = useMenu({
	        baseId: id,
	        visible: visible,
	        setVisible: setVisible,
	        disabled: disabled,
	        menuLabel: menuLabel,
	        horizontal: horizontal,
	        onToggleClick: onClick,
	        onToggleKeyDown: onKeyDown,
	        onToggleMouseEnter: onMouseEnter,
	        onToggleMouseLeave: onMouseLeave,
	        onMenuClick: propMenuProps === null || propMenuProps === void 0 ? void 0 : propMenuProps.onClick,
	        onMenuKeyDown: propMenuProps === null || propMenuProps === void 0 ? void 0 : propMenuProps.onKeyDown,
	        floating: floating,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExited: onExited,
	        anchor: anchor,
	        style: menuStyle,
	        fixedPositionOptions: fixedPositionOptions,
	        getFixedPositionOptions: getFixedPositionOptions,
	        menuitem: !root && menuitem,
	        preventScroll: preventScroll,
	        closeOnResize: closeOnResize,
	        closeOnScroll: closeOnScroll,
	        disableFocusOnMount: disableFocusOnMount,
	        disableFocusOnUnmount: disableFocusOnUnmount,
	    }), menuRef = _f.menuRef, menuProps = _f.menuProps, toggleRef = _f.toggleRef, toggleProps = _f.toggleProps;
	    var toggle;
	    if (menuitem) {
	        // see `DropdownMenuProps` about this typecast
	        var _g = props, buttonChildren = _g.buttonChildren, itemProps = __rest$1r(_g, ["buttonChildren"]);
	        toggle = (jsxRuntime.exports.jsx(MenuItemButton, __assign$1F({}, itemProps, { iconRotatorProps: iconRotatorProps }, toggleProps, { ref: toggleRef, visible: visible }, { children: buttonChildren })));
	    }
	    else {
	        // see `DropdownMenuProps` about this typecast
	        var _h = props, buttonChildren = _h.buttonChildren, buttonProps = __rest$1r(_h, ["buttonChildren"]);
	        toggle = (jsxRuntime.exports.jsx(MenuButton, __assign$1F({}, buttonProps, { iconRotatorProps: iconRotatorProps }, toggleProps, { ref: toggleRef, visible: visible }, { children: buttonChildren })));
	    }
	    return (jsxRuntime.exports.jsxs(MenuVisibilityProvider, __assign$1F({ visible: visible, setVisible: setVisible }, { children: [toggle, jsxRuntime.exports.jsx(MenuRenderer, __assign$1F({}, menuProps, { menuRef: menuRef, menuProps: propMenuProps, menuStyle: menuProps.style, menuClassName: menuClassName, sheetProps: sheetProps, sheetStyle: sheetStyle, sheetClassName: sheetClassName, sheetMenuProps: sheetMenuProps, sheetHeader: sheetHeader, sheetFooter: sheetFooter, sheetPosition: sheetPosition, sheetVerticalSize: sheetVerticalSize, listStyle: listStyle, listClassName: listClassName, listProps: listProps, onRequestClose: function () { return setVisible(false); }, horizontal: horizontal, renderAsSheet: renderAsSheet, temporary: temporary, portal: portal, portalInto: portalInto, portalIntoId: portalIntoId, appear: appear, enter: enter, exit: exit, onExit: onExit, onExiting: onExiting, timeout: timeout, classNames: classNames }, { children: children }))] })));
	}

	var __assign$1E = (undefined && undefined.__assign) || function () {
	    __assign$1E = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1E.apply(this, arguments);
	};
	var __rest$1q = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `MenuBar` component is used to link child `DropdownGroup`s' visibility
	 * together and following the specs for a
	 * [menubar](https://www.w3.org/TR/wai-aria-practices/#menu).
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import type { ReactElement } from "react";
	 * import { MenuBar, DropdownMenu, MenuItem } from "@react-md/menu";
	 *
	 * function Example(): ReactElement {
	 *   return (
	 *     <MenuBar aria-label="Example">
	 *       <DropdownMenu id="menubar-item-1" buttonChildren="Item 1">
	 *         <MenuItem>Sub-item 1</MenuItem>
	 *         <MenuItem>Sub-item 2</MenuItem>
	 *       </DropdownMenu>
	 *       <DropdownMenu id="menubar-item-2" buttonChildren="Item 2">
	 *         <MenuItem>Sub-item 1</MenuItem>
	 *         <MenuItem>Sub-item 2</MenuItem>
	 *       </DropdownMenu>
	 *     </MenuBar>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 5.0.0
	 */
	function MenuBar(_a) {
	    var hoverTimeout = _a.hoverTimeout, props = __rest$1q(_a, ["hoverTimeout"]);
	    return (jsxRuntime.exports.jsx(MenuBarProvider, __assign$1E({ hoverTimeout: hoverTimeout }, { children: jsxRuntime.exports.jsx(KeyboardMovementProvider, __assign$1E({ loopable: true, searchable: true, incrementKeys: ["ArrowRight"], decrementKeys: ["ArrowLeft"] }, { children: jsxRuntime.exports.jsx(MenuBarWidget, __assign$1E({}, props)) })) })));
	}

	var __assign$1D = (undefined && undefined.__assign) || function () {
	    __assign$1D = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1D.apply(this, arguments);
	};
	var __rest$1p = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * If a menu or menubar contains more than one group of menuitemradio elements,
	 * or if the menu contains one group and other, unrelated menu items, authors
	 * SHOULD nest each set of related menuitemradio elements in an element using
	 * the group role, and authors SHOULD delimit the group from other menu items
	 * with an element using the separator role.
	 *
	 * @see {@link https://www.w3.org/TR/wai-aria-1.1/#menuitemradio}
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { DropdownMenu, MenuItemGroup, MenuItemSeparator } from "@react-md/menu";
	 * import { MenuItemRadio, MenuItemSwitch } from "@react-md/form";
	 *
	 * function Example(): ReactElement {
	 *   const [value, setValue] = useState("value1");
	 *   const [checked, setChecked] = useState(false);
	 *
	 *   return (
	 *     <DropdownMenu id="dropdown-menu-id" buttonChildren="Button">
	 *       <MenuItemSwitch
	 *         id="switch-id"
	 *         checked={checked}
	 *         onCheckedChange={nextChecked => setChecked(nextChecked)}
	 *       >
	 *         Light mode
	 *       </MenuItemSwitch>
	 *       <MenuItemSeparator />
	 *       <MenuItemGroup aria-label="My Group Label">
	 *         <MenuItemRadio
	 *           id="radio-1"
	 *           checked={value === "value1"}
	 *           onCheckedChange={() => setValue("value1")}
	 *         >
	 *           Radio 1
	 *         </MenuItemRadio>
	 *         <MenuItemRadio
	 *           id="radio-2"
	 *           checked={value === "value2"}
	 *           onCheckedChange={() => setValue("value2")}
	 *         >
	 *           Radio 2
	 *         </MenuItemRadio>
	 *         <MenuItemRadio
	 *           id="radio-3"
	 *           checked={value === "value3"}
	 *           onCheckedChange={() => setValue("value3")}
	 *         >
	 *           Radio 3
	 *         </MenuItemRadio>
	 *       </MenuItemGroup>
	 *     </DropdownMenu>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 5.0.0
	 */
	var MenuItemGroup = require$$1.forwardRef(function MenuItemGroup(_a, ref) {
	    var children = _a.children, props = __rest$1p(_a, ["children"]);
	    return (jsxRuntime.exports.jsx(List, __assign$1D({}, props, { ref: ref, role: "group" }, { children: children })));
	});

	var __assign$1C = (undefined && undefined.__assign) || function () {
	    __assign$1C = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1C.apply(this, arguments);
	};
	var __rest$1o = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a wrapper for the {@link ListItemLink} component that allows for the
	 * correct keyboard focus behavior within {@link Menu}s. Just like the
	 * {@link ListItemLink}, set a {@link ListItemLinkProps.component} prop to your
	 * custom `Link` if needed.
	 *
	 * @remarks \@since 2.0.0
	 */
	var MenuItemLink = require$$1.forwardRef(function MenuItemLink(_a, nodeRef) {
	    var className = _a.className, children = _a.children, _b = _a.role, role = _b === void 0 ? "menuitem" : _b, _c = _a.tabIndex, tabIndex = _c === void 0 ? -1 : _c, liProps = _a.liProps, props = __rest$1o(_a, ["className", "children", "role", "tabIndex", "liProps"]);
	    var ref = useKeyboardFocusableElement(nodeRef);
	    return (jsxRuntime.exports.jsx("li", __assign$1C({}, liProps, { role: "none" }, { children: jsxRuntime.exports.jsx(ListItemLink, __assign$1C({}, props, { ref: ref, role: role, tabIndex: tabIndex, className: cn("rmd-menu-item", className) }, { children: children })) })));
	});

	var __assign$1B = (undefined && undefined.__assign) || function () {
	    __assign$1B = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1B.apply(this, arguments);
	};
	var __rest$1n = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$I = bem("rmd-divider");
	var Divider = require$$1.forwardRef(function Divider(_a, ref) {
	    var _b = _a.inset, inset = _b === void 0 ? false : _b, _c = _a.vertical, vertical = _c === void 0 ? false : _c, _d = _a.role, role = _d === void 0 ? "separator" : _d, className = _a.className, props = __rest$1n(_a, ["inset", "vertical", "role", "className"]);
	    var Component = (vertical ? "div" : "hr");
	    return (jsxRuntime.exports.jsx(Component, __assign$1B({}, props, { ref: ref, role: role, className: cn(block$I({ inset: !vertical && inset, vertical: vertical }), className) })));
	});

	var __assign$1A = (undefined && undefined.__assign) || function () {
	    __assign$1A = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1A.apply(this, arguments);
	};
	var __read$B = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This is a small hook that is used to automatically create a vertical divider
	 * based on the computed height of its parent element.
	 *
	 * @param maxHeight - The max height for the vertical divider. When the value is
	 * between 0 and 1, it will be used as a percentage. Otherwise the smaller value
	 * of parent element height and this will be used.
	 * @remarks \@since 5.0.0 The hook accepts an object instead of using multiple
	 * params and uses a generic for the HTMLElement type.
	 */
	function useVerticalDividerHeight(_a) {
	    var ref = _a.ref, style = _a.style, maxHeight = _a.maxHeight;
	    var _b = __read$B(require$$1.useState(undefined), 2), height = _b[0], setHeight = _b[1];
	    var refCallback = require$$1.useCallback(function (instance) {
	        applyRef(instance, ref);
	        if (!instance || !instance.parentElement || maxHeight === 0) {
	            return;
	        }
	        var height = instance.parentElement.offsetHeight;
	        if (maxHeight <= 1) {
	            setHeight(height * maxHeight);
	        }
	        else {
	            setHeight(Math.min(height, maxHeight));
	        }
	    }, [maxHeight, ref]);
	    return {
	        ref: refCallback,
	        style: maxHeight <= 0 ? style : __assign$1A(__assign$1A({}, style), { height: height }),
	    };
	}

	var __assign$1z = (undefined && undefined.__assign) || function () {
	    __assign$1z = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1z.apply(this, arguments);
	};
	var __rest$1m = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is used to create a vertical divider based on a parent
	 * element's height. This is really only needed when the parent element **has no
	 * defined height**.  If there is a defined height, this component is not worth
	 * much as the height can be computed in css as normal. This really just fixes
	 * the issue that the height would be set to `auto` (which computes to 0 most of
	 * the time) when it is not set on a parent element.
	 */
	var VerticalDivider = require$$1.forwardRef(function VerticalDivider(_a, ref) {
	    var style = _a.style, _b = _a.maxHeight, maxHeight = _b === void 0 ? 1 : _b, props = __rest$1m(_a, ["style", "maxHeight"]);
	    var heightProps = useVerticalDividerHeight({
	        ref: ref,
	        style: style,
	        maxHeight: maxHeight,
	    });
	    return jsxRuntime.exports.jsx(Divider, __assign$1z({}, props, heightProps, { vertical: true }));
	});

	var __assign$1y = (undefined && undefined.__assign) || function () {
	    __assign$1y = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1y.apply(this, arguments);
	};
	var __rest$1l = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$b = bem("rmd-divider");
	/**
	 * This component renders a `<li role="separator">` with the divider styles. It
	 * will also automatically render itself vertically instead of horizontally if
	 * the menu is rendering horizontally.
	 *
	 * @remarks \@since 5.0.0 Renders as an `<li>` instead of a `<div>` or `<hr />`.
	 */
	var MenuItemSeparator = require$$1.forwardRef(function MenuItemSeparator(_a, ref) {
	    var style = _a.style, className = _a.className, maxHeight = _a.maxHeight, inset = _a.inset, propVertical = _a.vertical, children = _a.children, props = __rest$1l(_a, ["style", "className", "maxHeight", "inset", "vertical", "children"]);
	    var horizontal = useMenuConfiguration().horizontal;
	    var vertical = propVertical !== null && propVertical !== void 0 ? propVertical : horizontal;
	    var heightProps = useVerticalDividerHeight({
	        ref: ref,
	        style: style,
	        maxHeight: vertical ? maxHeight !== null && maxHeight !== void 0 ? maxHeight : 1 : 0,
	    });
	    return (jsxRuntime.exports.jsx("li", __assign$1y({}, props, heightProps, { "aria-orientation": vertical ? "vertical" : undefined, role: "separator", className: cn(styles$b({ inset: inset && !vertical, vertical: vertical }), className) }, { children: children })));
	});

	var __assign$1x = (undefined && undefined.__assign) || function () {
	    __assign$1x = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1x.apply(this, arguments);
	};
	var __rest$1k = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$A = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook controls the visibility and positioning for a context menu.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import type { ReactElement } from "react";
	 * import [ Menu, MenuItem, useContextMenu ] from "@react-md/menu":
	 *
	 * function Example(): ReactElement {
	 *   const { menuProps, onContextMenu } = useContextMenu();
	 *
	 *   return (
	 *     <div onContextMenu={onContextMenu}>
	 *       <textarea />
	 *       <Menu {...menuProps}>
	 *         <MenuItem>Cut</MenuItem>
	 *         <MenuItem>Copy</MenuItem>
	 *         <MenuItem>Paste</MenuItem>
	 *         <MenuItem>Undo</MenuItem>
	 *       </Menu>
	 *     </div>
	 *   );
	 * }
	 * ```
	 *
	 *
	 * @remarks \@since 5.0.0
	 * @param options - The {@link ContextMenuHookOptions}
	 * @returns the {@link ContextMenuHookReturnValue}
	 */
	function useContextMenu(_a) {
	    if (_a === void 0) { _a = {}; }
	    var _b = _a.anchor, anchor = _b === void 0 ? BELOW_INNER_LEFT_ANCHOR : _b, _c = _a.baseId, baseId = _c === void 0 ? "context-menu" : _c, _d = _a.menuLabel, menuLabel = _d === void 0 ? "Context Menu" : _d, fixedPositionOptions = _a.fixedPositionOptions, _e = _a.onContextMenu, onContextMenu = _e === void 0 ? noop$9 : _e, _f = _a.preventScroll, preventScroll = _f === void 0 ? true : _f, options = __rest$1k(_a, ["anchor", "baseId", "menuLabel", "fixedPositionOptions", "onContextMenu", "preventScroll"]);
	    var _g = __read$A(require$$1.useState(false), 2), visible = _g[0], setVisible = _g[1];
	    var _h = __read$A(require$$1.useState({}), 2), coords = _h[0], setCoords = _h[1];
	    var _j = useMenu(__assign$1x(__assign$1x({}, options), { anchor: anchor, baseId: baseId, menuLabel: menuLabel, visible: visible, setVisible: setVisible, fixedPositionOptions: __assign$1x(__assign$1x({}, fixedPositionOptions), coords), preventScroll: preventScroll })), menuRef = _j.menuRef, menuProps = _j.menuProps, menuNodeRef = _j.menuNodeRef;
	    return {
	        menuRef: menuRef,
	        menuProps: menuProps,
	        menuNodeRef: menuNodeRef,
	        visible: visible,
	        setVisible: setVisible,
	        setCoords: setCoords,
	        onContextMenu: function (event) {
	            onContextMenu(event);
	            if (event.isPropagationStopped() ||
	                // make it so that if you right click the custom context menu, the
	                // browser's default context menu can appear (mostly for being able to
	                // inspect your custom context menu)
	                /* istanbul ignore next */
	                (event.target instanceof HTMLElement &&
	                    containsElement(menuNodeRef.current, event.target))) {
	                return;
	            }
	            event.preventDefault();
	            event.stopPropagation();
	            setCoords({
	                initialX: event.clientX,
	                initialY: event.clientY,
	            });
	            setVisible(true);
	        },
	    };
	}

	var __assign$1w = (undefined && undefined.__assign) || function () {
	    __assign$1w = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1w.apply(this, arguments);
	};
	var __rest$1j = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * A wrapper for the `<input type="file">` element that works within menus.
	 *
	 * @remarks \@since 5.0.0
	 */
	var MenuItemFileInput = require$$1.forwardRef(function MenuItemFileInput(_a, ref) {
	    var id = _a.id, onClick = _a.onClick, onChange = _a.onChange, accept = _a.accept, _b = _a.multiple, multiple = _b === void 0 ? false : _b, children = _a.children, inputProps = _a.inputProps, _c = _a.disableRepeatableFiles, disableRepeatableFiles = _c === void 0 ? false : _c, propLeftAddon = _a.leftAddon, _d = _a.inputLabel, inputLabel = _d === void 0 ? "Upload" : _d, props = __rest$1j(_a, ["id", "onClick", "onChange", "accept", "multiple", "children", "inputProps", "disableRepeatableFiles", "leftAddon", "inputLabel"]);
	    var inputRef = require$$1.useRef(null);
	    var leftAddon = useIcon("upload", propLeftAddon);
	    return (jsxRuntime.exports.jsxs(MenuItem, __assign$1w({}, props, { id: "".concat(id, "-menuitem"), ref: ref, onClick: function (event) {
	            var _a;
	            onClick === null || onClick === void 0 ? void 0 : onClick(event);
	            // prevent the menu from closing since you need access to the
	            // `<input type="file">` to select a file and the menu unmounts when
	            // hidden.
	            event.stopPropagation();
	            /* istanbul-ignore-next */
	            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.click();
	        }, leftAddon: leftAddon }, { children: [children, jsxRuntime.exports.jsx("input", __assign$1w({ "aria-label": inputLabel, id: id, ref: inputRef, type: "file", accept: accept, multiple: multiple, value: disableRepeatableFiles ? undefined : "", onChange: onChange }, inputProps, { onClick: function (event) {
	                    var _a;
	                    (_a = inputProps === null || inputProps === void 0 ? void 0 : inputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(inputProps, event);
	                    // prevent double click events since the MenuItem clicks this input
	                    event.stopPropagation();
	                }, className: cn("rmd-file-input", inputProps === null || inputProps === void 0 ? void 0 : inputProps.className) }))] })));
	});

	var __assign$1v = (undefined && undefined.__assign) || function () {
	    __assign$1v = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1v.apply(this, arguments);
	};
	var __rest$1i = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a simple wrapper for the {@link MenuItemInputToggle} component to
	 * render it as a radio and pulling the radio icon from the
	 * {@link IconProvider}.
	 *
	 * @remarks
	 * If a menu or menubar contains more than one group of menuitemradio elements,
	 * or if the menu contains one group and other, unrelated menu items, authors
	 * SHOULD nest each set of related menuitemradio elements in an element using
	 * the group role, and authors SHOULD delimit the group from other menu items
	 * with an element using the separator role.
	 * @see {@link https://www.w3.org/TR/wai-aria-1.1/#menuitemradio}
	 *
	 * @example
	 * Only Radio Items
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { DropdownMenu } from "@react-md/menu";
	 * import { MenuItemRadio } from "@react-md/form";
	 *
	 * function Example(): ReactElement {
	 *   const [value, setValue] = useState("value1");
	 *
	 *   return (
	 *     <DropdownMenu id="dropdown-menu-id" buttonChildren="Button">
	 *       <MenuItemRadio
	 *         id="radio-1"
	 *         checked={value === "value1"}
	 *         onCheckedChange={() => setValue("value1")}
	 *       >
	 *          Radio 1
	 *       </MenuItemRadio>
	 *       <MenuItemRadio
	 *         id="radio-2"
	 *         checked={value === "value2"}
	 *         onCheckedChange={() => setValue("value2")}
	 *       >
	 *         Radio 2
	 *       </MenuItemRadio>
	 *       <MenuItemRadio
	 *         id="radio-3"
	 *         checked={value === "value3"}
	 *         onCheckedChange={() => setValue("value3")}
	 *       >
	 *         Radio 3
	 *       </MenuItemRadio>
	 *     </DropdownMenu>
	 *   );
	 * }
	 * ```
	 *
	 * @example
	 * With Other Items
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { DropdownMenu, MenuItemGroup, MenuItemSeparator } from "@react-md/menu";
	 * import { MenuItemRadio, MenuItemSwitch } from "@react-md/form";
	 *
	 * function Example(): ReactElement {
	 *   const [value, setValue] = useState("value1");
	 *
	 *   return (
	 *     <DropdownMenu id="dropdown-menu-id" buttonChildren="Button">
	 *       <MenuItemSwitch
	 *         id="switch-id"
	 *         checked={checked}
	 *         onCheckedChange={nextChecked => setChecked(nextChecked)}
	 *       >
	 *         Light mode
	 *       </MenuItemSwitch>
	 *       <MenuItemSeparator />
	 *       <MenuItemGroup aria-label="My Group Label">
	 *         <MenuItemRadio
	 *           id="radio-1"
	 *           checked={value === "value1"}
	 *           onCheckedChange={() => setValue("value1")}
	 *         >
	 *           Radio 1
	 *         </MenuItemRadio>
	 *         <MenuItemRadio
	 *           id="radio-2"
	 *           checked={value === "value2"}
	 *           onCheckedChange={() => setValue("value2")}
	 *         >
	 *           Radio 2
	 *         </MenuItemRadio>
	 *         <MenuItemRadio
	 *           id="radio-3"
	 *           checked={value === "value3"}
	 *           onCheckedChange={() => setValue("value3")}
	 *         >
	 *           Radio 3
	 *         </MenuItemRadio>
	 *       </MenuItemGroup>
	 *     </DropdownMenu>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 2.8.0
	 */
	var MenuItemRadio = require$$1.forwardRef(function MenuItemRadio(_a, ref) {
	    var propIcon = _a.icon, props = __rest$1i(_a, ["icon"]);
	    var icon = useIcon("radio", propIcon);
	    return (jsxRuntime.exports.jsx(MenuItemInputToggle, __assign$1v({}, props, { ref: ref, icon: icon, type: "radio" })));
	});

	var __assign$1u = (undefined && undefined.__assign) || function () {
	    __assign$1u = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1u.apply(this, arguments);
	};
	/**
	 * This is a simple wrapper for the {@link MenuItemInputToggle} component to
	 * render it as a switch.
	 *
	 * @example
	 * Simple Example
	 * ```tsx
	 * import { ReactElement, useState } from "react";
	 * import { DropdownMenu } from "@react-md/menu";
	 * import { MenuItemSwitch } from "@react-md/form";
	 *
	 * function Example(): ReactElement {
	 *   const [checked, setChecked] = useState(false);
	 *
	 *   return (
	 *     <DropdownMenu id="dropdown-menu-id" buttonChildren="Button">
	 *       <MenuItemSwitch
	 *         id="switch-1"
	 *         checked={checked}
	 *         onCheckedChange={(nextChecked) => setChecked(nextChecked)}
	 *       >
	 *         Switch
	 *      </MenuItemSwitch>
	 *     </DropdownMenu>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 2.8.0
	 */
	var MenuItemSwitch = require$$1.forwardRef(function MenuItemSwitch(props, ref) {
	    return jsxRuntime.exports.jsx(MenuItemInputToggle, __assign$1u({}, props, { ref: ref, type: "switch" }));
	});

	var __assign$1t = (undefined && undefined.__assign) || function () {
	    __assign$1t = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1t.apply(this, arguments);
	};
	var __rest$1h = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$H = bem("rmd-floating-label");
	/**
	 * This is an extension of the `Label` component that is used with text fields
	 * and textareas to float above the input area.
	 */
	var FloatingLabel = require$$1.forwardRef(function FloatingLabel(_a, ref) {
	    var className = _a.className, dense = _a.dense, valued = _a.valued, floating = _a.floating, _b = _a.error, error = _b === void 0 ? false : _b, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, props = __rest$1h(_a, ["className", "dense", "valued", "floating", "error", "active", "disabled"]);
	    return (jsxRuntime.exports.jsx(Label, __assign$1t({}, props, { ref: ref, className: cn(block$H({
	            dense: dense,
	            active: floating,
	            inactive: valued && !active && !error && !disabled,
	        }), className), error: error, active: active, disabled: disabled })));
	});

	var __assign$1s = (undefined && undefined.__assign) || function () {
	    __assign$1s = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1s.apply(this, arguments);
	};
	var __rest$1g = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$G = bem("rmd-text-field-addon");
	/**
	 * This component is used to add an an icon before or after the text field with
	 * correct styling.
	 */
	var TextFieldAddon = require$$1.forwardRef(function TextFieldAddon(_a, ref) {
	    var children = _a.children, className = _a.className, _b = _a.presentational, presentational = _b === void 0 ? true : _b, props = __rest$1g(_a, ["children", "className", "presentational"]);
	    if (!children) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx("span", __assign$1s({}, props, { ref: ref, className: cn(block$G({ presentational: presentational }), className) }, { children: children })));
	});

	var __assign$1r = (undefined && undefined.__assign) || function () {
	    __assign$1r = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1r.apply(this, arguments);
	};
	var __rest$1f = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$F = bem("rmd-text-field-container");
	/**
	 * This is a container component that is used to structure the text field with
	 * different parts and themes.
	 */
	var TextFieldContainer = require$$1.forwardRef(function TextFieldContainer(_a, ref) {
	    var _b;
	    var className = _a.className, children = _a.children, _c = _a.inline, inline = _c === void 0 ? false : _c, propTheme = _a.theme, _d = _a.error, error = _d === void 0 ? false : _d, active = _a.active, label = _a.label, _e = _a.dense, dense = _e === void 0 ? false : _e, _f = _a.stretch, stretch = _f === void 0 ? false : _f, _g = _a.disabled, disabled = _g === void 0 ? false : _g, _h = _a.isLeftAddon, isLeftAddon = _h === void 0 ? true : _h, _j = _a.isRightAddon, isRightAddon = _j === void 0 ? true : _j, leftChildren = _a.leftChildren, rightChildren = _a.rightChildren, propUnderlineDirection = _a.underlineDirection, props = __rest$1f(_a, ["className", "children", "inline", "theme", "error", "active", "label", "dense", "stretch", "disabled", "isLeftAddon", "isRightAddon", "leftChildren", "rightChildren", "underlineDirection"]);
	    var _k = useFormTheme({
	        theme: propTheme,
	        underlineDirection: propUnderlineDirection,
	    }), theme = _k.theme, underlineDirection = _k.underlineDirection;
	    var underline = theme === "underline";
	    var outline = theme === "outline";
	    var filled = theme === "filled";
	    var isUnderlined = underline || filled;
	    var isOutlineActive = outline && active;
	    return (jsxRuntime.exports.jsxs("div", __assign$1r({}, props, { ref: ref, className: cn(block$F((_b = {
	                error: error,
	                inline: inline,
	                stretch: stretch,
	                filled: filled,
	                outline: outline,
	                disabled: disabled,
	                hoverable: !disabled && !isOutlineActive,
	                label: label && !dense,
	                dense: !label && dense,
	                "dense-label": dense && label,
	                "dense-placeholder": dense && isUnderlined && !label,
	                "outline-active": isOutlineActive,
	                "outline-error": outline && error,
	                "outline-left": outline && leftChildren,
	                "outline-right": outline && rightChildren,
	                underline: isUnderlined,
	                "underline-labelled": label && isUnderlined,
	                "underline-active": isUnderlined && active
	            },
	            _b["underline-".concat(underlineDirection)] = isUnderlined,
	            _b["underline-left-addon"] = isUnderlined && leftChildren,
	            _b["underline-right-addon"] = isUnderlined && rightChildren,
	            _b)), className) }, { children: [isLeftAddon ? (jsxRuntime.exports.jsx(TextFieldAddon, { children: leftChildren })) : (leftChildren), children, isRightAddon ? (jsxRuntime.exports.jsx(TextFieldAddon, { children: rightChildren })) : (rightChildren)] })));
	});

	var __read$z = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook is used to handle the different states for the text field based on
	 * the current value and user interaction.
	 *
	 * @internal
	 * @remarks \@since 2.5.2
	 */
	function useFieldStates(_a) {
	    var onBlur = _a.onBlur, onFocus = _a.onFocus, onChange = _a.onChange, value = _a.value, defaultValue = _a.defaultValue;
	    var _b = __read$z(require$$1.useState(false), 2), focused = _b[0], setFocused = _b[1];
	    var _c = __read$z(require$$1.useState(function () {
	        if (typeof value === "undefined") {
	            return typeof defaultValue !== "undefined" && defaultValue.length > 0;
	        }
	        return value.length > 0;
	    }), 2), valued = _c[0], setValued = _c[1];
	    var handleBlur = require$$1.useCallback(function (event) {
	        if (onBlur) {
	            onBlur(event);
	        }
	        setFocused(false);
	        var input = event.currentTarget;
	        if (input.getAttribute("type") === "number") {
	            input.checkValidity();
	            setValued(input.validity.badInput || (value !== null && value !== void 0 ? value : input.value).length > 0);
	        }
	    }, [onBlur, value]);
	    var handleFocus = require$$1.useCallback(function (event) {
	        if (onFocus) {
	            onFocus(event);
	        }
	        setFocused(true);
	    }, [onFocus]);
	    var handleChange = require$$1.useCallback(function (event) {
	        if (onChange) {
	            onChange(event);
	        }
	        var input = event.currentTarget;
	        if (input.getAttribute("type") === "number") {
	            input.checkValidity();
	            /* istanbul ignore next */
	            if (input.validity.badInput) {
	                return;
	            }
	        }
	        setValued(input.value.length > 0);
	    }, [onChange]);
	    // another way to handle this could be to just make the `valued` state derived
	    // based on the `value`, but it gets wonky for number fields. This technically
	    // still fails right now for number fields if you don't use the
	    // `useNumberField` hook since the `value` will be set back to the empty
	    // string on invalid numbers.
	    var prevValue = require$$1.useRef(value);
	    require$$1.useEffect(function () {
	        if (prevValue.current !== value && typeof value === "string") {
	            prevValue.current = value;
	            setValued(value.length > 0);
	        }
	    }, [value]);
	    return {
	        valued: valued,
	        focused: focused,
	        onBlur: handleBlur,
	        onFocus: handleFocus,
	        onChange: handleChange,
	    };
	}

	var __assign$1q = (undefined && undefined.__assign) || function () {
	    __assign$1q = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1q.apply(this, arguments);
	};
	var __rest$1e = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$E = bem("rmd-text-field");
	var SPECIAL_TYPES = [
	    "date",
	    "time",
	    "datetime-local",
	    "month",
	    "week",
	    "color",
	];
	/**
	 * The text field is a wrapper of the `<input type="text" />` component with
	 * some nice default themes. It can also be used to render other text input
	 * types with _some_ support.
	 */
	var TextField = require$$1.forwardRef(function TextField(_a, ref) {
	    var style = _a.style, className = _a.className, inputStyle = _a.inputStyle, inputClassName = _a.inputClassName, label = _a.label, labelStyle = _a.labelStyle, labelClassName = _a.labelClassName, _b = _a.type, type = _b === void 0 ? "text" : _b, propTheme = _a.theme, _c = _a.dense, dense = _c === void 0 ? false : _c, _d = _a.inline, inline = _d === void 0 ? false : _d, _e = _a.error, error = _e === void 0 ? false : _e, _f = _a.stretch, stretch = _f === void 0 ? false : _f, _g = _a.disabled, disabled = _g === void 0 ? false : _g, propOnBlur = _a.onBlur, propOnFocus = _a.onFocus, propOnChange = _a.onChange, containerRef = _a.containerRef, _h = _a.isLeftAddon, isLeftAddon = _h === void 0 ? true : _h, _j = _a.isRightAddon, isRightAddon = _j === void 0 ? true : _j, leftChildren = _a.leftChildren, rightChildren = _a.rightChildren, propUnderlineDirection = _a.underlineDirection, containerProps = _a.containerProps, props = __rest$1e(_a, ["style", "className", "inputStyle", "inputClassName", "label", "labelStyle", "labelClassName", "type", "theme", "dense", "inline", "error", "stretch", "disabled", "onBlur", "onFocus", "onChange", "containerRef", "isLeftAddon", "isRightAddon", "leftChildren", "rightChildren", "underlineDirection", "containerProps"]);
	    var id = props.id, value = props.value, defaultValue = props.defaultValue;
	    var _k = useFieldStates({
	        onBlur: propOnBlur,
	        onFocus: propOnFocus,
	        onChange: propOnChange,
	        value: value,
	        defaultValue: defaultValue,
	    }), valued = _k.valued, focused = _k.focused, onBlur = _k.onBlur, onFocus = _k.onFocus, onChange = _k.onChange;
	    var _l = useFormTheme({
	        theme: propTheme,
	        underlineDirection: propUnderlineDirection,
	    }), theme = _l.theme, underlineDirection = _l.underlineDirection;
	    return (jsxRuntime.exports.jsxs(TextFieldContainer, __assign$1q({}, containerProps, { style: style, className: className, ref: containerRef, theme: theme, error: error, active: focused, label: !!label, dense: dense, inline: inline, stretch: stretch, disabled: disabled, isLeftAddon: isLeftAddon, isRightAddon: isRightAddon, leftChildren: leftChildren, rightChildren: rightChildren, underlineDirection: underlineDirection }, { children: [jsxRuntime.exports.jsx(FloatingLabel, __assign$1q({ style: labelStyle, className: labelClassName, htmlFor: id, error: error, active: focused, floating: focused || valued || SPECIAL_TYPES.includes(type), valued: valued, dense: dense, disabled: disabled }, { children: label })), jsxRuntime.exports.jsx("input", __assign$1q({}, props, { ref: ref, type: type, disabled: disabled, onFocus: onFocus, onBlur: onBlur, onChange: onChange, style: inputStyle, className: cn(block$E({
	                    floating: label && theme !== "none",
	                }), inputClassName) }))] })));
	});

	var __assign$1p = (undefined && undefined.__assign) || function () {
	    __assign$1p = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1p.apply(this, arguments);
	};
	var __rest$1d = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a wrapper for the `TextField` component that can be used within
	 * `Menu`s by updating the `onKeyDown` and `onClick` behavior.
	 *
	 * Note: This is **not** the `TextFieldWithMessage` since the message part is
	 * hard to style nicely within menus. You'd most likely want to use another menu
	 * for displaying errors.
	 *
	 * @remarks \@since 5.0.0
	 */
	var MenuItemTextField = require$$1.forwardRef(function MenuItemTextField(_a, nodeRef) {
	    var liProps = _a.liProps, onKeyDown = _a.onKeyDown, _b = _a.stretch, stretch = _b === void 0 ? true : _b, props = __rest$1d(_a, ["liProps", "onKeyDown", "stretch"]);
	    var refCallback = useKeyboardFocusableElement(nodeRef);
	    return (jsxRuntime.exports.jsx("li", __assign$1p({ role: "none" }, liProps, { onClick: function (event) {
	            var _a;
	            (_a = liProps === null || liProps === void 0 ? void 0 : liProps.onClick) === null || _a === void 0 ? void 0 : _a.call(liProps, event);
	            event.stopPropagation();
	        }, className: cn("rmd-list-item rmd-menu-item", liProps === null || liProps === void 0 ? void 0 : liProps.className) }, { children: jsxRuntime.exports.jsx(TextField, __assign$1p({}, props, { ref: refCallback, stretch: stretch, onKeyDown: function (event) {
	                onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
	                switch (event.key) {
	                    case "Tab":
	                    case "Escape":
	                    case " ":
	                        // do default behavior
	                        break;
	                    default:
	                        if (event.key.length === 1 || event.currentTarget.value) {
	                            event.stopPropagation();
	                        }
	                }
	            } })) })));
	});

	var __assign$1o = (undefined && undefined.__assign) || function () {
	    __assign$1o = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1o.apply(this, arguments);
	};
	var __rest$1c = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$D = bem("rmd-native-select");
	var container$1 = bem("rmd-native-select-container");
	/**
	 * This component is used to render a native `<select>` element with the text
	 * field theme styles. This component is great to use for native behavior and
	 * full accessibility.
	 */
	var NativeSelect = require$$1.forwardRef(function NativeSelect(_a, ref) {
	    var style = _a.style, className = _a.className, labelStyle = _a.labelStyle, labelClassName = _a.labelClassName, selectStyle = _a.selectStyle, selectClassName = _a.selectClassName, propIcon = _a.icon, propTheme = _a.theme, _b = _a.dense, dense = _b === void 0 ? false : _b, _c = _a.inline, inline = _c === void 0 ? false : _c, _d = _a.stretch, stretch = _d === void 0 ? false : _d, _e = _a.error, error = _e === void 0 ? false : _e, _f = _a.disabled, disabled = _f === void 0 ? false : _f, label = _a.label, propOnBlur = _a.onBlur, propOnFocus = _a.onFocus, propOnChange = _a.onChange, containerRef = _a.containerRef, isLeftAddon = _a.isLeftAddon, isRightAddon = _a.isRightAddon, leftChildren = _a.leftChildren, rightChildren = _a.rightChildren, propUnderlineDirection = _a.underlineDirection, children = _a.children, props = __rest$1c(_a, ["style", "className", "labelStyle", "labelClassName", "selectStyle", "selectClassName", "icon", "theme", "dense", "inline", "stretch", "error", "disabled", "label", "onBlur", "onFocus", "onChange", "containerRef", "isLeftAddon", "isRightAddon", "leftChildren", "rightChildren", "underlineDirection", "children"]);
	    var id = props.id, value = props.value, defaultValue = props.defaultValue, multiple = props.multiple;
	    var _g = useFormTheme({
	        theme: propTheme,
	        underlineDirection: propUnderlineDirection,
	    }), theme = _g.theme, underlineDirection = _g.underlineDirection;
	    var underline = theme === "underline" || theme === "filled";
	    var icon = useIcon("dropdown", propIcon);
	    var _h = useFieldStates({
	        onBlur: propOnBlur,
	        onFocus: propOnFocus,
	        onChange: propOnChange,
	        value: value,
	        defaultValue: defaultValue,
	    }), valued = _h.valued, focused = _h.focused, onBlur = _h.onBlur, onFocus = _h.onFocus, onChange = _h.onChange;
	    return (jsxRuntime.exports.jsxs(TextFieldContainer, __assign$1o({ style: style, className: cn(container$1({
	            multi: multiple,
	            padded: multiple && label,
	        }), className), ref: containerRef, theme: theme, error: error, active: focused, label: !!label, dense: dense, inline: inline, stretch: stretch, disabled: disabled, isLeftAddon: isLeftAddon, isRightAddon: isRightAddon, leftChildren: leftChildren, rightChildren: multiple && rightChildren, underlineDirection: underlineDirection }, { children: [jsxRuntime.exports.jsx(FloatingLabel, __assign$1o({ style: labelStyle, className: cn(block$D("label"), labelClassName), htmlFor: id, error: error, active: valued && focused, valued: valued, floating: valued || multiple, dense: dense, disabled: disabled }, { children: label })), jsxRuntime.exports.jsx("select", __assign$1o({}, props, { ref: ref, style: selectStyle, className: cn(block$D({
	                    icon: icon,
	                    multi: multiple,
	                    "label-underline": label && underline,
	                    "placeholder-underline": !label && underline,
	                    floating: label && theme !== "none",
	                }), selectClassName), disabled: disabled, onFocus: onFocus, onBlur: onBlur, onChange: onChange }, { children: children })), !multiple && icon && jsxRuntime.exports.jsx("span", __assign$1o({ className: block$D("icon") }, { children: icon }))] })));
	});

	var __read$y = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @internal
	 */
	function useFocusState(_a) {
	    var onFocus = _a.onFocus, onBlur = _a.onBlur;
	    var _b = __read$y(useToggle(false), 3), focused = _b[0], setFocused = _b[1], setBlurred = _b[2];
	    var handleFocus = require$$1.useCallback(function (event) {
	        if (onFocus) {
	            onFocus(event);
	        }
	        setFocused();
	    }, [setFocused, onFocus]);
	    var handleBlur = require$$1.useCallback(function (event) {
	        if (onBlur) {
	            onBlur(event);
	        }
	        setBlurred();
	    }, [setBlurred, onBlur]);
	    return [focused, handleFocus, handleBlur];
	}

	var __assign$1n = (undefined && undefined.__assign) || function () {
	    __assign$1n = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1n.apply(this, arguments);
	};
	var __rest$1b = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$C = bem("rmd-option");
	/**
	 * The Option component is a simple wrapper for the `SimpleListItem` that adds
	 * some required a11y for behaving as the `option` role.
	 */
	var Option = require$$1.forwardRef(function Option(_a, ref) {
	    var className = _a.className, _b = _a.selected, selected = _b === void 0 ? false : _b, focused = _a.focused, children = _a.children, _c = _a.textChildren, textChildren = _c === void 0 ? true : _c, props = __rest$1b(_a, ["className", "selected", "focused", "children", "textChildren"]);
	    return (jsxRuntime.exports.jsx(SimpleListItem, __assign$1n({}, props, { ref: ref, role: "option", "aria-selected": selected || undefined, clickable: true, className: cn(block$C({
	            selected: selected,
	            focused: focused,
	        }), className), textChildren: textChildren }, { children: children })));
	});

	/**
	 * A type guard that simply checks if the option is considered an object of list
	 * item props.
	 *
	 * @param option - The option to check
	 * @returns true if the option is considered a object of list item props and
	 * will ensure that the option is typed as ListboxOptionProps
	 * @internal
	 */
	function isListboxOptionProps(option) {
	    return (option !== "" && option !== 0 && !!option && typeof option === "object");
	}
	/**
	 * The default implementation to check if an option is disabled. It will just
	 * check if the option is an object and if it has the disabled prop enabled.
	 *
	 * @param option - The option to check
	 * @returns true if the option is disabled
	 * @internal
	 */
	function defaultIsOptionDisabled(option) {
	    return isListboxOptionProps(option) && !!option.disabled;
	}
	/**
	 * The default way to generate a "unique" id for each option within the listbox
	 * by concatenating the current index with a base id.
	 *
	 * Note: The index will be incremented by 1 so the ids start from 1 instead of
	 * 0. This is so that it matches how paginated results work with `aria-posinset`
	 * + `aria-setsize`.
	 *
	 * @param baseId - The base id of the listbox.
	 * @param index - The current index of the option
	 * @returns a "unique" id for the option
	 */
	function getOptionId(baseId, index) {
	    return "".concat(baseId, "-option-").concat(index + 1);
	}
	/**
	 * A function that will get the label for an option. The default behavior is to
	 * check if the option is an object. If it is, it'll use the `labelKey` property
	 * and fallback to the `children` property. If it is anything else, the option
	 * itself will be returned.
	 *
	 * This is used in both the select's button element to show the current value as
	 * well as rendering each option within the listbox component.
	 *
	 * @param option - The option that should be converted into a renderable label
	 * element.
	 * @param labelKey - The object key to use to extract the label from an option
	 * object.
	 * @returns a renderable label to display.
	 */
	function getOptionLabel(option, labelKey) {
	    if (isListboxOptionProps(option)) {
	        if (typeof option.children !== "undefined") {
	            return option.children;
	        }
	        var label = option[labelKey];
	        return typeof label === "undefined" ? null : label;
	    }
	    return option;
	}
	/**
	 * A function that will get the display value for the `Select` field based on
	 * the current selected option. The default behavior will be to return null if
	 * an option is not currently selected so the placeholder text can be shown
	 * instead. If there is an option selected, it will:
	 * - get the option's label using the general `getOptionLabel` util
	 * - check if includeLeft is enabled and the option is an object with
	 *   `leftAddon`
	 *   - if there is a `leftAddon`, use the `TextIconSpacing` of
	 *     the label + the icon or avatar.
	 *
	 * @param option - The option to get a display label for
	 * @param labelKey - The key to use to extract a label from the option when it
	 * is an object
	 * @param includeLeft - Boolean if a `leftAddon` should be added with
	 * `TextIconSpacing` to the result.
	 * @returns A renderable node to display in a `Select` field.
	 */
	function getDisplayLabel(option, labelKey, includeLeft) {
	    if (!option && option !== 0) {
	        return null;
	    }
	    var label = getOptionLabel(option, labelKey);
	    if (!includeLeft || !isListboxOptionProps(option)) {
	        return label;
	    }
	    var leftAddon = option.leftAddon;
	    return require$$1.createElement(TextIconSpacing, { icon: leftAddon }, label);
	}

	var __assign$1m = (undefined && undefined.__assign) || function () {
	    __assign$1m = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1m.apply(this, arguments);
	};
	var __rest$1a = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$B = bem("rmd-listbox");
	/**
	 * This component is used to render the list part of a `<select>` element with
	 * built-in accessibility and the ability to add custom styles. This should
	 * probably not be used much outside of `react-md` itself and the `Select`
	 * component, but I'm planning on adding support for an inline listbox at some
	 * point.
	 */
	var Listbox = require$$1.forwardRef(function Listbox(_a, nodeRef) {
	    var propClassName = _a.className, _b = _a.visible, visible = _b === void 0 ? true : _b, _c = _a.temporary, temporary = _c === void 0 ? false : _c, _d = _a.labelKey, labelKey = _d === void 0 ? "label" : _d, _e = _a.valueKey, valueKey = _e === void 0 ? "value" : _e, _f = _a.getOptionId, getOptionId$1 = _f === void 0 ? getOptionId : _f, _g = _a.getOptionLabel, getOptionLabel$1 = _g === void 0 ? getOptionLabel : _g, _h = _a.getOptionValue, getOptionValue = _h === void 0 ? DEFAULT_GET_ITEM_VALUE : _h, _j = _a.isOptionDisabled, isOptionDisabled = _j === void 0 ? defaultIsOptionDisabled : _j, _k = _a.disableMovementChange, disableMovementChange = _k === void 0 ? false : _k, onFocus = _a.onFocus, propOnKeyDown = _a.onKeyDown, name = _a.name, options = _a.options, value = _a.value, onChange = _a.onChange, propTabIndex = _a.tabIndex, portal = _a.portal, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, onRequestClose = _a.onRequestClose, timeout = _a.timeout, readOnly = _a.readOnly, classNames = _a.classNames, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, props = __rest$1a(_a, ["className", "visible", "temporary", "labelKey", "valueKey", "getOptionId", "getOptionLabel", "getOptionValue", "isOptionDisabled", "disableMovementChange", "onFocus", "onKeyDown", "name", "options", "value", "onChange", "tabIndex", "portal", "portalInto", "portalIntoId", "onRequestClose", "timeout", "readOnly", "classNames", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited"]);
	    var id = props.id;
	    var tabIndex = propTabIndex;
	    if (temporary) {
	        tabIndex = -1;
	    }
	    else if (typeof propTabIndex === "undefined") {
	        tabIndex = 0;
	    }
	    /**
	     * Gets the current index of the option that has the same value as the
	     * provided prop value.
	     */
	    var getIndex = require$$1.useCallback(function () {
	        return options.findIndex(function (option) { return value === getOptionValue(option, valueKey); });
	    }, [getOptionValue, options, value, valueKey]);
	    /**
	     * Conditionally calls the onChange callback with the new value and option if
	     * the value has changed. This will be called when:
	     * - the user presses the enter or space key while "focusing" an option
	     * - the user keyboard navigates to a new option while the
	     *   `disableMovementChange` prop is `false`
	     * - the user clicks the option with a mouse or touch
	     */
	    var handleChange = require$$1.useCallback(function (index) {
	        if (readOnly) {
	            return;
	        }
	        var option = options[index];
	        if (!option || isOptionDisabled(option)) {
	            return;
	        }
	        var optionValue = getOptionValue(option, valueKey);
	        if (value !== optionValue) {
	            onChange(optionValue, options[index], {
	                id: id,
	                name: name,
	                value: value,
	                valueKey: valueKey,
	                options: options,
	            });
	        }
	    }, [
	        getOptionValue,
	        id,
	        isOptionDisabled,
	        name,
	        onChange,
	        options,
	        readOnly,
	        value,
	        valueKey,
	    ]);
	    var handleKeyboardClick = require$$1.useCallback(function (focusedIndex) {
	        handleChange(focusedIndex);
	        if (temporary && onRequestClose) {
	            onRequestClose();
	        }
	    }, [handleChange, onRequestClose, temporary]);
	    var _l = useActiveDescendantMovement(__assign$1m(__assign$1m({}, VERTICAL_LISTBOX), { defaultFocusedIndex: getIndex, items: options, baseId: id, valueKey: labelKey, getId: getOptionId$1, getItemValue: function (option, key) {
	            if (!isListboxOptionProps(option)) {
	                return "".concat(option);
	            }
	            var search = option[key];
	            if (typeof search === "number" || typeof search === "string") {
	                return "".concat(search);
	            }
	            return "";
	        }, onChange: function (data) {
	            if (disableMovementChange) {
	                return;
	            }
	            handleChange(data.index);
	        }, onEnter: handleKeyboardClick, onSpace: handleKeyboardClick, onKeyDown: function (event) {
	            if (propOnKeyDown) {
	                propOnKeyDown(event);
	            }
	            switch (event.key) {
	                case "Tab":
	                case "Escape":
	                    if (event.key === "Escape") {
	                        event.stopPropagation();
	                    }
	                    if (temporary && onRequestClose) {
	                        onRequestClose();
	                    }
	                    break;
	                // no default
	            }
	        } })), activeId = _l.activeId, itemRefs = _l.itemRefs, onKeyDown = _l.onKeyDown, focusedIndex = _l.focusedIndex, setFocusedIndex = _l.setFocusedIndex;
	    var prevVisible = require$$1.useRef(visible);
	    require$$1.useEffect(function () {
	        if (prevVisible.current === visible) {
	            return;
	        }
	        prevVisible.current = visible;
	        // whenever it gains visibility, try to set the focused index to the
	        // current active value
	        if (visible) {
	            setFocusedIndex(getIndex());
	        }
	    }, [getIndex, setFocusedIndex, visible]);
	    var handleFocus = require$$1.useCallback(function (event) {
	        if (onFocus) {
	            onFocus(event);
	        }
	        var item = itemRefs[focusedIndex] && itemRefs[focusedIndex].current;
	        if (item) {
	            scrollIntoView(event.currentTarget, item);
	        }
	    }, [focusedIndex, itemRefs, onFocus]);
	    var _m = useScaleTransition({
	        nodeRef: nodeRef,
	        timeout: timeout,
	        className: cn(block$B({ temporary: temporary }), propClassName),
	        classNames: classNames,
	        transitionIn: visible,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExit: onExit,
	        onExiting: onExiting,
	        onExited: onExited,
	    }), elementProps = _m.elementProps, rendered = _m.rendered;
	    return (jsxRuntime.exports.jsx(ConditionalPortal, __assign$1m({ portal: portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: rendered && (jsxRuntime.exports.jsx(List, __assign$1m({}, props, elementProps, { "aria-activedescendant": activeId, role: "listbox", tabIndex: tabIndex, onFocus: handleFocus, onKeyDown: onKeyDown }, { children: options.map(function (option, i) {
	                var optionId = getOptionId$1(id, i);
	                var optionValue = getOptionValue(option, valueKey);
	                var optionLabel = getOptionLabel$1(option, labelKey);
	                var optionProps;
	                if (isListboxOptionProps(option)) {
	                    optionProps = omit(option, [labelKey, valueKey]);
	                }
	                var disabled = isOptionDisabled(option);
	                var onClick;
	                if (!readOnly && !disabled) {
	                    onClick = function () {
	                        handleChange(i);
	                        setFocusedIndex(i);
	                    };
	                }
	                return (jsxRuntime.exports.jsx(Option, __assign$1m({ id: optionId, disabled: disabled }, optionProps, { ref: itemRefs[i], focused: optionId === activeId, selected: value === optionValue, onClick: onClick }, { children: optionLabel }), optionValue));
	            }) }))) })));
	});

	var __assign$1l = (undefined && undefined.__assign) || function () {
	    __assign$1l = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1l.apply(this, arguments);
	};
	var __rest$19 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$x = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var block$A = bem("rmd-select");
	/**
	 * This component is an accessible version of the `<select>` element that allows
	 * for some more custom styles by using the `@react-md/list` package to render
	 * the list of options.
	 *
	 * The `Select` component **must be controlled** with a `value` and `onChange`
	 * handler.
	 *
	 * Note: Since this is not a native `<select>` component, the current value will
	 * be rendered in an `<input type="hidden" />` element so that the value can be
	 * sent along in forms. It is highly recommended to always provide a `name` prop
	 * so this value is sent.
	 */
	var Select = require$$1.forwardRef(function Select(_a, forwardedRef) {
	    var onBlur = _a.onBlur, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, onClick = _a.onClick, className = _a.className, label = _a.label, labelStyle = _a.labelStyle, labelClassName = _a.labelClassName, displayLabelStyle = _a.displayLabelStyle, displayLabelClassName = _a.displayLabelClassName, propListboxStyle = _a.listboxStyle, listboxClassName = _a.listboxClassName, _b = _a.anchor, anchor = _b === void 0 ? BELOW_CENTER_ANCHOR : _b, propTheme = _a.theme, _c = _a.dense, dense = _c === void 0 ? false : _c, _d = _a.inline, inline = _d === void 0 ? false : _d, _e = _a.error, error = _e === void 0 ? false : _e, _f = _a.stretch, stretch = _f === void 0 ? false : _f, _g = _a.disabled, disabled = _g === void 0 ? false : _g, _h = _a.isLeftAddon, isLeftAddon = _h === void 0 ? true : _h, _j = _a.isRightAddon, isRightAddon = _j === void 0 ? true : _j, propUnderlineDirection = _a.underlineDirection, _k = _a.listboxWidth, listboxWidth = _k === void 0 ? "equal" : _k, _l = _a.portal, portal = _l === void 0 ? true : _l, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, name = _a.name, options = _a.options, _m = _a.labelKey, labelKey = _m === void 0 ? "label" : _m, _o = _a.valueKey, valueKey = _o === void 0 ? "value" : _o, _p = _a.getOptionId, getOptionId$1 = _p === void 0 ? getOptionId : _p, _q = _a.getOptionLabel, getOptionLabel$1 = _q === void 0 ? getOptionLabel : _q, _r = _a.getOptionValue, getOptionValue = _r === void 0 ? DEFAULT_GET_ITEM_VALUE : _r, _s = _a.getDisplayLabel, getDisplayLabel$1 = _s === void 0 ? getDisplayLabel : _s, _t = _a.isOptionDisabled, isOptionDisabled = _t === void 0 ? defaultIsOptionDisabled : _t, _u = _a.disableLeftAddon, disableLeftAddon = _u === void 0 ? false : _u, _v = _a.disableMovementChange, disableMovementChange = _v === void 0 ? false : _v, _w = _a.closeOnResize, closeOnResize = _w === void 0 ? false : _w, _x = _a.closeOnScroll, closeOnScroll = _x === void 0 ? false : _x, readOnly = _a.readOnly, placeholder = _a.placeholder, value = _a.value, onChange = _a.onChange, propRightChildren = _a.rightChildren, props = __rest$19(_a, ["onBlur", "onFocus", "onKeyDown", "onClick", "className", "label", "labelStyle", "labelClassName", "displayLabelStyle", "displayLabelClassName", "listboxStyle", "listboxClassName", "anchor", "theme", "dense", "inline", "error", "stretch", "disabled", "isLeftAddon", "isRightAddon", "underlineDirection", "listboxWidth", "portal", "portalInto", "portalIntoId", "name", "options", "labelKey", "valueKey", "getOptionId", "getOptionLabel", "getOptionValue", "getDisplayLabel", "isOptionDisabled", "disableLeftAddon", "disableMovementChange", "closeOnResize", "closeOnScroll", "readOnly", "placeholder", "value", "onChange", "rightChildren"]);
	    var id = props.id;
	    var rightChildren = useIcon("dropdown", propRightChildren);
	    var _y = useFormTheme({
	        theme: propTheme,
	        underlineDirection: propUnderlineDirection,
	    }), theme = _y.theme, underlineDirection = _y.underlineDirection;
	    var valued = typeof value === "number" || !!value;
	    var displayValue = require$$1.useMemo(function () {
	        var currentOption = options.find(function (option) { return getOptionValue(option, valueKey) === value; }) ||
	            null;
	        return getDisplayLabel$1(currentOption, labelKey, !disableLeftAddon);
	    }, [
	        options,
	        getDisplayLabel$1,
	        labelKey,
	        disableLeftAddon,
	        getOptionValue,
	        valueKey,
	        value,
	    ]);
	    var _z = __read$x(useToggle(false), 3), visible = _z[0], show = _z[1], hide = _z[2];
	    var _0 = __read$x(useFocusState({ onBlur: onBlur, onFocus: onFocus }), 3), focused = _0[0], handleFocus = _0[1], handleBlur = _0[2];
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        if (tryToSubmitRelatedForm(event)) {
	            return;
	        }
	        switch (event.key) {
	            case " ":
	            case "ArrowUp":
	            case "ArrowDown":
	                // prevent page scroll
	                event.preventDefault();
	                show();
	                break;
	            // no default
	        }
	    }, [onKeyDown, show]);
	    var _1 = __read$x(useEnsuredRef(forwardedRef), 2), ref = _1[0], refHandler = _1[1];
	    useCloseOnOutsideClick({
	        enabled: visible,
	        element: ref.current,
	        onOutsideClick: hide,
	    });
	    var nodeRef = require$$1.useRef(null);
	    var _2 = useFixedPositioning({
	        style: propListboxStyle,
	        fixedTo: ref,
	        nodeRef: nodeRef,
	        anchor: anchor,
	        onScroll: closeOnScroll ? hide : undefined,
	        onResize: closeOnResize ? hide : undefined,
	        transformOrigin: true,
	        width: listboxWidth,
	        onEntering: function () {
	            var _a;
	            // can't do onEnter since the positioning styles haven't been applied to the
	            // dom node at this time. this means the list is the last element in the DOM
	            // when portalled, which causes the page to scroll to the end. Moving it to
	            // onEntering will ensure the styles have been applied and won't cause page
	            // scrolling
	            (_a = nodeRef.current) === null || _a === void 0 ? void 0 : _a.focus();
	        },
	    }), listboxRef = _2.ref, listboxStyle = _2.style, transitionOptions = _2.callbacks;
	    var handleClick = require$$1.useCallback(function (event) {
	        if (onClick) {
	            onClick(event);
	        }
	        show();
	    }, [onClick, show]);
	    var handleKeyboardClose = require$$1.useCallback(function () {
	        hide();
	        if (ref.current) {
	            ref.current.focus();
	        }
	    }, [hide, ref]);
	    var labelId = "".concat(id, "-label");
	    var valueId = "".concat(id, "-value");
	    var listboxId = "".concat(id, "-listbox");
	    var displayValueId = "".concat(id, "-display-value");
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsxs(TextFieldContainer, __assign$1l({}, props, { "aria-haspopup": "listbox", "aria-disabled": disabled || undefined, ref: refHandler, role: "button", dense: dense, tabIndex: disabled ? undefined : 0, label: !!label, onFocus: handleFocus, onBlur: handleBlur, onKeyDown: disabled ? undefined : handleKeyDown, onClick: disabled ? undefined : handleClick, theme: theme, error: error, active: focused || visible, inline: inline, stretch: stretch, disabled: disabled, underlineDirection: underlineDirection, isLeftAddon: isLeftAddon, isRightAddon: isRightAddon, rightChildren: rightChildren, className: cn(block$A({ disabled: disabled }), className) }, { children: [jsxRuntime.exports.jsx(FloatingLabel, __assign$1l({ id: labelId, style: labelStyle, className: cn(block$A("label"), labelClassName), htmlFor: id, error: error, active: valued && (focused || visible), valued: valued, floating: focused || valued || visible, dense: dense, disabled: disabled, component: "span" }, { children: label })), jsxRuntime.exports.jsx("span", __assign$1l({ id: displayValueId, style: displayLabelStyle, className: cn(block$A("value", {
	                            disabled: disabled,
	                            readonly: readOnly,
	                            placeholder: !valued && placeholder,
	                            "placeholder-active": !valued && placeholder && (focused || visible),
	                        }), displayLabelClassName) }, { children: displayValue || (!valued && placeholder) })), jsxRuntime.exports.jsx("input", { id: valueId, type: "hidden", name: name, value: value })] })), jsxRuntime.exports.jsx(Listbox, __assign$1l({ id: listboxId, ref: listboxRef }, transitionOptions, { "aria-labelledby": id, style: listboxStyle, className: listboxClassName, name: name, readOnly: readOnly, portal: portal, portalInto: portalInto, portalIntoId: portalIntoId, value: value, onChange: onChange, visible: visible, temporary: true, onRequestClose: handleKeyboardClose, options: options, labelKey: labelKey, valueKey: valueKey, getOptionId: getOptionId$1, getOptionLabel: getOptionLabel$1, getOptionValue: getOptionValue, isOptionDisabled: isOptionDisabled, disableMovementChange: disableMovementChange }))] }));
	});

	/**
	 * @remarks \@since 2.5.0
	 */
	var DEFAULT_SLIDER_GET_VALUE_TEXT = function () { return ""; };
	/**
	 * @remarks \@since 2.5.0
	 */
	var DEFAULT_SLIDER_MIN = 0;
	/**
	 * @remarks \@since 2.5.0
	 */
	var DEFAULT_SLIDER_MAX = 100;
	/**
	 * @remarks \@since 2.5.0
	 */
	var DEFAULT_SLIDER_STEP = 1;
	/**
	 * @remarks \@since 2.5.0
	 */
	var DEFAULT_SLIDER_ANIMATION_TIME = 150;
	/**
	 * @remarks \@since 2.5.0
	 */
	var THUMB_1_VAR = "--offset1";
	/**
	 * @remarks \@since 2.5.0
	 */
	var THUMB_2_VAR = "--offset2";

	var __assign$1k = (undefined && undefined.__assign) || function () {
	    __assign$1k = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1k.apply(this, arguments);
	};
	var __rest$18 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$a = bem("rmd-slider-container");
	/**
	 * The `SliderContainer` component is mostly an internal component that is
	 * built-in to the `Slider` and `RangeSlider` components to add addons to the
	 * left or right of the `SliderTrack`. When vertical, it will add addons to the
	 * bottom or top instead.
	 *
	 * @remarks \@since 2.5.0
	 */
	var SliderContainer = require$$1.forwardRef(function SliderContainer(_a, ref) {
	    var className = _a.className, beforeAddon = _a.beforeAddon, afterAddon = _a.afterAddon, children = _a.children, _b = _a.vertical, vertical = _b === void 0 ? false : _b, label = _a.label, labelId = _a.labelId, labelProps = _a.labelProps, _c = _a.disabled, disabled = _c === void 0 ? false : _c, props = __rest$18(_a, ["className", "beforeAddon", "afterAddon", "children", "vertical", "label", "labelId", "labelProps", "disabled"]);
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [label && (jsxRuntime.exports.jsx("span", __assign$1k({}, labelProps, { id: labelId, className: cn(labelStyles({ disabled: disabled }), labelProps === null || labelProps === void 0 ? void 0 : labelProps.className) }, { children: label }))), jsxRuntime.exports.jsx("div", __assign$1k({}, props, { ref: ref, className: cn(styles$a({
	                    h: !vertical,
	                    "pad-left": !vertical && !beforeAddon,
	                    "pad-right": !vertical && !afterAddon,
	                    "pad-bottom": vertical && !beforeAddon,
	                    "pad-top": vertical && !afterAddon,
	                    v: vertical,
	                }), className) }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$1k({ icon: beforeAddon, stacked: vertical, flexReverse: vertical }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$1k({ icon: afterAddon, iconAfter: true, stacked: vertical, flexReverse: vertical }, { children: children })) })) }))] }));
	});

	/** @remarks \@since 2.0.0 */
	var DEFAULT_TOOLTIP_CLASSNAMES = {
	    appear: "rmd-tooltip--enter",
	    appearActive: "rmd-tooltip--visible",
	    enter: "rmd-tooltip--enter",
	    enterActive: "rmd-tooltip--visible",
	    enterDone: "rmd-tooltip--visible",
	    exit: "rmd-tooltip--visible rmd-tooltip--exit",
	    exitActive: "rmd-tooltip--exit-active",
	};
	/** @remarks \@since 2.0.0 */
	var DEFAULT_TOOLTIP_TIMEOUT = {
	    enter: 200,
	    exit: 150,
	};
	/** @remarks \@since 2.0.0 */
	var DEFAULT_TOOLTIP_DELAY = 1000;
	/** @remarks \@since 2.0.0 */
	var DEFAULT_TOOLTIP_THRESHOLD = 0.75;
	/** @remarks \@since 2.8.0 */
	var DEFAULT_TOOLTIP_SPACING = "1.5rem";
	/** @remarks \@since 2.8.0 */
	var DEFAULT_TOOLTIP_DENSE_SPACING = "0.875rem";
	/** @remarks \@since 2.8.0 */
	var DEFAULT_TOOLTIP_MARGIN = 16;
	/** @remarks \@since 2.8.0 */
	var DEFAULT_TOOLTIP_POSITION = "below";
	/**
	 * @internal
	 * @remarks \@since 2.8.0
	 */
	var TOOLTIP_SPACING_VAR = "--rmd-tooltip-spacing";

	var __assign$1j = (undefined && undefined.__assign) || function () {
	    __assign$1j = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1j.apply(this, arguments);
	};
	var __rest$17 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$z = bem("rmd-tooltip");
	/**
	 * This is the base tooltip component that can only be used to render a tooltip
	 * with an animation when the visibility changes. If this component is used, you
	 * will need to manually add all the event listeners and triggers to change the
	 * `visible` prop.
	 *
	 * @example
	 * Simple Usage
	 * ```tsx
	 * import { Button } from "@react-md/button";
	 * import { useTooltip, Tooltip } from "@react-md/tooltip";
	 *
	 * function Example() {
	 *   const { tooltipProps, elementProps } = useTooltip({
	 *     baseId: 'my-element',
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <Button {...elementProps}>Button</Button>
	 *       <Tooltip {...tooltipProps}>
	 *         Tooltip Content
	 *       </Tooltip>
	 *     </>
	 *   );
	 * }
	 * ```
	 */
	var Tooltip = require$$1.forwardRef(function Tooltip(_a, nodeRef) {
	    var _b;
	    var className = _a.className, _c = _a.classNames, classNames = _c === void 0 ? DEFAULT_TOOLTIP_CLASSNAMES : _c, visible = _a.visible, _d = _a.timeout, timeout = _d === void 0 ? DEFAULT_TOOLTIP_TIMEOUT : _d, _e = _a.dense, dense = _e === void 0 ? false : _e, _f = _a.lineWrap, lineWrap = _f === void 0 ? true : _f, _g = _a.position, position = _g === void 0 ? DEFAULT_TOOLTIP_POSITION : _g, children = _a.children, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, _h = _a.portal, portal = _h === void 0 ? true : _h, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, _j = _a.temporary, temporary = _j === void 0 ? true : _j, props = __rest$17(_a, ["className", "classNames", "visible", "timeout", "dense", "lineWrap", "position", "children", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "portal", "portalInto", "portalIntoId", "temporary"]);
	    var _k = useCSSTransition({
	        nodeRef: nodeRef,
	        timeout: timeout,
	        className: cn(block$z((_b = {
	                dense: dense,
	                "line-wrap": lineWrap,
	                "dense-line-wrap": dense && lineWrap
	            },
	            _b[position] = true,
	            _b)), className),
	        classNames: classNames,
	        transitionIn: visible,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExit: onExit,
	        onExiting: onExiting,
	        onExited: onExited,
	        temporary: temporary,
	    }), elementProps = _k.elementProps, rendered = _k.rendered;
	    return (jsxRuntime.exports.jsx(ConditionalPortal, __assign$1j({ portal: portal, portalInto: portalInto, portalIntoId: portalIntoId }, { children: rendered && (jsxRuntime.exports.jsx("span", __assign$1j({}, props, elementProps, { role: "tooltip" }, { children: children }))) })));
	});

	var __read$w = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/** @internal */
	var noop$6 = function () {
	    // do nothing
	};
	/**
	 * A hook that's used to determine the "best" position to render the tooltip
	 * within the viewport.
	 *
	 * @internal
	 * @remarks \@since 2.8.0
	 */
	function useTooltipPosition(_a) {
	    var determinedPosition = _a.position, _b = _a.defaultPosition, defaultPosition = _b === void 0 ? "below" : _b, _c = _a.threshold, threshold = _c === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _c;
	    var _d = __read$w(require$$1.useState(defaultPosition), 2), position = _d[0], setPosition = _d[1];
	    var updatePosition = require$$1.useCallback(function (container) {
	        var _a = container.getBoundingClientRect(), top = _a.top, left = _a.left;
	        var vh = getViewportSize("height");
	        var vw = getViewportSize("width");
	        var nextPosition = defaultPosition;
	        if (defaultPosition === "above" && top < vh * threshold) {
	            nextPosition = "below";
	        }
	        else if (defaultPosition === "below" && top > vh * threshold) {
	            nextPosition = "above";
	        }
	        else if (defaultPosition === "left" && left < vw * threshold) {
	            nextPosition = "right";
	        }
	        else if (defaultPosition === "right" && left > vw * threshold) {
	            nextPosition = "left";
	        }
	        setPosition(nextPosition);
	    }, [defaultPosition, threshold]);
	    if (typeof determinedPosition !== "undefined") {
	        return [determinedPosition, noop$6];
	    }
	    return [position, updatePosition];
	}

	var __assign$1i = (undefined && undefined.__assign) || function () {
	    __assign$1i = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1i.apply(this, arguments);
	};
	var __rest$16 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$v = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/** @internal */
	function getAnchor(position) {
	    switch (position) {
	        case "above":
	            return ABOVE_CENTER_ANCHOR;
	        case "below":
	            return BELOW_CENTER_ANCHOR;
	        case "left":
	            return CENTER_LEFT_ANCHOR;
	        case "right":
	            return CENTER_RIGHT_ANCHOR;
	        default:
	            throw new Error("Invalid position: ".concat(position));
	    }
	}
	/**
	 * This hook is used to handle the positioning and visibility of the tooltip
	 * component mostly within the {@link Tooltipped} component.
	 *
	 * @example
	 * Simple Usage
	 * ```tsx
	 * import { Button } from "@react-md/button";
	 * import { useTooltip, Tooltip } from "@react-md/tooltip";
	 *
	 * function Example() {
	 *   const { tooltipProps, elementProps } = useTooltip({
	 *     baseId: 'my-element',
	 *   });
	 *
	 *   return (
	 *     <>
	 *       <Button {...elementProps}>Button</Button>
	 *       <Tooltip {...tooltipProps}>
	 *         Tooltip Content
	 *       </Tooltip>
	 *     </>
	 *   );
	 * }
	 * ```
	 *
	 * @remarks \@since 2.8.0
	 * @param options - All the {@link TooltipHookOptions} to configure the tooltip behavior.
	 * @returns The {@link TooltipHookReturnValue}
	 */
	function useTooltip(_a) {
	    var baseId = _a.baseId, propStyle = _a.style, describedBy = _a.describedBy, _b = _a.dense, dense = _b === void 0 ? false : _b, _c = _a.spacing, spacing = _c === void 0 ? DEFAULT_TOOLTIP_SPACING : _c, _d = _a.denseSpacing, denseSpacing = _d === void 0 ? DEFAULT_TOOLTIP_DENSE_SPACING : _d, determinedPosition = _a.position, _e = _a.defaultPosition, defaultPosition = _e === void 0 ? DEFAULT_TOOLTIP_POSITION : _e, _f = _a.vwMargin, vwMargin = _f === void 0 ? DEFAULT_TOOLTIP_MARGIN : _f, _g = _a.vhMargin, vhMargin = _g === void 0 ? DEFAULT_TOOLTIP_MARGIN : _g, _h = _a.threshold, threshold = _h === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _h, _j = _a.touchTime, touchTime = _j === void 0 ? DEFAULT_TOOLTIP_DELAY : _j, _k = _a.focusTime, focusTime = _k === void 0 ? DEFAULT_TOOLTIP_DELAY : _k, propOnFocus = _a.onFocus, propOnBlur = _a.onBlur, propOnKeyDown = _a.onKeyDown, onClick = _a.onClick, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, propOnTouchStart = _a.onTouchStart, propOnContextMenu = _a.onContextMenu, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, _l = _a.disabled, disabled = _l === void 0 ? false : _l, _m = _a.disableSwapping, disableSwapping = _m === void 0 ? false : _m, propDisableHoverMode = _a.disableHoverMode, _o = _a.disableAutoSpacing, disableAutoSpacing = _o === void 0 ? "production" === "test" : _o;
	    var containerRef = require$$1.useRef(null);
	    var _p = __read$v(useTooltipPosition({
	        position: determinedPosition,
	        defaultPosition: defaultPosition,
	        threshold: threshold,
	    }), 2), position = _p[0], updatePosition = _p[1];
	    var mode = useUserInteractionMode();
	    var _q = __read$v(require$$1.useState(null), 2), initiatedBy = _q[0], setInitiatedBy = _q[1];
	    var windowFocusEvent = require$$1.useRef(false);
	    var timeout = require$$1.useRef(undefined);
	    var _r = useHoverMode({
	        disabled: propDisableHoverMode || disabled,
	        exitVisibilityDelay: 0,
	    }), visible = _r.visible, setVisible = _r.setVisible, handlers = _r.handlers; _r.hoverHandlers; var disableHoverMode = _r.disableHoverMode, clearHoverTimeout = _r.clearHoverTimeout, others = __rest$16(_r, ["visible", "setVisible", "handlers", "hoverHandlers", "disableHoverMode", "clearHoverTimeout"]);
	    var hide = require$$1.useCallback(function () {
	        window.clearTimeout(timeout.current);
	        setVisible(false);
	        setInitiatedBy(null);
	    }, [setVisible]);
	    var onBlur = function (event) {
	        propOnBlur === null || propOnBlur === void 0 ? void 0 : propOnBlur(event);
	        if (disabled || initiatedBy !== "keyboard") {
	            return;
	        }
	        hide();
	    };
	    var onFocus = function (event) {
	        propOnFocus === null || propOnFocus === void 0 ? void 0 : propOnFocus(event);
	        if (disabled) {
	            return;
	        }
	        // if the element gained focus immediately after the browser window gains
	        // focus, do not start timer and ignore this event instead
	        if (windowFocusEvent.current) {
	            windowFocusEvent.current = false;
	            return;
	        }
	        if (mode !== "keyboard" || initiatedBy !== null) {
	            return;
	        }
	        setInitiatedBy("keyboard");
	        window.clearTimeout(timeout.current);
	        containerRef.current = event.currentTarget;
	        updatePosition(event.currentTarget);
	        timeout.current = window.setTimeout(function () {
	            setVisible(true);
	        }, focusTime);
	    };
	    var onKeyDown = function (event) {
	        propOnKeyDown === null || propOnKeyDown === void 0 ? void 0 : propOnKeyDown(event);
	        if (disabled || initiatedBy !== "keyboard" || event.key !== "Escape") {
	            return;
	        }
	        hide();
	    };
	    var onTouchStart = function (event) {
	        propOnTouchStart === null || propOnTouchStart === void 0 ? void 0 : propOnTouchStart(event);
	        if (event.isPropagationStopped() || disabled || mode !== "touch") {
	            return;
	        }
	        setInitiatedBy("touch");
	        window.clearTimeout(timeout.current);
	        timeout.current = window.setTimeout(function () {
	            setVisible(true);
	        }, touchTime);
	        containerRef.current = event.currentTarget;
	        updatePosition(event.currentTarget);
	    };
	    var onContextMenu = function (event) {
	        var _a;
	        propOnContextMenu === null || propOnContextMenu === void 0 ? void 0 : propOnContextMenu(event);
	        if (event.isPropagationStopped() || disabled || mode !== "touch") {
	            return;
	        }
	        // Need to prevent the context menu from displaying and display the tooltip
	        // instead.
	        event.preventDefault();
	        var selection = window.getSelection();
	        var node = (_a = selection === null || selection === void 0 ? void 0 : selection.anchorNode) === null || _a === void 0 ? void 0 : _a.parentElement;
	        /* istanbul ignore next */
	        if (selection && node && event.currentTarget.contains(node)) {
	            selection.empty();
	        }
	        setVisible(true);
	    };
	    require$$1.useEffect(function () {
	        if (disabled) {
	            return;
	        }
	        if (mode !== "keyboard") {
	            windowFocusEvent.current = false;
	            return;
	        }
	        var handler = function () {
	            if (document.hidden) {
	                hide();
	                windowFocusEvent.current =
	                    document.activeElement === containerRef.current;
	            }
	        };
	        window.addEventListener("visibilitychange", handler);
	        return function () {
	            window.removeEventListener("visibilitychange", handler);
	        };
	    }, [disabled, hide, mode]);
	    require$$1.useEffect(function () {
	        if (initiatedBy !== "touch") {
	            return;
	        }
	        window.addEventListener("scroll", hide, true);
	        window.addEventListener("touchend", hide, true);
	        return function () {
	            window.removeEventListener("scroll", hide, true);
	            window.removeEventListener("touchend", hide, true);
	        };
	    }, [hide, initiatedBy, setVisible]);
	    useOnUnmount(function () {
	        window.clearTimeout(timeout.current);
	    });
	    var nodeRef = require$$1.useRef(null);
	    var _s = useFixedPositioning({
	        style: propStyle,
	        nodeRef: nodeRef,
	        anchor: getAnchor(position),
	        disableSwapping: disableSwapping !== null && disableSwapping !== void 0 ? disableSwapping : !!determinedPosition,
	        fixedTo: containerRef,
	        getFixedPositionOptions: function () {
	            var tooltipSpacing = dense ? denseSpacing : spacing;
	            var node = nodeRef.current;
	            /* istanbul ignore next */
	            if (!disableAutoSpacing && node) {
	                tooltipSpacing = window
	                    .getComputedStyle(node)
	                    .getPropertyValue(TOOLTIP_SPACING_VAR);
	            }
	            var currentSpacing = unitToNumber(tooltipSpacing);
	            return {
	                vwMargin: vwMargin,
	                vhMargin: vhMargin,
	                xMargin: currentSpacing,
	                yMargin: currentSpacing,
	            };
	        },
	        onResize: hide,
	        onScroll: hide,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExited: onExited,
	    }), ref = _s.ref, style = _s.style, transitionOptions = _s.callbacks;
	    var tooltipHandlers = {
	        onFocus: onFocus,
	        onBlur: onBlur,
	        onKeyDown: onKeyDown,
	        onTouchStart: onTouchStart,
	        onContextMenu: onContextMenu,
	        onClick: function (event) {
	            onClick === null || onClick === void 0 ? void 0 : onClick(event);
	            if (event.isPropagationStopped() || disabled) {
	                return;
	            }
	            setVisible(false);
	            setInitiatedBy(null);
	            window.clearTimeout(timeout.current);
	            clearHoverTimeout();
	        },
	        onMouseEnter: function (event) {
	            onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(event);
	            if (disabled) {
	                return;
	            }
	            if (initiatedBy !== null) {
	                event.stopPropagation();
	                return;
	            }
	            containerRef.current = event.currentTarget;
	            updatePosition(event.currentTarget);
	            setInitiatedBy("mouse");
	            handlers.onMouseEnter(event);
	        },
	        onMouseLeave: function (event) {
	            onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(event);
	            if (disabled) {
	                return;
	            }
	            if (initiatedBy !== "mouse") {
	                event.stopPropagation();
	                return;
	            }
	            setInitiatedBy(null);
	            handlers.onMouseLeave(event);
	        },
	    };
	    var tooltipId = "".concat(baseId, "-tooltip");
	    var elementProps = __assign$1i({ id: baseId, "aria-describedby": cn(visible && tooltipId, describedBy) || undefined }, tooltipHandlers);
	    var tooltipProps = __assign$1i({ id: tooltipId, ref: ref, dense: dense, visible: visible, position: position, style: style }, transitionOptions);
	    return __assign$1i(__assign$1i({}, others), { visible: visible, setVisible: setVisible, handlers: tooltipHandlers, elementProps: elementProps, tooltipProps: tooltipProps, disableHoverMode: disableHoverMode, clearHoverTimeout: clearHoverTimeout });
	}

	var __assign$1h = (undefined && undefined.__assign) || function () {
	    __assign$1h = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1h.apply(this, arguments);
	};
	var __rest$15 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var MERGABLE_PROPS = [
	    "onClick",
	    "onMouseEnter",
	    "onMouseLeave",
	    "onTouchStart",
	    "onFocus",
	    "onKeyDown",
	    "onContextMenu",
	];
	/**
	 * The `Tooltipped` component can be used to dynamically add a tooltip to child
	 * element by cloning the required event handlers and accessibility props into
	 * the child with `React.cloneChild`.
	 *
	 * Note: This component is _kind of_ deprecated in favor of using the
	 * `useTooltip` hook and `Tooltip` component instead.
	 *
	 * @see {@link Tooltip} for an example
	 */
	function Tooltipped(_a) {
	    var id = _a.id, style = _a.style, children = _a.children, tooltipChildren = _a.tooltip, _b = _a.dense, dense = _b === void 0 ? false : _b, _c = _a.vhMargin, vhMargin = _c === void 0 ? DEFAULT_TOOLTIP_MARGIN : _c, _d = _a.vwMargin, vwMargin = _d === void 0 ? DEFAULT_TOOLTIP_MARGIN : _d, _e = _a.spacing, spacing = _e === void 0 ? DEFAULT_TOOLTIP_SPACING : _e, _f = _a.denseSpacing, denseSpacing = _f === void 0 ? DEFAULT_TOOLTIP_DENSE_SPACING : _f, propPosition = _a.position, _g = _a.threshold, threshold = _g === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _g, onClick = _a.onClick, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, onTouchStart = _a.onTouchStart, onContextMenu = _a.onContextMenu, onBlur = _a.onBlur, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, describedBy = _a["aria-describedby"], _h = _a.defaultPosition, defaultPosition = _h === void 0 ? DEFAULT_TOOLTIP_POSITION : _h, _j = _a.temporary, temporary = _j === void 0 ? true : _j, disableSwapping = _a.disableSwapping, disableHoverMode = _a.disableHoverMode, _k = _a.disableAutoSpacing, disableAutoSpacing = _k === void 0 ? "production" === "test" : _k, props = __rest$15(_a, ["id", "style", "children", "tooltip", "dense", "vhMargin", "vwMargin", "spacing", "denseSpacing", "position", "threshold", "onClick", "onMouseEnter", "onMouseLeave", "onTouchStart", "onContextMenu", "onBlur", "onFocus", "onKeyDown", "aria-describedby", "defaultPosition", "temporary", "disableSwapping", "disableHoverMode", "disableAutoSpacing"]);
	    var _l = useTooltip({
	        baseId: id,
	        style: style,
	        dense: dense,
	        spacing: spacing,
	        denseSpacing: denseSpacing,
	        vwMargin: vwMargin,
	        vhMargin: vhMargin,
	        position: propPosition,
	        defaultPosition: defaultPosition,
	        disableSwapping: disableSwapping,
	        disableHoverMode: disableHoverMode,
	        disableAutoSpacing: disableAutoSpacing,
	        onFocus: onFocus,
	        onBlur: onBlur,
	        onKeyDown: onKeyDown,
	        onClick: onClick,
	        onMouseEnter: onMouseEnter,
	        onMouseLeave: onMouseLeave,
	        onTouchStart: onTouchStart,
	        onContextMenu: onContextMenu,
	        threshold: threshold,
	    }), elementProps = _l.elementProps, tooltipProps = _l.tooltipProps;
	    if (!tooltipChildren) {
	        if (typeof children === "function") {
	            return children({ id: id, tooltip: null, "aria-describedby": describedBy });
	        }
	        var child_1 = require$$1.Children.only(children);
	        return require$$1.cloneElement(child_1, { id: id, "aria-describedby": describedBy });
	    }
	    var tooltip = (jsxRuntime.exports.jsx(Tooltip, __assign$1h({}, tooltipProps, props, { temporary: temporary }, { children: tooltipChildren })));
	    if (typeof children === "function") {
	        return children(__assign$1h(__assign$1h({}, elementProps), { tooltip: tooltip }));
	    }
	    var child = require$$1.Children.only(children);
	    // TODO: remove this mess since you should provide handlers to the
	    // `Tooltipped` component instead of the child element.
	    /* istanbul ignore next */
	    var merged = MERGABLE_PROPS.reduce(function (result, propName) {
	        var propHandler = child.props[propName];
	        var configHandler = elementProps[propName];
	        if (!propHandler) {
	            result[propName] = configHandler;
	        }
	        else if (!configHandler) {
	            result[propName] = propHandler;
	        }
	        else {
	            // not sure of a way to actually strongly type this nicely.
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            result[propName] = function (event) {
	                propHandler(event);
	                configHandler(event);
	            };
	        }
	        return result;
	    }, __assign$1h({}, elementProps));
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [require$$1.cloneElement(child, merged), tooltip] }));
	}

	var __assign$1g = (undefined && undefined.__assign) || function () {
	    __assign$1g = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1g.apply(this, arguments);
	};
	var __rest$14 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$9 = bem("rmd-slider-value");
	var HORIZONTAL_CLASS_NAMES = {
	    enter: "rmd-slider-value--h-off",
	    enterActive: "rmd-slider-value--h-on rmd-slider-value--animate",
	    exit: "rmd-slider-value--animate",
	    exitActive: "rmd-slider-value--h-off",
	};
	var VERTICAL_CLASS_NAMES = {
	    enter: "rmd-slider-value--v-off",
	    enterActive: "rmd-slider-value--v-on rmd-slider-value--animate",
	    exit: "rmd-slider-value--animate",
	    exitActive: "rmd-slider-value--v-off",
	};
	/**
	 * This component creates the "discrete" slider thumb value by rendering a
	 * tooltip when needed.
	 *
	 * @remarks \@since 2.5.0
	 * @internal
	 */
	function SliderValue(_a) {
	    var _b;
	    var index = _a.index, animate = _a.animate, discrete = _a.discrete, vertical = _a.vertical, children = _a.children, className = _a.className, _c = _a.portal, portal = _c === void 0 ? false : _c, props = __rest$14(_a, ["index", "animate", "discrete", "vertical", "children", "className", "portal"]);
	    if (!discrete) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx(Tooltip, __assign$1g({}, props, { portal: portal, className: cn(styles$9({
	            h: !vertical,
	            v: vertical,
	        }), (_b = {
	                "rmd-slider-thumb--animate": animate
	            },
	            _b["rmd-slider-thumb--h".concat(index + 1)] = !vertical,
	            _b["rmd-slider-thumb--v".concat(index + 1)] = vertical,
	            _b), className), classNames: vertical ? VERTICAL_CLASS_NAMES : HORIZONTAL_CLASS_NAMES, position: vertical ? "left" : "above", dense: true }, { children: children })));
	}

	var __read$u = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @internal
	 */
	var noop$5 = function () {
	    // do nothing
	};
	/**
	 * This is a completely internal hook that helps control the visibility of the
	 * discrete value tooltip's visibility for the `Slider` and `RangeSlider`.
	 *
	 * Note: This isn't 100% there since the tooltip doesn't animate in when the
	 * user holds the mouse down in the same spot for the `animationDuration`.
	 *
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	function useDiscreteValueVisibility(_a) {
	    var active = _a.active, animate = _a.animate, animationDuration = _a.animationDuration, discrete = _a.discrete, disabled = _a.disabled, _b = _a.onBlur, propOnBlur = _b === void 0 ? noop$5 : _b, _c = _a.onFocus, propOnFocus = _c === void 0 ? noop$5 : _c;
	    var ref = require$$1.useRef(null);
	    var isKeyboard = useIsUserInteractionMode("keyboard");
	    // when the user interaction mode changes from keyboard -> mouse by clicking
	    // on the track, need to make sure that the thumb value has the animation
	    // state enabled so it moves at the same speed as the thumb instead of jumping
	    // immediately
	    var _d = __read$u(require$$1.useState(false), 2), isModeTransition = _d[0], setModeTransition = _d[1];
	    var _e = __read$u(require$$1.useState(false), 2), visible = _e[0], setVisible = _e[1];
	    require$$1.useEffect(function () {
	        if (!discrete) {
	            setVisible(false);
	            setModeTransition(false);
	            return;
	        }
	        if (discrete && visible && disabled) {
	            setVisible(false);
	            return;
	        }
	        if (!isKeyboard) {
	            // only considered a "transition" when the tooltip is already visible and
	            // switching away from keyboard mode
	            setModeTransition(visible);
	            return;
	        }
	        // when swapping from mouse/touch -> keyboard, the tooltip's visibility will
	        // need to be enabled since default drag behavior is to hide on drag end.
	        // The drag process automatically focuses the current "target" thumb to help
	        // the user switch between the modes more easily so if the active element is
	        // the current thumb, we're good to go
	        setModeTransition(false);
	        setVisible(!disabled && document.activeElement === ref.current);
	    }, [isKeyboard, visible, discrete, disabled]);
	    require$$1.useEffect(function () {
	        if (!discrete) {
	            return;
	        }
	        if (!active) {
	            setVisible(false);
	            setModeTransition(false);
	            return;
	        }
	        // need to delay the visibility for the same `animationDuration` as the
	        // thumb's active state so that the tooltip appears at the same time the
	        // thumb stops animating with click drag events
	        var timeout = window.setTimeout(function () {
	            setVisible(true);
	            setModeTransition(false);
	        }, animationDuration);
	        return function () {
	            window.clearTimeout(timeout);
	        };
	    }, [active, animationDuration, discrete]);
	    var onBlur = require$$1.useCallback(function (event) {
	        propOnBlur(event);
	        var track = event.currentTarget.parentElement;
	        // need to hide on blur because it _usually_ means the user clicked
	        // somewhere else on the page after using the keyboard. However, it is
	        // possible the user used the keyboard to update the value and then
	        // clicked on the track to update more quickly, so verify that the next
	        // focus element isn't the track or any children of the track.
	        if (!track ||
	            document.activeElement ||
	            !track.contains(document.activeElement)) {
	            ref.current = null;
	            setVisible(false);
	        }
	    }, [propOnBlur]);
	    var onFocus = require$$1.useCallback(function (event) {
	        ref.current = event.currentTarget;
	        propOnFocus(event);
	        if (discrete && isKeyboard) {
	            setVisible(true);
	        }
	    }, [discrete, propOnFocus, isKeyboard]);
	    return {
	        onBlur: onBlur,
	        onFocus: onFocus,
	        animateValue: isModeTransition || (animate && isKeyboard),
	        visible: visible,
	    };
	}

	var __assign$1f = (undefined && undefined.__assign) || function () {
	    __assign$1f = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1f.apply(this, arguments);
	};
	var __rest$13 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$8 = bem("rmd-slider-thumb");
	/**
	 * The slider thumb implements the `role="slider"` for the `Slider` and
	 * `RangeSlider` components.
	 *
	 * @remarks \@since 2.5.0
	 */
	var SliderThumb = require$$1.forwardRef(function SliderThumb(_a, ref) {
	    var propId = _a.id, baseId = _a.baseId, className = _a.className, _b = _a.min, min = _b === void 0 ? DEFAULT_SLIDER_MIN : _b, _c = _a.max, max = _c === void 0 ? DEFAULT_SLIDER_MAX : _c, _d = _a.animationDuration, animationDuration = _d === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _d, _e = _a.getValueText, getValueText = _e === void 0 ? DEFAULT_SLIDER_GET_VALUE_TEXT : _e, name = _a.name, value = _a.value, index = _a.index, _f = _a.active, active = _f === void 0 ? false : _f, _g = _a.animate, animate = _g === void 0 ? false : _g, _h = _a.discrete, discrete = _h === void 0 ? false : _h, _j = _a.disabled, disabled = _j === void 0 ? false : _j, _k = _a.vertical, vertical = _k === void 0 ? false : _k, _l = _a.tabIndex, tabIndex = _l === void 0 ? disabled ? -1 : 0 : _l, propOnBlur = _a.onBlur, propOnFocus = _a.onFocus, props = __rest$13(_a, ["id", "baseId", "className", "min", "max", "animationDuration", "getValueText", "name", "value", "index", "active", "animate", "discrete", "disabled", "vertical", "tabIndex", "onBlur", "onFocus"]);
	    var id = propId || "".concat(baseId, "-thumb-").concat(index + 1);
	    var isFirst = index === 0;
	    var _m = useDiscreteValueVisibility({
	        active: active,
	        animate: animate,
	        discrete: discrete,
	        disabled: disabled,
	        onBlur: propOnBlur,
	        onFocus: propOnFocus,
	        animationDuration: animationDuration,
	    }), onBlur = _m.onBlur, onFocus = _m.onFocus, animateValue = _m.animateValue, visible = _m.visible;
	    var styleOptions = {
	        h: !vertical,
	        h1: !vertical && isFirst,
	        h2: !vertical && !isFirst,
	        v: vertical,
	        v1: vertical && isFirst,
	        v2: vertical && !isFirst,
	        active: active,
	        animate: animate,
	        disabled: disabled,
	    };
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [disabled && (jsxRuntime.exports.jsx("span", { className: cn(styles$8(__assign$1f(__assign$1f({}, styleOptions), { mask: true, "mask-h": !vertical, "mask-v": vertical })), className) })), jsxRuntime.exports.jsx("span", __assign$1f({}, props, { id: id, ref: ref, role: "slider", "aria-valuemin": min, "aria-valuemax": max, "aria-valuenow": value, "aria-valuetext": getValueText(value) || undefined, "aria-disabled": disabled || undefined, "aria-orientation": (vertical && "vertical") || undefined, tabIndex: tabIndex, onBlur: onBlur, onFocus: onFocus, className: cn(styles$8(__assign$1f(__assign$1f({}, styleOptions), { "disabled-h": disabled && !vertical, "disabled-v": disabled && vertical })), className) })), jsxRuntime.exports.jsx("input", { id: "".concat(id, "-value"), type: "hidden", name: name, value: value }), jsxRuntime.exports.jsx(SliderValue, __assign$1f({ id: "".concat(id, "-value"), visible: visible, index: index, animate: animateValue, discrete: discrete, vertical: vertical }, { children: value }))] }));
	});

	var __assign$1e = (undefined && undefined.__assign) || function () {
	    __assign$1e = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1e.apply(this, arguments);
	};
	var __rest$12 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$7 = bem("rmd-slider-track");
	/**
	 * The `SliderTrack` component is used to show the distance that the slider can
	 * be dragged as well as a visual indication of the value. The main usage is to
	 * update the custom css properties for the thumb's values.
	 *
	 * @remarks \@since 2.5.0
	 */
	var SliderTrack = require$$1.forwardRef(function SliderTrack(_a, ref) {
	    var _b;
	    var propStyle = _a.style, className = _a.className, children = _a.children, _c = _a.animate, animate = _c === void 0 ? false : _c, _d = _a.vertical, vertical = _d === void 0 ? false : _d, _e = _a.disabled, disabled = _e === void 0 ? false : _e, thumb1Percentage = _a.thumb1Percentage, thumb2Percentage = _a.thumb2Percentage, props = __rest$12(_a, ["style", "className", "children", "animate", "vertical", "disabled", "thumb1Percentage", "thumb2Percentage"]);
	    var style = __assign$1e(__assign$1e({}, propStyle), (_b = {}, _b[THUMB_1_VAR] = thumb1Percentage, _b[THUMB_2_VAR] = thumb2Percentage, _b));
	    return (jsxRuntime.exports.jsx("span", __assign$1e({}, props, { ref: ref, style: style, className: cn(styles$7({
	            animate: animate,
	            hoverable: !disabled,
	            disabled: disabled,
	            h: !vertical,
	            h1: !vertical && !thumb2Percentage,
	            h2: !vertical && thumb2Percentage,
	            v: vertical,
	            v1: vertical && !thumb2Percentage,
	            v2: vertical && thumb2Percentage,
	        }), className) }, { children: children })));
	});

	/**
	 * Gets the number of steps in the allowed range of values.
	 *
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var getSteps = function (min, max, step) {
	    return Math.abs(max - min) / step;
	};
	/**
	 *
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var getJumpValue = function (min, max, step, jump) {
	    var steps = getSteps(min, max, step);
	    var value = jump !== null && jump !== void 0 ? jump : (steps / 10) * step;
	    if (Number.isInteger(step)) {
	        return Math.ceil(value);
	    }
	    return value;
	};
	/**
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var isMouseEvent = function (event) {
	    return event.type === "mousedown" ||
	        event.type === "mousemove" ||
	        event.type === "mouseup";
	};
	/**
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var isTouchEvent = function (event) {
	    return event.type === "touchstart" ||
	        event.type === "touchmove" ||
	        event.type === "touchend";
	};
	/**
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var isRangeSlider = function (controls) { return Array.isArray(controls.value); };
	/**
	 * This is used to get the next value for the slider while being dragged via
	 * mouse or touch.
	 *
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var getDragValue = function (_a) {
	    var min = _a.min, max = _a.max, step = _a.step, vertical = _a.vertical, clientX = _a.clientX, clientY = _a.clientY, left = _a.left, top = _a.top, height = _a.height, width = _a.width, isRtl = _a.isRtl, minValue = _a.minValue, maxValue = _a.maxValue;
	    var sliderSize = vertical ? height : width;
	    var sliderPosition = vertical ? top + height : left;
	    var cursorPosition = vertical ? clientY : clientX;
	    var difference = vertical
	        ? sliderPosition - cursorPosition
	        : cursorPosition - sliderPosition;
	    var distanceDragged = Math.min(Math.max(0, difference), sliderSize);
	    var percentageDragged = distanceDragged / sliderSize;
	    if (isRtl && !vertical) {
	        percentageDragged = 1 - percentageDragged;
	    }
	    var range = max - min;
	    var steps = getSteps(min, max, step);
	    var value = percentageDragged * range + min;
	    var rounded = nearest(value, minValue, maxValue, steps, range);
	    return {
	        value: rounded,
	        current: percentageDragged,
	    };
	};
	/**
	 * Small util to get the drag percentage for the thumbs within a slider. This
	 * makes sure to use the current `dragValue` when possible so that the thumb
	 * moves with the mouse/touch instead of only for the current values. See
	 * {@link getDragValue} for more examples.
	 *
	 * @remarks \@since 2.5.0
	 * @internal
	 */
	var getDragPercentage = function (_a) {
	    var min = _a.min, max = _a.max, dragging = _a.dragging, dragValue = _a.dragValue, draggingIndex = _a.draggingIndex, thumb1Value = _a.thumb1Value, thumb2Value = _a.thumb2Value;
	    var thumb1Percentage = dragging && draggingIndex === 0
	        ? dragValue
	        : getPercentage({
	            min: min,
	            max: max,
	            value: thumb1Value,
	            validate: false,
	        });
	    var thumb2Percentage;
	    if (typeof thumb2Value === "number") {
	        var percentage = getPercentage({
	            min: min,
	            max: max,
	            value: thumb2Value,
	            validate: false,
	        });
	        thumb1Percentage = Math.min(thumb1Percentage, percentage);
	        thumb2Percentage =
	            dragging && draggingIndex === 1
	                ? Math.max(thumb1Percentage, dragValue)
	                : percentage;
	    }
	    return {
	        thumb1Percentage: "".concat(thumb1Percentage * 100, "%"),
	        thumb2Percentage: typeof thumb2Percentage === "number"
	            ? "".concat(thumb2Percentage * 100, "%")
	            : undefined,
	    };
	};

	var __assign$1d = (undefined && undefined.__assign) || function () {
	    __assign$1d = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1d.apply(this, arguments);
	};
	var __rest$11 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$t = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var VALID_KEYS = [
	    "ArrowDown",
	    "ArrowUp",
	    "ArrowLeft",
	    "ArrowRight",
	    "Home",
	    "End",
	    "PageUp",
	    "PageDown",
	];
	/**
	 * This hook provides all the logic for updating the slider's when the user
	 * interacts with the slider.
	 *
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	function useSliderControls(_a) {
	    var _b, _c;
	    var ref = _a.ref, propThumb1Ref = _a.thumb1Ref, propThumb2Ref = _a.thumb2Ref, min = _a.min, max = _a.max, step = _a.step, _d = _a.disabled, disabled = _d === void 0 ? false : _d, _e = _a.vertical, vertical = _e === void 0 ? false : _e, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onMouseDown = _a.onMouseDown, onTouchStart = _a.onTouchStart, _f = _a.animationDuration, animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f, controls = __rest$11(_a, ["ref", "thumb1Ref", "thumb2Ref", "min", "max", "step", "disabled", "vertical", "onBlur", "onKeyDown", "onMouseDown", "onTouchStart", "animationDuration"]);
	    var trackRef = require$$1.useRef(null);
	    var thumb1Ref = require$$1.useRef(null);
	    var thumb2Ref = require$$1.useRef(null);
	    var _g = __read$t(require$$1.useState(false), 2), dragging = _g[0], setDragging = _g[1];
	    var _h = __read$t(require$$1.useState(min), 2), dragValue = _h[0], setDragValue = _h[1];
	    var _j = __read$t(require$$1.useState(null), 2), draggingBy = _j[0], setDraggingBy = _j[1];
	    var _k = __read$t(require$$1.useState(null), 2), draggingIndex = _k[0], setDraggingIndex = _k[1];
	    var controlsRef = require$$1.useRef(controls);
	    useIsomorphicLayoutEffect(function () {
	        controlsRef.current = controls;
	    });
	    var dir = useDir().dir;
	    var isRtl = dir === "rtl";
	    var thumb1Value;
	    var thumb1Percentage;
	    var thumb2Value;
	    var thumb2Percentage;
	    if (isRangeSlider(controls)) {
	        _b = __read$t(controls.value, 2), thumb1Value = _b[0], thumb2Value = _b[1];
	        (_c = getDragPercentage({
	            min: min,
	            max: max,
	            thumb1Value: thumb1Value,
	            thumb2Value: thumb2Value,
	            dragging: dragging,
	            dragValue: dragValue,
	            draggingIndex: draggingIndex,
	        }), thumb1Percentage = _c.thumb1Percentage, thumb2Percentage = _c.thumb2Percentage);
	    }
	    else {
	        thumb1Value = controls.value;
	        (thumb1Percentage = getDragPercentage({
	            min: min,
	            max: max,
	            thumb1Value: thumb1Value,
	            dragging: dragging,
	            dragValue: dragValue,
	            draggingIndex: draggingIndex,
	        }).thumb1Percentage);
	    }
	    /**
	     * The main handler for updating the value of the slider. To help keep the
	     * drag experience smooth, some values are stored in refs to prevent the
	     * `useEffect` from being run during renders which adds and removes the move
	     * event handlers
	     */
	    var drag = require$$1.useCallback(function (event) {
	        var track = trackRef.current;
	        var slider1 = thumb1Ref.current;
	        var slider2 = thumb2Ref.current;
	        var altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey, shiftKey = event.shiftKey;
	        if (altKey ||
	            ctrlKey ||
	            metaKey ||
	            shiftKey ||
	            disabled ||
	            !track ||
	            !slider1 ||
	            (isMouseEvent(event) && event.button !== 0) ||
	            (isTouchEvent(event) && event.changedTouches.length !== 1) ||
	            (!isMouseEvent(event) && !isTouchEvent(event))) {
	            return;
	        }
	        // prevent text from being highlighted on desktop or the page from
	        // scrolling on mobile while dragging
	        if (!isTouchEvent(event) || event.type === "touchmove") {
	            event.preventDefault();
	        }
	        event.stopPropagation();
	        // get the current mouse/touch position to help determine hwo far the
	        // slider is being dragged
	        var clientX;
	        var clientY;
	        if (isMouseEvent(event)) {
	            (clientX = event.clientX, clientY = event.clientY);
	        }
	        else {
	            var touch = event.changedTouches[0];
	            (clientX = touch.clientX, clientY = touch.clientY);
	        }
	        var index = 0;
	        var slider = slider1;
	        if (slider2) {
	            // if we aren't dragging yet, try to find the slider closest to the
	            // mouse/touch position and use that one
	            if (draggingIndex === null) {
	                var x1 = slider1.getBoundingClientRect().x;
	                var x2 = slider2.getBoundingClientRect().x;
	                var y1 = slider1.getBoundingClientRect().y;
	                var y2 = slider2.getBoundingClientRect().y;
	                if (vertical) {
	                    index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;
	                }
	                else {
	                    index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;
	                }
	            }
	            else {
	                index = draggingIndex;
	            }
	            slider = index === 0 ? slider1 : slider2;
	        }
	        // if we aren't dragging yet, want to focus the slider element to make it
	        // easier to switch between mouse dragging and keyboard "dragging"
	        if (draggingIndex !== index) {
	            slider.focus();
	            setDraggingIndex(index);
	        }
	        setDraggingBy(isMouseEvent(event) ? "mouse" : "touch");
	        var _a = track.getBoundingClientRect(), left = _a.left, top = _a.top, height = _a.height, width = _a.width;
	        var options = {
	            min: min,
	            max: max,
	            step: step,
	            vertical: vertical,
	            clientX: clientX,
	            clientY: clientY,
	            left: left,
	            top: top,
	            height: height,
	            width: width,
	            isRtl: isRtl,
	            minValue: min,
	            maxValue: max,
	        };
	        var controls = controlsRef.current;
	        if (isRangeSlider(controls)) {
	            var _b = __read$t(controls.value, 2), thumb1Value_1 = _b[0], thumb2Value_1 = _b[1];
	            var _c = getDragValue(__assign$1d(__assign$1d({}, options), { minValue: index === 0 ? min : thumb1Value_1 + step, maxValue: index === 1 ? max : thumb2Value_1 - step })), value = _c.value, current = _c.current;
	            setDragValue(current);
	            controls.setValue(index === 0 ? [value, thumb2Value_1] : [thumb1Value_1, value]);
	        }
	        else {
	            var _d = getDragValue(options), value = _d.value, current = _d.current;
	            setDragValue(current);
	            controls.setValue(value);
	        }
	    }, [disabled, isRtl, draggingIndex, max, min, step, vertical]);
	    var stop = require$$1.useCallback(function () {
	        controlsRef.current.persist();
	        setDragging(false);
	        setDraggingIndex(null);
	        setDraggingBy(null);
	    }, []);
	    require$$1.useEffect(function () {
	        if (draggingBy === null) {
	            return;
	        }
	        if (draggingBy === "mouse") {
	            window.addEventListener("mousemove", drag);
	            window.addEventListener("mouseup", stop);
	        }
	        else {
	            window.addEventListener("touchmove", drag, { passive: false });
	            window.addEventListener("touchend", stop);
	        }
	        return function () {
	            if (draggingBy === "mouse") {
	                window.removeEventListener("mousemove", drag);
	                window.removeEventListener("mouseup", stop);
	            }
	            else {
	                window.removeEventListener("touchmove", drag);
	                window.removeEventListener("touchend", stop);
	            }
	        };
	    }, [draggingBy, drag, stop]);
	    require$$1.useEffect(function () {
	        if (draggingIndex === null && draggingBy === null) {
	            return;
	        }
	        // I don't know how to reach this flow.. so maybe can be removed?
	        /* istanbul ignore if */
	        if (draggingIndex === null) {
	            setDragging(false);
	            return;
	        }
	        var timeout = window.setTimeout(function () {
	            setDragging(true);
	        }, animationDuration);
	        return function () {
	            window.clearTimeout(timeout);
	        };
	    }, [draggingIndex, draggingBy, animationDuration]);
	    var handleBlur = require$$1.useCallback(function (event) {
	        if (onBlur) {
	            onBlur(event);
	        }
	        controlsRef.current.persist();
	    }, [onBlur]);
	    /**
	     * Note: this should be attached to the `SliderTrack` component.
	     */
	    var handleMouseDown = require$$1.useCallback(function (event) {
	        if (onMouseDown) {
	            onMouseDown(event);
	        }
	        // only call drag again when the dragging by isn't null since it can cause
	        // the "drag" events to be re-started if the mouse appears over the slider
	        // thumb again
	        if (draggingBy === null) {
	            drag(event);
	        }
	    }, [drag, draggingBy, onMouseDown]);
	    /**
	     * Note: this should be attached to the `SliderTrack` component.
	     */
	    var handleTouchStart = require$$1.useCallback(function (event) {
	        if (onTouchStart) {
	            onTouchStart(event);
	        }
	        // only call drag again when the dragging by isn't null since it can cause
	        // the "drag" events to be re-started if the user's finger appears over
	        // the slider thumb again
	        if (draggingBy === null) {
	            drag(event);
	        }
	    }, [drag, draggingBy, onTouchStart]);
	    /**
	     * Note: this should be attached to each `SliderThumb` component.
	     */
	    var handleKeyDown = require$$1.useCallback(function (event) {
	        if (onKeyDown) {
	            onKeyDown(event);
	        }
	        var key = event.key, altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey, shiftKey = event.shiftKey;
	        if (altKey ||
	            ctrlKey ||
	            metaKey ||
	            shiftKey ||
	            disabled ||
	            !VALID_KEYS.includes(key)) {
	            return;
	        }
	        var controls;
	        if (isRangeSlider(controlsRef.current)) {
	            var _a = controlsRef.current, increment_1 = _a.increment, incrementJump_1 = _a.incrementJump, decrement_1 = _a.decrement, decrementJump_1 = _a.decrementJump, minimum_1 = _a.minimum, maximum_1 = _a.maximum;
	            var index = event.currentTarget === thumb2Ref.current ? 1 : 0;
	            controls = {
	                increment: increment_1.bind(null, index),
	                incrementJump: incrementJump_1.bind(null, index),
	                decrement: decrement_1.bind(null, index),
	                decrementJump: decrementJump_1.bind(null, index),
	                minimum: minimum_1.bind(null, index),
	                maximum: maximum_1.bind(null, index),
	            };
	        }
	        else {
	            controls = controlsRef.current;
	        }
	        var increment = controls.increment, incrementJump = controls.incrementJump, decrement = controls.decrement, decrementJump = controls.decrementJump, minimum = controls.minimum, maximum = controls.maximum;
	        event.preventDefault();
	        event.stopPropagation();
	        switch (key) {
	            case "ArrowUp":
	            case "ArrowRight":
	                increment();
	                break;
	            case "ArrowDown":
	            case "ArrowLeft":
	                decrement();
	                break;
	            case "Home":
	                minimum();
	                break;
	            case "End":
	                maximum();
	                break;
	            case "PageUp":
	                incrementJump();
	                break;
	            case "PageDown":
	                decrementJump();
	                break;
	        }
	    }, [onKeyDown, disabled]);
	    var trackRefHandler = require$$1.useCallback(function (instance) {
	        applyRef(instance, ref);
	        trackRef.current = instance;
	    }, [ref]);
	    var thumb1RefHandler = require$$1.useCallback(function (instance) {
	        applyRef(instance, propThumb1Ref);
	        thumb1Ref.current = instance;
	    }, [propThumb1Ref]);
	    var thumb2RefHandler = require$$1.useCallback(function (instance) {
	        applyRef(instance, propThumb2Ref);
	        thumb2Ref.current = instance;
	    }, [propThumb2Ref]);
	    return {
	        thumb1Ref: thumb1RefHandler,
	        thumb1Value: thumb1Value,
	        thumb1Percentage: thumb1Percentage,
	        thumb2Ref: thumb2RefHandler,
	        thumb2Value: thumb2Value,
	        thumb2Percentage: thumb2Percentage,
	        dragging: dragging,
	        draggingIndex: draggingIndex,
	        ref: trackRefHandler,
	        onBlur: handleBlur,
	        onKeyDown: handleKeyDown,
	        onMouseDown: handleMouseDown,
	        onTouchStart: handleTouchStart,
	    };
	}

	var __assign$1c = (undefined && undefined.__assign) || function () {
	    __assign$1c = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1c.apply(this, arguments);
	};
	var __rest$10 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `Slider` component allows the user to select a single value from a range
	 * of numbers. The functionality for controlling the value of this component is
	 * provided by the `useSlider` hook.
	 *
	 * @remarks \@since 2.5.0
	 */
	var Slider = require$$1.forwardRef(function Slider(_a, ref) {
	    var baseId = _a.baseId, propTrackProps = _a.trackProps, label = _a.label, labelProps = _a.labelProps, thumbLabel = _a.thumbLabel, thumbLabelledBy = _a.thumbLabelledBy, thumbProps = _a.thumbProps, min = _a.min, max = _a.max, step = _a.step, _b = _a.discrete, discrete = _b === void 0 ? false : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, _d = _a.vertical, vertical = _d === void 0 ? false : _d, onBlur = _a.onBlur, onMouseDown = _a.onMouseDown, onTouchStart = _a.onTouchStart, _e = _a.getValueText, getValueText = _e === void 0 ? DEFAULT_SLIDER_GET_VALUE_TEXT : _e, _f = _a.animationDuration, animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f, value = _a.value, minimum = _a.minimum, maximum = _a.maximum, increment = _a.increment, incrementJump = _a.incrementJump, decrement = _a.decrement, decrementJump = _a.decrementJump, persist = _a.persist, setValue = _a.setValue, props = __rest$10(_a, ["baseId", "trackProps", "label", "labelProps", "thumbLabel", "thumbLabelledBy", "thumbProps", "min", "max", "step", "discrete", "disabled", "vertical", "onBlur", "onMouseDown", "onTouchStart", "getValueText", "animationDuration", "value", "minimum", "maximum", "increment", "incrementJump", "decrement", "decrementJump", "persist", "setValue"]);
	    var _g = useSliderControls({
	        ref: propTrackProps === null || propTrackProps === void 0 ? void 0 : propTrackProps.ref,
	        thumb1Ref: thumbProps === null || thumbProps === void 0 ? void 0 : thumbProps.ref,
	        min: min,
	        max: max,
	        step: step,
	        value: value,
	        disabled: disabled,
	        vertical: vertical,
	        onBlur: onBlur,
	        onKeyDown: thumbProps === null || thumbProps === void 0 ? void 0 : thumbProps.onKeyDown,
	        onMouseDown: onMouseDown,
	        onTouchStart: onTouchStart,
	        animationDuration: animationDuration,
	        minimum: minimum,
	        maximum: maximum,
	        increment: increment,
	        incrementJump: incrementJump,
	        decrement: decrement,
	        decrementJump: decrementJump,
	        persist: persist,
	        setValue: setValue,
	    }), thumb1Ref = _g.thumb1Ref, thumb1Value = _g.thumb1Value; _g.thumb2Ref; _g.thumb2Value; var dragging = _g.dragging, draggingIndex = _g.draggingIndex, onKeyDown = _g.onKeyDown, trackProps = __rest$10(_g, ["thumb1Ref", "thumb1Value", "thumb2Ref", "thumb2Value", "dragging", "draggingIndex", "onKeyDown"]);
	    var labelId = "";
	    if (label) {
	        labelId = (labelProps === null || labelProps === void 0 ? void 0 : labelProps.id) || "".concat(baseId, "-label");
	    }
	    return (jsxRuntime.exports.jsx(SliderContainer, __assign$1c({}, props, { ref: ref, label: label, labelId: labelId, labelProps: labelProps, disabled: disabled, vertical: vertical }, { children: jsxRuntime.exports.jsx(SliderTrack, __assign$1c({ id: baseId }, propTrackProps, trackProps, { animate: !dragging, disabled: disabled, vertical: vertical }, { children: jsxRuntime.exports.jsx(SliderThumb, __assign$1c({}, thumbProps, { "aria-label": thumbLabel, "aria-labelledby": thumbLabelledBy || labelId, baseId: baseId, ref: thumb1Ref, getValueText: getValueText, min: min, max: max, discrete: discrete, disabled: disabled, vertical: vertical, animate: !dragging, animationDuration: animationDuration, value: thumb1Value, index: 0, active: draggingIndex === 0, onKeyDown: onKeyDown })) })) })));
	});

	var __assign$1b = (undefined && undefined.__assign) || function () {
	    __assign$1b = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1b.apply(this, arguments);
	};
	var __rest$$ = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `RangeSlider` component allows the user to select a min and max value from
	 * a predefined range of numbers. The functionality for controlling the value of
	 * this component is provided by the `useRangeSlider` hook.
	 *
	 * @remarks \@since 2.5.0
	 */
	var RangeSlider = require$$1.forwardRef(function RangeSlider(_a, ref) {
	    var baseId = _a.baseId, min = _a.min, max = _a.max, step = _a.step, _b = _a.discrete, discrete = _b === void 0 ? false : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, _d = _a.vertical, vertical = _d === void 0 ? false : _d, label = _a.label, labelProps = _a.labelProps, propTrackProps = _a.trackProps, onBlur = _a.onBlur, onMouseDown = _a.onMouseDown, onTouchStart = _a.onTouchStart, _e = _a.getValueText, getValueText = _e === void 0 ? DEFAULT_SLIDER_GET_VALUE_TEXT : _e, _f = _a.animationDuration, animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f, value = _a.value, minimum = _a.minimum, maximum = _a.maximum, increment = _a.increment, incrementJump = _a.incrementJump, decrement = _a.decrement, decrementJump = _a.decrementJump, persist = _a.persist, setValue = _a.setValue, thumb1Props = _a.thumb1Props, _g = _a.thumb1Label, thumb1Label = _g === void 0 ? "Min" : _g, thumb1LabelledBy = _a.thumb1LabelledBy, thumb2Props = _a.thumb2Props, _h = _a.thumb2Label, thumb2Label = _h === void 0 ? "Max" : _h, thumb2LabelledBy = _a.thumb2LabelledBy, props = __rest$$(_a, ["baseId", "min", "max", "step", "discrete", "disabled", "vertical", "label", "labelProps", "trackProps", "onBlur", "onMouseDown", "onTouchStart", "getValueText", "animationDuration", "value", "minimum", "maximum", "increment", "incrementJump", "decrement", "decrementJump", "persist", "setValue", "thumb1Props", "thumb1Label", "thumb1LabelledBy", "thumb2Props", "thumb2Label", "thumb2LabelledBy"]);
	    var _j = useSliderControls({
	        ref: propTrackProps === null || propTrackProps === void 0 ? void 0 : propTrackProps.ref,
	        thumb1Ref: thumb1Props === null || thumb1Props === void 0 ? void 0 : thumb1Props.ref,
	        thumb2Ref: thumb2Props === null || thumb2Props === void 0 ? void 0 : thumb2Props.ref,
	        min: min,
	        max: max,
	        step: step,
	        value: value,
	        disabled: disabled,
	        vertical: vertical,
	        onBlur: onBlur,
	        onMouseDown: onMouseDown,
	        onTouchStart: onTouchStart,
	        animationDuration: animationDuration,
	        minimum: minimum,
	        maximum: maximum,
	        increment: increment,
	        incrementJump: incrementJump,
	        decrement: decrement,
	        decrementJump: decrementJump,
	        persist: persist,
	        setValue: setValue,
	    }), thumb1Ref = _j.thumb1Ref, thumb1Value = _j.thumb1Value, thumb2Ref = _j.thumb2Ref, thumb2Value = _j.thumb2Value, dragging = _j.dragging, draggingIndex = _j.draggingIndex, onKeyDown = _j.onKeyDown, trackProps = __rest$$(_j, ["thumb1Ref", "thumb1Value", "thumb2Ref", "thumb2Value", "dragging", "draggingIndex", "onKeyDown"]);
	    var thumb1KeyDown = require$$1.useCallback(function (event) {
	        if (thumb1Props === null || thumb1Props === void 0 ? void 0 : thumb1Props.onKeyDown) {
	            thumb1Props.onKeyDown(event);
	        }
	        onKeyDown(event);
	    }, [thumb1Props, onKeyDown]);
	    var thumb2KeyDown = require$$1.useCallback(function (event) {
	        if (thumb2Props === null || thumb2Props === void 0 ? void 0 : thumb2Props.onKeyDown) {
	            thumb2Props.onKeyDown(event);
	        }
	        onKeyDown(event);
	    }, [thumb2Props, onKeyDown]);
	    var thumbProps = {
	        baseId: baseId,
	        min: min,
	        max: max,
	        discrete: discrete,
	        disabled: disabled,
	        vertical: vertical,
	        animate: !dragging,
	        animationDuration: animationDuration,
	        getValueText: getValueText,
	    };
	    var labelId = "";
	    if (label) {
	        labelId = (labelProps === null || labelProps === void 0 ? void 0 : labelProps.id) || "".concat(baseId, "-label");
	    }
	    return (jsxRuntime.exports.jsx(SliderContainer, __assign$1b({}, props, { ref: ref, label: label, labelId: labelId, labelProps: labelProps, disabled: disabled, vertical: vertical }, { children: jsxRuntime.exports.jsxs(SliderTrack, __assign$1b({ id: baseId }, propTrackProps, trackProps, { animate: !dragging, disabled: disabled, vertical: vertical }, { children: [jsxRuntime.exports.jsx(SliderThumb, __assign$1b({ "aria-label": thumb1Label, "aria-labelledby": thumb1LabelledBy }, thumb1Props, thumbProps, { ref: thumb1Ref, value: thumb1Value, index: 0, active: draggingIndex === 0, onKeyDown: thumb1KeyDown })), jsxRuntime.exports.jsx(SliderThumb, __assign$1b({ "aria-label": thumb2Label, "aria-labelledby": thumb2LabelledBy }, thumb2Props, thumbProps, { ref: thumb2Ref, value: thumb2Value, index: 1, active: draggingIndex === 1, onKeyDown: thumb2KeyDown }))] })) })));
	});

	var __read$s = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var noop$4 = function () {
	    // do nothing
	};
	/**
	 * This hook is used to control the value and behavior of the `Slider`
	 * component. The first argument will contain the current slider value while
	 * the second argument will be all the props required to control the `Slider`
	 * component.
	 *
	 * @param defaultValue - An optional default value to use for the slider. This
	 * will default to the `min` option when undefined.
	 * @param options - An object containing the `min` and `max` values allowed for
	 * the slider as well as a `step` to indicate valid values between the `min` and
	 * `max`.
	 * @returns an ordered list containing the current value followed by the
	 * `Slider` props
	 * @remarks \@since 2.5.0
	 */
	function useSlider(defaultValue, _a) {
	    var _b = _a === void 0 ? {} : _a, _c = _b.min, min = _c === void 0 ? DEFAULT_SLIDER_MIN : _c, _d = _b.max, max = _d === void 0 ? DEFAULT_SLIDER_MAX : _d, _e = _b.step, step = _e === void 0 ? DEFAULT_SLIDER_STEP : _e, propJump = _b.jump, _f = _b.updateOn, updateOn = _f === void 0 ? "change" : _f, _g = _b.onChange, onChange = _g === void 0 ? noop$4 : _g;
	    var jump = require$$1.useMemo(function () { return getJumpValue(min, max, step, propJump); }, [min, max, step, propJump]);
	    // since the `currentValue` is a ref, this state is used to force a re-render
	    // to get the updated value from the ref.
	    var _h = __read$s(require$$1.useState([]), 2), hack = _h[1];
	    var _j = __read$s(require$$1.useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : min), 2), value = _j[0], setValue = _j[1];
	    var currentValue = require$$1.useRef(value);
	    var increment = require$$1.useCallback(function () {
	        setValue(function (prevValue) { return Math.max(min, Math.min(max, prevValue + step)); });
	    }, [min, max, step]);
	    var incrementJump = require$$1.useCallback(function () {
	        setValue(function (prevValue) { return Math.max(min, Math.min(max, prevValue + jump)); });
	    }, [min, max, jump]);
	    var decrement = require$$1.useCallback(function () {
	        setValue(function (prevValue) { return Math.max(min, Math.min(max, prevValue - step)); });
	    }, [min, max, step]);
	    var decrementJump = require$$1.useCallback(function () {
	        setValue(function (prevValue) { return Math.max(min, Math.min(max, prevValue - jump)); });
	    }, [min, max, jump]);
	    var minimum = require$$1.useCallback(function () {
	        setValue(min);
	    }, [min]);
	    var maximum = require$$1.useCallback(function () {
	        setValue(max);
	    }, [max]);
	    var persist = require$$1.useCallback(function () {
	        if (currentValue.current === value) {
	            return;
	        }
	        onChange(value);
	        currentValue.current = value;
	        hack([]);
	    }, [onChange, value]);
	    var prev = require$$1.useRef({ min: min, max: max, step: step });
	    require$$1.useEffect(function () {
	        if (prev.current.min !== min ||
	            prev.current.max !== max ||
	            prev.current.step !== step) {
	            // ensure that if the `min`, `max`, or `step` value changes that the value
	            // is updated as well. Without this, there will be a runtime error if the
	            // value is not within the new range.
	            prev.current = { min: min, max: max, step: step };
	            var nextValue = nearest(value, min, max, getSteps(min, max, step));
	            currentValue.current = nextValue;
	            setValue(nextValue);
	        }
	    }, [min, max, step, value]);
	    if (updateOn === "change" && currentValue.current !== value) {
	        currentValue.current = value;
	    }
	    return [
	        currentValue.current,
	        {
	            min: min,
	            max: max,
	            step: step,
	            value: value,
	            increment: increment,
	            incrementJump: incrementJump,
	            decrement: decrement,
	            decrementJump: decrementJump,
	            minimum: minimum,
	            maximum: maximum,
	            persist: persist,
	            setValue: setValue,
	        },
	    ];
	}

	var __read$r = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var noop$3 = function () {
	    // do nothing
	};
	/**
	 * This hook is used to control the value and behavior of the `RangeSlider`
	 * component. The first argument will contain the current slider value while the
	 * second argument will be all the props required to control the `RangeSlider`
	 * component.
	 *
	 * @param defaultValue - An optional default value to use. When omitted, this
	 * will be the `[min, max]` values
	 * @param options - An object containing the `min` and `max` values allowed for
	 * the slider as well as a `step` to indicate valid values between the `min` and
	 * `max`.
	 * @returns an ordered list containing the current value followed by the
	 * `RangeSlider` props
	 * @remarks \@since 2.5.0
	 */
	function useRangeSlider(defaultValue, _a) {
	    var _b = _a === void 0 ? {} : _a, _c = _b.min, min = _c === void 0 ? DEFAULT_SLIDER_MIN : _c, _d = _b.max, max = _d === void 0 ? DEFAULT_SLIDER_MAX : _d, _e = _b.step, step = _e === void 0 ? DEFAULT_SLIDER_STEP : _e, propJump = _b.jump, _f = _b.updateOn, updateOn = _f === void 0 ? "change" : _f, _g = _b.onChange, onChange = _g === void 0 ? noop$3 : _g;
	    var jump = require$$1.useMemo(function () { return getJumpValue(min, max, step, propJump); }, [min, max, step, propJump]);
	    // since the `currentValue` is a ref, this state is used to force a re-render
	    // to get the updated value from the ref.
	    var _h = __read$r(require$$1.useState([]), 2), hack = _h[1];
	    var _j = __read$r(require$$1.useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : [min, max]), 2), value = _j[0], setValue = _j[1];
	    var currentValue = require$$1.useRef(value);
	    var update = require$$1.useCallback(function (_a) {
	        var index = _a.index, type = _a.type;
	        setValue(function (_a) {
	            var _b = __read$r(_a, 2), thumb1Value = _b[0], thumb2Value = _b[1];
	            var value;
	            var minValue = min;
	            var maxValue = max;
	            if (index === 0) {
	                value = thumb1Value;
	                maxValue = thumb2Value - step;
	            }
	            else {
	                value = thumb2Value;
	                minValue = thumb1Value + step;
	            }
	            switch (type) {
	                case "min":
	                    value = minValue;
	                    break;
	                case "max":
	                    value = maxValue;
	                    break;
	                case "increment":
	                    value += step;
	                    break;
	                case "decrement":
	                    value -= step;
	                    break;
	                case "increment-jump":
	                    value += jump;
	                    break;
	                case "decrement-jump":
	                    value -= jump;
	                    break;
	            }
	            value = Math.max(minValue, Math.min(maxValue, value));
	            return index === 0 ? [value, thumb2Value] : [thumb1Value, value];
	        });
	    }, [jump, max, min, step]);
	    var increment = require$$1.useCallback(function (index) { return update({ index: index, type: "increment" }); }, [update]);
	    var incrementJump = require$$1.useCallback(function (index) { return update({ index: index, type: "increment-jump" }); }, [update]);
	    var decrement = require$$1.useCallback(function (index) { return update({ index: index, type: "decrement" }); }, [update]);
	    var decrementJump = require$$1.useCallback(function (index) { return update({ index: index, type: "decrement-jump" }); }, [update]);
	    var minimum = require$$1.useCallback(function (index) { return update({ index: index, type: "min" }); }, [update]);
	    var maximum = require$$1.useCallback(function (index) { return update({ index: index, type: "max" }); }, [update]);
	    var persist = require$$1.useCallback(function () {
	        var _a = __read$r(currentValue.current, 2), prev1 = _a[0], prev2 = _a[1];
	        if (prev1 === value[0] && prev2 === value[1]) {
	            return;
	        }
	        onChange(value);
	        currentValue.current = value;
	        hack([]);
	    }, [onChange, value]);
	    var prev = require$$1.useRef({ min: min, max: max, step: step });
	    require$$1.useEffect(function () {
	        if (prev.current.min !== min ||
	            prev.current.max !== max ||
	            prev.current.step !== step) {
	            // ensure that if the `min`, `max`, or `step` value changes that the value
	            // is updated as well. Without this, there will be a runtime error if the
	            // value is not within the new range.
	            prev.current = { min: min, max: max, step: step };
	            var steps = getSteps(min, max, step);
	            var nextValue = [
	                nearest(value[0], min, max, steps),
	                nearest(value[1], min, max, steps),
	            ];
	            currentValue.current = nextValue;
	            setValue(nextValue);
	        }
	    }, [min, max, step, value]);
	    if (updateOn === "change" && currentValue.current !== value) {
	        currentValue.current = value;
	    }
	    return [
	        currentValue.current,
	        {
	            min: min,
	            max: max,
	            step: step,
	            value: value,
	            minimum: minimum,
	            maximum: maximum,
	            increment: increment,
	            incrementJump: incrementJump,
	            decrement: decrement,
	            decrementJump: decrementJump,
	            persist: persist,
	            setValue: setValue,
	        },
	    ];
	}

	var __assign$1a = (undefined && undefined.__assign) || function () {
	    __assign$1a = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1a.apply(this, arguments);
	};
	var __rest$_ = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$q = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var block$y = bem("rmd-password");
	function isConfigurableIcon(icon) {
	    return !!icon && !require$$1.isValidElement(icon);
	}
	/**
	 * This component is a simple wrapper of the `TextField` that can only be
	 * rendered for password inputs. There is built-in functionality to be able to
	 * temporarily show the password's value by swapping the `type` to `"text"`.
	 */
	var Password = require$$1.forwardRef(function Password(_a, ref) {
	    var className = _a.className, inputClassName = _a.inputClassName, propVisibilityIcon = _a.visibilityIcon, visibilityStyle = _a.visibilityStyle, visibilityClassName = _a.visibilityClassName, _b = _a.visibilityLabel, visibilityLabel = _b === void 0 ? "Show password" : _b, onVisibilityClick = _a.onVisibilityClick, getVisibilityIcon = _a.getVisibilityIcon, _c = _a.disableVisibility, disableVisibility = _c === void 0 ? false : _c, propRightChildren = _a.rightChildren, _d = _a.isRightAddon, isRightAddon = _d === void 0 ? disableVisibility : _d, props = __rest$_(_a, ["className", "inputClassName", "visibilityIcon", "visibilityStyle", "visibilityClassName", "visibilityLabel", "onVisibilityClick", "getVisibilityIcon", "disableVisibility", "rightChildren", "isRightAddon"]);
	    var id = props.id;
	    var _e = __read$q(require$$1.useState("password"), 2), type = _e[0], setType = _e[1];
	    var toggle = require$$1.useCallback(function (event) {
	        if (onVisibilityClick) {
	            onVisibilityClick(event);
	        }
	        setType(function (prevType) { return (prevType === "password" ? "text" : "password"); });
	    }, [onVisibilityClick]);
	    var visible = type === "text";
	    var visibilityIcon = useIcon("password", propVisibilityIcon);
	    if (isConfigurableIcon(propVisibilityIcon)) {
	        visibilityIcon = visible
	            ? propVisibilityIcon.visible
	            : propVisibilityIcon.invisible;
	    }
	    var rightChildren = propRightChildren;
	    if (!disableVisibility) {
	        rightChildren = (jsxRuntime.exports.jsx(Button, __assign$1a({ id: "".concat(id, "-password-toggle"), "aria-label": visibilityLabel, "aria-pressed": visible, buttonType: "icon", onClick: toggle, style: visibilityStyle, className: cn(block$y("toggle"), visibilityClassName) }, { children: typeof getVisibilityIcon === "function"
	                ? getVisibilityIcon(type)
	                : visibilityIcon })));
	    }
	    return (jsxRuntime.exports.jsx(TextField, __assign$1a({}, props, { className: cn(block$y({ offset: !disableVisibility }), className), inputClassName: cn(block$y("input", { offset: !disableVisibility }), inputClassName), ref: ref, type: type, isRightAddon: isRightAddon, rightChildren: rightChildren })));
	});

	var __assign$19 = (undefined && undefined.__assign) || function () {
	    __assign$19 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$19.apply(this, arguments);
	};
	var __rest$Z = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$p = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var block$x = bem("rmd-textarea");
	var container = bem("rmd-textarea-container");
	var PADDING_VARIABLES = "var(--rmd-form-text-padding-top, 0px) + var(--rmd-form-textarea-padding, 0px)";
	// this is the default of 1.5rem line-height in the styles
	var DEFAULT_LINE_HEIGHT = "24";
	var TextArea = require$$1.forwardRef(function TextArea(_a, forwardedRef) {
	    var style = _a.style, className = _a.className, areaStyle = _a.areaStyle, areaClassName = _a.areaClassName, containerRef = _a.containerRef, containerProps = _a.containerProps, label = _a.label, labelStyle = _a.labelStyle, labelClassName = _a.labelClassName, _b = _a.rows, rows = _b === void 0 ? 2 : _b, _c = _a.maxRows, maxRows = _c === void 0 ? -1 : _c, _d = _a.resize, resize = _d === void 0 ? "auto" : _d, propTheme = _a.theme, _e = _a.dense, dense = _e === void 0 ? false : _e, _f = _a.inline, propInline = _f === void 0 ? false : _f, _g = _a.error, error = _g === void 0 ? false : _g, _h = _a.stretch, stretch = _h === void 0 ? false : _h, _j = _a.disabled, disabled = _j === void 0 ? false : _j, _k = _a.animate, animate = _k === void 0 ? true : _k, _l = _a.isLeftAddon, isLeftAddon = _l === void 0 ? true : _l, _m = _a.isRightAddon, isRightAddon = _m === void 0 ? true : _m, propUnderlineDirection = _a.underlineDirection, propOnBlur = _a.onBlur, propOnFocus = _a.onFocus, propOnChange = _a.onChange, leftChildren = _a.leftChildren, rightChildren = _a.rightChildren, props = __rest$Z(_a, ["style", "className", "areaStyle", "areaClassName", "containerRef", "containerProps", "label", "labelStyle", "labelClassName", "rows", "maxRows", "resize", "theme", "dense", "inline", "error", "stretch", "disabled", "animate", "isLeftAddon", "isRightAddon", "underlineDirection", "onBlur", "onFocus", "onChange", "leftChildren", "rightChildren"]);
	    var id = props.id, value = props.value, defaultValue = props.defaultValue;
	    var _o = useFormTheme({
	        theme: propTheme,
	        underlineDirection: propUnderlineDirection,
	    }), theme = _o.theme, underlineDirection = _o.underlineDirection;
	    var _p = __read$p(require$$1.useState(), 2), height = _p[0], setHeight = _p[1];
	    require$$1.useEffect(function () {
	        if (resize !== "auto" && typeof height === "number") {
	            setHeight(undefined);
	        }
	    }, [resize, height]);
	    var maskRef = require$$1.useRef(null);
	    var _q = __read$p(require$$1.useState(false), 2), scrollable = _q[0], setScrollable = _q[1];
	    var updateHeight = require$$1.useCallback(function () {
	        var mask = maskRef.current;
	        /* istanbul ignore if */
	        if (!mask) {
	            return;
	        }
	        var nextHeight = mask.scrollHeight;
	        /* istanbul ignore if */
	        if (maxRows > 0) {
	            var lineHeight = parseFloat(window.getComputedStyle(mask).lineHeight || DEFAULT_LINE_HEIGHT);
	            var maxHeight = maxRows * lineHeight;
	            nextHeight = Math.min(maxHeight, nextHeight);
	            // only want the textarea to be scrollable if there's a limit on the rows
	            // since it'll flash the scrollbar on most OS during the height transition
	            if (nextHeight === maxHeight && !scrollable) {
	                setScrollable(true);
	            }
	            else if (nextHeight !== maxHeight && scrollable) {
	                setScrollable(false);
	            }
	        }
	        if (height !== nextHeight) {
	            setHeight(nextHeight);
	        }
	    }, [height, maxRows, scrollable]);
	    // the window can be resized while there is text inside the textarea so need to
	    // recalculate the height when the width changes as well.
	    var _r = __read$p(useResizeObserver(updateHeight, {
	        ref: maskRef,
	        disableHeight: true,
	    }), 2), maskRefHandler = _r[1];
	    var _s = useFieldStates({
	        onBlur: propOnBlur,
	        onFocus: propOnFocus,
	        onChange: function (event) {
	            var mask = maskRef.current;
	            if (propOnChange) {
	                propOnChange(event);
	            }
	            /* istanbul ignore if */
	            if (!mask || resize !== "auto") {
	                return;
	            }
	            // to get the height transition to work, you have to set the height on:
	            // - the main container element (including padding) that has the height
	            //    transition enabled
	            // - a child div wrapper (without padding) that has the height transition
	            //    enabled
	            // - the textarea element (without padding) and without a height transition
	            //
	            // if it isn't done this way, the height transition will look weird since
	            // the text will be fixed to the bottom of the area and more text at the top
	            // will become visible as the height transition completes. applying the
	            // transition on the two parent elements work because:
	            // - the height is set immediately on the text field so it expands to show all
	            //    the text
	            // - the height is correctly applied to both parent elements, but their height
	            //    haven't fully been adjusted due to the animation
	            // - the parent divs have overflow visible by default, so the textarea's text
	            //    will expand past the boundaries of the divs and not cause the upwards
	            //    animation weirdness.
	            mask.value = event.currentTarget.value;
	            updateHeight();
	        },
	        value: value,
	        defaultValue: defaultValue,
	    }), valued = _s.valued, focused = _s.focused, onBlur = _s.onBlur, onFocus = _s.onFocus, onChange = _s.onChange;
	    var _t = __read$p(useEnsuredRef(forwardedRef), 2), ref = _t[0], refHandler = _t[1];
	    // the container element adds some padding so that the content can scroll and
	    // not be covered by the floating label. unfortunately, this means that the entire
	    // container is no longer clickable to focus the input. This is used to add that
	    // functionality back.
	    var handleClick = require$$1.useCallback(function (event) {
	        if (ref.current && event.target === event.currentTarget) {
	            ref.current.focus();
	        }
	    }, [ref]);
	    var area = (jsxRuntime.exports.jsx("textarea", __assign$19({}, props, { ref: refHandler, rows: rows, disabled: disabled, onFocus: onFocus, onBlur: onBlur, onChange: onChange, style: __assign$19(__assign$19({}, areaStyle), { height: height !== null && height !== void 0 ? height : areaStyle === null || areaStyle === void 0 ? void 0 : areaStyle.height }), className: cn(block$x({
	            scrollable: scrollable || resize === "none",
	            floating: label && theme !== "none",
	            rh: resize === "horizontal",
	            rv: resize === "vertical",
	            rn: resize === "auto" || resize === "none",
	        }), areaClassName) })));
	    var children = area;
	    if (resize === "auto") {
	        children = (jsxRuntime.exports.jsxs("div", __assign$19({ style: { height: height }, className: container("inner", { animate: animate }) }, { children: [area, jsxRuntime.exports.jsx("textarea", { "aria-hidden": true, defaultValue: value || defaultValue, id: "".concat(id, "-mask"), ref: maskRefHandler, readOnly: true, rows: rows, tabIndex: -1, style: areaStyle, className: cn(block$x({
	                        rn: true,
	                        mask: true,
	                        floating: label && theme !== "none",
	                    }), areaClassName) })] })));
	    }
	    var inline = propInline;
	    if (resize === "horizontal" || resize === "both") {
	        // have to force it inline or else you won't be able to resize
	        // it horizontally.
	        inline = true;
	    }
	    return (jsxRuntime.exports.jsxs(TextFieldContainer, __assign$19({}, containerProps, { style: __assign$19(__assign$19({}, style), { height: height
	                ? "calc(".concat(PADDING_VARIABLES, " + ").concat(height, "px)")
	                : style === null || style === void 0 ? void 0 : style.height }), className: cn(container({
	            animate: animate && resize === "auto",
	            cursor: !disabled,
	        }), className), ref: containerRef, theme: theme, error: error, active: focused, label: !!label, dense: dense, inline: inline, stretch: stretch, disabled: disabled, isLeftAddon: isLeftAddon, isRightAddon: isRightAddon, leftChildren: leftChildren, rightChildren: rightChildren, underlineDirection: underlineDirection, onClick: !disabled ? handleClick : undefined }, { children: [jsxRuntime.exports.jsx(FloatingLabel, __assign$19({ style: labelStyle, className: labelClassName, htmlFor: id, error: error, active: focused, floating: focused || valued, valued: valued, dense: dense, disabled: disabled }, { children: label })), children] })));
	});

	var __assign$18 = (undefined && undefined.__assign) || function () {
	    __assign$18 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$18.apply(this, arguments);
	};
	var __rest$Y = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is a simple wrapper for the `TextField` and `FormMessage`
	 * components that should be used along with the `useTextField` hook to
	 * conditionally show help and error messages with a `TextField`.
	 *
	 * Simple example:
	 *
	 * ```ts
	 * const [value, fieldProps] = useTextField({
	 *   id: "field-id",
	 * });
	 *
	 * return (
	 *   <TextFieldWithMessage
	 *     label="Label"
	 *     placeholder="Placeholder"
	 *     {...fieldProps}
	 *   />
	 * );
	 * ```
	 *
	 * @remarks \@since 2.5.0
	 */
	var TextFieldWithMessage = require$$1.forwardRef(function TextFieldWithMessage(_a, ref) {
	    var messageProps = _a.messageProps, messageContainerProps = _a.messageContainerProps, props = __rest$Y(_a, ["messageProps", "messageContainerProps"]);
	    return (jsxRuntime.exports.jsx(FormMessageContainer, __assign$18({}, messageContainerProps, { messageProps: messageProps }, { children: jsxRuntime.exports.jsx(TextField, __assign$18({}, props, { ref: ref })) })));
	});

	var __assign$17 = (undefined && undefined.__assign) || function () {
	    __assign$17 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$17.apply(this, arguments);
	};
	var __rest$X = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is a simple wrapper for the `TextArea` and `FormMessage`
	 * components that should be used along with the `useTextField` hook to
	 * conditionally show help and error messages with a `TextArea`.
	 *
	 * Simple example:
	 *
	 * ```ts
	 * const [value, areaProps] = useTextField({
	 *   id: "area-id",
	 * });
	 *
	 * return (
	 *   <TextFieldWithMessage
	 *     label="Label"
	 *     placeholder="Placeholder"
	 *     {...areaProps}
	 *   />
	 * );
	 * ```
	 *
	 * @remarks \@since 2.5.0
	 */
	var TextAreaWithMessage = require$$1.forwardRef(function TextAreaWithMessage(_a, ref) {
	    var messageProps = _a.messageProps, messageContainerProps = _a.messageContainerProps, props = __rest$X(_a, ["messageProps", "messageContainerProps"]);
	    return (jsxRuntime.exports.jsx(FormMessageContainer, __assign$17({}, messageContainerProps, { messageProps: messageProps }, { children: jsxRuntime.exports.jsx(TextArea, __assign$17({}, props, { ref: ref })) })));
	});

	var __assign$16 = (undefined && undefined.__assign) || function () {
	    __assign$16 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$16.apply(this, arguments);
	};
	var __rest$W = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is a simple wrapper for the `Password` and `FormMessage`
	 * components that should be used along with the `useTextField` hook to
	 * conditionally show help and error messages with a `Password`.
	 *
	 * Simple example:
	 *
	 * ```ts
	 * const [value, fieldProps] = useTextField({
	 *   id: "field-id",
	 *   required: true,
	 *   minLength: 10,
	 * });
	 *
	 * return (
	 *   <PasswordWithMessage
	 *     label="Label"
	 *     placeholder="Placeholder"
	 *     {...fieldProps}
	 *   />
	 * );
	 * ```
	 *
	 * Note: Unlike the `TextFieldWithMessage` and `TextAreaWithMessage`, the error
	 * icon will do nothing for this component unless the `disableVisibility` prop
	 * is enabled.
	 *
	 * @remarks \@since 2.5.0
	 */
	var PasswordWithMessage = require$$1.forwardRef(function PasswordWithMessage(_a, ref) {
	    var messageProps = _a.messageProps, messageContainerProps = _a.messageContainerProps, props = __rest$W(_a, ["messageProps", "messageContainerProps"]);
	    return (jsxRuntime.exports.jsx(FormMessageContainer, __assign$16({}, messageContainerProps, { messageProps: messageProps }, { children: jsxRuntime.exports.jsx(Password, __assign$16({}, props, { ref: ref })) })));
	});

	/**
	 * The default implementation for checking if a `TextField` or `TextArea` is
	 * errored by returning `true` if the `errorMessage` string is truthy or the
	 * value is not within the `minLength` and `maxLength` constraints when they
	 * exist.
	 *
	 * @remarks \@since 2.5.0
	 */
	var defaultIsErrored = function (_a) {
	    var value = _a.value, errorMessage = _a.errorMessage, minLength = _a.minLength, maxLength = _a.maxLength, isBlurEvent = _a.isBlurEvent;
	    return !!errorMessage ||
	        (typeof maxLength === "number" && value.length > maxLength) ||
	        (isBlurEvent && typeof minLength === "number" && value.length < minLength);
	};

	/**
	 * The default implementation for showing an error icon in `TextField` and
	 * `TextArea` components that will only display when the error flag is enabled.
	 *
	 * @remarks \@since 2.5.0
	 */
	var defaultGetErrorIcon = function (_message, error, errorIcon) {
	    return error && errorIcon;
	};

	var __read$o = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$7 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var VALIDITY_STATE_KEYS = [
	    "badInput",
	    "customError",
	    "patternMismatch",
	    "rangeOverflow",
	    "rangeUnderflow",
	    "stepMismatch",
	    "tooLong",
	    "tooShort",
	    "typeMismatch",
	    "valueMissing",
	];
	/**
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var RECOMMENDED_STATE_KEYS = [
	    "badInput",
	    "tooLong",
	    "valueMissing",
	];
	/**
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var RECOMMENDED_NUMBER_STATE_KEYS = __spreadArray$7(__spreadArray$7([], __read$o(RECOMMENDED_STATE_KEYS), false), [
	    "rangeOverflow",
	    "rangeUnderflow",
	    "tooShort",
	    "typeMismatch",
	], false);
	/**
	 * The validation message is actually kind of weird since it's possible for a
	 * form element to have multiple errors at once. The validation message will be
	 * the first error that appears, so need to make sure that the first error is
	 * one of the recommended state keys so the message appears for only those types
	 * of errors.
	 *
	 * @internal
	 * @remarks \@since 2.5.0
	 */
	var isRecommended = function (validity, isNumber) {
	    var errorable = isNumber
	        ? RECOMMENDED_NUMBER_STATE_KEYS
	        : RECOMMENDED_STATE_KEYS;
	    return VALIDITY_STATE_KEYS.every(function (key) {
	        var errored = validity[key];
	        return !errored || errorable.includes(key);
	    });
	};
	/**
	 * The default implementation for getting an error message for the `TextField`
	 * or `TextArea` components that relies on the behavior of the
	 * {@link ChangeValidationBehavior}
	 *
	 * @remarks \@since 2.5.0
	 */
	var defaultGetErrorMessage = function (_a) {
	    var isBlurEvent = _a.isBlurEvent, validity = _a.validity, validationMessage = _a.validationMessage, validateOnChange = _a.validateOnChange;
	    if (isBlurEvent || !validationMessage || validateOnChange === true) {
	        return validationMessage;
	    }
	    if (!validateOnChange) {
	        return "";
	    }
	    if (validateOnChange === "recommended" ||
	        validateOnChange === "number-recommended") {
	        return isRecommended(validity, validateOnChange === "number-recommended")
	            ? validationMessage
	            : "";
	    }
	    var keys = typeof validateOnChange === "string"
	        ? [validateOnChange]
	        : validateOnChange;
	    return keys.length &&
	        VALIDITY_STATE_KEYS.some(function (key) { return validity[key] && keys.includes(key); })
	        ? validationMessage
	        : "";
	};

	var __assign$15 = (undefined && undefined.__assign) || function () {
	    __assign$15 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$15.apply(this, arguments);
	};
	var __read$n = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var noop$2 = function () {
	    // do nothing
	};
	function useTextField(_a) {
	    var id = _a.id, _b = _a.defaultValue, defaultValue = _b === void 0 ? "" : _b, theme = _a.theme, pattern = _a.pattern, required = _a.required, minLength = _a.minLength, maxLength = _a.maxLength, _c = _a.disableMaxLength, disableMaxLength = _c === void 0 ? false : _c, onBlur = _a.onBlur, onChange = _a.onChange, helpText = _a.helpText, propErrorIcon = _a.errorIcon, _d = _a.counter, counter = _d === void 0 ? false : _d, _e = _a.disableMessage, disableMessage = _e === void 0 ? false : _e, _f = _a.validateOnChange, validateOnChange = _f === void 0 ? "recommended" : _f, _g = _a.isErrored, isErrored = _g === void 0 ? defaultIsErrored : _g, _h = _a.onErrorChange, onErrorChange = _h === void 0 ? noop$2 : _h, _j = _a.getErrorIcon, getErrorIcon = _j === void 0 ? defaultGetErrorIcon : _j, _k = _a.getErrorMessage, getErrorMessage = _k === void 0 ? defaultGetErrorMessage : _k;
	    var _l = __read$n(require$$1.useState(function () {
	        var value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
	        return {
	            value: value,
	            error: false,
	            errorMessage: "",
	        };
	    }), 2), state = _l[0], setState = _l[1];
	    var value = state.value, error = state.error, errorMessage = state.errorMessage;
	    var errored = require$$1.useRef(false);
	    var fieldRef = require$$1.useRef(null);
	    var messageId = "".concat(id, "-message");
	    var isCounting = counter && typeof maxLength === "number";
	    var reset = require$$1.useCallback(function () {
	        /* istanbul ignore next */
	        if (fieldRef.current) {
	            fieldRef.current.setCustomValidity("");
	        }
	        setState({
	            value: "",
	            error: false,
	            errorMessage: "",
	        });
	    }, []);
	    var updateState = require$$1.useCallback(function (field, isBlurEvent) {
	        fieldRef.current = field;
	        // need to temporarily set the `maxLength` back so it can be "verified"
	        // through the validity api
	        /* istanbul ignore next */
	        if (isBlurEvent && disableMaxLength && typeof maxLength === "number") {
	            field.maxLength = maxLength;
	        }
	        var value = field.value;
	        field.setCustomValidity("");
	        field.checkValidity();
	        // remove the temporarily set `maxLength` attribute after checking the
	        // validity
	        /* istanbul ignore next */
	        if (disableMaxLength && typeof maxLength === "number") {
	            field.removeAttribute("maxLength");
	        }
	        var options = {
	            value: value,
	            pattern: pattern,
	            required: required,
	            minLength: minLength,
	            maxLength: maxLength,
	            isBlurEvent: isBlurEvent,
	            validity: field.validity,
	            validationMessage: field.validationMessage,
	            validateOnChange: validateOnChange,
	        };
	        var errorMessage = getErrorMessage(options);
	        var error = isErrored(__assign$15(__assign$15({}, options), { errorMessage: errorMessage }));
	        if (errored.current !== error) {
	            errored.current = error;
	            onErrorChange(id, error);
	        }
	        /* istanbul ignore next */
	        if (errorMessage !== field.validationMessage) {
	            field.setCustomValidity(errorMessage);
	        }
	        setState({ value: value, error: error, errorMessage: errorMessage });
	    }, [
	        disableMaxLength,
	        getErrorMessage,
	        id,
	        isErrored,
	        maxLength,
	        minLength,
	        onErrorChange,
	        pattern,
	        required,
	        validateOnChange,
	    ]);
	    var handleBlur = require$$1.useCallback(function (event) {
	        if (onBlur) {
	            onBlur(event);
	        }
	        if (event.isPropagationStopped()) {
	            return;
	        }
	        updateState(event.currentTarget, true);
	    }, [onBlur, updateState]);
	    var handleChange = require$$1.useCallback(function (event) {
	        if (onChange) {
	            onChange(event);
	        }
	        if (event.isPropagationStopped()) {
	            return;
	        }
	        if (!validateOnChange ||
	            (Array.isArray(validateOnChange) && !validateOnChange.length)) {
	            setState(function (prevState) { return (__assign$15(__assign$15({}, prevState), { value: event.currentTarget.value })); });
	            return;
	        }
	        updateState(event.currentTarget, false);
	    }, [onChange, updateState, validateOnChange]);
	    var errorIcon = useIcon("error", propErrorIcon);
	    var props = {
	        id: id,
	        value: value,
	        theme: theme,
	        error: error,
	        required: required,
	        pattern: pattern,
	        minLength: minLength,
	        maxLength: disableMaxLength ? undefined : maxLength,
	        rightChildren: getErrorIcon(errorMessage, error, errorIcon),
	        onBlur: handleBlur,
	        onChange: handleChange,
	    };
	    if (!disableMessage) {
	        props["aria-describedby"] = messageId;
	        props.messageProps = {
	            id: messageId,
	            error: error,
	            theme: theme,
	            length: counter ? value.length : undefined,
	            maxLength: isCounting ? maxLength : undefined,
	            children: errorMessage || helpText,
	        };
	    }
	    return [
	        value,
	        props,
	        {
	            reset: reset,
	            setState: setState,
	        },
	    ];
	}

	var __assign$14 = (undefined && undefined.__assign) || function () {
	    __assign$14 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$14.apply(this, arguments);
	};
	var __read$m = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	function useNumberField(_a) {
	    var id = _a.id, defaultValue = _a.defaultValue, theme = _a.theme, pattern = _a.pattern, required = _a.required, minLength = _a.minLength, maxLength = _a.maxLength, _b = _a.disableMaxLength, disableMaxLength = _b === void 0 ? false : _b, onBlur = _a.onBlur, onChange = _a.onChange, helpText = _a.helpText, errorIcon = _a.errorIcon, _c = _a.counter, counter = _c === void 0 ? false : _c, _d = _a.disableMessage, disableMessage = _d === void 0 ? false : _d, _e = _a.validateOnChange, validateOnChange = _e === void 0 ? "number-recommended" : _e, isErrored = _a.isErrored, onErrorChange = _a.onErrorChange, getErrorIcon = _a.getErrorIcon, getErrorMessage = _a.getErrorMessage, min = _a.min, max = _a.max, step = _a.step, _f = _a.fixOnBlur, fixOnBlur = _f === void 0 ? true : _f, _g = _a.updateOnChange, updateOnChange = _g === void 0 ? true : _g;
	    var _h = __read$m(require$$1.useState(defaultValue), 2), number = _h[0], setNumber = _h[1];
	    var initial = require$$1.useRef(number);
	    var handleBlur = require$$1.useCallback(function (event) {
	        if (onBlur) {
	            onBlur(event);
	        }
	        if (event.isPropagationStopped()) {
	            return;
	        }
	        var input = event.currentTarget;
	        input.setCustomValidity("");
	        input.checkValidity();
	        if (!fixOnBlur ||
	            // do nothing else since it's a weird value like: `"--0"` which causes
	            // the value to be `""` and `numberAsValue` to be `NaN`
	            input.validity.badInput ||
	            (input.validity.rangeUnderflow && fixOnBlur === "max") ||
	            (input.validity.rangeOverflow && fixOnBlur === "min")) {
	            return;
	        }
	        var value = input.valueAsNumber;
	        if (input.value === "" && typeof initial.current === "number") {
	            value = min !== null && min !== void 0 ? min : initial.current;
	        }
	        // can't have both rangeUnderflow and rangeOverflow at the same time, so
	        // it's "safe" to always provide both
	        value = withinRange(value, min, max);
	        if (!Number.isNaN(value)) {
	            setNumber(value);
	            input.value = "".concat(value);
	        }
	        else if (typeof initial.current === "undefined") {
	            setNumber(undefined);
	        }
	    }, [onBlur, fixOnBlur, min, max]);
	    var handleChange = require$$1.useCallback(function (event) {
	        if (onChange) {
	            onChange(event);
	        }
	        if (event.isPropagationStopped() || !updateOnChange) {
	            return;
	        }
	        var input = event.currentTarget;
	        input.checkValidity();
	        var value = withinRange(event.currentTarget.valueAsNumber, min, max);
	        if (!input.validity.valid &&
	            !input.validity.rangeUnderflow &&
	            !input.validity.rangeOverflow) {
	            return;
	        }
	        if (!Number.isNaN(value)) {
	            setNumber(value);
	        }
	        else if (initial.current === undefined) {
	            setNumber(undefined);
	        }
	    }, [onChange, updateOnChange, min, max]);
	    var _j = __read$m(useTextField({
	        id: id,
	        defaultValue: "".concat(number !== null && number !== void 0 ? number : ""),
	        theme: theme,
	        pattern: pattern,
	        required: required,
	        minLength: minLength,
	        maxLength: maxLength,
	        disableMaxLength: disableMaxLength,
	        onBlur: handleBlur,
	        onChange: handleChange,
	        helpText: helpText,
	        errorIcon: errorIcon,
	        counter: counter,
	        disableMessage: disableMessage,
	        validateOnChange: validateOnChange,
	        isErrored: isErrored,
	        onErrorChange: onErrorChange,
	        getErrorIcon: getErrorIcon,
	        getErrorMessage: getErrorMessage,
	    }), 3), props = _j[1], setState = _j[2].setState;
	    var reset = require$$1.useCallback(function () {
	        var _a;
	        setNumber(initial.current);
	        setState({
	            value: "".concat((_a = initial.current) !== null && _a !== void 0 ? _a : ""),
	            error: false,
	            errorMessage: "",
	        });
	    }, [setState]);
	    var updateNumber = require$$1.useCallback(function (value) {
	        if (typeof value === "function") {
	            setNumber(function (prevNumber) {
	                var updated = value(prevNumber);
	                setState(function (prevState) { return (__assign$14(__assign$14({}, prevState), { value: "".concat(updated !== null && updated !== void 0 ? updated : "") })); });
	                return updated;
	            });
	            return;
	        }
	        setNumber(value);
	        setState(function (prevState) { return (__assign$14(__assign$14({}, prevState), { value: "".concat(value !== null && value !== void 0 ? value : "") })); });
	    }, [setState]);
	    return [
	        number,
	        __assign$14(__assign$14({}, props), { min: min, max: max, step: step, type: "number" }),
	        {
	            reset: reset,
	            setNumber: updateNumber,
	        },
	    ];
	}

	var __assign$13 = (undefined && undefined.__assign) || function () {
	    __assign$13 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$13.apply(this, arguments);
	};
	var __rest$V = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$w = bem("rmd-toggle-container");
	/**
	 * The `ToggleContainer` component should generally be used around a
	 * custom `"checkbox"`, `"radio"`, or `"switch"` component to help with
	 * additional styles. This is mostly an internal component so I'm not
	 * sure useful it will be though.
	 */
	var ToggleContainer = require$$1.forwardRef(function ToggleContainer(_a, ref) {
	    var className = _a.className, _b = _a.inline, inline = _b === void 0 ? false : _b, _c = _a.stacked, stacked = _c === void 0 ? false : _c, children = _a.children, props = __rest$V(_a, ["className", "inline", "stacked", "children"]);
	    return (jsxRuntime.exports.jsx("div", __assign$13({}, props, { ref: ref, className: cn(block$w({ stacked: stacked, inline: inline }), className) }, { children: children })));
	});

	var __assign$12 = (undefined && undefined.__assign) || function () {
	    __assign$12 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$12.apply(this, arguments);
	};
	var __rest$U = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$l = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var block$v = bem("rmd-toggle");
	var InputToggle = require$$1.forwardRef(function InputToggle(allProps, ref) {
	    var _a = allProps, style = _a.style, className = _a.className, iconStyle = _a.iconStyle, iconClassName = _a.iconClassName, toggleStyle = _a.toggleStyle, propToggleClassName = _a.toggleClassName, inputStyle = _a.inputStyle, inputClassName = _a.inputClassName, icon = _a.icon, propOnFocus = _a.onFocus, propOnBlur = _a.onBlur, _b = _a.error, error = _b === void 0 ? false : _b, _c = _a.inline, inline = _c === void 0 ? false : _c, _d = _a.stacked, stacked = _d === void 0 ? false : _d, _e = _a.disabled, disabled = _e === void 0 ? false : _e, label = _a.label, labelStyle = _a.labelStyle, labelClassName = _a.labelClassName, labelDisabled = _a.labelDisabled, _f = _a.iconAfter, iconAfter = _f === void 0 ? false : _f, _g = _a.disableIconOverlay, disableIconOverlay = _g === void 0 ? false : _g, disableRipple = _a.disableRipple, disableProgrammaticRipple = _a.disableProgrammaticRipple, rippleTimeout = _a.rippleTimeout, rippleClassNames = _a.rippleClassNames, children = _a.children, indeterminate = _a.indeterminate, props = __rest$U(_a, ["style", "className", "iconStyle", "iconClassName", "toggleStyle", "toggleClassName", "inputStyle", "inputClassName", "icon", "onFocus", "onBlur", "error", "inline", "stacked", "disabled", "label", "labelStyle", "labelClassName", "labelDisabled", "iconAfter", "disableIconOverlay", "disableRipple", "disableProgrammaticRipple", "rippleTimeout", "rippleClassNames", "children", "indeterminate"]);
	    var id = props.id, type = props.type;
	    var _h = useInteractionStates({
	        handlers: props,
	        disabled: disabled,
	        className: propToggleClassName,
	        disableRipple: disableRipple,
	        disableProgrammaticRipple: disableProgrammaticRipple,
	        rippleTimeout: rippleTimeout,
	        rippleClassNames: rippleClassNames,
	    }), ripples = _h.ripples, handlers = _h.handlers, toggleClassName = _h.className;
	    var _j = __read$l(useFocusState({
	        onFocus: propOnFocus,
	        onBlur: propOnBlur,
	    }), 3), focused = _j[0], onFocus = _j[1], onBlur = _j[2];
	    var labelEl = (jsxRuntime.exports.jsx(Label, __assign$12({ style: labelStyle, className: labelClassName, htmlFor: id, error: error, disabled: typeof labelDisabled === "boolean" ? labelDisabled : disabled }, { children: label })));
	    return (jsxRuntime.exports.jsxs(ToggleContainer, __assign$12({ style: style, className: className, inline: inline, stacked: stacked }, { children: [iconAfter && labelEl, jsxRuntime.exports.jsxs("span", __assign$12({ style: toggleStyle, className: cn(block$v({
	                    focused: focused,
	                    disabled: disabled,
	                }), toggleClassName) }, { children: [jsxRuntime.exports.jsx("input", __assign$12({}, props, handlers, { ref: ref, style: inputStyle, disabled: disabled, onFocus: onFocus, onBlur: onBlur, className: cn(block$v("input"), inputClassName) })), jsxRuntime.exports.jsx(InputToggleIcon, __assign$12({ circle: !disableIconOverlay && type === "radio", disabled: disabled, overlay: !disableIconOverlay, indeterminate: indeterminate, style: iconStyle, className: iconClassName }, { children: icon })), ripples, children] })), !iconAfter && labelEl] })));
	});

	var __assign$11 = (undefined && undefined.__assign) || function () {
	    __assign$11 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$11.apply(this, arguments);
	};
	var __rest$T = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `Checkbox` component is just a wrapper for the `InputToggle` that
	 * defaults to reasonable defaults for a checkbox input.
	 */
	var Checkbox = require$$1.forwardRef(function Checkbox(_a, ref) {
	    var propIcon = _a.icon, _b = _a.indeterminate, indeterminate = _b === void 0 ? false : _b, props = __rest$T(_a, ["icon", "indeterminate"]);
	    var icon = useIcon("checkbox", propIcon);
	    return (jsxRuntime.exports.jsx(InputToggle, __assign$11({}, props, { icon: icon, ref: ref, type: "checkbox", indeterminate: indeterminate })));
	});

	var __assign$10 = (undefined && undefined.__assign) || function () {
	    __assign$10 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$10.apply(this, arguments);
	};
	var __rest$S = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `Radio` component is just a wrapper for the `InputToggle` that
	 * defaults to reasonable defaults for a radio input.
	 */
	var Radio = require$$1.forwardRef(function Radio(_a, ref) {
	    var propIcon = _a.icon, props = __rest$S(_a, ["icon"]);
	    var icon = useIcon("radio", propIcon);
	    return jsxRuntime.exports.jsx(InputToggle, __assign$10({}, props, { icon: icon, ref: ref, type: "radio" }));
	});

	var __assign$$ = (undefined && undefined.__assign) || function () {
	    __assign$$ = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$$.apply(this, arguments);
	};
	var __rest$R = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var Switch = require$$1.forwardRef(function Switch(_a, ref) {
	    var style = _a.style, className = _a.className, ballStyle = _a.ballStyle, ballClassName = _a.ballClassName, trackStyle = _a.trackStyle, trackClassName = _a.trackClassName, label = _a.label, labelStyle = _a.labelStyle, labelClassName = _a.labelClassName, labelDisabled = _a.labelDisabled, _b = _a.error, error = _b === void 0 ? false : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, _d = _a.stacked, stacked = _d === void 0 ? false : _d, _e = _a.inline, inline = _e === void 0 ? false : _e, _f = _a.iconAfter, iconAfter = _f === void 0 ? false : _f, children = _a.children, props = __rest$R(_a, ["style", "className", "ballStyle", "ballClassName", "trackStyle", "trackClassName", "label", "labelStyle", "labelClassName", "labelDisabled", "error", "disabled", "stacked", "inline", "iconAfter", "children"]);
	    var id = props.id;
	    return (jsxRuntime.exports.jsx(ToggleContainer, __assign$$({ style: style, className: cn("rmd-switch-container", className), inline: inline, stacked: stacked }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$$({ icon: jsxRuntime.exports.jsx(Label, __assign$$({ style: labelStyle, className: labelClassName, htmlFor: id, error: error, disabled: labelDisabled !== null && labelDisabled !== void 0 ? labelDisabled : disabled }, { children: label })), iconAfter: !iconAfter }, { children: jsxRuntime.exports.jsx(SwitchTrack, __assign$$({}, props, { ref: ref, style: trackStyle, className: trackClassName, disabled: disabled, ballStyle: ballStyle, ballClassName: ballClassName }, { children: children })) })) })));
	});

	var __assign$_ = (undefined && undefined.__assign) || function () {
	    __assign$_ = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$_.apply(this, arguments);
	};
	var __rest$Q = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$u = bem("rmd-linear-progress");
	var LinearProgress = require$$1.forwardRef(function LinearProgress(_a, ref) {
	    var propStyle = _a.style, className = _a.className, propBarStyle = _a.barStyle, barClassName = _a.barClassName, _b = _a.min, min = _b === void 0 ? 0 : _b, _c = _a.max, max = _c === void 0 ? 100 : _c, value = _a.value, _d = _a.reverse, reverse = _d === void 0 ? false : _d, _e = _a.animate, animate = _e === void 0 ? true : _e, _f = _a.vertical, vertical = _f === void 0 ? false : _f, _g = _a.verticalHeight, verticalHeight = _g === void 0 ? 240 : _g, props = __rest$Q(_a, ["style", "className", "barStyle", "barClassName", "min", "max", "value", "reverse", "animate", "vertical", "verticalHeight"]);
	    var style = require$$1.useMemo(function () {
	        if (!vertical || verticalHeight === null) {
	            return propStyle;
	        }
	        return __assign$_(__assign$_({}, propStyle), { height: verticalHeight });
	    }, [propStyle, vertical, verticalHeight]);
	    var progress;
	    if (typeof value === "number") {
	        progress = getPercentage({ min: min, max: max, value: value });
	    }
	    var barStyle = require$$1.useMemo(function () {
	        var _a;
	        if (typeof progress !== "number") {
	            return propBarStyle;
	        }
	        var key = vertical ? "height" : "width";
	        return __assign$_(__assign$_({}, propBarStyle), (_a = {}, _a[key] = "".concat(progress * 100, "%"), _a));
	    }, [progress, propBarStyle, vertical]);
	    var determinate = typeof progress === "number";
	    var indeterminate = !determinate;
	    return (jsxRuntime.exports.jsx("span", __assign$_({}, props, { ref: ref, style: style, role: "progressbar", "aria-valuemin": min, "aria-valuemax": max, "aria-valuenow": value, className: cn(block$u({
	            vertical: vertical,
	            determinate: determinate,
	            indeterminate: indeterminate,
	        }), className) }, { children: jsxRuntime.exports.jsx("span", { style: barStyle, className: cn(block$u("bar", {
	                vertical: vertical,
	                "vertical-reverse": vertical && reverse,
	                horizontal: !vertical,
	                "horizontal-reverse": !vertical && reverse,
	                animate: animate && determinate,
	                determinate: determinate,
	                indeterminate: indeterminate,
	                "determinate-reverse": determinate && reverse && !vertical,
	                "determinate-vertical-reverse": determinate && reverse && vertical,
	                "indeterminate-reverse": indeterminate && reverse && !vertical,
	                "indeterminate-vertical": indeterminate && vertical,
	                "indeterminate-vertical-reverse": indeterminate && reverse && vertical,
	            }), barClassName) }) })));
	});

	var __assign$Z = (undefined && undefined.__assign) || function () {
	    __assign$Z = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$Z.apply(this, arguments);
	};
	var __rest$P = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$t = bem("rmd-circular-progress");
	var CircularProgress = require$$1.forwardRef(function CircularProgress(_a, ref) {
	    var className = _a.className, propSvgStyle = _a.svgStyle, svgClassName = _a.svgClassName, propCircleStyle = _a.circleStyle, circleClassName = _a.circleClassName, value = _a.value, _b = _a.min, min = _b === void 0 ? 0 : _b, _c = _a.max, max = _c === void 0 ? 100 : _c, _d = _a.radius, radius = _d === void 0 ? 30 : _d, _e = _a.center, center = _e === void 0 ? 33 : _e, _f = _a.viewBox, viewBox = _f === void 0 ? "0 0 66 66" : _f, _g = _a.dashoffset, dashoffset = _g === void 0 ? 187 : _g, _h = _a.animate, animate = _h === void 0 ? true : _h, _j = _a.centered, centered = _j === void 0 ? true : _j, _k = _a.maxRotation, maxRotation = _k === void 0 ? 360 * 1.75 : _k, _l = _a.small, small = _l === void 0 ? false : _l, props = __rest$P(_a, ["className", "svgStyle", "svgClassName", "circleStyle", "circleClassName", "value", "min", "max", "radius", "center", "viewBox", "dashoffset", "animate", "centered", "maxRotation", "small"]);
	    var progress;
	    if (typeof value === "number") {
	        progress = getPercentage({ min: min, max: max, value: value });
	    }
	    var svgStyle = require$$1.useMemo(function () {
	        if (typeof progress !== "number") {
	            return propSvgStyle;
	        }
	        var transform = propSvgStyle && propSvgStyle.transform;
	        if (maxRotation > 0) {
	            var rotate = "rotate(".concat(maxRotation * progress, "deg)");
	            transform = "".concat(rotate).concat(transform ? " ".concat(transform) : "");
	        }
	        return __assign$Z(__assign$Z({}, propSvgStyle), { WebkitTransform: transform, transform: transform });
	    }, [progress, maxRotation, propSvgStyle]);
	    var circleStyle = require$$1.useMemo(function () {
	        if (typeof progress !== "number") {
	            return propCircleStyle;
	        }
	        return __assign$Z(__assign$Z({}, propCircleStyle), { strokeDashoffset: dashoffset - dashoffset * progress });
	    }, [progress, propCircleStyle, dashoffset]);
	    var determinate = typeof progress === "number";
	    var indeterminate = !determinate;
	    return (jsxRuntime.exports.jsx("span", __assign$Z({}, props, { ref: ref, role: "progressbar", "aria-valuemin": min, "aria-valuemax": max, "aria-valuenow": value, className: cn(block$t({ centered: centered, small: small }), className) }, { children: jsxRuntime.exports.jsx("svg", __assign$Z({ style: svgStyle, className: cn(block$t("svg", {
	                animate: animate && determinate,
	                determinate: determinate,
	                indeterminate: indeterminate,
	            }), svgClassName), viewBox: viewBox }, { children: jsxRuntime.exports.jsx("circle", { style: circleStyle, className: cn(block$t("circle", {
	                    animate: animate && determinate,
	                    determinate: determinate,
	                    indeterminate: indeterminate,
	                }), circleClassName), r: radius, cx: center, cy: center }) })) })));
	});

	/**
	 * An extremely simple util that can be used to get the required a11y props for
	 * another component that relies on a progress component.
	 *
	 * @param progressId - The id for the progress bar
	 * @param progressing - Boolean if the progress bar is visible and progressing
	 */
	function getProgressA11y(progressId, progressing) {
	    if (!progressing) {
	        return undefined;
	    }
	    return {
	        "aria-busy": true,
	        "aria-describedby": progressId,
	    };
	}

	var __assign$Y = (undefined && undefined.__assign) || function () {
	    __assign$Y = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$Y.apply(this, arguments);
	};
	var __rest$O = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	// this is used while the loading state is enabled to "disable" the switch
	// toggle. If we disable the entire switch, keyboard focus is lost which is not
	// desired.
	var noop$1 = function () {
	    // do nothing
	};
	/**
	 * This component will create an async switch that will show a loading indicator
	 * and prevent the switch from being toggled while the loading state is true.
	 */
	var AsyncSwitch = require$$1.forwardRef(function AsyncSwitch(_a, ref) {
	    var id = _a.id, disabled = _a.disabled, className = _a.className, progressStyle = _a.progressStyle, progressClassName = _a.progressClassName, loading = _a.loading, onChange = _a.onChange, props = __rest$O(_a, ["id", "disabled", "className", "progressStyle", "progressClassName", "loading", "onChange"]);
	    var progressId = "".concat(id, "-loading");
	    return (jsxRuntime.exports.jsx(Switch, __assign$Y({}, props, getProgressA11y(progressId, loading), { id: id, ref: ref, disabled: disabled, className: cn("rmd-switch--async", className), labelDisabled: disabled || false, onChange: loading ? noop$1 : onChange }, { children: loading && (jsxRuntime.exports.jsx(CircularProgress, { id: progressId, style: progressStyle, className: cn("rmd-switch__progress", progressClassName), centered: false })) })));
	});

	var __read$k = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * A small hook that can be used for controlling the state of a single Checkbox
	 * component.
	 *
	 * @param defaultChecked - Boolean if the input should be checked by default.
	 * Changing this value will not update the state after initial render.
	 * @param onChange - An optional change event handler to also call when the
	 * checked state changes.
	 * @returns a list containing the checked state, a change event handler, and
	 * then a manual set checked action.
	 */
	function useChecked(defaultChecked, onChange) {
	    var _a = __read$k(require$$1.useState(defaultChecked), 2), checked = _a[0], setChecked = _a[1];
	    var handleChange = require$$1.useCallback(function (event) {
	        if (onChange) {
	            onChange(event);
	        }
	        setChecked(event.currentTarget.checked);
	    }, [onChange]);
	    return [checked, handleChange, setChecked];
	}

	var __read$j = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook can be used to control the state of a radio group or a select
	 * element.
	 *
	 * @param defaultValue - The default value. If you want the user to specifically
	 * choose a value, set this to the empty string.
	 * @param onChange - An optional change event handler to also call when the
	 * change event is triggered.
	 * @returns a list containing the current value, a change event handler, and
	 * then a manual value setter.
	 */
	function useChoice(defaultValue, onChange) {
	    var _a = __read$j(require$$1.useState(defaultValue), 2), value = _a[0], setValue = _a[1];
	    var handleChange = require$$1.useCallback(function (event) {
	        if (onChange) {
	            onChange(event);
	        }
	        setValue(event.currentTarget.value);
	    }, [onChange]);
	    return [value, handleChange, setValue];
	}

	var __read$i = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This is a simple hook that will allow you to "strongly" type a `Select`
	 * component's value since the `onChange` handler only returns a `string`.
	 *
	 * @param defaultValue - The default value to use
	 * @returns an ordered list containing the current value followed by the
	 * dispatch function to update the state.
	 */
	function useSelectState(defaultValue) {
	    var _a = __read$i(require$$1.useState(defaultValue), 2), value = _a[0], setValue = _a[1];
	    var setTypedValue = require$$1.useCallback(function (nextValue) {
	        setValue(nextValue);
	    }, []);
	    return [value, setTypedValue];
	}

	var __read$h = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	function useIndeterminateChecked(values, _a) {
	    var _b;
	    var _c = _a === void 0 ? {} : _a, _d = _c.menu, menu = _d === void 0 ? false : _d, propOnChange = _c.onChange, _e = _c.defaultCheckedValues, defaultCheckedValues = _e === void 0 ? [] : _e;
	    var _f = __read$h(require$$1.useState(defaultCheckedValues), 2), checkedValues = _f[0], setCheckedValues = _f[1];
	    var checked = checkedValues.length > 0;
	    var indeterminate = checked && checkedValues.length < values.length;
	    var updateCheckedValues = function (values) {
	        propOnChange === null || propOnChange === void 0 ? void 0 : propOnChange(values);
	        setCheckedValues(values);
	    };
	    var rootProps = (_b = {
	            "aria-checked": indeterminate ? "mixed" : undefined,
	            checked: checked,
	            indeterminate: indeterminate
	        },
	        _b[menu ? "onCheckedChange" : "onChange"] = function () {
	            updateCheckedValues(checkedValues.length === 0 || indeterminate ? values : []);
	        },
	        _b);
	    var getProps = function (value) {
	        var _a;
	        return _a = {
	                value: value,
	                checked: checkedValues.includes(value)
	            },
	            _a[menu ? "onCheckedChange" : "onChange"] = function () {
	                var i = checkedValues.indexOf(value);
	                var nextChecked = checkedValues.slice();
	                if (i === -1) {
	                    nextChecked.push(value);
	                }
	                else {
	                    nextChecked.splice(i, 1);
	                }
	                updateCheckedValues(nextChecked);
	            },
	            _a;
	    };
	    return {
	        rootProps: rootProps,
	        getProps: getProps,
	        checkedValues: checkedValues,
	        setCheckedValues: setCheckedValues,
	    };
	}

	var __assign$X = (undefined && undefined.__assign) || function () {
	    __assign$X = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$X.apply(this, arguments);
	};
	/**
	 * The `HighlightedResult` component can be used to bold specific letters
	 * within the `children` if the `children` is a string.
	 */
	function HighlightedResult(_a) {
	    var propId = _a.id, style = _a.style, className = _a.className, _b = _a.enabled, enabled = _b === void 0 ? true : _b, value = _a.value, children = _a.children, _c = _a.repeatable, repeatable = _c === void 0 ? false : _c, _d = _a.index, index = _d === void 0 ? 0 : _d;
	    if (!enabled || !value || typeof children !== "string") {
	        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children });
	    }
	    var i = children.toLowerCase().indexOf(value.toLowerCase());
	    if (i === -1) {
	        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children });
	    }
	    var end = i + value.length;
	    var id = propId;
	    if (id && index > 0) {
	        id = "".concat(id, "-").concat(index);
	    }
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [i > 0 && children.substring(0, i), jsxRuntime.exports.jsx("span", __assign$X({ id: id, style: style, className: cn("rmd-typography--bold", className) }, { children: children.substring(i, end) })), end < children.length && (jsxRuntime.exports.jsx(HighlightedResult, __assign$X({ style: style, className: className, value: value, enabled: enabled && repeatable, repeatable: repeatable, index: index + 1 }, { children: children.substring(end) })))] }));
	}

	/**
	 * Generates an id for each result in the autocomplete's listbox.
	 *
	 * @param id - The listbox's id
	 * @param index - The index of the result in the list
	 * @returns an id string
	 */
	function getResultId(id, index) {
	    return "".concat(id, "-result-").concat(index + 1);
	}
	/**
	 * Gets a renderable label for each result in the autocomplete's listbox. This
	 * will be applied as the `children` for the `Option` element.
	 *
	 * @param datum - The current result datum to get a label for
	 * @param labelKey - The key to extract a label from if the datum is an object
	 * @param _query - The current search query. This is useful if you want to
	 * implement text "highlighting" (bold) of all the letters that match in the
	 * item.
	 * @returns a renderable node to display
	 */
	function getResultLabel(datum, labelKey, _query) {
	    if (typeof datum === "string") {
	        return datum;
	    }
	    var label = datum[labelKey];
	    return datum.children || (typeof label === "undefined" ? null : label);
	}
	/**
	 * Gets a value string from each result that can be searched.
	 *
	 * @param datum - The current result datum that should have a string extracted
	 * @param valueKey - The key to use to extract a string value from if the datum
	 * is an object
	 * @returns a searchable string.
	 */
	function getResultValue(datum, valueKey) {
	    if (typeof datum === "string") {
	        return datum;
	    }
	    var value = datum[valueKey];
	    return "".concat(value);
	}
	/**
	 * This is used to disable filtering and just return the data list immediately.
	 * Useful when the filtering is done somewhere else like a server/API
	 * @internal
	 */
	var noFilter = function (_, data) { return data; };
	/**
	 * Gets the filter function to use within the Autocomplete based on the provided
	 * filter prop
	 *
	 * @internal
	 */
	function getFilterFunction(filter) {
	    if (typeof filter === "function") {
	        return filter;
	    }
	    switch (filter) {
	        case "fuzzy":
	            return fuzzyFilter;
	        case "case-insensitive":
	            return caseInsensitiveFilter;
	        case "none":
	            return noFilter;
	        default:
	            return noFilter;
	    }
	}
	/**
	 * This is an extremely simple type guard that is useful when using the
	 * `onAutoComplete` handler since I'm terrible at typescript types. This will
	 * ensure that if the result is an object, it will match the provided data type
	 * of your data list.
	 *
	 * Example:
	 *
	 * ```ts
	 * interface Example {
	 *   name: string;
	 *   value: string;
	 * }
	 *
	 *
	 * const [example, setExample] = useState<Example | null>(null);
	 * const onAutoComplete = useCallback<AuoCompleteHandler>((_name, example) => {
	 *   if (isResultOf<Example>(example)) {
	 *     setExample(example);
	 *   }
	 * }, [])
	 * ```
	 *
	 * @param datum - The result data to type guard against.
	 */
	function isResultOf(datum) {
	    return !!datum && typeof datum === "object";
	}

	var __assign$W = (undefined && undefined.__assign) || function () {
	    __assign$W = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$W.apply(this, arguments);
	};
	var __read$g = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This hook handles all the autocomplete's "logic" and behavior.
	 *
	 * @internal
	 */
	function useAutoComplete(_a) {
	    var _b;
	    var suggestionsId = _a.suggestionsId, data = _a.data, propValue = _a.propValue, _c = _a.defaultValue, defaultValue = _c === void 0 ? "" : _c, filterFn = _a.filter, filterOptions = _a.filterOptions, filterOnNoValue = _a.filterOnNoValue, valueKey = _a.valueKey, getResultId = _a.getResultId, getResultValue = _a.getResultValue, onBlur = _a.onBlur, onFocus = _a.onFocus, onClick = _a.onClick, onChange = _a.onChange, onKeyDown = _a.onKeyDown, forwardedRef = _a.forwardedRef, onAutoComplete = _a.onAutoComplete, clearOnAutoComplete = _a.clearOnAutoComplete, anchor = _a.anchor, xMargin = _a.xMargin, yMargin = _a.yMargin, vwMargin = _a.vwMargin, vhMargin = _a.vhMargin, transformOrigin = _a.transformOrigin, listboxWidth = _a.listboxWidth, listboxStyle = _a.listboxStyle, preventOverlap = _a.preventOverlap, disableSwapping = _a.disableSwapping, disableVHBounds = _a.disableVHBounds, closeOnResize = _a.closeOnResize, closeOnScroll = _a.closeOnScroll, propDisableShowOnFocus = _a.disableShowOnFocus, isListAutocomplete = _a.isListAutocomplete, isInlineAutocomplete = _a.isInlineAutocomplete;
	    var _d = __read$g(useEnsuredRef(forwardedRef), 2), ref = _d[0], refHandler = _d[1];
	    var filter = getFilterFunction(filterFn);
	    var _e = __read$g(require$$1.useState(function () {
	        var _a;
	        var options = __assign$W(__assign$W({}, filterOptions), { valueKey: valueKey, getItemValue: getResultValue, startsWith: (_a = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _a !== void 0 ? _a : isInlineAutocomplete });
	        var value = propValue !== null && propValue !== void 0 ? propValue : defaultValue;
	        var filteredData = filterOnNoValue || value ? filter(value, data, options) : data;
	        var match = value;
	        if (isInlineAutocomplete && filteredData.length) {
	            match = getResultValue(filteredData[0], valueKey);
	        }
	        return {
	            value: value,
	            match: match,
	            filteredData: filteredData,
	        };
	    }), 2), _f = _e[0], stateValue = _f.value, match = _f.match, stateFilteredData = _f.filteredData, setState = _e[1];
	    var filteredData = filterFn === "none" ? data : stateFilteredData;
	    var startsWith = (_b = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _b !== void 0 ? _b : isInlineAutocomplete;
	    var value = propValue !== null && propValue !== void 0 ? propValue : stateValue;
	    var setValue = require$$1.useCallback(function (nextValue) {
	        var isBackspace = value.length > nextValue.length ||
	            (!!match && value.length === nextValue.length);
	        var filtered = data;
	        if (nextValue || filterOnNoValue) {
	            var options = __assign$W(__assign$W({}, filterOptions), { valueKey: valueKey, getItemValue: getResultValue, startsWith: startsWith });
	            filtered = filter(nextValue, data, options);
	        }
	        var nextMatch = nextValue;
	        if (isInlineAutocomplete && filtered.length && !isBackspace) {
	            nextMatch = getResultValue(filtered[0], valueKey);
	            var input = ref.current;
	            if (input && !isBackspace) {
	                input.value = nextMatch;
	                input.setSelectionRange(nextValue.length, nextMatch.length);
	            }
	        }
	        setState({ value: nextValue, match: nextMatch, filteredData: filtered });
	    }, [
	        ref,
	        data,
	        filter,
	        filterOnNoValue,
	        filterOptions,
	        isInlineAutocomplete,
	        getResultValue,
	        value,
	        match,
	        startsWith,
	        valueKey,
	    ]);
	    // this is really just a hacky way to make sure that once a value has been
	    // autocompleted, the menu doesn't immediately re-appear due to the hook below
	    // for showing when the value/ filtered data list change
	    var autocompleted = require$$1.useRef(false);
	    var handleChange = require$$1.useCallback(function (event) {
	        if (onChange) {
	            onChange(event);
	        }
	        autocompleted.current = false;
	        setValue(event.currentTarget.value);
	    }, [setValue, onChange]);
	    var _g = __read$g(useToggle(false), 3), visible = _g[0], show = _g[1], hide = _g[2];
	    var isTouch = useIsUserInteractionMode("touch");
	    var disableShowOnFocus = propDisableShowOnFocus !== null && propDisableShowOnFocus !== void 0 ? propDisableShowOnFocus : isTouch;
	    var focused = require$$1.useRef(false);
	    var handleBlur = require$$1.useCallback(function (event) {
	        if (onBlur) {
	            onBlur(event);
	        }
	        focused.current = false;
	    }, [onBlur]);
	    var handleFocus = require$$1.useCallback(function (event) {
	        if (onFocus) {
	            onFocus(event);
	        }
	        if (disableShowOnFocus) {
	            return;
	        }
	        focused.current = true;
	        if (isListAutocomplete && filteredData.length) {
	            show();
	        }
	    }, [filteredData, isListAutocomplete, onFocus, show, disableShowOnFocus]);
	    var handleClick = require$$1.useCallback(function (event) {
	        if (onClick) {
	            onClick(event);
	        }
	        // since click events also trigger focus events right beforehand, want to
	        // skip the first click handler and require a second click to show it.
	        // this is why the focused.current isn't set onFocus for
	        // disableShowOnFocus
	        if (disableShowOnFocus && !focused.current) {
	            focused.current = true;
	            return;
	        }
	        if (isListAutocomplete && filteredData.length) {
	            show();
	        }
	    }, [disableShowOnFocus, filteredData.length, isListAutocomplete, onClick, show]);
	    var handleAutoComplete = require$$1.useCallback(function (index) {
	        var result = filteredData[index];
	        var resultValue = getResultValue(result, valueKey);
	        if (onAutoComplete) {
	            onAutoComplete({
	                value: resultValue,
	                index: index,
	                result: result,
	                dataIndex: data.findIndex(function (datum) { return getResultValue(datum, valueKey) === resultValue; }),
	                filteredData: filteredData,
	            });
	        }
	        setValue(clearOnAutoComplete ? "" : resultValue);
	        autocompleted.current = true;
	    }, [
	        clearOnAutoComplete,
	        data,
	        filteredData,
	        getResultValue,
	        onAutoComplete,
	        valueKey,
	        setValue,
	    ]);
	    var nodeRef = require$$1.useRef(null);
	    var _h = useActiveDescendantMovement(__assign$W(__assign$W({}, VERTICAL_COMBOBOX), { getId: getResultId, items: filteredData, baseId: suggestionsId, onChange: function (_a, itemRefs) {
	            var index = _a.index, items = _a.items, target = _a.target;
	            // the default scroll into view behavior for aria-activedescendant
	            // movement won't work here since the "target" element will actually be
	            // the input element instead of the listbox. So need to implement the
	            // scroll into view behavior manually from the listbox instead.
	            var item = itemRefs[index] && itemRefs[index].current;
	            var listbox = nodeRef.current;
	            if (item && listbox && listbox.scrollHeight > listbox.offsetHeight) {
	                scrollIntoView(listbox, item);
	            }
	            if (!isInlineAutocomplete) {
	                return;
	            }
	            var nextMatch = getResultValue(items[index], valueKey);
	            target.value = nextMatch;
	            target.setSelectionRange(0, nextMatch.length);
	            setState(function (prevState) { return (__assign$W(__assign$W({}, prevState), { value: nextMatch, match: nextMatch })); });
	        }, onKeyDown: function (event) {
	            if (onKeyDown) {
	                onKeyDown(event);
	            }
	            var input = event.currentTarget;
	            switch (event.key) {
	                case "ArrowDown":
	                    if (isListAutocomplete &&
	                        event.altKey &&
	                        !visible &&
	                        filteredData.length) {
	                        // don't want the cursor to move if there is text
	                        event.preventDefault();
	                        event.stopPropagation();
	                        show();
	                        setFocusedIndex(-1);
	                    }
	                    break;
	                case "ArrowUp":
	                    if (isListAutocomplete && event.altKey && visible) {
	                        // don't want the cursor to move if there is text
	                        event.preventDefault();
	                        event.stopPropagation();
	                        hide();
	                    }
	                    break;
	                case "Tab":
	                    event.stopPropagation();
	                    hide();
	                    break;
	                case "ArrowRight":
	                    if (isInlineAutocomplete &&
	                        input.selectionStart !== input.selectionEnd) {
	                        var index = focusedIndex !== -1 ? focusedIndex : 0;
	                        hide();
	                        handleAutoComplete(index);
	                    }
	                    break;
	                case "Enter":
	                    if (visible && focusedIndex >= 0) {
	                        event.stopPropagation();
	                        handleAutoComplete(focusedIndex);
	                        hide();
	                    }
	                    break;
	                case "Escape":
	                    if (visible) {
	                        event.stopPropagation();
	                        hide();
	                    }
	                    else if (value) {
	                        event.stopPropagation();
	                        setValue("");
	                    }
	                    break;
	                // no default
	            }
	        } })), activeId = _h.activeId, itemRefs = _h.itemRefs, handleKeyDown = _h.onKeyDown, focusedIndex = _h.focusedIndex, setFocusedIndex = _h.setFocusedIndex;
	    useCloseOnOutsideClick({
	        enabled: visible,
	        element: ref.current,
	        onOutsideClick: hide,
	    });
	    var _j = useFixedPositioning({
	        fixedTo: ref,
	        nodeRef: nodeRef,
	        anchor: anchor,
	        onScroll: function (_event, _a) {
	            var visible = _a.visible;
	            if (closeOnScroll || !visible) {
	                hide();
	            }
	        },
	        onResize: closeOnResize ? hide : undefined,
	        width: listboxWidth,
	        xMargin: xMargin,
	        yMargin: yMargin,
	        vwMargin: vwMargin,
	        vhMargin: vhMargin,
	        transformOrigin: transformOrigin,
	        preventOverlap: preventOverlap,
	        disableSwapping: disableSwapping,
	        disableVHBounds: disableVHBounds,
	    }), listboxRef = _j.ref, style = _j.style, callbacks = _j.callbacks, updateStyle = _j.updateStyle;
	    require$$1.useEffect(function () {
	        if (!focused.current || autocompleted.current) {
	            return;
	        }
	        if (filteredData.length && !visible && value.length && isListAutocomplete) {
	            show();
	        }
	        else if (!filteredData.length && visible) {
	            hide();
	        }
	        // this effect is just for toggling the visibility states as needed if the
	        // value or filter data list changes
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [filteredData, value]);
	    require$$1.useEffect(function () {
	        if (!visible) {
	            setFocusedIndex(-1);
	            return;
	        }
	        updateStyle();
	        // only want to trigger on data changes and setFocusedIndex shouldn't change
	        // anyways
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [visible, filteredData]);
	    return {
	        ref: refHandler,
	        value: value,
	        match: match,
	        visible: visible,
	        activeId: activeId,
	        itemRefs: itemRefs,
	        filteredData: filteredData,
	        fixedStyle: __assign$W(__assign$W({}, style), listboxStyle),
	        transitionHooks: callbacks,
	        listboxRef: listboxRef,
	        handleBlur: handleBlur,
	        handleFocus: handleFocus,
	        handleClick: handleClick,
	        handleChange: handleChange,
	        handleKeyDown: handleKeyDown,
	        handleAutoComplete: handleAutoComplete,
	    };
	}

	var __assign$V = (undefined && undefined.__assign) || function () {
	    __assign$V = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$V.apply(this, arguments);
	};
	var __rest$N = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$f = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$6 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var block$s = bem("rmd-autocomplate");
	var listbox = bem("rmd-listbox");
	var DEFAULT_FILTER_OPTIONS = {
	    trim: true,
	    ignoreWhitespace: true,
	};
	var EMPTY_LIST = [];
	/**
	 * An AutoComplete is an accessible combobox widget that allows for real-time
	 * suggestions as the user types.
	 */
	var AutoComplete = require$$1.forwardRef(function AutoComplete(_a, forwardedRef) {
	    var _b = _a.autoComplete, autoComplete = _b === void 0 ? "list" : _b, data = _a.data, _c = _a.filter, filter = _c === void 0 ? "case-insensitive" : _c, _d = _a.filterOptions, filterOptions = _d === void 0 ? DEFAULT_FILTER_OPTIONS : _d, _e = _a.filterOnNoValue, filterOnNoValue = _e === void 0 ? false : _e, className = _a.className, onBlur = _a.onBlur, onFocus = _a.onFocus, onClick = _a.onClick, onKeyDown = _a.onKeyDown, onChange = _a.onChange, containerProps = _a.containerProps, _f = _a.portal, portal = _f === void 0 ? false : _f, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, listboxStyle = _a.listboxStyle, listboxClassName = _a.listboxClassName, onAutoComplete = _a.onAutoComplete, _g = _a.clearOnAutoComplete, clearOnAutoComplete = _g === void 0 ? false : _g, _h = _a.labelKey, labelKey = _h === void 0 ? "label" : _h, _j = _a.valueKey, valueKey = _j === void 0 ? "value" : _j, _k = _a.getResultId, getResultId$1 = _k === void 0 ? getResultId : _k, _l = _a.getResultLabel, getResultLabel$1 = _l === void 0 ? getResultLabel : _l, _m = _a.getResultValue, getResultValue$1 = _m === void 0 ? getResultValue : _m, _o = _a.highlight, highlight = _o === void 0 ? false : _o, _p = _a.highlightReapeating, highlightReapeating = _p === void 0 ? false : _p, highlightStyle = _a.highlightStyle, highlightClassName = _a.highlightClassName, _q = _a.anchor, anchor = _q === void 0 ? BELOW_CENTER_ANCHOR : _q, _r = _a.listboxWidth, listboxWidth = _r === void 0 ? "equal" : _r, _s = _a.xMargin, xMargin = _s === void 0 ? 0 : _s, _t = _a.yMargin, yMargin = _t === void 0 ? 0 : _t, _u = _a.vwMargin, vwMargin = _u === void 0 ? 16 : _u, _v = _a.vhMargin, vhMargin = _v === void 0 ? 16 : _v, _w = _a.transformOrigin, transformOrigin = _w === void 0 ? true : _w, _x = _a.preventOverlap, preventOverlap = _x === void 0 ? true : _x, _y = _a.disableVHBounds, disableVHBounds = _y === void 0 ? false : _y, _z = _a.disableSwapping, disableSwapping = _z === void 0 ? true : _z, disableShowOnFocus = _a.disableShowOnFocus, _0 = _a.closeOnResize, closeOnResize = _0 === void 0 ? false : _0, _1 = _a.closeOnScroll, closeOnScroll = _1 === void 0 ? false : _1, _2 = _a.omitKeys, omitKeys = _2 === void 0 ? EMPTY_LIST : _2, propValue = _a.value, defaultValue = _a.defaultValue, beforeResultsChildren = _a.beforeResultsChildren, afterResultsChildren = _a.afterResultsChildren, props = __rest$N(_a, ["autoComplete", "data", "filter", "filterOptions", "filterOnNoValue", "className", "onBlur", "onFocus", "onClick", "onKeyDown", "onChange", "containerProps", "portal", "portalInto", "portalIntoId", "listboxStyle", "listboxClassName", "onAutoComplete", "clearOnAutoComplete", "labelKey", "valueKey", "getResultId", "getResultLabel", "getResultValue", "highlight", "highlightReapeating", "highlightStyle", "highlightClassName", "anchor", "listboxWidth", "xMargin", "yMargin", "vwMargin", "vhMargin", "transformOrigin", "preventOverlap", "disableVHBounds", "disableSwapping", "disableShowOnFocus", "closeOnResize", "closeOnScroll", "omitKeys", "value", "defaultValue", "beforeResultsChildren", "afterResultsChildren"]);
	    var id = props.id;
	    var comboboxId = "".concat(id, "-combobox");
	    var suggestionsId = "".concat(id, "-listbox");
	    var isListAutocomplete = autoComplete === "list" || autoComplete === "both";
	    var isInlineAutocomplete = autoComplete === "inline" || autoComplete === "both";
	    var _3 = useAutoComplete({
	        suggestionsId: suggestionsId,
	        defaultValue: defaultValue,
	        data: data,
	        filter: filter,
	        filterOptions: filterOptions,
	        filterOnNoValue: filterOnNoValue,
	        valueKey: valueKey,
	        getResultId: getResultId$1,
	        getResultValue: getResultValue$1,
	        onBlur: onBlur,
	        onFocus: onFocus,
	        onClick: onClick,
	        onChange: onChange,
	        onKeyDown: onKeyDown,
	        forwardedRef: forwardedRef,
	        onAutoComplete: onAutoComplete,
	        clearOnAutoComplete: clearOnAutoComplete,
	        isListAutocomplete: isListAutocomplete,
	        isInlineAutocomplete: isInlineAutocomplete,
	        anchor: anchor,
	        xMargin: xMargin,
	        yMargin: yMargin,
	        vwMargin: vwMargin,
	        vhMargin: vhMargin,
	        transformOrigin: transformOrigin,
	        listboxWidth: listboxWidth,
	        listboxStyle: listboxStyle,
	        preventOverlap: preventOverlap,
	        disableSwapping: disableSwapping,
	        disableVHBounds: disableVHBounds,
	        closeOnResize: closeOnResize,
	        closeOnScroll: closeOnScroll,
	        disableShowOnFocus: disableShowOnFocus,
	    }), ref = _3.ref, match = _3.match, value = _3.value, visible = _3.visible, activeId = _3.activeId, itemRefs = _3.itemRefs, filteredData = _3.filteredData, listboxRef = _3.listboxRef, fixedStyle = _3.fixedStyle, transitionHooks = _3.transitionHooks, handleBlur = _3.handleBlur, handleFocus = _3.handleFocus, handleClick = _3.handleClick, handleChange = _3.handleChange, handleKeyDown = _3.handleKeyDown, handleAutoComplete = _3.handleAutoComplete;
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsx(TextField, __assign$V({}, props, { "aria-autocomplete": autoComplete, "aria-controls": comboboxId, "aria-activedescendant": activeId, autoComplete: "off", value: propValue !== null && propValue !== void 0 ? propValue : match, onBlur: handleBlur, onFocus: handleFocus, onClick: handleClick, onKeyDown: handleKeyDown, onChange: handleChange, ref: ref, className: cn(block$s(), className), containerProps: __assign$V(__assign$V({}, containerProps), { "aria-haspopup": "listbox", "aria-owns": suggestionsId, "aria-expanded": visible, id: comboboxId, role: "combobox" }) })), jsxRuntime.exports.jsx(ScaleTransition, __assign$V({ nodeRef: listboxRef, portal: portal, portalInto: portalInto, portalIntoId: portalIntoId, vertical: true, transitionIn: visible }, transitionHooks, { className: cn(listbox({ temporary: true }), listboxClassName) }, { children: jsxRuntime.exports.jsxs(List, __assign$V({ id: suggestionsId, role: "listbox", style: fixedStyle }, { children: [beforeResultsChildren, filteredData.map(function (datum, i) {
	                            var resultId = getResultId$1(suggestionsId, i);
	                            var optionProps;
	                            if (isListboxOptionProps(datum)) {
	                                optionProps = omit(datum, __spreadArray$6([labelKey, valueKey], __read$f(omitKeys), false));
	                            }
	                            return (jsxRuntime.exports.jsx(Option, __assign$V({}, optionProps, { id: resultId, selected: false, focused: resultId === activeId, ref: itemRefs[i], onClick: function () { return handleAutoComplete(i); } }, { children: jsxRuntime.exports.jsx(HighlightedResult, __assign$V({ id: "".concat(resultId, "-match"), style: highlightStyle, className: highlightClassName, value: propValue !== null && propValue !== void 0 ? propValue : value, enabled: highlight, repeatable: highlightReapeating }, { children: getResultLabel$1(datum, labelKey, value) })) }), resultId));
	                        }), afterResultsChildren] })) }))] }));
	});

	var __assign$U = (undefined && undefined.__assign) || function () {
	    __assign$U = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$U.apply(this, arguments);
	};
	var __rest$M = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$r = bem("rmd-avatar");
	/**
	 * An `Avatar` is generally used to represent objects or people within your app.
	 * The avatar can consist of an image, an icon, or some text to display. When
	 * the avatar is not an image, different themes can be applied to make the
	 * avatar more unique.
	 */
	var Avatar = require$$1.forwardRef(function Avatar(_a, ref) {
	    var _b;
	    var className = _a.className, children = _a.children, src = _a.src, _c = _a.alt, alt = _c === void 0 ? "" : _c, _d = _a.color, color = _d === void 0 ? "" : _d, imgProps = _a.imgProps, referrerPolicy = _a.referrerPolicy, props = __rest$M(_a, ["className", "children", "src", "alt", "color", "imgProps", "referrerPolicy"]);
	    var img;
	    if (src || imgProps) {
	        img = (jsxRuntime.exports.jsx("img", __assign$U({ src: src, alt: alt, referrerPolicy: referrerPolicy }, imgProps, { className: cn(block$r("image"), imgProps === null || imgProps === void 0 ? void 0 : imgProps.className) })));
	    }
	    return (jsxRuntime.exports.jsxs("span", __assign$U({}, props, { ref: ref, className: cn(block$r((_b = {}, _b[color] = color, _b)), className) }, { children: [img, children] })));
	});

	/**
	 * A small util to check if the badge is considered empty.
	 *
	 * @internal
	 */
	function isEmpty(children, disableNullOnZero) {
	    return (!disableNullOnZero &&
	        (children === 0 || children === "0" || children === null));
	}

	var __assign$T = (undefined && undefined.__assign) || function () {
	    __assign$T = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$T.apply(this, arguments);
	};
	var __rest$L = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$q = bem("rmd-badge");
	/**
	 * This component is generally used for displaying notifications with a count
	 * relative to another element with the `BadgeContainer` component. However, it
	 * can be used by itself to display any supplementary content if needed.
	 */
	var Badge = require$$1.forwardRef(function Badge(_a, ref) {
	    var _b;
	    var className = _a.className, _c = _a.theme, theme = _c === void 0 ? "default" : _c, _d = _a.children, children = _d === void 0 ? null : _d, _e = _a.disableNullOnZero, disableNullOnZero = _e === void 0 ? false : _e, props = __rest$L(_a, ["className", "theme", "children", "disableNullOnZero"]);
	    if (isEmpty(children, disableNullOnZero)) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx("span", __assign$T({}, props, { ref: ref, className: cn(block$q((_b = {}, _b[theme] = theme !== "clear", _b)), className) }, { children: children })));
	});

	var __assign$S = (undefined && undefined.__assign) || function () {
	    __assign$S = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$S.apply(this, arguments);
	};
	var __rest$K = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$p = bem("rmd-badge-container");
	/**
	 * This is a really simple component that will just allow you to position a
	 * badge relative to another component.
	 */
	var BadgeContainer = require$$1.forwardRef(function BadgeContainer(_a, ref) {
	    var className = _a.className, children = _a.children, props = __rest$K(_a, ["className", "children"]);
	    return (jsxRuntime.exports.jsx("span", __assign$S({}, props, { className: cn(block$p(), className), ref: ref }, { children: children })));
	});

	var __assign$R = (undefined && undefined.__assign) || function () {
	    __assign$R = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$R.apply(this, arguments);
	};
	var __rest$J = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is a small wrapper for the `Button` component that will automatically
	 * apply the `aria-describedby` attribute when it has been "badged". It also
	 * adds some reasonable defaults for the most common use-case for badges:
	 * notifications.
	 */
	var BadgedButton = require$$1.forwardRef(function BadgedButton(_a, ref) {
	    var _b = _a["aria-label"], ariaLabel = _b === void 0 ? "Notifications" : _b, badgeStyle = _a.badgeStyle, badgeClassName = _a.badgeClassName, badgeRef = _a.badgeRef, propBadgeId = _a.badgeId, propButtonChildren = _a.buttonChildren, _c = _a.buttonType, buttonType = _c === void 0 ? "icon" : _c, badgeTheme = _a.badgeTheme, _d = _a.children, children = _d === void 0 ? null : _d, _e = _a.disableNullOnZero, disableNullOnZero = _e === void 0 ? false : _e, propDescribedBy = _a["aria-describedby"], props = __rest$J(_a, ["aria-label", "badgeStyle", "badgeClassName", "badgeRef", "badgeId", "buttonChildren", "buttonType", "badgeTheme", "children", "disableNullOnZero", "aria-describedby"]);
	    var id = props.id;
	    var buttonChildren = useIcon("notification", propButtonChildren);
	    var badgeId = propBadgeId || "";
	    if (!badgeId && id) {
	        badgeId = "".concat(id, "-badge");
	    }
	    var describedBy = propDescribedBy;
	    if (!isEmpty(children, disableNullOnZero)) {
	        describedBy = cn(describedBy, badgeId);
	    }
	    return (jsxRuntime.exports.jsxs(Button, __assign$R({}, props, { "aria-label": ariaLabel, "aria-describedby": describedBy, ref: ref, buttonType: buttonType }, { children: [buttonChildren, jsxRuntime.exports.jsx(Badge, __assign$R({ id: badgeId, ref: badgeRef, theme: badgeTheme, style: badgeStyle, className: badgeClassName, disableNullOnZero: disableNullOnZero }, { children: children }))] })));
	});

	var __assign$Q = (undefined && undefined.__assign) || function () {
	    __assign$Q = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$Q.apply(this, arguments);
	};
	var __rest$I = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$o = bem("rmd-card");
	/**
	 * This is the root card component that should be used along side all the other
	 * card parts. It adds some general styles and elevation to help show
	 * prominence.
	 */
	var Card = require$$1.forwardRef(function Card(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a.raiseable, raiseable = _b === void 0 ? false : _b, _c = _a.raisable, raisable = _c === void 0 ? raiseable : _c, _d = _a.fullWidth, fullWidth = _d === void 0 ? false : _d, _e = _a.bordered, bordered = _e === void 0 ? false : _e, props = __rest$I(_a, ["className", "children", "raiseable", "raisable", "fullWidth", "bordered"]);
	    return (jsxRuntime.exports.jsx("div", __assign$Q({}, props, { ref: ref, className: cn(block$o({
	            bordered: bordered,
	            shadowed: !bordered,
	            raisable: !bordered && raisable,
	            "full-width": fullWidth,
	        }), className) }, { children: children })));
	});

	var __assign$P = (undefined && undefined.__assign) || function () {
	    __assign$P = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$P.apply(this, arguments);
	};
	var __rest$H = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$n = bem("rmd-card");
	/**
	 * This component is used to dynamically add addons to the `CardHeader`
	 * component. When no children are provided, nothing will be rendered.
	 *
	 * @internal
	 */
	function CardHeaderAddon(_a) {
	    var className = _a.className, children = _a.children, props = __rest$H(_a, ["className", "children"]);
	    if (!children) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx("span", __assign$P({}, props, { className: cn(block$n("header-addon"), className) }, { children: children })));
	}

	var __assign$O = (undefined && undefined.__assign) || function () {
	    __assign$O = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$O.apply(this, arguments);
	};
	var __rest$G = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$m = bem("rmd-card");
	/**
	 * The header for a `Card`. There should only be up to 1 `CardHeader` within a
	 * card and normally contains the `CardTitle` and optionally `CardSubtitle`
	 * components. There is also additional functionality built in to render items
	 * before or after the main children with some additional spacing.
	 */
	var CardHeader = require$$1.forwardRef(function CardHeader(_a, ref) {
	    var _b;
	    var _c = _a.align, align = _c === void 0 ? "center" : _c, className = _a.className, contentClassName = _a.contentClassName, children = _a.children, beforeChildren = _a.beforeChildren, afterChildren = _a.afterChildren, props = __rest$G(_a, ["align", "className", "contentClassName", "children", "beforeChildren", "afterChildren"]);
	    return (jsxRuntime.exports.jsx("header", __assign$O({}, props, { ref: ref, className: cn(block$m("header", (_b = {},
	            _b[align] = align !== "none",
	            _b)), className) }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$O({ icon: jsxRuntime.exports.jsx(CardHeaderAddon, { children: beforeChildren }) }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$O({ icon: jsxRuntime.exports.jsx(CardHeaderAddon, { children: afterChildren }), iconAfter: true }, { children: jsxRuntime.exports.jsx("span", __assign$O({ className: cn(block$m("header-content"), contentClassName) }, { children: children })) })) })) })));
	});

	var __assign$N = (undefined && undefined.__assign) || function () {
	    __assign$N = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$N.apply(this, arguments);
	};
	var __rest$F = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$l = bem("rmd-card");
	/**
	 * The `CardTitle` component should normally be used within the `CardHeader` to
	 * create a nicely styled `<h5>` title for your card. This can also be used
	 * along with the `CardSubtitle` component within the `CardHeader` for a main
	 * title and a subtitle.
	 */
	var CardTitle = require$$1.forwardRef(function CardTitle(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a.small, small = _b === void 0 ? false : _b, _c = _a.noWrap, noWrap = _c === void 0 ? false : _c, props = __rest$F(_a, ["className", "children", "small", "noWrap"]);
	    return (jsxRuntime.exports.jsx("h5", __assign$N({}, props, { ref: ref, className: cn(block$l("title", { small: small }), {
	            "rmd-card--no-wrap": noWrap,
	        }, className) }, { children: children })));
	});

	var __assign$M = (undefined && undefined.__assign) || function () {
	    __assign$M = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$M.apply(this, arguments);
	};
	var __rest$E = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$k = bem("rmd-card");
	/**
	 * A subtitle for the `Card`. This is usually used with the `CardHeader`
	 * component after the `CardTitle`.
	 */
	var CardSubtitle = require$$1.forwardRef(function CardSubtitle(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a.noWrap, noWrap = _b === void 0 ? false : _b, _c = _a.disableSecondaryColor, disableSecondaryColor = _c === void 0 ? false : _c, props = __rest$E(_a, ["className", "children", "noWrap", "disableSecondaryColor"]);
	    return (jsxRuntime.exports.jsx("h6", __assign$M({}, props, { ref: ref, className: cn(block$k("subtitle", {
	            secondary: !disableSecondaryColor,
	        }), {
	            "rmd-card--no-wrap": noWrap,
	        }, className) }, { children: children })));
	});

	var __assign$L = (undefined && undefined.__assign) || function () {
	    __assign$L = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$L.apply(this, arguments);
	};
	var __rest$D = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$j = bem("rmd-card");
	/**
	 * The main content for the `Card`. This adds some additional padding and removes
	 * margin from `<p>` tags by default.
	 */
	var CardContent = require$$1.forwardRef(function CardContent(_a, ref) {
	    var _b = _a.disablePadding, disablePadding = _b === void 0 ? false : _b, _c = _a.disableExtraPadding, disableExtraPadding = _c === void 0 ? false : _c, _d = _a.disableSecondaryColor, disableSecondaryColor = _d === void 0 ? false : _d, _e = _a.disableParagraphMargin, disableParagraphMargin = _e === void 0 ? false : _e, className = _a.className, children = _a.children, props = __rest$D(_a, ["disablePadding", "disableExtraPadding", "disableSecondaryColor", "disableParagraphMargin", "className", "children"]);
	    return (jsxRuntime.exports.jsx("div", __assign$L({}, props, { ref: ref, className: cn(block$j("content", {
	            padded: !disablePadding,
	            "extra-padding": !disablePadding && !disableExtraPadding,
	            "remove-margin": !disableParagraphMargin,
	            secondary: !disableSecondaryColor,
	        }), className) }, { children: children })));
	});

	var __assign$K = (undefined && undefined.__assign) || function () {
	    __assign$K = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$K.apply(this, arguments);
	};
	var __rest$C = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$i = bem("rmd-card");
	/**
	 * This component is generally used to hold the main actions for the `Card`.
	 * It's a good place to add additional buttons or expansion toggles.
	 */
	var CardActions = require$$1.forwardRef(function CardActions(_a, ref) {
	    var _b;
	    var className = _a.className, _c = _a.align, align = _c === void 0 ? "end" : _c, children = _a.children, props = __rest$C(_a, ["className", "align", "children"]);
	    return (jsxRuntime.exports.jsx("div", __assign$K({}, props, { ref: ref, className: cn(block$i("actions", (_b = {},
	            _b[align] = align !== "end",
	            _b)), className) }, { children: children })));
	});

	var __assign$J = (undefined && undefined.__assign) || function () {
	    __assign$J = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$J.apply(this, arguments);
	};
	var __rest$B = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$h = bem("rmd-chip");
	/**
	 * A chip is a simplified and condensed button component that be used to create
	 * compact radio groups, checkboxes, and trigger actions. The chip only has a
	 * `"solid"` and `"outline"` theme but can be raisable once clicked or
	 * selectable with an inline icon. A chip also supports rendering icons, avatars,
	 * or circular progress bars to the left and right of the children.
	 */
	var Chip = require$$1.forwardRef(function Chip(_a, ref) {
	    var _b;
	    var ariaPressed = _a["aria-pressed"], propClassName = _a.className, children = _a.children, _c = _a.theme, theme = _c === void 0 ? "solid" : _c, propLeftIcon = _a.leftIcon, rightIcon = _a.rightIcon, _d = _a.raisable, raisable = _d === void 0 ? false : _d, _e = _a.disabled, disabled = _e === void 0 ? false : _e, selected = _a.selected, _f = _a.selectedThemed, selectedThemed = _f === void 0 ? false : _f, contentStyle = _a.contentStyle, contentClassName = _a.contentClassName, _g = _a.disableContentWrap, disableContentWrap = _g === void 0 ? false : _g, propSelectedIcon = _a.selectedIcon, _h = _a.noninteractable, noninteractable = _h === void 0 ? false : _h, _j = _a.disableIconTransition, disableIconTransition = _j === void 0 ? false : _j, props = __rest$B(_a, ["aria-pressed", "className", "children", "theme", "leftIcon", "rightIcon", "raisable", "disabled", "selected", "selectedThemed", "contentStyle", "contentClassName", "disableContentWrap", "selectedIcon", "noninteractable", "disableIconTransition"]);
	    var _k = useInteractionStates({
	        handlers: props,
	        className: propClassName,
	        disabled: disabled || noninteractable,
	        enablePressedAndRipple: raisable && !noninteractable,
	    }), ripples = _k.ripples, className = _k.className, handlers = _k.handlers;
	    var content = children;
	    if (!disableContentWrap) {
	        content = (jsxRuntime.exports.jsx("span", __assign$J({ style: contentStyle, className: cn(block$h("content"), contentClassName) }, { children: children })));
	    }
	    var leftIcon = propLeftIcon;
	    var selectable = typeof selected === "boolean";
	    var selectedIcon = useIcon("selected", propSelectedIcon);
	    var isHiddenIcon = false;
	    if (selectable &&
	        !selectedThemed &&
	        typeof leftIcon === "undefined" &&
	        selectedIcon) {
	        leftIcon = selectedIcon;
	        if (!disableIconTransition && require$$1.isValidElement(selectedIcon)) {
	            isHiddenIcon = !selected;
	            leftIcon = require$$1.cloneElement(selectedIcon, {
	                className: block$h("selected-icon", { visible: selected }),
	            });
	        }
	        else if (disableIconTransition && !selected) {
	            // don't want to render it when not selected if there's no transition
	            leftIcon = null;
	        }
	    }
	    var leading = leftIcon && !isHiddenIcon;
	    var trailing = rightIcon;
	    var Component = noninteractable ? "span" : "button";
	    var buttonProps = {
	        "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : (!!selected || undefined),
	        type: "button",
	        disabled: disabled,
	    };
	    return (jsxRuntime.exports.jsxs(Component, __assign$J({}, (noninteractable ? {} : buttonProps), props, handlers, { ref: ref, className: cn(block$h((_b = {},
	            _b[theme] = true,
	            _b.disabled = disabled,
	            _b.selected = !disabled && selected && !selectedThemed,
	            _b.themed = !disabled && selected && selectedThemed,
	            _b["solid-disabled"] = disabled && theme === "solid",
	            _b["leading-icon"] = leading && !trailing,
	            _b["trailing-icon"] = trailing && !leading,
	            _b.surrounded = leading && trailing,
	            _b.noninteractable = noninteractable,
	            _b)), className) }, { children: [jsxRuntime.exports.jsx(TextIconSpacing, __assign$J({ icon: leftIcon, beforeClassName: isHiddenIcon ? "" : undefined }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$J({ icon: rightIcon, iconAfter: true }, { children: content })) })), ripples] })));
	});

	var __assign$I = (undefined && undefined.__assign) || function () {
	    __assign$I = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$I.apply(this, arguments);
	};
	var __rest$A = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$g = bem("rmd-expansion-panel");
	/**
	 * The header for a panel that controls the expansion state. This is really just
	 * a simple button that displays the children before an expander icon.
	 *
	 * Reminder: Since this is a `<button>`, only `inline` elements should be
	 * rendered within (so use `<span>` instead of `<div>` for children).
	 */
	var ExpansionPanelHeader = require$$1.forwardRef(function ExpansionPanelHeader(_a, ref) {
	    var propIcon = _a.icon, expanded = _a.expanded, children = _a.children, className = _a.className, _b = _a.disableTransition, disableTransition = _b === void 0 ? false : _b, props = __rest$A(_a, ["icon", "expanded", "children", "className", "disableTransition"]);
	    var icon = useIcon("expander", propIcon);
	    return (jsxRuntime.exports.jsxs(UnstyledButton, __assign$I({}, props, { ref: ref, "aria-expanded": expanded || undefined, className: cn(block$g("header"), className) }, { children: [children, icon && (jsxRuntime.exports.jsx("span", __assign$I({ className: block$g("icon") }, { children: jsxRuntime.exports.jsx(IconRotator, __assign$I({ animate: !disableTransition, rotated: expanded }, { children: icon })) })))] })));
	});

	var __assign$H = (undefined && undefined.__assign) || function () {
	    __assign$H = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$H.apply(this, arguments);
	};
	var __rest$z = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$f = bem("rmd-expansion-panel");
	/**
	 * The expansion panel renders a header element (that is just a button) and
	 * dynamically shows content once expanded.
	 */
	var ExpansionPanel = require$$1.forwardRef(function ExpansionPanel(_a, ref) {
	    var className = _a.className, children = _a.children, headerStyle = _a.headerStyle, headerClassName = _a.headerClassName, contentStyle = _a.contentStyle, contentClassName = _a.contentClassName, headerRef = _a.headerRef, _b = _a.disablePadding, disablePadding = _b === void 0 ? false : _b, _c = _a.disableSecondaryColor, disableSecondaryColor = _c === void 0 ? false : _c, customHeader = _a.customHeader, header = _a.header, expanded = _a.expanded, onExpandClick = _a.onExpandClick, expanderIcon = _a.expanderIcon, _d = _a.marginTop, marginTop = _d === void 0 ? false : _d, _e = _a.fullWidth, fullWidth = _e === void 0 ? true : _e, _f = _a.persistent, persistent = _f === void 0 ? false : _f, _g = _a.disabled, disabled = _g === void 0 ? false : _g, _h = _a.disableTransition, disableTransition = _h === void 0 ? false : _h, props = __rest$z(_a, ["className", "children", "headerStyle", "headerClassName", "contentStyle", "contentClassName", "headerRef", "disablePadding", "disableSecondaryColor", "customHeader", "header", "expanded", "onExpandClick", "expanderIcon", "marginTop", "fullWidth", "persistent", "disabled", "disableTransition"]);
	    var id = props.id;
	    var contentId = "".concat(id, "-content");
	    var _j = useCollapseTransition({
	        style: contentStyle,
	        className: contentClassName,
	        timeout: disableTransition ? 0 : undefined,
	        transitionIn: expanded,
	        temporary: !persistent,
	    }), elementProps = _j.elementProps, rendered = _j.rendered;
	    return (jsxRuntime.exports.jsxs(Card, __assign$H({}, props, { id: "".concat(id, "-container"), ref: ref, fullWidth: fullWidth, className: cn(block$f({ expanded: expanded, "margin-top": marginTop }), className) }, { children: [customHeader || (jsxRuntime.exports.jsx(ExpansionPanelHeader, __assign$H({ "aria-disabled": disabled || undefined, id: id, ref: headerRef, style: headerStyle, className: headerClassName, icon: expanderIcon, expanded: expanded, onClick: onExpandClick, disableTransition: disableTransition }, { children: header }))), rendered && (jsxRuntime.exports.jsx(CardContent, __assign$H({}, elementProps, { id: contentId, "aria-labelledby": id, role: "region", disableSecondaryColor: disableSecondaryColor, disablePadding: disablePadding, disableExtraPadding: true }, { children: children })))] })));
	});

	var __assign$G = (undefined && undefined.__assign) || function () {
	    __assign$G = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$G.apply(this, arguments);
	};
	var __rest$y = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is honestly not very helpful since it does not apply any
	 * styles. It is a simple wrapper for a `<div>` that updates the props to
	 * require the `children` and `onKeyDown` props.
	 */
	var ExpansionList = require$$1.forwardRef(function ExpansionList(_a, ref) {
	    var children = _a.children, props = __rest$y(_a, ["children"]);
	    return (jsxRuntime.exports.jsx("div", __assign$G({}, props, { ref: ref }, { children: children })));
	});

	var __read$e = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @internal
	 */
	var attemptFocus = function (index, panels) {
	    var _a;
	    var panel = (_a = panels[index]) === null || _a === void 0 ? void 0 : _a.headerRef.current;
	    if (panel) {
	        panel.focus();
	    }
	};
	/**
	 * This hook is used to control the expansion of a list of panels along with
	 * providing some of the required props for each panel. This hook will provide
	 * an ordered list of:
	 *
	 * - the list of panel props that include the `id`, `key`, `expanded`, and
	 *   `onExpandChange`.
	 * - a keydown event handler to pass to a parent component (normally the
	 *   ExpansionList) to allow keyboard movement with the arrow keys, and home+end
	 *   keys. This should only be used when there are multiple panels.
	 * - the current list of panel ids that are expanded
	 * - the React setState dispatcher for controlling the expanded list of ids
	 *   manually if desired
	 * - a function to create a handler for toggling the expansion of a specific
	 *   panel
	 *
	 * This hook is usually used to control a list of expansion panels, but can also
	 * control a single panel if desired.
	 *
	 * Examples:
	 *
	 * Single panel:
	 *
	 * ```tsx
	 * const [panels] = usePanels({ count: 1, idPrefix: "my-panel" });
	 * // since the count is one, it'll just be a list of only one panel props
	 * const [panelProps] = panels;
	 *
	 * return (
	 *   <ExpansionPanel {...panelProps}>
	 *     Content within the panel...
	 *   </ExpansionPanel>
	 * );
	 * ```
	 *
	 * Multiple Panels:
	 *
	 * ```tsx
	 * const [panels, onKeyDown] = usePanels({ count: 3, idPrefix: "panel-list" });
	 *
	 * const [panel1Props, panel2Props, panel3Props] = panels;
	 *
	 * return (
	 *   <ExpansionList onKeyDown={onKeyDown}>
	 *     <ExpansionPanel {...panel1Props}>
	 *       Panel 1 Content...
	 *     </ExpansionPanel>
	 *     <ExpansionPanel {...panel2Props}>
	 *       Panel 2 Content...
	 *     </ExpansionPanel>
	 *     <ExpansionPanel {...panel3Props}>
	 *       Panel 3 Content...
	 *     </ExpansionPanel>
	 *   </ExpansionList>
	 * );
	 * ```
	 */
	function usePanels(_a) {
	    var idPrefix = _a.idPrefix, count = _a.count, _b = _a.multiple, multiple = _b === void 0 ? false : _b, _c = _a.preventAllClosed, preventAllClosed = _c === void 0 ? false : _c, defaultExpandedIndex = _a.defaultExpandedIndex;
	    var panels = require$$1.useMemo(function () {
	        return Array.from({ length: count }, function (_, i) { return ({
	            id: "".concat(idPrefix, "-").concat(i + 1),
	            headerRef: require$$1.createRef(),
	        }); });
	    }, [idPrefix, count]);
	    var _d = __read$e(require$$1.useState(function () {
	        if (typeof defaultExpandedIndex === "undefined") {
	            return preventAllClosed ? [panels[0].id] : [];
	        }
	        if (typeof defaultExpandedIndex === "number") {
	            return defaultExpandedIndex === -1
	                ? panels.map(function (_a) {
	                    var id = _a.id;
	                    return id;
	                })
	                : [panels[Math.min(defaultExpandedIndex, panels.length)].id];
	        }
	        return panels
	            .filter(function (_, i) { return defaultExpandedIndex.includes(i); })
	            .map(function (_a) {
	            var id = _a.id;
	            return id;
	        });
	    }), 2), expandedIds = _d[0], setExpandedIds = _d[1];
	    var createExpandClick = function (panelId) { return function () {
	        setExpandedIds(function (prevIds) {
	            var i = prevIds.indexOf(panelId);
	            if (!multiple) {
	                if (prevIds[0] === panelId && prevIds.length === 1) {
	                    return preventAllClosed ? prevIds : [];
	                }
	                return [panelId];
	            }
	            var nextSelectedIds = prevIds.slice();
	            if (i === -1) {
	                nextSelectedIds.push(panelId);
	            }
	            else {
	                nextSelectedIds.splice(i, 1);
	            }
	            if (preventAllClosed && nextSelectedIds.length === 0) {
	                return [panelId];
	            }
	            return nextSelectedIds;
	        });
	    }; };
	    var previousExpanded = false;
	    var panelPropList = panels.map(function (_a, i) {
	        var id = _a.id, headerRef = _a.headerRef;
	        var expanded = expandedIds.includes(id);
	        var marginTop = i > 0 && (expanded || previousExpanded);
	        previousExpanded = expanded;
	        return {
	            id: id,
	            disabled: expanded && preventAllClosed && expandedIds.length === 1,
	            expanded: expanded,
	            headerRef: headerRef,
	            marginTop: marginTop,
	            onExpandClick: createExpandClick(id),
	        };
	    });
	    var onKeyDown = require$$1.useCallback(function (event) {
	        if (event.shiftKey || event.ctrlKey || event.metaKey || event.altKey) {
	            return;
	        }
	        var key = event.key;
	        var increment = key === "ArrowDown";
	        var decrement = key === "ArrowUp";
	        var jumpToFirst = key === "Home";
	        var jumpToLast = key === "End";
	        if (!increment && !decrement && !jumpToFirst && !jumpToLast) {
	            return;
	        }
	        var currentIndex = panels.findIndex(function (_a) {
	            var headerRef = _a.headerRef;
	            return event.target === headerRef.current;
	        });
	        if (currentIndex === -1) {
	            return;
	        }
	        // don't want page scroll behavior
	        event.preventDefault();
	        if (jumpToFirst) {
	            attemptFocus(0, panels);
	            return;
	        }
	        if (jumpToLast) {
	            attemptFocus(panels.length - 1, panels);
	            return;
	        }
	        attemptFocus(loop({
	            value: currentIndex,
	            max: panels.length - 1,
	            increment: increment,
	        }), panels);
	    }, [panels]);
	    return [
	        panelPropList,
	        onKeyDown,
	        expandedIds,
	        setExpandedIds,
	        createExpandClick,
	    ];
	}

	var __assign$F = (undefined && undefined.__assign) || function () {
	    __assign$F = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$F.apply(this, arguments);
	};
	/**
	 * This component allows you to quickly configure different functionality within
	 * `react-md` in one place with reasonable defaults.
	 */
	function Configuration(_a) {
	    var onAppResize = _a.onAppResize, children = _a.children, icons = _a.icons, formTheme = _a.formTheme, _b = _a.defaultDir, defaultDir = _b === void 0 ? DEFAULT_DIR : _b, _c = _a.phoneMaxWidth, phoneMaxWidth = _c === void 0 ? DEFAULT_PHONE_MAX_WIDTH : _c, _d = _a.tabletMinWidth, tabletMinWidth = _d === void 0 ? DEFAULT_TABLET_MIN_WIDTH : _d, _e = _a.tabletMaxWidth, tabletMaxWidth = _e === void 0 ? DEFAULT_TABLET_MAX_WIDTH : _e, _f = _a.desktopMinWidth, desktopMinWidth = _f === void 0 ? DEFAULT_DESKTOP_MIN_WIDTH : _f, _g = _a.desktopLargeMinWidth, desktopLargeMinWidth = _g === void 0 ? DEFAULT_DESKTOP_LARGE_MIN_WIDTH : _g, _h = _a.defaultSize, defaultSize = _h === void 0 ? DEFAULT_APP_SIZE : _h, _j = _a.rippleTimeout, rippleTimeout = _j === void 0 ? DEFAULT_RIPPLE_TIMEOUT : _j, _k = _a.rippleClassNames, rippleClassNames = _k === void 0 ? DEFAULT_RIPPLE_CLASSNAMES : _k, _l = _a.disableRipple, disableRipple = _l === void 0 ? false : _l, _m = _a.disableProgrammaticRipple, disableProgrammaticRipple = _m === void 0 ? false : _m, hoverMode = _a.hoverMode, menuConfiguration = _a.menuConfiguration;
	    return (jsxRuntime.exports.jsx(Dir, __assign$F({ defaultDir: defaultDir }, { children: jsxRuntime.exports.jsx(AppSizeListener, __assign$F({ defaultSize: defaultSize, onChange: onAppResize, phoneMaxWidth: phoneMaxWidth, tabletMinWidth: tabletMinWidth, tabletMaxWidth: tabletMaxWidth, desktopMinWidth: desktopMinWidth, desktopLargeMinWidth: desktopLargeMinWidth }, { children: jsxRuntime.exports.jsx(NestedDialogContextProvider, { children: jsxRuntime.exports.jsx(UserInteractionModeListener, { children: jsxRuntime.exports.jsx(StatesConfig, __assign$F({ disableRipple: disableRipple, disableProgrammaticRipple: disableProgrammaticRipple, rippleTimeout: rippleTimeout, rippleClassNames: rippleClassNames }, { children: jsxRuntime.exports.jsx(HoverModeProvider, __assign$F({}, hoverMode, { children: jsxRuntime.exports.jsx(IconProvider, __assign$F({}, icons, { children: jsxRuntime.exports.jsx(FormThemeProvider, __assign$F({}, formTheme, { children: jsxRuntime.exports.jsx(MenuConfigurationProvider, __assign$F({}, menuConfiguration, { children: children })) })) })) })) })) }) }) })) })));
	}

	var DEFAULT_PHONE_LAYOUT = "temporary";
	var DEFAULT_TABLET_LAYOUT = "toggleable";
	var DEFAULT_LANDSCAPE_TABLET_LAYOUT = "toggleable";
	var DEFAULT_DESKTOP_LAYOUT = "full-height";
	var DEFAULT_LAYOUT_MAIN_CLASSNAMES = {
	    enter: "rmd-layout-transition--enter",
	    enterActive: "rmd-layout-main--nav-offset",
	    enterDone: "rmd-layout-main--nav-offset",
	    exit: "rmd-layout-transition--exit",
	};
	var DEFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES = {
	    enter: "rmd-layout-transition--enter",
	    enterActive: "rmd-layout-nav-toggle--offset",
	    enterDone: "rmd-layout-nav-toggle--offset",
	    exit: "rmd-layout-transition--exit",
	};
	/** @deprecated \@since 5.1.3 use `DEFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES` instead */
	var DEFFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES = DEFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES;

	var __assign$E = (undefined && undefined.__assign) || function () {
	    __assign$E = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$E.apply(this, arguments);
	};
	var __rest$x = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `TreeGroup` component is used to render a tree item's nested items
	 * whenever the `expanded` prop is `true`. It uses the `Collapse` component
	 * behind the scenes to animate in-and-out of view and will fully unrender when
	 * the `expanded` prop is `false`.
	 */
	var TreeGroup = require$$1.forwardRef(function TreeGroup(_a, nodeRef) {
	    var style = _a.style, className = _a.className, collapsed = _a.collapsed, minHeight = _a.minHeight, minPaddingBottom = _a.minPaddingBottom, minPaddingTop = _a.minPaddingTop, timeout = _a.timeout, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, children = _a.children, temporary = _a.temporary, props = __rest$x(_a, ["style", "className", "collapsed", "minHeight", "minPaddingBottom", "minPaddingTop", "timeout", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "children", "temporary"]);
	    var _b = useCollapseTransition({
	        style: style,
	        className: cn("rmd-tree-group", className),
	        nodeRef: nodeRef,
	        minHeight: minHeight,
	        minPaddingBottom: minPaddingBottom,
	        minPaddingTop: minPaddingTop,
	        timeout: timeout,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExit: onExit,
	        onExiting: onExiting,
	        onExited: onExited,
	        temporary: temporary,
	        transitionIn: !collapsed,
	    }), elementProps = _b.elementProps, rendered = _b.rendered;
	    if (!rendered) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx(List, __assign$E({}, props, elementProps, { role: "group" }, { children: children })));
	});

	var __assign$D = (undefined && undefined.__assign) || function () {
	    __assign$D = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$D.apply(this, arguments);
	};
	var __rest$w = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$e = bem("rmd-tree-item");
	/**
	 * The `TreeItemExpanderIcon` is a simple wrapper of the `IconRotator` prop to
	 * be used within a `TreeView`.
	 */
	function TreeItemExpanderIcon(_a) {
	    var className = _a.className, children = _a.children, _b = _a.rotated, rotated = _b === void 0 ? false : _b, props = __rest$w(_a, ["className", "children", "rotated"]);
	    var icon = useIcon("expander", children);
	    return (jsxRuntime.exports.jsx(IconRotator, __assign$D({}, props, { rotated: rotated, className: cn(block$e("rotator-icon"), className) }, { children: icon })));
	}

	var __assign$C = (undefined && undefined.__assign) || function () {
	    __assign$C = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$C.apply(this, arguments);
	};
	var __rest$v = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$d = bem("rmd-tree-item");
	/**
	 * This component renders an item within a tree with optional child items. This
	 * should almost always be used from the `itemRenderer` prop from the `Tree`
	 * component as it provides a lot of the required a11y props for you.
	 */
	var TreeItem = require$$1.forwardRef(function TreeItem(_a, ref) {
	    var _b;
	    var id = _a.id, propClassName = _a.className, liStyle = _a.liStyle, liClassName = _a.liClassName, liRef = _a.liRef, depth = _a.depth, listSize = _a.listSize, itemIndex = _a.itemIndex, renderChildItems = _a.renderChildItems, expanded = _a.expanded, selected = _a.selected, focused = _a.focused, propExpanderIcon = _a.expanderIcon, _c = _a.expanderLeft, expanderLeft = _c === void 0 ? false : _c, textClassName = _a.textClassName, secondaryTextClassName = _a.secondaryTextClassName, _d = _a.textChildren, textChildren = _d === void 0 ? true : _d, primaryText = _a.primaryText, secondaryText = _a.secondaryText, propLeftAddon = _a.leftAddon, _e = _a.leftAddonType, leftAddonType = _e === void 0 ? "icon" : _e, _f = _a.leftAddonPosition, leftAddonPosition = _f === void 0 ? "middle" : _f, propRightAddon = _a.rightAddon, _g = _a.rightAddonType, rightAddonType = _g === void 0 ? "icon" : _g, _h = _a.rightAddonPosition, rightAddonPosition = _h === void 0 ? "middle" : _h, forceAddonWrap = _a.forceAddonWrap, _j = _a.height, height = _j === void 0 ? "auto" : _j, _k = _a.threeLines, threeLines = _k === void 0 ? false : _k, children = _a.children, _l = _a.contentComponent, Content = _l === void 0 ? "span" : _l, propIsLink = _a.isLink, _m = _a.disabled, disabled = _m === void 0 ? false : _m, readOnly = _a.readOnly, onFocus = _a.onFocus, onKeyUp = _a.onKeyUp, onKeyDown = _a.onKeyDown, onClick = _a.onClick, onMouseUp = _a.onMouseUp, onMouseDown = _a.onMouseDown, onMouseLeave = _a.onMouseLeave, onTouchMove = _a.onTouchMove, onTouchEnd = _a.onTouchEnd, onTouchStart = _a.onTouchStart, props = __rest$v(_a, ["id", "className", "liStyle", "liClassName", "liRef", "depth", "listSize", "itemIndex", "renderChildItems", "expanded", "selected", "focused", "expanderIcon", "expanderLeft", "textClassName", "secondaryTextClassName", "textChildren", "primaryText", "secondaryText", "leftAddon", "leftAddonType", "leftAddonPosition", "rightAddon", "rightAddonType", "rightAddonPosition", "forceAddonWrap", "height", "threeLines", "children", "contentComponent", "isLink", "disabled", "readOnly", "onFocus", "onKeyUp", "onKeyDown", "onClick", "onMouseUp", "onMouseDown", "onMouseLeave", "onTouchMove", "onTouchEnd", "onTouchStart"]);
	    var expanderIcon = useIcon("expander", propExpanderIcon);
	    var isLink = typeof propIsLink === "boolean"
	        ? propIsLink
	        : typeof Content !== "string" || Content === "a";
	    var _o = useInteractionStates({
	        disabled: disabled,
	        className: propClassName,
	        handlers: {
	            onKeyUp: onKeyUp,
	            onKeyDown: onKeyDown,
	            onClick: onClick,
	            onMouseUp: onMouseUp,
	            onMouseDown: onMouseDown,
	            onMouseLeave: onMouseLeave,
	            onTouchMove: onTouchMove,
	            onTouchEnd: onTouchEnd,
	            onTouchStart: onTouchStart,
	        },
	        disableSpacebarClick: isLink,
	    }), ripples = _o.ripples, className = _o.className, handlers = _o.handlers;
	    var group;
	    var leftAddon = propLeftAddon;
	    var rightAddon = propRightAddon;
	    if (renderChildItems) {
	        var icon = (jsxRuntime.exports.jsx(TreeItemExpanderIcon, __assign$C({ rotated: expanded }, { children: expanderIcon })));
	        if (expanderLeft) {
	            leftAddon = icon;
	        }
	        else {
	            rightAddon = icon;
	        }
	        group = jsxRuntime.exports.jsx(TreeGroup, __assign$C({ collapsed: !expanded }, { children: renderChildItems() }));
	    }
	    var handleFocus = require$$1.useCallback(function (event) {
	        var _a;
	        if (onFocus) {
	            onFocus(event);
	        }
	        event.preventDefault();
	        (_a = event.currentTarget.closest('[role="tree"]')) === null || _a === void 0 ? void 0 : _a.focus();
	    }, [onFocus]);
	    var a11y = __assign$C(__assign$C({ "aria-expanded": renderChildItems ? expanded : undefined, "aria-selected": selected, "aria-level": depth + 1, "aria-setsize": listSize, "aria-posinset": itemIndex + 1, "aria-disabled": disabled || undefined, id: id, role: "treeitem", tabIndex: -1 }, handlers), { onFocus: handleFocus });
	    var noA11y = { role: "none" };
	    return (jsxRuntime.exports.jsxs("li", __assign$C({}, (isLink ? noA11y : a11y), { ref: liRef, style: liStyle, className: cn(block$d(), liClassName) }, { children: [jsxRuntime.exports.jsxs(Content, __assign$C({}, props, (isLink ? a11y : undefined), { ref: ref, className: cn(block$d("content", (_b = {
	                        link: isLink,
	                        clickable: !disabled && !readOnly
	                    },
	                    _b[height] = height !== "auto" && height !== "normal",
	                    _b["three-lines"] = !!secondaryText && threeLines,
	                    _b.selected = selected,
	                    _b.focused = focused,
	                    _b)), className) }, { children: [jsxRuntime.exports.jsx(ListItemChildren, __assign$C({ textClassName: textClassName, secondaryTextClassName: secondaryTextClassName, textChildren: textChildren, primaryText: primaryText, secondaryText: secondaryText, leftAddon: leftAddon, leftAddonType: leftAddonType, leftAddonPosition: leftAddonPosition, rightAddon: rightAddon, rightAddonType: rightAddonType, rightAddonPosition: rightAddonPosition, forceAddonWrap: forceAddonWrap }, { children: children })), ripples] })), group] })));
	});

	var __assign$B = (undefined && undefined.__assign) || function () {
	    __assign$B = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$B.apply(this, arguments);
	};
	function isElementType(contentComponent) {
	    return typeof contentComponent !== "undefined";
	}
	/**
	 * A "reasonable" default implementation for rendering a tree item that extracts
	 * the most used ListItem props and passes them down to the `TreeItem`.
	 *
	 * This is actually exported from this package so it can be used along with a
	 * custom renderer for all items that have `isCustom` enabled.
	 *
	 * ```tsx
	 * const itemRenderer: TreeItemRenderer<MyTreeItem> = (
	 *   itemProps,
	 *   item,
	 *   treeProps
	 * ) => {
	 *   const { key } = itemProps;
	 *   const { isCustom } = item;
	 *   if (isCustom) {
	 *     return <MyFancyNonTreeItem item={item} key={key} />
	 *   }
	 *
	 *   return defaultTreeItemRenderer(itemProps, item, treeProps);
	 * }
	 * ```
	 *
	 * @param itemProps - The provided tree item props that should be passed down
	 * for keyboard functionality, accessibility, and a `key` for the item.
	 * @param item - The item itself. This is used to extract any of the common
	 * ListItemChildren props.
	 * @param treeProps - The props for the Tree this item is being rendered in.
	 * This is really used so the `expanderLeft`, `expanderIcon`, `labelKey`,
	 * `getItemLabel`, and `getItemProps` can be used to render the TreeItem
	 * itself.
	 * @returns a `TreeItem` or a custom `ReactElement`
	 */
	function defaultTreeItemRenderer(itemProps, item, treeProps) {
	    var treeItem = item;
	    var focused = itemProps.focused, selected = itemProps.selected, expanded = itemProps.expanded;
	    var expanderLeft = treeProps.expanderLeft, expanderIcon = treeProps.expanderIcon, labelKey = treeProps.labelKey, getItemLabel = treeProps.getItemLabel, getItemProps = treeProps.getItemProps, linkComponent = treeProps.linkComponent;
	    var leftAddon = treeItem.leftAddon, leftAddonType = treeItem.leftAddonType, leftAddonPosition = treeItem.leftAddonPosition, rightAddon = treeItem.rightAddon, rightAddonType = treeItem.rightAddonType, rightAddonPosition = treeItem.rightAddonPosition, as = treeItem.as, to = treeItem.to, href = treeItem.href;
	    var isLink;
	    var readOnly;
	    var disabled;
	    var className;
	    var liClassName;
	    if (typeof treeItem.isLink === "boolean") {
	        (isLink = treeItem.isLink);
	    }
	    if (typeof treeItem.readOnly === "boolean") {
	        (readOnly = treeItem.readOnly);
	    }
	    if (typeof treeItem.disabled === "boolean") {
	        (disabled = treeItem.disabled);
	    }
	    if (typeof treeItem.className === "string") {
	        (className = treeItem.className);
	    }
	    if (typeof treeItem.liClassName === "string") {
	        (liClassName = treeItem.liClassName);
	    }
	    var overrides = getItemProps(__assign$B(__assign$B({}, treeItem), { focused: focused, selected: selected, expanded: expanded }));
	    var children = (overrides && overrides.children) || undefined;
	    if (typeof children === "undefined") {
	        children = getItemLabel(treeItem, labelKey);
	    }
	    var contentComponent;
	    if (isElementType(treeItem.contentComponent)) {
	        (contentComponent = treeItem.contentComponent);
	    }
	    if (isLink !== false && (to || href || isLink)) {
	        contentComponent = contentComponent || linkComponent;
	    }
	    return (jsxRuntime.exports.jsx(TreeItem, __assign$B({}, itemProps, { as: as, to: to, href: href, isLink: isLink, contentComponent: contentComponent, readOnly: readOnly, disabled: disabled, leftAddon: leftAddon, leftAddonType: leftAddonType, leftAddonPosition: leftAddonPosition, rightAddon: rightAddon, rightAddonType: rightAddonType, rightAddonPosition: rightAddonPosition, expanderLeft: expanderLeft, expanderIcon: expanderIcon, className: className, liClassName: liClassName }, overrides, { children: children })));
	}

	var __read$d = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$5 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * Gets all the child items for a specific parent item id. If the `recursive`
	 * argument is enabled, all children of the items will also be returned instead
	 * of only the top level items.
	 *
	 * @param data - Either the flattened tree data or a list of all the tree data
	 * to iterate over
	 * @param parentId - The parent id to get children of
	 * @param recursive - Boolean if the children's children should also be returned
	 * @returns a list of all the items for a specific parent item id. Note: if the
	 * recursive param is enabled, the list will be ordered so that the children of
	 * a item will appear before the next item at the same level. So you either need
	 * to sort by `parentId` or something else if you want a specific order.
	 */
	function getChildItems(data, parentId, recursive) {
	    if (recursive === void 0) { recursive = false; }
	    var items = Array.isArray(data) ? data : Object.values(data);
	    return items.reduce(function (list, item) {
	        if (parentId !== item.parentId) {
	            return list;
	        }
	        return __spreadArray$5(__spreadArray$5(__spreadArray$5([], __read$d(list), false), [
	            item
	        ], false), __read$d((recursive ? getChildItems(items, item.itemId, recursive) : [])), false);
	    }, []);
	}

	/**
	 * This will get all the items from the provided itemId up to the root of the
	 * tree that can be used for drag and drop behavior or building a breadcrumb
	 * list.
	 *
	 * @param data - The flattened tree data to navigate.
	 * @param itemId - The item id to start the search at.
	 * @returns an ordered list of the current item followed by all the direct
	 * parents of that item.
	 */
	function getItemsFrom(data, itemId) {
	    var items = [];
	    var currentId = itemId;
	    while (currentId) {
	        var item = data[currentId];
	        currentId = (item && item.parentId) || null;
	        if (item) {
	            items.push(item);
	        }
	    }
	    return items;
	}

	/**
	 * A "reasonable" default implementation for rendering a label for a tree item.
	 *
	 * @internal
	 */
	function defaultGetItemLabel(item, labelKey) {
	    var result = item[labelKey];
	    if (typeof result === "undefined") {
	        result = item.children;
	    }
	    if (typeof result === "undefined") {
	        result = null;
	    }
	    return result;
	}

	/**
	 * A "reasonable" default implementation for the getItemValue prop on a tree
	 * that will warn about items that are not keyboard searchable in non-production
	 * environments.
	 *
	 * @internal
	 */
	function defaultGetItemValue(item, valueKey) {
	    var result = item[valueKey];
	    return "".concat(result);
	}

	/**
	 * A small util for recursively generating a unique id for each tree item based
	 * on the current depth within the tree and the index within the current list.
	 *
	 * @param treeId - The base id of the tree element
	 * @param index - The current index of the item
	 * @param parentIndexes - A list of parent indexes that are joined together with
	 * `'-'` to generate the full id.
	 * @internal
	 */
	function getTreeItemId(treeId, index, parentIndexes) {
	    if (parentIndexes === void 0) { parentIndexes = []; }
	    if (!parentIndexes.length) {
	        return "".concat(treeId, "-item-").concat(index + 1);
	    }
	    return "".concat(treeId, "-item-").concat(parentIndexes.join("-"), "-").concat(index + 1);
	}

	var __read$c = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$4 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	function flatten(_a) {
	    var list = _a.list, item = _a.item, index = _a.index, baseId = _a.baseId, parentIndexes = _a.parentIndexes, valueKey = _a.valueKey, getItemValue = _a.getItemValue;
	    if (item.isCustom) {
	        return list;
	    }
	    var id = getTreeItemId(baseId, index, parentIndexes);
	    var value = getItemValue(item, valueKey);
	    var itemId = item.itemId, parentId = item.parentId, childItems = item.childItems;
	    list.push({
	        id: id,
	        itemId: itemId,
	        parentId: parentId,
	        isParent: !!childItems,
	        value: value,
	    });
	    if (!childItems) {
	        return list;
	    }
	    var nextIndexes = __spreadArray$4(__spreadArray$4([], __read$c(parentIndexes), false), [index + 1], false);
	    childItems.forEach(function (child, childIndex) {
	        flatten({
	            list: list,
	            item: child,
	            index: childIndex,
	            valueKey: valueKey,
	            getItemValue: getItemValue,
	            baseId: baseId,
	            parentIndexes: nextIndexes,
	        });
	    });
	    return list;
	}
	/**
	 * Creates a flattened and ordered list of all the tree items that are current visible
	 * in the DOM based on the expanded ids. This is only required for handling keyboard
	 * navigation with `aria-activedescendant` movement so the items can be "focused" with
	 * typeahead and keyboard movement since the keyboard movement API requires DOM refs
	 * to be passed to each element.
	 *
	 * This flattened list will remove the `childItems` (if it existed) on each item for
	 * simplicity and the child items aren't needed for this flattened list.
	 *
	 * @internal
	 */
	function useFlattenedTreeList(_a) {
	    var id = _a.id, items = _a.items, rootId = _a.rootId, expandedIds = _a.expandedIds, valueKey = _a.valueKey, getItemValue = _a.getItemValue;
	    var flattenedItems = require$$1.useMemo(function () {
	        return items.reduce(function (list, item, index) {
	            return flatten({
	                list: list,
	                item: item,
	                index: index,
	                valueKey: valueKey,
	                getItemValue: getItemValue,
	                baseId: id,
	                parentIndexes: [],
	            });
	        }, []);
	    }, [getItemValue, id, items, valueKey]);
	    var _b = require$$1.useMemo(function () {
	        var index = 0;
	        return flattenedItems.reduce(function (collection, item) {
	            var _a, _b;
	            var parentId = item.parentId, itemId = item.itemId;
	            var isVisible = parentId === rootId;
	            if (parentId !== null && expandedIds.includes(parentId)) {
	                // need to also make sure that the parent is visible
	                isVisible =
	                    ((_b = (_a = collection.itemRefs[parentId]) === null || _a === void 0 ? void 0 : _a.visibleIndex) !== null && _b !== void 0 ? _b : -1) !== -1;
	            }
	            collection.itemRefs[itemId] = {
	                id: item.id,
	                ref: { current: null },
	                visibleIndex: isVisible ? index : -1,
	            };
	            if (isVisible) {
	                index += 1;
	                collection.visibleItems.push(item);
	            }
	            return collection;
	        }, { visibleItems: [], itemRefs: {} });
	    }, [expandedIds, flattenedItems, rootId]), visibleItems = _b.visibleItems, itemRefs = _b.itemRefs;
	    return [visibleItems, itemRefs, flattenedItems];
	}

	var __assign$A = (undefined && undefined.__assign) || function () {
	    __assign$A = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$A.apply(this, arguments);
	};
	var __read$b = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * This util performantly builds a nested list of tree items from a giant flat
	 * list of items by linking items together with the provided `parentId`. This
	 * will also recursively build the tree and _hopefully_ all items will be added.
	 *
	 * If there are no children for a specific item
	 *
	 * TODO: Add a dev-only warning/error if the tree is built, but there are some
	 * items that never referenced another `itemId`
	 *
	 * @internal
	 */
	function buildTree(parentId, items, sort) {
	    var childItems = [];
	    // doing a "reverse" order filter/move so that the items array shrinks while
	    // looping. This makes it so that the entire items array doesn't need to
	    // continually be looped through as more items are added to the tree, only the
	    // remaining items will have to be looped
	    var i = items.length;
	    while (i > 0) {
	        i -= 1;
	        if (items[i] && items[i].parentId === parentId) {
	            var _a = __read$b(items.splice(i, 1), 1), item = _a[0];
	            // shallow cloning so childItems doesn't get applied to the original data
	            // set
	            childItems.unshift(__assign$A({}, item));
	        }
	    }
	    if (!childItems.length) {
	        return undefined;
	    }
	    childItems.forEach(function (childItem) {
	        childItem.childItems = buildTree(childItem.itemId, items, sort);
	    });
	    return sort ? sort(childItems) : childItems;
	}
	/**
	 * This is an internal hook that will create a renderable nested list view of
	 * the tree data.
	 *
	 * @internal
	 * @param tree - The full tree to convert to a nested list representation
	 * @param sort - An optional function that sorts the items at each level
	 * @param rootId - The starting `parentId` to use while building the tree. This
	 * defaults to `null` since this is most likely the general use case, but if
	 * there's a different unique identifier for the "root level" items, that can be
	 * used instead.
	 */
	function useNestedTreeList(tree, sort, rootId) {
	    if (rootId === void 0) { rootId = null; }
	    return require$$1.useMemo(function () { return buildTree(rootId, Object.values(tree), sort) || []; }, [rootId, sort, tree]);
	}

	var __assign$z = (undefined && undefined.__assign) || function () {
	    __assign$z = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$z.apply(this, arguments);
	};
	var __read$a = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$3 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * This is a temporary workaround for allowing the navigation tree to scroll
	 * correctly with keyboard movement since it manually sets the
	 * `overflow: visible` which prevents scrolling. I'll need to think of a better
	 * way to find/get the scrollable element (if any). It might also just go into
	 * the `scrollIntoView` util.
	 *
	 * @remarks \@since 2.5.3
	 * @internal
	 */
	var getScrollContainer = function (target) {
	    if (target.classList.contains("rmd-layout-tree")) {
	        return target.parentElement;
	    }
	    return target;
	};
	/**
	 * This hook handles all the complex and "fun" stuff for selecting keyboard
	 * accessibility within a tree and enabling keyboard movement, selection, and
	 * expansion.
	 *
	 * @internal
	 */
	function useTreeMovement(_a) {
	    var id = _a.id, data = _a.data, rootId = _a.rootId, sort = _a.sort, onBlur = _a.onBlur, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, multiSelect = _a.multiSelect, selectedIds = _a.selectedIds, onItemSelect = _a.onItemSelect, onMultiItemSelect = _a.onMultiItemSelect, expandedIds = _a.expandedIds, onItemExpansion = _a.onItemExpansion, onMultiItemExpansion = _a.onMultiItemExpansion, valueKey = _a.valueKey, getItemValue = _a.getItemValue;
	    var items = useNestedTreeList(data, sort, rootId);
	    var _b = __read$a(useFlattenedTreeList({
	        id: id,
	        items: items,
	        expandedIds: expandedIds,
	        rootId: rootId,
	        valueKey: valueKey,
	        getItemValue: getItemValue,
	    }), 3), visibleItems = _b[0], itemIdRefs = _b[1], flattenedItems = _b[2];
	    var isKeyboard = useIsUserInteractionMode("keyboard");
	    var _c = useActiveDescendantMovement(__assign$z(__assign$z({}, VERTICAL_TREE), { items: visibleItems, baseId: id, getId: function (_baseId, index) {
	            return (visibleItems[index] || { id: "" }).id;
	        }, onSpace: function (focusedIndex) {
	            var item = visibleItems[focusedIndex];
	            if (!item) {
	                return;
	            }
	            var itemId = item.itemId;
	            onItemSelect(itemId);
	        }, onChange: function (data) {
	            var index = data.index, target = data.target, query = data.query;
	            var itemId = visibleItems[index].itemId;
	            // Note: have to do a custom `scrollIntoView` here instead of relying on
	            // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the
	            // tree renders with the ref behavior.
	            var item = itemIdRefs[itemId].ref.current;
	            var container = getScrollContainer(target);
	            if (item &&
	                container &&
	                container.scrollHeight > container.offsetHeight) {
	                scrollIntoView(container, item);
	            }
	            if (!multiSelect) {
	                return;
	            }
	            var isToStart = query.endsWith(exports.JumpMovementKey.ControlShiftHome);
	            var isToEnd = query.endsWith(exports.JumpMovementKey.ControlShiftEnd);
	            if (!isToStart && !isToEnd) {
	                return;
	            }
	            var start = isToStart ? 0 : focusedIndex;
	            var end = isToStart ? focusedIndex + 1 : undefined;
	            var jumpSelectedIds = visibleItems
	                .slice(start, end)
	                .map(function (_a) {
	                var itemId = _a.itemId;
	                return itemId;
	            });
	            var uniqueSelectedIds = Array.from(new Set(__spreadArray$3(__spreadArray$3([], __read$a(selectedIds), false), __read$a(jumpSelectedIds), false)));
	            if (selectedIds.length !== uniqueSelectedIds.length) {
	                onMultiItemSelect(uniqueSelectedIds);
	            }
	        }, onKeyDown: function (event) {
	            var _a, _b, _c, _d;
	            if (onKeyDown) {
	                onKeyDown(event);
	            }
	            var item = visibleItems[focusedIndex];
	            if (!item) {
	                return;
	            }
	            var itemId = item.itemId, parentId = item.parentId, isParent = item.isParent;
	            switch (event.key) {
	                case "Enter": {
	                    if (isParent) {
	                        onItemExpansion(itemId, !expandedIds.includes(itemId));
	                        return;
	                    }
	                    var node = itemIdRefs[itemId].ref.current;
	                    var anchor = node &&
	                        node.getAttribute("role") === "none" &&
	                        node.querySelector("a[href]");
	                    if (!anchor) {
	                        onItemSelect(itemId);
	                        return;
	                    }
	                    // if a user is navigating through the app with a keyboard and presses
	                    // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will
	                    // be forcefully opened in a new tab irregardless of the target
	                    // attribute on the anchor tag. Since a tree doesn't actually focus
	                    // the link in this case, need to "polyfill" it with this workaround.
	                    // the `meta` key is for Mac and `ctrlKey` for Windows
	                    var forceNewTab = event.shiftKey && (event.metaKey || event.ctrlKey);
	                    var prevTarget = anchor.target;
	                    if (forceNewTab) {
	                        anchor.target = "_blank";
	                    }
	                    anchor.click();
	                    if (forceNewTab) {
	                        anchor.target = prevTarget;
	                    }
	                    break;
	                }
	                case "ArrowRight":
	                    if (!isParent) {
	                        return;
	                    }
	                    if (!expandedIds.includes(itemId)) {
	                        onItemExpansion(itemId, true);
	                    }
	                    else {
	                        var nextIndex = focusedIndex + 1;
	                        var nextItem = (_b = itemIdRefs[(_a = visibleItems[nextIndex]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;
	                        setFocusedIndex(nextIndex);
	                        scrollIntoView(event.currentTarget, nextItem);
	                    }
	                    break;
	                case "ArrowLeft":
	                    if (isParent && expandedIds.includes(itemId)) {
	                        onItemExpansion(itemId, false);
	                    }
	                    else if (parentId !== rootId) {
	                        var parentIndex = visibleItems.findIndex(function (item) { return item.itemId === parentId; });
	                        var parentItem = (_d = itemIdRefs[(_c = visibleItems[parentIndex]) === null || _c === void 0 ? void 0 : _c.itemId]) === null || _d === void 0 ? void 0 : _d.ref.current;
	                        setFocusedIndex(parentIndex);
	                        scrollIntoView(event.currentTarget, parentItem);
	                    }
	                    break;
	                case "a": {
	                    if (!multiSelect || !event.ctrlKey) {
	                        return;
	                    }
	                    event.preventDefault();
	                    var allItemIds = visibleItems.map(function (_a) {
	                        var itemId = _a.itemId;
	                        return itemId;
	                    });
	                    if (selectedIds.length === allItemIds.length) {
	                        onMultiItemSelect([]);
	                    }
	                    else {
	                        onMultiItemSelect(allItemIds);
	                    }
	                    break;
	                }
	                case "*": {
	                    var item_1 = visibleItems[focusedIndex];
	                    if (!item_1) {
	                        return;
	                    }
	                    var expectedExpandedIds = visibleItems
	                        .filter(function (_a) {
	                        var isParent = _a.isParent, parentId = _a.parentId;
	                        return isParent && parentId === item_1.parentId;
	                    })
	                        .map(function (_a) {
	                        var itemId = _a.itemId;
	                        return itemId;
	                    });
	                    var nextIds = Array.from(new Set(__spreadArray$3(__spreadArray$3([], __read$a(expandedIds), false), __read$a(expectedExpandedIds), false)));
	                    if (nextIds.length !== expandedIds.length) {
	                        onMultiItemExpansion(nextIds);
	                        // since new items will be rendered, need to also update the focused
	                        // index so the currently active item is still the "focused" item
	                        //
	                        // TODO: Look into a much better way to handle this sort of stuff..
	                        // This still doesn't correctly scroll the active element into view.
	                        // I should probably move all the scroll behavior into a useEffect
	                        // for whenever the focusedIndex changes.
	                        var visibleCount = 0;
	                        var lookup = {};
	                        for (var i = 0; i < flattenedItems.length; i += 1) {
	                            var item_2 = flattenedItems[i];
	                            var isVisible = item_2.parentId === rootId;
	                            if (item_2.parentId !== null && nextIds.includes(item_2.parentId)) {
	                                isVisible = !!lookup[item_2.parentId];
	                            }
	                            lookup[item_2.itemId] = isVisible;
	                            if (itemId === item_2.itemId) {
	                                setFocusedIndex(visibleCount);
	                                return;
	                            }
	                            if (isVisible) {
	                                visibleCount += 1;
	                            }
	                        }
	                    }
	                }
	                // no default
	            }
	        } })), activeId = _c.activeId, handleKeyDown = _c.onKeyDown, focusedIndex = _c.focusedIndex, setFocusedIndex = _c.setFocusedIndex;
	    var lastFocus = require$$1.useRef(0);
	    var handleBlur = require$$1.useCallback(function (event) {
	        if (onBlur) {
	            onBlur(event);
	        }
	        if (document.activeElement &&
	            event.currentTarget.contains(document.activeElement)) {
	            return;
	        }
	        lastFocus.current = focusedIndex;
	        setFocusedIndex(-1);
	    }, [focusedIndex, onBlur, setFocusedIndex]);
	    var handleFocus = require$$1.useCallback(function (event) {
	        var _a, _b;
	        if (onFocus) {
	            onFocus(event);
	        }
	        if (focusedIndex !== -1) {
	            // this happens when a tree item is clicked with the mouse or touch
	            return;
	        }
	        var index = -1;
	        // try to "focus" the first selected itemId if there is a selection.
	        if (selectedIds.length) {
	            index = visibleItems.findIndex(function (item) {
	                return selectedIds.includes(item.itemId);
	            });
	        }
	        // fallback to the first visible tree item if there were no selected ids
	        if (index === -1) {
	            index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));
	        }
	        var currentItem = (_b = itemIdRefs[(_a = visibleItems[index]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;
	        if (currentItem && isKeyboard) {
	            scrollIntoView(getScrollContainer(event.currentTarget), currentItem);
	        }
	        setFocusedIndex(index);
	    }, [
	        focusedIndex,
	        isKeyboard,
	        itemIdRefs,
	        onFocus,
	        selectedIds,
	        setFocusedIndex,
	        visibleItems,
	    ]);
	    var setActiveId = require$$1.useCallback(function (itemId) {
	        var index = visibleItems.findIndex(function (item) { return item.itemId === itemId; });
	        if (index !== -1) {
	            setFocusedIndex(index);
	        }
	    }, [setFocusedIndex, visibleItems]);
	    return {
	        items: items,
	        activeId: activeId,
	        setActiveId: setActiveId,
	        itemIdRefs: itemIdRefs,
	        handleBlur: handleBlur,
	        handleFocus: handleFocus,
	        handleKeyDown: handleKeyDown,
	    };
	}

	var __assign$y = (undefined && undefined.__assign) || function () {
	    __assign$y = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$y.apply(this, arguments);
	};
	var __rest$u = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$9 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$2 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var block$c = bem("rmd-tree");
	var defaultGetItemProps = function () { return undefined; };
	/**
	 * Creates an accessible tree widget that allows you to show hierarchical data
	 * in a list presentation view. This component requires the selection and
	 * expansion state to be provided/controlled but you can use the
	 * `useTreeItemSelection` and `useTreeItemExpansion` hooks for a great starting
	 * point for this functionality.
	 */
	var Tree = require$$1.forwardRef(function Tree(// eslint-disable-line @typescript-eslint/no-explicit-any
	_a, ref) {
	    var id = _a.id, className = _a.className, _b = _a.itemRenderer, itemRenderer = _b === void 0 ? defaultTreeItemRenderer : _b, data = _a.data, _c = _a.multiSelect, multiSelect = _c === void 0 ? false : _c, selectedIds = _a.selectedIds, onItemSelect = _a.onItemSelect, onMultiItemSelect = _a.onMultiItemSelect, expandedIds = _a.expandedIds, onItemExpansion = _a.onItemExpansion, onMultiItemExpansion = _a.onMultiItemExpansion, _d = _a.expanderLeft, expanderLeft = _d === void 0 ? false : _d, propExpanderIcon = _a.expanderIcon, _e = _a.labelKey, labelKey = _e === void 0 ? "name" : _e, _f = _a.valueKey, valueKey = _f === void 0 ? "name" : _f, _g = _a.getItemLabel, getItemLabel = _g === void 0 ? defaultGetItemLabel : _g, _h = _a.getItemValue, getItemValue = _h === void 0 ? defaultGetItemValue : _h, _j = _a.getItemProps, getItemProps = _j === void 0 ? defaultGetItemProps : _j, linkComponent = _a.linkComponent, sort = _a.sort, _k = _a.rootId, rootId = _k === void 0 ? null : _k, onBlur = _a.onBlur, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, props = __rest$u(_a, // eslint-disable-line @typescript-eslint/no-explicit-any
	    ["id", "className", "itemRenderer", "data", "multiSelect", "selectedIds", "onItemSelect", "onMultiItemSelect", "expandedIds", "onItemExpansion", "onMultiItemExpansion", "expanderLeft", "expanderIcon", "labelKey", "valueKey", "getItemLabel", "getItemValue", "getItemProps", "linkComponent", "sort", "rootId", "onBlur", "onFocus", "onKeyDown"]);
	    var expanderIcon = useIcon("dropdown", propExpanderIcon);
	    var _l = useTreeMovement({
	        id: id,
	        data: data,
	        sort: sort,
	        rootId: rootId,
	        onBlur: onBlur,
	        onFocus: onFocus,
	        onKeyDown: onKeyDown,
	        multiSelect: multiSelect,
	        selectedIds: selectedIds,
	        onItemSelect: onItemSelect,
	        onMultiItemSelect: onMultiItemSelect,
	        expandedIds: expandedIds,
	        onItemExpansion: onItemExpansion,
	        onMultiItemExpansion: onMultiItemExpansion,
	        valueKey: valueKey,
	        getItemValue: getItemValue,
	    }), items = _l.items, activeId = _l.activeId, setActiveId = _l.setActiveId, itemIdRefs = _l.itemIdRefs, handleBlur = _l.handleBlur, handleFocus = _l.handleFocus, handleKeyDown = _l.handleKeyDown;
	    var renderChildItems = function (items, depth, parentIndexes) {
	        var listSize = items.length;
	        return items.map(function (item, index) {
	            var _a;
	            var itemId = item.itemId, childItems = item.childItems, isCustom = item.isCustom;
	            var selected = selectedIds.includes(itemId);
	            var expanded = expandedIds.includes(itemId);
	            var id = "";
	            var ref;
	            var visibleIndex = -1;
	            if (!isCustom) {
	                (_a = itemIdRefs[itemId], id = _a.id, ref = _a.ref, visibleIndex = _a.visibleIndex);
	            }
	            var focused = id === activeId;
	            return itemRenderer({
	                key: itemId,
	                id: id,
	                liRef: ref,
	                depth: depth,
	                listSize: listSize,
	                itemIndex: index,
	                selected: selected,
	                expanded: expanded,
	                focused: focused,
	                onClick: function (event) {
	                    event.stopPropagation();
	                    setActiveId(itemId);
	                    onItemSelect(itemId);
	                    if (childItems) {
	                        onItemExpansion(itemId, !expanded);
	                    }
	                },
	                renderChildItems: childItems
	                    ? function () {
	                        return renderChildItems(childItems, depth + 1, __spreadArray$2(__spreadArray$2([], __read$9(parentIndexes), false), [
	                            index + 1,
	                        ], false));
	                    }
	                    : undefined,
	            }, __assign$y(__assign$y({}, item), { visibleIndex: visibleIndex }), __assign$y({ id: id, expanderLeft: expanderLeft, expanderIcon: expanderIcon, multiSelect: multiSelect, labelKey: labelKey, valueKey: valueKey, getItemLabel: getItemLabel, getItemValue: getItemValue, getItemProps: getItemProps, linkComponent: linkComponent, rootId: rootId }, props));
	        });
	    };
	    return (jsxRuntime.exports.jsx(List, __assign$y({}, props, { ref: ref, id: id, "aria-activedescendant": activeId, "aria-multiselectable": multiSelect || undefined, role: "tree", tabIndex: 0, className: cn(block$c(), className), onBlur: handleBlur, onFocus: handleFocus, onKeyDown: handleKeyDown }, { children: renderChildItems(items, 0, []) })));
	});

	var __read$8 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * A hook that implements the base functionality for expanding different tree
	 * items.
	 *
	 * @param defaultExpandedIds - Either a list of tree item ids to be expanded by
	 * default or a function that will return the list of tree item ids to be
	 * expanded by default
	 * @returns An object containing props that can be passed to the `Tree`
	 * component to handle the expansion state within the tree.
	 */
	function useTreeItemExpansion(defaultExpandedIds) {
	    var _a = __read$8(require$$1.useState(defaultExpandedIds), 2), expandedIds = _a[0], setExpandedIds = _a[1];
	    var onItemExpansion = require$$1.useCallback(function (itemId, expanded) {
	        setExpandedIds(function (expandedIds) {
	            var i = expandedIds.indexOf(itemId);
	            if (i === -1 && expanded) {
	                return __spreadArray$1(__spreadArray$1([], __read$8(expandedIds), false), [itemId], false);
	            }
	            if (i !== -1 && !expanded) {
	                var nextIds = expandedIds.slice();
	                nextIds.splice(i, 1);
	                return nextIds;
	            }
	            return expandedIds;
	        });
	    }, []);
	    return {
	        expandedIds: expandedIds,
	        onItemExpansion: onItemExpansion,
	        onMultiItemExpansion: setExpandedIds,
	    };
	}

	var __read$7 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * A hook that implements the base functionality for selecting different tree
	 * items.
	 *
	 * @param defaultSelectedIds - The default list of tree item ids that should be
	 * expanded by default
	 * @param multiSelect - Boolean if the tree can have multiple items selected or
	 * not.
	 * @returns an object containing props that can be passed to the `Tree`
	 * component to handle the selection state within the tree
	 */
	function useTreeItemSelection(defaultSelectedIds, multiSelect) {
	    if (multiSelect === void 0) { multiSelect = false; }
	    var _a = __read$7(require$$1.useState(defaultSelectedIds), 2), selectedIds = _a[0], setSelectedIds = _a[1];
	    var onItemSelect = require$$1.useCallback(function (itemId) {
	        setSelectedIds(function (selectedIds) {
	            if (!multiSelect) {
	                if (selectedIds[0] === itemId && selectedIds.length === 1) {
	                    return selectedIds;
	                }
	                return [itemId];
	            }
	            var i = selectedIds.indexOf(itemId);
	            var nextSelectedIds = selectedIds.slice();
	            if (i === -1) {
	                nextSelectedIds.push(itemId);
	            }
	            else {
	                nextSelectedIds.splice(i, 1);
	            }
	            return nextSelectedIds;
	        });
	    }, [multiSelect]);
	    var onMultiItemSelect = require$$1.useCallback(function (itemIds) {
	        setSelectedIds(itemIds);
	    }, []);
	    return {
	        selectedIds: selectedIds,
	        multiSelect: multiSelect,
	        onItemSelect: onItemSelect,
	        onMultiItemSelect: onMultiItemSelect,
	    };
	}

	var __assign$x = (undefined && undefined.__assign) || function () {
	    __assign$x = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$x.apply(this, arguments);
	};
	var __rest$t = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is the default mini navigation item renderer provided by the layout
	 * package that has some reasonable defaults for creating a navigation tree.
	 *
	 * This renderer behaves a bit differently than the
	 * `defaultNavigationItemRenderer` since it will only render the tree item if:
	 *
	 * - the item is at the root -- `parentId === null`
	 * - the item is a divider at the root
	 * - the item is not a subheader -- there isn't enough space
	 * - the item does not have any child items -- not enough space to show nesting
	 * - the item has a `leftAddon` -- the mini variant only renders icons
	 *
	 * This rendered `TreeItem` will only display the `leftAddon` as the children
	 * but will also render the tree item's label in the `SrOnly` component so an
	 * accessible label still exists for the icon `TreeItem`.
	 *
	 * @see {@link TreeItemRenderer}
	 * @see {@link defaultNavigationItemRenderer}
	 */
	var defaultMiniNavigationItemRenderer = function (itemProps, item, _a) {
	    var _b, _c, _d, _e;
	    var linkComponent = _a.linkComponent, getItemProps = _a.getItemProps, getItemLabel = _a.getItemLabel, labelKey = _a.labelKey;
	    var key = itemProps.key, renderChildItems = itemProps.renderChildItems, props = __rest$t(itemProps, ["key", "renderChildItems"]);
	    var divider = item.divider, subheader = item.subheader, leftAddon = item.leftAddon, parentId = item.parentId, style = item.style, className = item.className, liStyle = item.liStyle, liClassName = item.liClassName, as = item.as, to = item.to, href = item.href, isLink = item.isLink, propContentComponent = item.contentComponent;
	    if (divider && parentId === null) {
	        return jsxRuntime.exports.jsx(Divider, {}, key);
	    }
	    if (subheader || parentId !== null || !leftAddon || renderChildItems) {
	        return null;
	    }
	    var contentComponent = propContentComponent;
	    if (!contentComponent && isLink !== false && (to || href || isLink)) {
	        contentComponent = linkComponent;
	    }
	    var focused = itemProps.focused, selected = itemProps.selected, expanded = itemProps.expanded;
	    var overrides = getItemProps(__assign$x(__assign$x({}, item), { focused: focused, selected: selected, expanded: expanded }));
	    var children = (overrides && overrides.children) || undefined;
	    if (typeof children === "undefined") {
	        children = getItemLabel(item, labelKey);
	    }
	    return (jsxRuntime.exports.jsxs(TreeItem, __assign$x({}, props, { as: as, to: to, href: href, isLink: isLink, contentComponent: contentComponent, style: (_b = overrides === null || overrides === void 0 ? void 0 : overrides.style) !== null && _b !== void 0 ? _b : style, className: cn("rmd-layout-nav__mini-item", (_c = overrides === null || overrides === void 0 ? void 0 : overrides.className) !== null && _c !== void 0 ? _c : className), liStyle: (_d = overrides === null || overrides === void 0 ? void 0 : overrides.liStyle) !== null && _d !== void 0 ? _d : liStyle, liClassName: (_e = overrides === null || overrides === void 0 ? void 0 : overrides.liClassName) !== null && _e !== void 0 ? _e : liClassName, textChildren: false }, { children: [leftAddon, jsxRuntime.exports.jsx(SrOnly, { children: children })] }), key));
	};

	var __assign$w = (undefined && undefined.__assign) || function () {
	    __assign$w = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$w.apply(this, arguments);
	};
	/**
	 * This is the default navigation item renderer provided by the layout package
	 * that has some reasonable defaults for creating a navigation tree. This is
	 * just an extension of the base `defaultTreeItemRenderer` from the
	 * `@react-md/tree` package that adds in some support for also rendering
	 * dividers and subheader elements.
	 */
	var defaultNavigationItemRenderer = function (itemProps, item, treeProps) {
	    var key = itemProps.key;
	    var divider = item.divider, subheader = item.subheader;
	    if (divider) {
	        return jsxRuntime.exports.jsx(Divider, {}, key);
	    }
	    if (subheader) {
	        return (jsxRuntime.exports.jsx(ListSubheader, __assign$w({ role: "none" }, { children: item.children }), key));
	    }
	    return defaultTreeItemRenderer(itemProps, item, treeProps);
	};

	var __assign$v = (undefined && undefined.__assign) || function () {
	    __assign$v = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$v.apply(this, arguments);
	};
	var __rest$s = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$b = bem("rmd-link");
	/**
	 * The `Link` component is used to render links within your app with a basic
	 * styles applied and some additional "security" built-in if using the
	 * `rel="_blank"`. This can be used with a browser routing library like
	 * `react-router` or `reach-router` by providing the `Link` as the
	 * `linkComponent` prop.
	 */
	var Link = require$$1.forwardRef(function Link(_a, ref) {
	    var propClassName = _a.className, _b = _a.component, Component = _b === void 0 ? "a" : _b, propHref = _a.href, children = _a.children, propRel = _a.rel, _c = _a.flexCentered, flexCentered = _c === void 0 ? false : _c, _d = _a.preventMaliciousTarget, preventMaliciousTarget = _d === void 0 ? true : _d, props = __rest$s(_a, ["className", "component", "href", "children", "rel", "flexCentered", "preventMaliciousTarget"]);
	    var target = props.target;
	    var href = propHref === "" ? undefined : propHref;
	    var className = cn(block$b({ "flex-centered": flexCentered }), propClassName);
	    var rel = propRel;
	    if (preventMaliciousTarget &&
	        typeof rel !== "string" &&
	        target === "_blank") {
	        rel = "noopener noreferrer";
	    }
	    return (jsxRuntime.exports.jsx(Component, __assign$v({}, props, { className: className, ref: ref, rel: rel, href: href }, { children: children })));
	});

	var __assign$u = (undefined && undefined.__assign) || function () {
	    __assign$u = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$u.apply(this, arguments);
	};
	var __rest$r = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$a = bem("rmd-link-skip");
	/**
	 * This component allows you to create a screen-reader only/keyboard focusable
	 * only link that allows a user to skip to the main content of the page. This is
	 * extremely useful when you have a lot of navigation items that must be tabbed
	 * through before the main content can be focused and this component should
	 * normally be the first focusable element on your page.
	 */
	var SkipToMainContent = require$$1.forwardRef(function SkipToMainContent(_a, ref) {
	    var _b = _a.id, id = _b === void 0 ? "skip-to-main-content" : _b, _c = _a.children, children = _c === void 0 ? "Skip to main content" : _c, _d = _a.unstyled, unstyled = _d === void 0 ? false : _d, mainId = _a.mainId, className = _a.className, onClick = _a.onClick, props = __rest$r(_a, ["id", "children", "unstyled", "mainId", "className", "onClick"]);
	    var handleClick = require$$1.useCallback(function (event) {
	        if (onClick) {
	            onClick(event);
	        }
	        event.preventDefault();
	        var main = document.getElementById(mainId);
	        if (!main) {
	            return;
	        }
	        main.focus();
	    }, [mainId, onClick]);
	    return (jsxRuntime.exports.jsx(Link, __assign$u({}, props, { id: id, ref: ref, href: "#".concat(mainId), onClick: handleClick, className: cn(block$a({ styled: !unstyled }), className) }, { children: children })));
	});

	/**
	 * Gets the current layout based on the app size and layout configuration.
	 *
	 * @returns The current layout type
	 */
	function getLayoutType(_a) {
	    var appSize = _a.appSize, _b = _a.phoneLayout, phoneLayout = _b === void 0 ? DEFAULT_PHONE_LAYOUT : _b, _c = _a.tabletLayout, tabletLayout = _c === void 0 ? DEFAULT_TABLET_LAYOUT : _c, _d = _a.landscapeTabletLayout, landscapeTabletLayout = _d === void 0 ? DEFAULT_LANDSCAPE_TABLET_LAYOUT : _d, _e = _a.desktopLayout, desktopLayout = _e === void 0 ? DEFAULT_DESKTOP_LAYOUT : _e, _f = _a.largeDesktopLayout, largeDesktopLayout = _f === void 0 ? desktopLayout : _f;
	    var isPhone = appSize.isPhone, isTablet = appSize.isTablet, isLargeDesktop = appSize.isLargeDesktop, isLandscape = appSize.isLandscape;
	    if (isPhone) {
	        return phoneLayout;
	    }
	    if (isTablet) {
	        return isLandscape ? landscapeTabletLayout : tabletLayout;
	    }
	    if (isLargeDesktop) {
	        return largeDesktopLayout;
	    }
	    return desktopLayout;
	}
	/**
	 * Checks if the current `layout` is one of the temporary types
	 *
	 * @param layout - The layout to check against
	 * @returns true if the current layout has a temporary navigation.
	 */
	function isTemporaryLayout(layout) {
	    return layout === "temporary" || layout === "temporary-mini";
	}
	/**
	 * Checks if the current `layout` is one of the toggleable types
	 *
	 * @param layout - The layout to check against
	 * @returns true if the current layout is toggleable.
	 */
	function isToggleableLayout(layout) {
	    return layout === "toggleable" || layout === "toggleable-mini";
	}
	/**
	 * Checks if the current `layout` is `"clipped"`, `"floating"`, or
	 * `"full-height"`.
	 *
	 * @param layout - The layout to check against
	 * @returns true if the current layout is persistent.
	 */
	function isPersistentLayout(layout) {
	    return (layout === "clipped" || layout === "floating" || layout === "full-height");
	}
	/**
	 * Checks if the current `layout` is the `"full-height"` variant.
	 *
	 * @param layout - The layout to check against
	 * @returns true if the current layout is the full height variant.
	 */
	function isFullHeightLayout(layout) {
	    return layout === "full-height";
	}
	/**
	 * Checks if the current `layout` is either `"temporary-mini"` or
	 * `"toggleable-mini"`.
	 *
	 * @param layout - The layout to check against
	 * @returns true if the current layout is the mini variant.
	 * @remarks \@since 2.7.0
	 */
	function isMiniLayout(layout) {
	    return layout === "temporary-mini" || layout === "toggleable-mini";
	}

	var __assign$t = (undefined && undefined.__assign) || function () {
	    __assign$t = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$t.apply(this, arguments);
	};
	var __read$6 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @internal
	 */
	var notInitialized = function (name) { return function () {
	}; };
	var context$4 = require$$1.createContext({
	    baseId: "layout",
	    layout: "temporary",
	    visible: false,
	    showNav: notInitialized(),
	    hideNav: notInitialized(),
	    fixedAppBar: true,
	    isMiniable: false,
	});
	/**
	 * Gets the current layout state and configuration.
	 */
	function useLayoutConfig() {
	    return require$$1.useContext(context$4);
	}
	var Provider$1 = context$4.Provider;
	/**
	 * @remarks \@since 2.6.0
	 * @internal
	 */
	function isToggleableVisible(behavior, layout) {
	    return typeof behavior === "string"
	        ? behavior === layout
	        : behavior && isToggleableLayout(layout);
	}
	/**
	 * Determines the current layout based on the `LayoutConfiguration` and hooks
	 * into the `AppSizeListener` to update on resize. This also initializes the
	 * `LayLayoutContext` so that a custom layout implementation can be used along
	 * with the `useLayoutConfig()` hook and the multiple `Layout` components.
	 */
	function LayoutProvider(_a) {
	    var baseId = _a.baseId, _b = _a.phoneLayout, phoneLayout = _b === void 0 ? DEFAULT_PHONE_LAYOUT : _b, _c = _a.tabletLayout, tabletLayout = _c === void 0 ? DEFAULT_TABLET_LAYOUT : _c, _d = _a.landscapeTabletLayout, landscapeTabletLayout = _d === void 0 ? DEFAULT_LANDSCAPE_TABLET_LAYOUT : _d, _e = _a.desktopLayout, desktopLayout = _e === void 0 ? DEFAULT_DESKTOP_LAYOUT : _e, largeDesktopLayout = _a.largeDesktopLayout, _f = _a.defaultToggleableVisible, defaultToggleableVisible = _f === void 0 ? false : _f, _g = _a.fixedAppBar, fixedAppBar = _g === void 0 ? true : _g, children = _a.children;
	    var appSize = useAppSize();
	    var layout = getLayoutType({
	        appSize: appSize,
	        phoneLayout: phoneLayout,
	        tabletLayout: tabletLayout,
	        landscapeTabletLayout: landscapeTabletLayout,
	        desktopLayout: desktopLayout,
	        largeDesktopLayout: largeDesktopLayout,
	    });
	    var isMiniable = [
	        phoneLayout,
	        tabletLayout,
	        landscapeTabletLayout,
	        desktopLayout,
	        largeDesktopLayout,
	    ].some(function (layout) { return !!layout && isMiniLayout(layout); });
	    var isDesktop = appSize.isDesktop;
	    var _h = __read$6(require$$1.useState((isPersistentLayout(layout) && isDesktop) ||
	        isToggleableVisible(defaultToggleableVisible, layout)), 2), visible = _h[0], setVisible = _h[1];
	    require$$1.useEffect(function () {
	        setVisible(isPersistentLayout(layout) ||
	            isToggleableVisible(defaultToggleableVisible, layout));
	    }, [defaultToggleableVisible, layout]);
	    var showNav = require$$1.useCallback(function () {
	        setVisible(true);
	    }, []);
	    var hideNav = require$$1.useCallback(function () {
	        if (!isPersistentLayout(layout)) {
	            setVisible(false);
	        }
	    }, [layout]);
	    var value = require$$1.useMemo(function () { return ({
	        baseId: baseId,
	        layout: layout,
	        visible: visible,
	        showNav: showNav,
	        hideNav: hideNav,
	        fixedAppBar: fixedAppBar,
	        isMiniable: isMiniable,
	    }); }, [baseId, layout, visible, showNav, hideNav, fixedAppBar, isMiniable]);
	    return jsxRuntime.exports.jsx(Provider$1, __assign$t({ value: value }, { children: children }));
	}

	var __assign$s = (undefined && undefined.__assign) || function () {
	    __assign$s = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$s.apply(this, arguments);
	};
	var __rest$q = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$6 = bem("rmd-layout-title");
	/**
	 * An extremely simple wrapper for the `AppBarTitle` that will automatically
	 * apply an `id` and apply the correct margin for full-height layouts.
	 */
	var LayoutAppBarTitle = require$$1.forwardRef(function LayoutAppBarTitle(_a, ref) {
	    var propId = _a.id, className = _a.className, children = _a.children, props = __rest$q(_a, ["id", "className", "children"]);
	    var _b = useLayoutConfig(), baseId = _b.baseId, layout = _b.layout;
	    var id = propId !== null && propId !== void 0 ? propId : "".concat(baseId, "-title");
	    return (jsxRuntime.exports.jsx(AppBarTitle, __assign$s({}, props, { id: id, ref: ref, className: cn(styles$6({ offset: isFullHeightLayout(layout) }), className) }, { children: children })));
	});

	var __assign$r = (undefined && undefined.__assign) || function () {
	    __assign$r = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$r.apply(this, arguments);
	};
	var __rest$p = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is the default implementation for the navigation toggle button within
	 * the `Layout` component and should normally be the first child for the
	 * `LayoutAppBar`. In addition, this component will automatically update itself
	 * to provide an accessible `aria-label` for screen readers and change to a
	 * toggle button for toggleable layouts.
	 */
	var LayoutNavToggle = require$$1.forwardRef(function LayoutNavToggle(_a, nodeRef) {
	    var propAriaLabel = _a["aria-label"], propAriaPressed = _a["aria-pressed"], propChildren = _a.children, className = _a.className, _b = _a.buttonType, buttonType = _b === void 0 ? "icon" : _b, onClick = _a.onClick, propOffset = _a.offset, rendered = _a.rendered, propTabIndex = _a.tabIndex, _c = _a.timeout, timeout = _c === void 0 ? DEFAULT_SHEET_TIMEOUT : _c, _d = _a.classNames, classNames = _d === void 0 ? DEFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES : _d, props = __rest$p(_a, ["aria-label", "aria-pressed", "children", "className", "buttonType", "onClick", "offset", "rendered", "tabIndex", "timeout", "classNames"]);
	    var icon = useIcon("menu");
	    var _e = useLayoutConfig(), baseId = _e.baseId, layout = _e.layout, showNav = _e.showNav, hideNav = _e.hideNav, visible = _e.visible;
	    var isToggleable = isToggleableLayout(layout);
	    var isTemporary = isTemporaryLayout(layout);
	    var isRendered = rendered;
	    if (typeof isRendered === "undefined") {
	        isRendered = isTemporary || isToggleable;
	    }
	    var offset = propOffset;
	    if (typeof offset === "undefined") {
	        offset = isToggleable && visible;
	    }
	    var elementProps = useCSSTransition({
	        nodeRef: nodeRef,
	        transitionIn: offset,
	        temporary: false,
	        timeout: timeout,
	        classNames: classNames,
	        className: cn("rmd-layout-nav-toggle", className),
	    }).elementProps;
	    if (!isRendered) {
	        return null;
	    }
	    var children = propChildren;
	    if (buttonType === "icon" && typeof children === "undefined") {
	        children = icon;
	    }
	    var tabIndex = propTabIndex;
	    if (typeof tabIndex === "undefined" && visible && isToggleable) {
	        // set to -1 so it isn't tab focusable but is still programmatically
	        // focusable for temporary navigation drawers to re-focus once closed
	        tabIndex = -1;
	    }
	    var ariaPressed = propAriaPressed;
	    if (typeof ariaPressed === "undefined" && isToggleable) {
	        ariaPressed = visible;
	    }
	    var ariaLabel = propAriaLabel;
	    if (typeof ariaLabel === "undefined" &&
	        typeof props["aria-labelledby"] === "undefined") {
	        ariaLabel = isToggleable ? "Navigation" : "Show Navigation";
	    }
	    return (jsxRuntime.exports.jsx(AppBarNav, __assign$r({ id: "".concat(baseId, "-nav-toggle") }, props, elementProps, { "aria-label": ariaLabel, "aria-pressed": ariaPressed, onClick: function (event) {
	            if (onClick) {
	                onClick(event);
	            }
	            if (!visible) {
	                showNav();
	            }
	            else {
	                hideNav();
	            }
	        }, buttonType: buttonType, tabIndex: tabIndex }, { children: children })));
	});

	var __assign$q = (undefined && undefined.__assign) || function () {
	    __assign$q = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$q.apply(this, arguments);
	};
	var __rest$o = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This is the default implementation for an `AppBar` within the `Layout` that
	 * will conditionally render the default `LayoutNavToggle` button and
	 * `AppBarTitle` depending on specific props that were provided.
	 */
	var LayoutAppBar = require$$1.forwardRef(function LayoutAppBar(_a, ref) {
	    var children = _a.children, _b = _a.fixed, fixed = _b === void 0 ? true : _b, propNavToggle = _a.navToggle, navToggleProps = _a.navToggleProps, customTitle = _a.customTitle, titleChildren = _a.title, titleProps = _a.titleProps, props = __rest$o(_a, ["children", "fixed", "navToggle", "navToggleProps", "customTitle", "title", "titleProps"]);
	    var _c = useLayoutConfig(), baseId = _c.baseId, layout = _c.layout;
	    var nav = propNavToggle;
	    if (typeof nav === "undefined") {
	        // set the key to the current layout since we want the button to re-mount
	        // on layout changes so the transition does not occur
	        nav = jsxRuntime.exports.jsx(LayoutNavToggle, __assign$q({}, navToggleProps), layout);
	    }
	    var title = customTitle;
	    if (typeof title === "undefined") {
	        title = (jsxRuntime.exports.jsx(LayoutAppBarTitle, __assign$q({}, titleProps, { children: titleChildren })));
	    }
	    return (jsxRuntime.exports.jsxs(AppBar, __assign$q({ id: "".concat(baseId, "-header") }, props, { ref: ref, fixed: fixed }, { children: [nav, title, children] })));
	});

	var __assign$p = (undefined && undefined.__assign) || function () {
	    __assign$p = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$p.apply(this, arguments);
	};
	var __rest$n = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$5 = bem("rmd-layout-main");
	/**
	 * This is the `<main>` element for your app that has some built in styles to be
	 * able to update based on the current layout types.
	 */
	var LayoutMain = require$$1.forwardRef(function LayoutMain(_a, nodeRef) {
	    var className = _a.className, propTabIndex = _a.tabIndex, _b = _a.component, Component = _b === void 0 ? "main" : _b, propNavOffset = _a.navOffset, _c = _a.headerOffset, headerOffset = _c === void 0 ? false : _c, _d = _a.timeout, propTimeout = _d === void 0 ? DEFAULT_SHEET_TIMEOUT : _d, _e = _a.classNames, classNames = _e === void 0 ? DEFAULT_LAYOUT_MAIN_CLASSNAMES : _e, _f = _a.mini, mini = _f === void 0 ? false : _f, _g = _a.miniHidden, miniHidden = _g === void 0 ? false : _g, props = __rest$n(_a, ["className", "tabIndex", "component", "navOffset", "headerOffset", "timeout", "classNames", "mini", "miniHidden"]);
	    // this makes it so that the SkipToMainContent button can still
	    // focus the `<main>` element, but the `<main>` will no longer be
	    // focused if the user clicks inside. This is super nice since one
	    // of my bigger patterns is to click somewhere then press tab to
	    // focus a specific element. Without this fix, the first element in
	    // the `<main>` tag would be focused instead of the closest focusable
	    // element to the click area.
	    var tabIndex = propTabIndex;
	    if (useIsUserInteractionMode("keyboard") &&
	        typeof propTabIndex === "undefined") {
	        tabIndex = -1;
	    }
	    var _h = useLayoutConfig(), layout = _h.layout, visible = _h.visible, fixedAppBar = _h.fixedAppBar;
	    var navOffset = propNavOffset;
	    if (typeof navOffset === "undefined") {
	        navOffset = visible && !isTemporaryLayout(layout);
	    }
	    var timeout = propTimeout;
	    var prevLayout = require$$1.useRef(layout);
	    if (prevLayout.current !== layout) {
	        // this is kind of weird and hacky, but this will allow for the required
	        // classnames to be applied to the main element based on the current
	        // layout type without needing a unique `key` for the main content. this
	        // is super nice since we really don't want to remount the full app each
	        // time the layout changes.
	        timeout = 0;
	    }
	    var isMini = mini && (fixedAppBar || miniHidden);
	    var isMiniOffset = mini &&
	        navOffset &&
	        !fixedAppBar &&
	        visible &&
	        isToggleableLayout(layout);
	    var elementProps = useCSSTransition({
	        nodeRef: nodeRef,
	        transitionIn: !!navOffset,
	        temporary: false,
	        className: cn(styles$5({
	            mini: isMini && (isTemporaryLayout(layout) || !visible),
	            "nav-offset": isMini,
	            "mini-offset": isMiniOffset,
	            "header-offset": headerOffset,
	        }), className),
	        timeout: timeout,
	        classNames: classNames,
	        onEntered: function () {
	            prevLayout.current = layout;
	        },
	        onExited: function () {
	            prevLayout.current = layout;
	        },
	    }).elementProps;
	    return jsxRuntime.exports.jsx(Component, __assign$p({}, props, elementProps, { tabIndex: tabIndex }));
	});

	var __assign$o = (undefined && undefined.__assign) || function () {
	    __assign$o = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$o.apply(this, arguments);
	};
	var __rest$m = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `LayoutCloseNavigationButton` is used to close the navigation panel for
	 * toggleable layouts.
	 */
	var LayoutCloseNavigationButton = require$$1.forwardRef(function LayoutCloseNavigationButton(_a, ref) {
	    var propId = _a.id, ariaLabelledBy = _a["aria-labelledby"], _b = _a["aria-label"], ariaLabel = _b === void 0 ? ariaLabelledBy ? undefined : "Hide Navigation" : _b, onClick = _a.onClick, _c = _a.first, first = _c === void 0 ? true : _c, _d = _a.last, last = _d === void 0 ? true : _d, _e = _a.buttonType, buttonType = _e === void 0 ? "icon" : _e, propChildren = _a.children, rendered = _a.rendered, props = __rest$m(_a, ["id", "aria-labelledby", "aria-label", "onClick", "first", "last", "buttonType", "children", "rendered"]);
	    var children = useIcon("back", propChildren);
	    var _f = useLayoutConfig(), baseId = _f.baseId, layout = _f.layout, hideNav = _f.hideNav;
	    var handleClick = require$$1.useCallback(function (event) {
	        if (onClick) {
	            onClick(event);
	        }
	        hideNav();
	    }, [onClick, hideNav]);
	    var id = propId !== null && propId !== void 0 ? propId : "".concat(baseId, "-nav-x");
	    var isRendered = rendered !== null && rendered !== void 0 ? rendered : isToggleableLayout(layout);
	    if (!isRendered) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx(AppBarAction, __assign$o({}, props, { id: id, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, ref: ref, first: first, last: last, buttonType: buttonType, onClick: handleClick }, { children: children })));
	});

	var __assign$n = (undefined && undefined.__assign) || function () {
	    __assign$n = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$n.apply(this, arguments);
	};
	var __rest$l = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$4 = bem("rmd-layout-nav-header");
	/**
	 * The default implementation for the `AppBar` within the `LayoutNavigation`
	 * that allows for rendering a title along with the `LayoutCloseNavigationButton`.
	 */
	var LayoutNavigationHeader = require$$1.forwardRef(function LayoutNavigationHeader(_a, ref) {
	    var _b = _a.theme, theme = _b === void 0 ? "clear" : _b, children = _a.children, className = _a.className, closeNav = _a.closeNav, closeNavProps = _a.closeNavProps, propTitle = _a.title, titleProps = _a.titleProps, _c = _a.disableBorderBottom, disableBorderBottom = _c === void 0 ? false : _c, props = __rest$l(_a, ["theme", "children", "className", "closeNav", "closeNavProps", "title", "titleProps", "disableBorderBottom"]);
	    var layout = useLayoutConfig().layout;
	    if (layout === "clipped" || layout === "floating") {
	        return null;
	    }
	    var title = null;
	    if (propTitle) {
	        title = jsxRuntime.exports.jsx(AppBarTitle, __assign$n({}, titleProps, { children: propTitle }));
	    }
	    var action = closeNav;
	    if (typeof action === "undefined") {
	        action = jsxRuntime.exports.jsx(LayoutCloseNavigationButton, __assign$n({}, closeNavProps));
	    }
	    return (jsxRuntime.exports.jsxs(AppBar, __assign$n({}, props, { ref: ref, theme: theme, className: cn(styles$4({ bordered: !disableBorderBottom }), className) }, { children: [title, children, action] })));
	});

	var __assign$m = (undefined && undefined.__assign) || function () {
	    __assign$m = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$m.apply(this, arguments);
	};
	var __rest$k = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read$5 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var styles$3 = bem("rmd-layout-nav");
	/**
	 * Renders the navigation tree for the Layout component that adds some
	 * reasonable defaults to work with navigation items.
	 */
	var LayoutTree = require$$1.forwardRef(function LayoutTree(_a, ref) {
	    var propId = _a.id, ariaLabelledBy = _a["aria-labelledby"], _b = _a["aria-label"], ariaLabel = _b === void 0 ? ariaLabelledBy ? undefined : "Navigation" : _b, className = _a.className, _c = _a.mini, mini = _c === void 0 ? false : _c, _d = _a.sticky, sticky = _d === void 0 ? false : _d, navStyle = _a.navStyle, navClassName = _a.navClassName, navItems = _a.navItems, _e = _a.labelKey, labelKey = _e === void 0 ? "children" : _e, _f = _a.valueKey, valueKey = _f === void 0 ? "children" : _f, _g = _a.itemRenderer, itemRenderer = _g === void 0 ? defaultNavigationItemRenderer : _g, _h = _a.miniItemRenderer, miniItemRenderer = _h === void 0 ? defaultMiniNavigationItemRenderer : _h, selectedIds = _a.selectedIds, _j = _a.disableTemporaryAutoclose, disableTemporaryAutoclose = _j === void 0 ? false : _j, props = __rest$k(_a, ["id", "aria-labelledby", "aria-label", "className", "mini", "sticky", "navStyle", "navClassName", "navItems", "labelKey", "valueKey", "itemRenderer", "miniItemRenderer", "selectedIds", "disableTemporaryAutoclose"]);
	    var _k = useLayoutConfig(), baseId = _k.baseId, layout = _k.layout, hideNav = _k.hideNav, visible = _k.visible;
	    var _l = __read$5(selectedIds, 1), selectedId = _l[0];
	    var lastSelectedId = require$$1.useRef(selectedId);
	    var isTemporary = isTemporaryLayout(layout);
	    var id = propId !== null && propId !== void 0 ? propId : "".concat(baseId, "-navigation-tree");
	    require$$1.useEffect(function () {
	        if (disableTemporaryAutoclose ||
	            !isTemporary ||
	            !visible ||
	            lastSelectedId.current === selectedId) {
	            // need to update the lastSelectedId since the selectedId might've changed
	            // by a route change OUTSIDE of the navigation drawer. if it isn't
	            // updated, it'll automatically close the next time it is opened.
	            lastSelectedId.current = selectedId;
	            return;
	        }
	        lastSelectedId.current = selectedId;
	        hideNav();
	    }, [disableTemporaryAutoclose, isTemporary, visible, hideNav, selectedId]);
	    return (jsxRuntime.exports.jsx("nav", __assign$m({ id: "".concat(id, "-nav"), style: navStyle, className: cn(styles$3({ sticky: sticky, grow: !sticky }), navClassName) }, { children: jsxRuntime.exports.jsx(Tree, __assign$m({}, props, { id: id, ref: ref, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, data: navItems, labelKey: labelKey, valueKey: valueKey, selectedIds: selectedIds, itemRenderer: mini ? miniItemRenderer : itemRenderer, className: cn("rmd-layout-tree", className) })) })));
	});

	var __assign$l = (undefined && undefined.__assign) || function () {
	    __assign$l = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$l.apply(this, arguments);
	};
	var __rest$j = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$2 = bem("rmd-layout-navigation");
	/**
	 * The container for the main navigation within the `Layout` that renders
	 * differently depending on the current layout type.
	 */
	var LayoutNavigation = require$$1.forwardRef(function LayoutNavigation(_a, ref) {
	    var propId = _a.id, _b = _a["aria-label"], ariaLabel = _b === void 0 ? "Navigation" : _b, ariaLabelledby = _a["aria-labelledby"], className = _a.className, children = _a.children, _c = _a.mini, mini = _c === void 0 ? false : _c, propHeader = _a.header, headerProps = _a.headerProps, headerTitle = _a.headerTitle, headerTitleProps = _a.headerTitleProps, closeNav = _a.closeNav, closeNavProps = _a.closeNavProps, treeProps = _a.treeProps, _d = _a.sticky, sticky = _d === void 0 ? false : _d, _e = _a.miniNavItemRenderer, miniNavItemRenderer = _e === void 0 ? defaultMiniNavigationItemRenderer : _e, props = __rest$j(_a, ["id", "aria-label", "aria-labelledby", "className", "children", "mini", "header", "headerProps", "headerTitle", "headerTitleProps", "closeNav", "closeNavProps", "treeProps", "sticky", "miniNavItemRenderer"]);
	    var _f = useLayoutConfig(), baseId = _f.baseId, layout = _f.layout, isNonMiniVisible = _f.visible, hideNav = _f.hideNav;
	    var visible = mini || isNonMiniVisible;
	    var id = propId || "".concat(baseId, "-").concat(mini ? "mini-" : "", "nav-container");
	    var isTemporary = !mini && isTemporaryLayout(layout);
	    var isPersistent = mini || isPersistentLayout(layout);
	    var isToggleable = !mini && isToggleableLayout(layout);
	    var floating = layout === "floating";
	    var header = propHeader;
	    if (!mini && typeof header === "undefined") {
	        header = (jsxRuntime.exports.jsx(LayoutNavigationHeader, __assign$l({ closeNav: closeNav, closeNavProps: closeNavProps, title: headerTitle, titleProps: headerTitleProps }, headerProps)));
	    }
	    return (require$$1.createElement(Sheet, __assign$l({}, props, { key: layout, id: id, ref: ref, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, role: !isPersistent ? "dialog" : "none", visible: visible, onRequestClose: hideNav, 
	        // do not want to portal for the other types so that logical tab order
	        // is preserved
	        portal: isTemporary, overlay: isTemporary, disableScrollLock: !isTemporary, disableTabFocusWrap: isToggleable, disableNestedDialogFixes: mini, className: cn(styles$2({
	            mini: mini,
	            sticky: sticky,
	            floating: floating,
	            "header-offset": layout === "clipped" || floating,
	        }), className) }),
	        header,
	        treeProps && (jsxRuntime.exports.jsx(LayoutTree, __assign$l({ miniItemRenderer: miniNavItemRenderer, sticky: mini && sticky }, treeProps, { mini: mini }))),
	        children));
	});

	var __assign$k = (undefined && undefined.__assign) || function () {
	    __assign$k = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$k.apply(this, arguments);
	};
	var __rest$i = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles$1 = bem("rmd-layout-mini-wrapper");
	/**
	 * This is probably an internal only component.
	 *
	 * @remarks \@since 2.8.3
	 */
	function MiniLayoutWrapper(_a) {
	    var mini = _a.mini, miniHidden = _a.miniHidden, miniNav = _a.miniNav, miniNavItems = _a.miniNavItems, treeProps = _a.treeProps, header = _a.header, headerProps = _a.headerProps, headerTitle = _a.headerTitle, headerTitleProps = _a.headerTitleProps, closeNav = _a.closeNav, closeNavProps = _a.closeNavProps, children = _a.children, containerProps = _a.containerProps, props = __rest$i(_a, ["mini", "miniHidden", "miniNav", "miniNavItems", "treeProps", "header", "headerProps", "headerTitle", "headerTitleProps", "closeNav", "closeNavProps", "children", "containerProps"]);
	    var _b = useLayoutConfig(), fixedAppBar = _b.fixedAppBar, isMiniable = _b.isMiniable;
	    if ((!mini && !isMiniable) || !treeProps || typeof miniNav !== "undefined") {
	        return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [miniNav, children] }));
	    }
	    var miniTreeProps = treeProps;
	    if (miniNavItems) {
	        miniTreeProps = __assign$k(__assign$k({}, miniTreeProps), { navItems: miniNavItems });
	    }
	    var miniNavigation = (jsxRuntime.exports.jsx(LayoutNavigation, __assign$k({ header: header, headerProps: headerProps, headerTitle: headerTitle, headerTitleProps: headerTitleProps, closeNav: closeNav, closeNavProps: closeNavProps, treeProps: miniTreeProps }, props, { mini: true, sticky: !fixedAppBar, hidden: miniHidden })));
	    if (fixedAppBar) {
	        return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [miniNavigation, children] }));
	    }
	    return (jsxRuntime.exports.jsxs("div", __assign$k({}, containerProps, { className: cn(!miniHidden && mini && styles$1(), containerProps === null || containerProps === void 0 ? void 0 : containerProps.className) }, { children: [mini && miniNavigation, children] })));
	}

	var __assign$j = (undefined && undefined.__assign) || function () {
	    __assign$j = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$j.apply(this, arguments);
	};
	var __read$4 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * The only purpose of this component is to render the children and different
	 * parts of the `Layout` depending on the current layout that is active. Since
	 * the `Layout` component defines the provider itself, this has to be a child
	 * component to get the resolved `layout` type.
	 *
	 * @remarks \@since 2.7.0
	 * @internal
	 */
	function LayoutChildren(_a) {
	    var _b = _a.id, id = _b === void 0 ? "layout" : _b, propAppBar = _a.appBar, appBarProps = _a.appBarProps, customTitle = _a.customTitle, title = _a.title, titleProps = _a.titleProps, navToggle = _a.navToggle, navToggleProps = _a.navToggleProps, _c = _a.navAfterAppBar, navAfterAppBar = _c === void 0 ? false : _c, propNav = _a.nav, miniNav = _a.miniNav, miniNavItems = _a.miniNavItems, miniWrapperProps = _a.miniWrapperProps, navHeader = _a.navHeader, navHeaderProps = _a.navHeaderProps, navHeaderTitle = _a.navHeaderTitle, navHeaderTitleProps = _a.navHeaderTitleProps, closeNav = _a.closeNav, closeNavProps = _a.closeNavProps, treeProps = _a.treeProps, navProps = _a.navProps, skipProps = _a.skipProps, mainProps = _a.mainProps, children = _a.children;
	    var mainId = (mainProps === null || mainProps === void 0 ? void 0 : mainProps.id) || "".concat(id, "-main");
	    var _d = useLayoutConfig(), layout = _d.layout, visible = _d.visible, fixedAppBar = _d.fixedAppBar;
	    var mini = isMiniLayout(layout);
	    var _e = __read$4(require$$1.useState(visible), 2), miniHidden = _e[0], setMiniHidden = _e[1];
	    // when the layout changes, the hidden state for the mini drawer must also be
	    // updated
	    require$$1.useEffect(function () {
	        setMiniHidden(visible);
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [layout]);
	    var appBar = propAppBar;
	    if (typeof appBar === "undefined") {
	        appBar = (jsxRuntime.exports.jsx(LayoutAppBar, __assign$j({}, appBarProps, { customTitle: customTitle, title: title, titleProps: titleProps, navToggle: navToggle, navToggleProps: navToggleProps })));
	    }
	    var nav = propNav;
	    if (typeof nav === "undefined") {
	        nav = (jsxRuntime.exports.jsx(LayoutNavigation, __assign$j({ header: navHeader, headerProps: navHeaderProps, headerTitle: navHeaderTitle, headerTitleProps: navHeaderTitleProps, closeNav: closeNav, closeNavProps: closeNavProps, treeProps: treeProps }, navProps, { onEntered: function (appearing) {
	                var _a;
	                (_a = navProps === null || navProps === void 0 ? void 0 : navProps.onEntered) === null || _a === void 0 ? void 0 : _a.call(navProps, appearing);
	                setMiniHidden(true);
	            }, onExit: function () {
	                var _a;
	                (_a = navProps === null || navProps === void 0 ? void 0 : navProps.onExit) === null || _a === void 0 ? void 0 : _a.call(navProps);
	                setMiniHidden(false);
	            } })));
	    }
	    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsx(SkipToMainContent, __assign$j({}, skipProps, { mainId: mainId })), navAfterAppBar && appBar, nav, !navAfterAppBar && appBar, jsxRuntime.exports.jsx(MiniLayoutWrapper, __assign$j({ mini: mini, miniNav: miniNav, miniHidden: miniHidden, containerProps: miniWrapperProps, miniNavItems: miniNavItems, treeProps: treeProps, header: navHeader, headerProps: navHeaderProps, headerTitle: navHeaderTitle, headerTitleProps: navHeaderTitleProps, closeNav: closeNav, closeNavProps: closeNavProps }, { children: jsxRuntime.exports.jsx(LayoutMain, __assign$j({ headerOffset: fixedAppBar, mini: mini, miniHidden: miniHidden }, mainProps, { id: mainId }, { children: children })) }))] }));
	}

	var __assign$i = (undefined && undefined.__assign) || function () {
	    __assign$i = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$i.apply(this, arguments);
	};
	var __rest$h = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The layout to use for your app. There are 9 different types of layouts
	 * supported out of the box that work for a decent amount of apps out of the
	 * box.
	 *
	 * Note: You will need to ensure that the base `Configuration` component is a
	 * parent of this `Layout` component to work since it relies on the
	 * `AppSizeContext` for automatically updating the layout based on media
	 * queries.
	 */
	function Layout(_a) {
	    var _b, _c;
	    var _d = _a.id, id = _d === void 0 ? "layout" : _d, _e = _a.phoneLayout, phoneLayout = _e === void 0 ? DEFAULT_PHONE_LAYOUT : _e, _f = _a.tabletLayout, tabletLayout = _f === void 0 ? DEFAULT_TABLET_LAYOUT : _f, _g = _a.landscapeTabletLayout, landscapeTabletLayout = _g === void 0 ? DEFAULT_LANDSCAPE_TABLET_LAYOUT : _g, _h = _a.desktopLayout, desktopLayout = _h === void 0 ? DEFAULT_DESKTOP_LAYOUT : _h, largeDesktopLayout = _a.largeDesktopLayout, _j = _a.defaultToggleableVisible, defaultToggleableVisible = _j === void 0 ? false : _j, props = __rest$h(_a, ["id", "phoneLayout", "tabletLayout", "landscapeTabletLayout", "desktopLayout", "largeDesktopLayout", "defaultToggleableVisible"]);
	    return (jsxRuntime.exports.jsx(LayoutProvider, __assign$i({ baseId: id, fixedAppBar: (_c = (_b = props.appBarProps) === null || _b === void 0 ? void 0 : _b.fixed) !== null && _c !== void 0 ? _c : typeof props.appBar === "undefined", phoneLayout: phoneLayout, tabletLayout: tabletLayout, landscapeTabletLayout: landscapeTabletLayout, desktopLayout: desktopLayout, largeDesktopLayout: largeDesktopLayout, defaultToggleableVisible: defaultToggleableVisible }, { children: jsxRuntime.exports.jsx(LayoutChildren, __assign$i({ id: id }, props)) })));
	}

	var __read$3 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * @internal
	 */
	var getParentIds = function (itemId, navItems) {
	    return getItemsFrom(navItems, itemId).map(function (_a) {
	        var itemId = _a.itemId;
	        return itemId;
	    });
	};
	/**
	 * This is used to disable the item select and multi item select functionality
	 * since only one id can be selected at a time, and it'll always be the current
	 * pathname's itemId
	 *
	 * @internal
	 */
	var noop = function () {
	    // do nothing
	};
	/**
	 * This used to just be `pathname.replace(/\?.*$/, "")` but that can apparently
	 * cause performance issues or a DoS attack if the pathname contains multiple
	 * ?`?` (shouldn't really be possible though)
	 *
	 * @remarks \@since 2.9.0
	 */
	var removeQueryParams = function (pathname) {
	    var i = pathname.indexOf("?");
	    if (i === -1) {
	        return pathname;
	    }
	    return pathname.substring(0, i);
	};
	/**
	 * This is a pretty reasonable default implementation for having a navigation
	 * tree within the Layout component. The way it'll work is that the current
	 * route will be the only selected item within the tree. When the pathname
	 * changes, the selectedIds will be updated to only be the current pathname once
	 * again.
	 *
	 * This means that you can use whatever routing library or history provider that
	 * ensures that your layout re-renders on a path change.
	 *
	 * @see LayoutNavigationTree for description of the navItems
	 * @param navItems - All the navigation items within your layout. This is used
	 * for determining which parent tree items should be expanded when the route
	 * changes so the current route won't be hidden from view. This sort of flow
	 * happens if you have a link outside of the navigation tree.
	 * @param pathname - The current pathname
	 * @param linkComponent - The link component to use within the navigation tree
	 * for any item that has a `to` or `href` attribute. This defaults to the `Link`
	 * from `@react-md/link` but should be changed to whatever link component you
	 * need if using a routing library like `react-router`.
	 * @returns the required `Tree` selection and expansion state and handlers that
	 * should be passed to the `Layout` component.
	 */
	function useLayoutNavigation(navItems, pathname, linkComponent) {
	    if (linkComponent === void 0) { linkComponent = Link; }
	    var itemId = removeQueryParams(pathname);
	    var _a = useTreeItemExpansion(function () { return getParentIds(itemId, navItems); }), expandedIds = _a.expandedIds, onItemExpansion = _a.onItemExpansion, onMultiItemExpansion = _a.onMultiItemExpansion;
	    require$$1.useEffect(function () {
	        onMultiItemExpansion(function (prevExpandedIds) {
	            var nextExpandedIds = __spreadArray([], __read$3(new Set(__spreadArray(__spreadArray([], __read$3(prevExpandedIds), false), __read$3(getParentIds(itemId, navItems)), false))), false);
	            if (nextExpandedIds.length !== prevExpandedIds.length) {
	                return nextExpandedIds;
	            }
	            var prevSorted = prevExpandedIds.slice().sort();
	            var nextSorted = nextExpandedIds.slice().sort();
	            return nextSorted.some(function (itemId, index) { return itemId !== prevSorted[index]; })
	                ? nextSorted
	                : prevSorted;
	        });
	    }, [itemId, navItems, onMultiItemExpansion]);
	    return {
	        navItems: navItems,
	        multiSelect: false,
	        selectedIds: [itemId],
	        onItemSelect: noop,
	        onMultiItemSelect: noop,
	        expandedIds: expandedIds,
	        onItemExpansion: onItemExpansion,
	        onMultiItemExpansion: onMultiItemExpansion,
	        linkComponent: linkComponent,
	    };
	}

	var __assign$h = (undefined && undefined.__assign) || function () {
	    __assign$h = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$h.apply(this, arguments);
	};
	var __rest$g = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$9 = bem("rmd-media-container");
	/**
	 * The `MediaContainer` component is used to make responsive images and videos
	 * within your app. This component also allows for forcing a specific aspect
	 * ratio for these elements with both the `height` and `width` props are
	 * provided.
	 */
	var MediaContainer = require$$1.forwardRef(function MediaContainer(_a, ref) {
	    var className = _a.className, height = _a.height, width = _a.width, children = _a.children, _b = _a.auto, auto = _b === void 0 ? true : _b, _c = _a.fullWidth, fullWidth = _c === void 0 ? false : _c, props = __rest$g(_a, ["className", "height", "width", "children", "auto", "fullWidth"]);
	    var aspectRatio = height && width ? "rmd-media-container--".concat(width, "-").concat(height) : "";
	    return (jsxRuntime.exports.jsx("div", __assign$h({}, props, { ref: ref, className: cn(block$9({
	            auto: auto,
	            "aspect-ratio": aspectRatio,
	            "full-width": fullWidth,
	        }), aspectRatio, className) }, { children: children })));
	});

	var __assign$g = (undefined && undefined.__assign) || function () {
	    __assign$g = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$g.apply(this, arguments);
	};
	var __rest$f = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `MediaOverlay` component is used to create an overlay over specific media
	 * items within the `MediaContainer` component. You will need to apply most of
	 * your own styles as this is really just used for positioning.
	 */
	var MediaOverlay = require$$1.forwardRef(function MediaOverlay(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a.position, position = _b === void 0 ? "bottom" : _b, props = __rest$f(_a, ["className", "children", "position"]);
	    return (jsxRuntime.exports.jsx("div", __assign$g({}, props, { ref: ref, className: cn("rmd-media-overlay rmd-media-overlay--".concat(position), className) }, { children: children })));
	});

	var __assign$f = (undefined && undefined.__assign) || function () {
	    __assign$f = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$f.apply(this, arguments);
	};
	var __rest$e = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * An extremely "useful" component that should be used with the `Table`
	 * component if you want to make a responsive table within the page. If you
	 * don't want to use this component, you can just apply `overflow: auto` to a
	 * parent element of the table.
	 */
	var TableContainer = require$$1.forwardRef(function TableContainer(_a, ref) {
	    var className = _a.className, children = _a.children, props = __rest$e(_a, ["className", "children"]);
	    return (jsxRuntime.exports.jsx("div", __assign$f({}, props, { ref: ref, className: cn("rmd-table-container", className) }, { children: children })));
	});

	var context$3 = require$$1.createContext({
	    header: false,
	    hAlign: "left",
	    vAlign: "middle",
	    lineWrap: false,
	    disableHover: false,
	    disableBorders: false,
	});
	/**
	 * An internal hook for getting the current table configuration in child
	 * components for the table. This will use the inherited table configuration
	 * context if the prop value is `undefined`.
	 *
	 * @internal
	 */
	function useTableConfig(options) {
	    var _a, _b, _c, _d, _e, _f;
	    var inherited = require$$1.useContext(context$3);
	    var header = (_a = options.header) !== null && _a !== void 0 ? _a : inherited.header;
	    var hAlign = (_b = options.hAlign) !== null && _b !== void 0 ? _b : inherited.hAlign;
	    var vAlign = (_c = options.vAlign) !== null && _c !== void 0 ? _c : inherited.vAlign;
	    var lineWrap = (_d = options.lineWrap) !== null && _d !== void 0 ? _d : inherited.lineWrap;
	    var disableHover = (_e = options.disableHover) !== null && _e !== void 0 ? _e : inherited.disableHover;
	    var disableBorders = (_f = options.disableBorders) !== null && _f !== void 0 ? _f : inherited.disableBorders;
	    return {
	        header: header,
	        hAlign: hAlign,
	        vAlign: vAlign,
	        lineWrap: lineWrap,
	        disableHover: disableHover,
	        disableBorders: disableBorders,
	    };
	}
	/**
	 * @internal
	 */
	var TableConfigProvider = context$3.Provider;

	var __assign$e = (undefined && undefined.__assign) || function () {
	    __assign$e = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$e.apply(this, arguments);
	};
	var __rest$d = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$8 = bem("rmd-table");
	/**
	 * Creates a `<table>` element with some default styles and a quick way to
	 * configure the other styles within a table. That being said, styling tables is
	 * awful if you are used to flexbox and this component will not be helping with
	 * layout styles of tables.
	 *
	 * The table will not be responsive by default, but you can easily create a
	 * responsive table with overflow by wrapping with the `TableContainer`
	 * component or just adding `overflow: auto` to a parent element. Note that
	 * horizontal scrolling is still not one of the best user interactions and it
	 * might be better to render a table in a different manner for mobile devices to
	 * help display all the required data.
	 */
	var Table = require$$1.forwardRef(function Table(_a, ref) {
	    var className = _a.className, children = _a.children, _b = _a.dense, dense = _b === void 0 ? false : _b, _c = _a.hAlign, hAlign = _c === void 0 ? "left" : _c, _d = _a.vAlign, vAlign = _d === void 0 ? "middle" : _d, _e = _a.lineWrap, lineWrap = _e === void 0 ? false : _e, _f = _a.fullWidth, fullWidth = _f === void 0 ? false : _f, _g = _a.disableHover, disableHover = _g === void 0 ? false : _g, _h = _a.disableBorders, disableBorders = _h === void 0 ? false : _h, props = __rest$d(_a, ["className", "children", "dense", "hAlign", "vAlign", "lineWrap", "fullWidth", "disableHover", "disableBorders"]);
	    var configuration = require$$1.useMemo(function () { return ({
	        header: false,
	        hAlign: hAlign,
	        vAlign: vAlign,
	        lineWrap: lineWrap,
	        disableHover: disableHover,
	        disableBorders: disableBorders,
	    }); }, [hAlign, vAlign, lineWrap, disableHover, disableBorders]);
	    return (jsxRuntime.exports.jsx(TableConfigProvider, __assign$e({ value: configuration }, { children: jsxRuntime.exports.jsx("table", __assign$e({}, props, { ref: ref, className: cn(block$8({
	                dense: dense,
	                "full-width": fullWidth,
	            }), className) }, { children: children })) })));
	});

	var context$2 = require$$1.createContext(false);
	/**
	 * A quick way to conditionally inherit the sticky context within a table.  If
	 * the sticky prop was defined and a boolean, it will be used. Otherwise the
	 * inherited context value will be used.
	 * @internal
	 */
	function useSticky(sticky) {
	    var isSticky = require$$1.useContext(context$2);
	    return typeof sticky !== "undefined" ? !!sticky : isSticky;
	}
	/**
	 * @internal
	 */
	var StickyTableProvider = context$2.Provider;

	var __assign$d = (undefined && undefined.__assign) || function () {
	    __assign$d = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$d.apply(this, arguments);
	};
	var __rest$c = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$7 = bem("rmd-thead");
	/**
	 * Creates a `<thead>` element with some basic styles. This component will also
	 * update the table configuration so that all the `TableCell` children will
	 * automatically become `<th>` elements instead of the normal `<td>` as well as
	 * disabling the hover effect and line wrapping. The hover effect and
	 * line-wrapping can be re-enabled if desired through the `hoverable` and
	 * `disableNoWrap` props.
	 */
	var TableHeader = require$$1.forwardRef(function TableHeader(_a, ref) {
	    var className = _a.className, _b = _a.hoverable, hoverable = _b === void 0 ? false : _b, propLineWrap = _a.lineWrap, children = _a.children, _c = _a.sticky, sticky = _c === void 0 ? false : _c, props = __rest$c(_a, ["className", "hoverable", "lineWrap", "children", "sticky"]);
	    // update the table configuration with the custom overrides for the `<thead>`
	    var _d = useTableConfig({
	        lineWrap: propLineWrap,
	        disableHover: !hoverable,
	    }), hAlign = _d.hAlign, vAlign = _d.vAlign, lineWrap = _d.lineWrap, disableHover = _d.disableHover, disableBorders = _d.disableBorders;
	    var configuration = require$$1.useMemo(function () { return ({
	        header: true,
	        hAlign: hAlign,
	        vAlign: vAlign,
	        lineWrap: lineWrap,
	        disableBorders: disableBorders,
	        disableHover: disableHover,
	    }); }, [hAlign, vAlign, lineWrap, disableBorders, disableHover]);
	    return (jsxRuntime.exports.jsx(TableConfigProvider, __assign$d({ value: configuration }, { children: jsxRuntime.exports.jsx("thead", __assign$d({}, props, { ref: ref, className: cn(block$7(), className) }, { children: jsxRuntime.exports.jsx(StickyTableProvider, __assign$d({ value: sticky }, { children: children })) })) })));
	});

	var __assign$c = (undefined && undefined.__assign) || function () {
	    __assign$c = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$c.apply(this, arguments);
	};
	var __rest$b = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * Creates a `<tbody>` element that also allows for overriding all the child
	 * `TableCell` components with additional styling behavior.
	 */
	var TableBody = require$$1.forwardRef(function TableBody(_a, ref) {
	    var className = _a.className, children = _a.children, propHAlign = _a.hAlign, propVAlign = _a.vAlign, propLineWrap = _a.lineWrap, propDisableHover = _a.disableHover, propDisableBorders = _a.disableBorders, props = __rest$b(_a, ["className", "children", "hAlign", "vAlign", "lineWrap", "disableHover", "disableBorders"]);
	    // update the table configuration with the custom overrides for the `<thead>`
	    var _b = useTableConfig({
	        hAlign: propHAlign,
	        vAlign: propVAlign,
	        lineWrap: propLineWrap,
	        disableHover: propDisableHover,
	        disableBorders: propDisableBorders,
	    }), hAlign = _b.hAlign, vAlign = _b.vAlign, lineWrap = _b.lineWrap, disableHover = _b.disableHover, disableBorders = _b.disableBorders;
	    var configuration = require$$1.useMemo(function () { return ({
	        header: false,
	        hAlign: hAlign,
	        vAlign: vAlign,
	        lineWrap: lineWrap,
	        disableBorders: disableBorders,
	        disableHover: disableHover,
	    }); }, [hAlign, vAlign, lineWrap, disableBorders, disableHover]);
	    return (jsxRuntime.exports.jsx(TableConfigProvider, __assign$c({ value: configuration }, { children: jsxRuntime.exports.jsx("tbody", __assign$c({}, props, { ref: ref, className: cn("rmd-tbody", className) }, { children: children })) })));
	});

	var context$1 = require$$1.createContext(false);
	/**
	 * @internal
	 */
	var TableFooterProvider = context$1.Provider;
	/**
	 * @internal
	 */
	function useTableFooter() {
	    return require$$1.useContext(context$1);
	}

	var __assign$b = (undefined && undefined.__assign) || function () {
	    __assign$b = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$b.apply(this, arguments);
	};
	var __rest$a = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$6 = bem("rmd-foot");
	/**
	 * Creates a `<tfoot>` element with some basic styles. This component will
	 * disable the hover effect and line wrapping by default, but the hover effect
	 * and line-wrapping can be re-enabled if desired through the `hoverable` and
	 * `disableNoWrap` props.
	 */
	var TableFooter = require$$1.forwardRef(function TableFooter(_a, ref) {
	    var className = _a.className, _b = _a.hoverable, hoverable = _b === void 0 ? false : _b, propLineWrap = _a.lineWrap, children = _a.children, _c = _a.sticky, sticky = _c === void 0 ? false : _c, props = __rest$a(_a, ["className", "hoverable", "lineWrap", "children", "sticky"]);
	    // update the table configuration with the custom overrides for the `<tfoot>`
	    var _d = useTableConfig({
	        lineWrap: propLineWrap,
	        disableHover: !hoverable,
	    }), hAlign = _d.hAlign, vAlign = _d.vAlign, lineWrap = _d.lineWrap, disableHover = _d.disableHover, disableBorders = _d.disableBorders;
	    var configuration = require$$1.useMemo(function () { return ({
	        header: false,
	        hAlign: hAlign,
	        vAlign: vAlign,
	        lineWrap: lineWrap,
	        disableBorders: disableBorders,
	        disableHover: disableHover,
	    }); }, [hAlign, vAlign, lineWrap, disableBorders, disableHover]);
	    return (jsxRuntime.exports.jsx(TableConfigProvider, __assign$b({ value: configuration }, { children: jsxRuntime.exports.jsx(TableFooterProvider, __assign$b({ value: true }, { children: jsxRuntime.exports.jsx("tfoot", __assign$b({}, props, { ref: ref, className: cn(block$6(), className) }, { children: jsxRuntime.exports.jsx(StickyTableProvider, __assign$b({ value: sticky }, { children: children })) })) })) })));
	});

	var __assign$a = (undefined && undefined.__assign) || function () {
	    __assign$a = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$a.apply(this, arguments);
	};
	var __rest$9 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$5 = bem("rmd-tr");
	/**
	 * Creates a `<tr>` element with some general styles that are inherited from the
	 * base table configuration.
	 */
	var TableRow = require$$1.forwardRef(function TableRow(_a, ref) {
	    var className = _a.className, propDisableHover = _a.disableHover, propDisableBorders = _a.disableBorders, children = _a.children, _b = _a.selected, selected = _b === void 0 ? false : _b, _c = _a.clickable, clickable = _c === void 0 ? false : _c, props = __rest$9(_a, ["className", "disableHover", "disableBorders", "children", "selected", "clickable"]);
	    var _d = useTableConfig({
	        disableHover: propDisableHover,
	        disableBorders: propDisableBorders,
	    }), disableHover = _d.disableHover, disableBorders = _d.disableBorders;
	    return (jsxRuntime.exports.jsx("tr", __assign$a({}, props, { ref: ref, className: cn(block$5({
	            bordered: !disableBorders,
	            hoverable: !disableHover,
	            clickable: clickable,
	            selected: selected,
	            "selected-hoverable": selected && !disableHover,
	        }), className) }, { children: children })));
	});

	var __assign$9 = (undefined && undefined.__assign) || function () {
	    __assign$9 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$9.apply(this, arguments);
	};
	var __rest$8 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$4 = bem("rmd-table-cell");
	/**
	 * This is mostly an internal component since it is automatically used within
	 * the `TableCell` component but this will conditionally wrap the `children`
	 * within an `UnstyledButton` to make a clickable cell. This is really to help
	 * with sort behavior within headers.
	 */
	var TableCellContent = require$$1.forwardRef(function TableCellContent(_a, ref) {
	    var _b;
	    var id = _a.id, propIcon = _a.icon, style = _a.style, className = _a.className, sortOrder = _a.sortOrder, children = _a.children, propRotated = _a.rotated, _c = _a.hAlign, hAlign = _c === void 0 ? "left" : _c, props = __rest$8(_a, ["id", "icon", "style", "className", "sortOrder", "children", "rotated", "hAlign"]);
	    if (!sortOrder || propIcon === null) {
	        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children });
	    }
	    var icon = null;
	    if (sortOrder !== "none") {
	        var rotated = propRotated !== null && propRotated !== void 0 ? propRotated : sortOrder === "descending";
	        icon = jsxRuntime.exports.jsx(IconRotator, __assign$9({ rotated: rotated }, { children: propIcon }));
	    }
	    return (jsxRuntime.exports.jsx(UnstyledButton, __assign$9({ id: id, ref: ref, style: style, className: cn(block$4("child", (_b = {},
	            _b[hAlign] = hAlign !== "left",
	            _b)), className) }, { children: jsxRuntime.exports.jsx(TextIconSpacing, __assign$9({}, props, { icon: icon }, { children: children })) })));
	});

	var __assign$8 = (undefined && undefined.__assign) || function () {
	    __assign$8 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$8.apply(this, arguments);
	};
	var __rest$7 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$3 = bem("rmd-table-cell");
	/**
	 * Creates a `<th>` or `<td>` cell with sensible styled defaults. You can create
	 * a `<th>` element by enabling the `header` prop OR having a `TableCell` as a
	 * child of the `TableHeader` component.
	 *
	 * Note: If you have a checkbox column in the `TableHeader` without any labels,
	 * you will need to manually set the `header={false}` prop for that cell since
	 * it is invalid to have a `<th>` without any readable content for screen
	 * readers.
	 */
	var TableCell = require$$1.forwardRef(function TableCell(_a, ref) {
	    var _b;
	    var sortOrder = _a["aria-sort"], id = _a.id, className = _a.className, _c = _a.grow, grow = _c === void 0 ? false : _c, propScope = _a.scope, propHAlign = _a.hAlign, propVAlign = _a.vAlign, propHeader = _a.header, propDisableLineWrap = _a.lineWrap, children = _a.children, propSticky = _a.sticky, propSortIcon = _a.sortIcon, _d = _a.sortIconAfter, sortIconAfter = _d === void 0 ? false : _d, sortIconRotated = _a.sortIconRotated, disablePadding = _a.disablePadding, propColSpan = _a.colSpan, props = __rest$7(_a, ["aria-sort", "id", "className", "grow", "scope", "hAlign", "vAlign", "header", "lineWrap", "children", "sticky", "sortIcon", "sortIconAfter", "sortIconRotated", "disablePadding", "colSpan"]);
	    // have to double cast to get the `100%` value to work.
	    var colSpan = propColSpan;
	    var sortIcon = useIcon("sort", propSortIcon);
	    var isNoPadding = disablePadding !== null && disablePadding !== void 0 ? disablePadding : (sortIcon && sortOrder);
	    // Note: unlike the other usages of `useTableConfig`, the `propHeader`
	    // is not provided. This is so that `TableCheckbox` components can still
	    // be a sticky header without being rendered as a `<th>`. This also makes
	    // it so the scope can be defaulted to `col` or `row` automatically.
	    var _e = useTableConfig({
	        hAlign: propHAlign,
	        vAlign: propVAlign,
	        lineWrap: propDisableLineWrap,
	    }), inheritedHeader = _e.header, hAlign = _e.hAlign, vAlign = _e.vAlign, lineWrap = _e.lineWrap;
	    var header = propHeader !== null && propHeader !== void 0 ? propHeader : inheritedHeader;
	    var footer = useTableFooter();
	    var sticky = useSticky(propSticky);
	    var isStickyCell = propSticky === "cell" || (!header && sticky);
	    var isStickyHeader = propSticky === "header";
	    var isStickyFooter = sticky && footer;
	    var isStickyFooterCell = isStickyFooter && (propColSpan === "100%" || propColSpan === 0);
	    var isStickyAbove = propSticky === "header-cell" || isStickyFooterCell;
	    var scope = propScope;
	    if (!scope && header) {
	        scope = !inheritedHeader && propHeader ? "row" : "col";
	    }
	    var Component = header ? "th" : "td";
	    return (jsxRuntime.exports.jsx(Component, __assign$8({}, props, { ref: ref, id: id, "aria-sort": sortOrder === "none" ? undefined : sortOrder, colSpan: colSpan, className: cn(block$3((_b = {
	                grow: grow,
	                header: header,
	                sticky: sticky,
	                "sticky-header": (header && sticky && propSticky !== "cell") ||
	                    isStickyHeader ||
	                    isStickyAbove,
	                "sticky-cell": isStickyCell || isStickyAbove || isStickyFooterCell,
	                "sticky-footer": isStickyFooter,
	                "sticky-above": isStickyAbove
	            },
	            _b[hAlign] = hAlign !== "left",
	            _b[vAlign] = vAlign !== "middle",
	            _b.vertical = vAlign !== "middle",
	            _b["no-wrap"] = !lineWrap,
	            _b.padded = !isNoPadding && lineWrap === "padded",
	            _b["no-padding"] = isNoPadding,
	            _b)), className), scope: scope }, { children: jsxRuntime.exports.jsx(TableCellContent, __assign$8({ id: id ? "".concat(id, "-sort") : undefined, icon: sortIcon, iconAfter: sortIconAfter, sortOrder: sortOrder, rotated: sortIconRotated, hAlign: hAlign }, { children: children })) })));
	});

	var __assign$7 = (undefined && undefined.__assign) || function () {
	    __assign$7 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$7.apply(this, arguments);
	};
	var __rest$6 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * This component is really just a simple wrapper for applying the `<caption>`
	 * typography styles and probably doesn't have much real use if you don't use
	 * captions.
	 */
	var Caption = require$$1.forwardRef(function Caption(_a, ref) {
	    var className = _a.className, children = _a.children, props = __rest$6(_a, ["className", "children"]);
	    return (jsxRuntime.exports.jsx("caption", __assign$7({}, props, { ref: ref, className: cn("rmd-caption", className) }, { children: children })));
	});

	var __assign$6 = (undefined && undefined.__assign) || function () {
	    __assign$6 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$6.apply(this, arguments);
	};
	var __rest$5 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var DEFAULT_ARIA_LABEL = "Toggle Row Selection";
	/**
	 * This is a simple wrapper for the `Checkbox` component that allows you to
	 * render a nicely styled `Checkbox` within a `TableCell` element. This will
	 * mostly just remove the additional padding applied and default an `aria-label`
	 * since you normally don't want a checkbox with a label within a table since
	 * it's more for selection.
	 */
	var TableCheckbox = require$$1.forwardRef(function TableCheckbox(_a, ref) {
	    var cellId = _a.cellId, className = _a.className, id = _a.id, ariaLabel = _a["aria-label"], ariaLabelledBy = _a["aria-labelledby"], ariaChecked = _a["aria-checked"], ariaControls = _a["aria-controls"], checkboxRef = _a.checkboxRef, checkboxStyle = _a.checkboxStyle, checkboxClassName = _a.checkboxClassName, icon = _a.icon, iconStyle = _a.iconStyle, iconClassName = _a.iconClassName, toggleStyle = _a.toggleStyle, toggleClassName = _a.toggleClassName, disableIconOverlay = _a.disableIconOverlay, name = _a.name, value = _a.value, checked = _a.checked, onChange = _a.onChange, defaultChecked = _a.defaultChecked, indeterminate = _a.indeterminate, props = __rest$5(_a, ["cellId", "className", "id", "aria-label", "aria-labelledby", "aria-checked", "aria-controls", "checkboxRef", "checkboxStyle", "checkboxClassName", "icon", "iconStyle", "iconClassName", "toggleStyle", "toggleClassName", "disableIconOverlay", "name", "value", "checked", "onChange", "defaultChecked", "indeterminate"]);
	    return (jsxRuntime.exports.jsx(TableCell, __assign$6({}, props, { ref: ref, id: cellId, header: false, className: cn("rmd-table-cell--checkbox", className) }, { children: jsxRuntime.exports.jsx(Checkbox, { id: id, "aria-label": (ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : ariaLabelledBy) ? undefined : DEFAULT_ARIA_LABEL, "aria-labelledby": ariaLabelledBy, "aria-checked": ariaChecked, "aria-controls": ariaControls, ref: checkboxRef, style: checkboxStyle, indeterminate: indeterminate, className: checkboxClassName, icon: icon, iconStyle: iconStyle, iconClassName: iconClassName, toggleStyle: toggleStyle, toggleClassName: toggleClassName, disableIconOverlay: disableIconOverlay, name: name, value: value, checked: checked, onChange: onChange, defaultChecked: defaultChecked }) })));
	});

	var __assign$5 = (undefined && undefined.__assign) || function () {
	    __assign$5 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$5.apply(this, arguments);
	};
	var __read$2 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var context = require$$1.createContext({
	    tabsId: "tabs",
	    activeIndex: 0,
	    onActiveIndexChange: function () {
	        // do nothing
	    },
	    tabs: [],
	});
	/**
	 * This hook returns the current "state" for the tabs which can be useful if you
	 * need additional control or access to the tabs behavior.
	 */
	function useTabs() {
	    return require$$1.useContext(context);
	}
	var Provider = context.Provider;
	/**
	 * The `TabsManager` is used to configure your `Tabs` component and handle some
	 * of the default behavior such as:
	 *
	 * - controlling the `activeIndex`
	 * - general tab configuration
	 * - callbacks when the tab has changed
	 * - providing an `id` prefix for all tabs for simplicity
	 */
	function TabsManager(_a) {
	    var tabsId = _a.tabsId, _b = _a.defaultActiveIndex, defaultActiveIndex = _b === void 0 ? 0 : _b, propActiveIndex = _a.activeIndex, onActiveIndexChange = _a.onActiveIndexChange, tabs = _a.tabs, _c = _a.stacked, stacked = _c === void 0 ? false : _c, _d = _a.iconAfter, iconAfter = _d === void 0 ? false : _d, children = _a.children;
	    var _e = __read$2(require$$1.useState(defaultActiveIndex), 2), localActiveIndex = _e[0], setActiveIndex = _e[1];
	    var handleActiveIndexChange = require$$1.useCallback(function (activeIndex) {
	        if (onActiveIndexChange) {
	            onActiveIndexChange(activeIndex);
	        }
	        setActiveIndex(activeIndex);
	    }, [onActiveIndexChange]);
	    var activeIndex = typeof propActiveIndex === "number" ? propActiveIndex : localActiveIndex;
	    var updateActiveIndex = typeof propActiveIndex === "number"
	        ? onActiveIndexChange
	        : handleActiveIndexChange;
	    var value = require$$1.useMemo(function () { return ({
	        activeIndex: activeIndex,
	        onActiveIndexChange: updateActiveIndex,
	        tabs: tabs.map(function (config, i) {
	            var tab;
	            if (typeof config === "string" || require$$1.isValidElement(config)) {
	                tab = { children: config };
	            }
	            else {
	                tab = config;
	            }
	            return __assign$5(__assign$5({}, tab), { id: tab.id || "".concat(tabsId, "-tab-").concat(i + 1), panelId: activeIndex === i
	                    ? "".concat(tabsId, "-panel-").concat(activeIndex + 1)
	                    : undefined, stacked: typeof tab.stacked === "boolean" ? tab.stacked : stacked, iconAfter: typeof tab.iconAfter === "boolean" ? tab.iconAfter : iconAfter });
	        }),
	        tabsId: tabsId,
	    }); }, [activeIndex, iconAfter, stacked, tabs, tabsId, updateActiveIndex]);
	    return jsxRuntime.exports.jsx(Provider, __assign$5({ value: value }, { children: children }));
	}

	var __read$1 = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var TAB_WIDTH_VAR = "--rmd-tab-width";
	var TAB_OFFSET_VAR = "--rmd-tab-offset";
	function useTabIndicatorStyles(options) {
	    var ref = options.ref, activeIndex = options.activeIndex;
	    var isRTL = useDir().dir === "rtl";
	    var tabs = useTabs().tabs;
	    var watching = useKeyboardFocusContext().watching;
	    var _a = __read$1(require$$1.useState(function () {
	        var _a;
	        var tabWidth = "".concat(100 / tabs.length, "%");
	        return _a = {},
	            _a[TAB_WIDTH_VAR] = tabWidth,
	            _a[TAB_OFFSET_VAR] = "calc(".concat(activeIndex, " * ").concat(tabWidth, ")"),
	            _a;
	    }), 2), indicatorStyles = _a[0], setIndicatorStyles = _a[1];
	    var updateIndicatorStyles = require$$1.useCallback(function () {
	        var _a;
	        var _b;
	        var current = (_b = watching.current[activeIndex]) === null || _b === void 0 ? void 0 : _b.element;
	        if (!current) {
	            return;
	        }
	        var cssVars = (_a = {},
	            _a[TAB_WIDTH_VAR] = "".concat(current.offsetWidth, "px"),
	            _a[TAB_OFFSET_VAR] = "".concat(current.offsetLeft, "px"),
	            _a);
	        setIndicatorStyles(function (prevStyles) {
	            if (prevStyles[TAB_WIDTH_VAR] === cssVars[TAB_WIDTH_VAR] &&
	                prevStyles[TAB_OFFSET_VAR] === cssVars[TAB_OFFSET_VAR]) {
	                return prevStyles;
	            }
	            return cssVars;
	        });
	    }, [activeIndex, watching, isRTL]);
	    var _b = __read$1(useResizeObserver(updateIndicatorStyles, {
	        ref: ref,
	    }), 2), nodeRef = _b[0], refCallback = _b[1];
	    useIsomorphicLayoutEffect(function () {
	        var _a;
	        var activeTab = (_a = watching.current[activeIndex]) === null || _a === void 0 ? void 0 : _a.element;
	        var container = nodeRef.current;
	        if (!activeTab || !container) {
	            return;
	        }
	        // NOTE: This should probably be moved into the `scrollIntoView` util
	        // whenever I do another major version update. This is the same code, just
	        // using horizontal properties
	        var offsetLeft = activeTab.offsetLeft;
	        var scrollLeft = container.scrollLeft;
	        var tabRight = offsetLeft + activeTab.offsetWidth;
	        var containerRight = container.offsetWidth + scrollLeft;
	        if (tabRight > containerRight) {
	            container.scrollLeft = tabRight - container.offsetWidth;
	        }
	        else if (offsetLeft < scrollLeft) {
	            container.scrollLeft = offsetLeft;
	        }
	    }, [activeIndex, isRTL, nodeRef, watching]);
	    return {
	        refCallback: refCallback,
	        indicatorStyles: indicatorStyles,
	    };
	}

	var __assign$4 = (undefined && undefined.__assign) || function () {
	    __assign$4 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$4.apply(this, arguments);
	};
	var __rest$4 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var styles = bem("rmd-tabs");
	/**
	 * The `TabsList` component is the container for all the individual `Tab`s that
	 * should be rendered. This handles adding an active indicator underneath the
	 * active tab and animating it to the new location when a new tab becomes
	 * active. It also handles the ability update which tab is selected when it has
	 * been clicked or updated with keyboard movement.
	 *
	 * This should probably not be used outside of this package unless a custom
	 * implementation is desired.
	 */
	var TabsList = require$$1.forwardRef(function TabsList(_a, ref) {
	    var _b;
	    var style = _a.style, className = _a.className, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, children = _a.children, activeIndex = _a.activeIndex, _c = _a.align, align = _c === void 0 ? "left" : _c, _d = _a.automatic, automatic = _d === void 0 ? false : _d, _e = _a.padded, padded = _e === void 0 ? false : _e, _f = _a.orientation, orientation = _f === void 0 ? "horizontal" : _f, onActiveIndexChange = _a.onActiveIndexChange, _g = _a.disableTransition, disableTransition = _g === void 0 ? false : _g, props = __rest$4(_a, ["style", "className", "onFocus", "onKeyDown", "children", "activeIndex", "align", "automatic", "padded", "orientation", "onActiveIndexChange", "disableTransition"]);
	    var horizontal = orientation === "horizontal";
	    var isKeyboard = useIsUserInteractionMode("keyboard");
	    var _h = useKeyboardFocus({
	        onFocus: onFocus,
	        onKeyDown: onKeyDown,
	        onFocusChange: function (element, focusIndex) {
	            element.focus();
	            if (automatic) {
	                onActiveIndexChange(focusIndex);
	            }
	        },
	    }); _h.focusIndex; var eventHandlers = __rest$4(_h, ["focusIndex"]);
	    var _j = useTabIndicatorStyles({
	        ref: ref,
	        activeIndex: activeIndex,
	    }), refCallback = _j.refCallback, indicatorStyles = _j.indicatorStyles;
	    return (jsxRuntime.exports.jsx("div", __assign$4({}, props, { "aria-orientation": orientation, style: __assign$4(__assign$4({}, style), indicatorStyles), role: "tablist", ref: refCallback, className: cn(styles((_b = {},
	            _b[align] = true,
	            _b.padded = padded,
	            _b.vertical = !horizontal,
	            _b.animate = !disableTransition && (!automatic || !isKeyboard),
	            _b)), className) }, eventHandlers, { children: children })));
	});

	var __assign$3 = (undefined && undefined.__assign) || function () {
	    __assign$3 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3.apply(this, arguments);
	};
	var __rest$3 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block$2 = bem("rmd-tab");
	/**
	 * The `Tab` is a low-level component that just renders an accessible tab widget
	 * along with some general styles and an optional icon.
	 */
	var Tab = require$$1.forwardRef(function Tab(_a, ref) {
	    var propClassName = _a.className, contentStyle = _a.contentStyle, contentClassName = _a.contentClassName, _b = _a.disabled, disabled = _b === void 0 ? false : _b, icon = _a.icon, _c = _a.stacked, stacked = _c === void 0 ? false : _c, _d = _a.iconAfter, iconAfter = _d === void 0 ? false : _d, children = _a.children, active = _a.active, panelId = _a.panelId, disableRipple = _a.disableRipple, disableProgrammaticRipple = _a.disableProgrammaticRipple, rippleTimeout = _a.rippleTimeout, rippleClassNames = _a.rippleClassNames, rippleClassName = _a.rippleClassName, rippleContainerClassName = _a.rippleContainerClassName, enablePressedAndRipple = _a.enablePressedAndRipple, props = __rest$3(_a, ["className", "contentStyle", "contentClassName", "disabled", "icon", "stacked", "iconAfter", "children", "active", "panelId", "disableRipple", "disableProgrammaticRipple", "rippleTimeout", "rippleClassNames", "rippleClassName", "rippleContainerClassName", "enablePressedAndRipple"]);
	    var _e = useInteractionStates({
	        handlers: props,
	        className: propClassName,
	        disabled: disabled,
	        disableRipple: disableRipple,
	        disableProgrammaticRipple: disableProgrammaticRipple,
	        rippleTimeout: rippleTimeout,
	        rippleClassNames: rippleClassNames,
	        rippleClassName: rippleClassName,
	        rippleContainerClassName: rippleContainerClassName,
	        enablePressedAndRipple: enablePressedAndRipple,
	    }), ripples = _e.ripples, className = _e.className, handlers = _e.handlers;
	    var refCallback = useKeyboardFocusableElement(ref);
	    return (jsxRuntime.exports.jsxs("button", __assign$3({}, props, handlers, { ref: refCallback, "aria-selected": active, "aria-controls": panelId, type: "button", role: "tab", disabled: disabled, className: cn(block$2({ active: active, stacked: icon && stacked }), className), tabIndex: active ? undefined : -1 }, { children: [jsxRuntime.exports.jsx(TextIconSpacing, __assign$3({ icon: icon, stacked: stacked, iconAfter: iconAfter }, { children: jsxRuntime.exports.jsx("span", __assign$3({ style: contentStyle, className: cn(block$2("content"), contentClassName) }, { children: children })) })), ripples] })));
	});

	var __assign$2 = (undefined && undefined.__assign) || function () {
	    __assign$2 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2.apply(this, arguments);
	};
	var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	/**
	 * The `Tabs` component is used to render all the configured `tabs` from the
	 * parent `TabsManager` component inside of the `TabsList`.
	 */
	var Tabs = require$$1.forwardRef(function Tabs(props, ref) {
	    var _a = useTabs(), tabsId = _a.tabsId, tabs = _a.tabs, activeIndex = _a.activeIndex, onActiveIndexChange = _a.onActiveIndexChange;
	    var horizontal = props.orientation !== "vertical";
	    return (jsxRuntime.exports.jsx(KeyboardMovementProvider, __assign$2({ loopable: true, horizontal: horizontal }, { children: jsxRuntime.exports.jsx(TabsList, __assign$2({}, props, { id: tabsId, ref: ref, activeIndex: activeIndex, onActiveIndexChange: onActiveIndexChange }, { children: tabs.map(function (_a, index) {
	                var id = _a.id, config = __rest$2(_a, ["id"]);
	                return (require$$1.createElement(Tab, __assign$2({}, config, { id: id, key: id, active: activeIndex === index, onClick: function () {
	                        onActiveIndexChange(index);
	                    } })));
	            }) })) })));
	});

	var __assign$1 = (undefined && undefined.__assign) || function () {
	    __assign$1 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1.apply(this, arguments);
	};
	var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __read = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var block$1 = bem("rmd-tab-panels");
	/**
	 * This component allows you to control the visibility of the `TabPanel`
	 * components and animating the next and current panels as needed. This works by
	 * looping over all the children and getting the current `TabPanel` by the
	 * `activeIndex`. This is why the children for this component can only be
	 * `TabPanel` and should not be conditional.
	 */
	var TabPanels = require$$1.forwardRef(function TabPanels(_a, forwardedRef) {
	    var className = _a.className, children = _a.children, _b = _a.disableScrollFix, disableScrollFix = _b === void 0 ? false : _b, _c = _a.disableTransition, disableTransition = _c === void 0 ? false : _c, _d = _a.persistent, persistent = _d === void 0 ? false : _d, props = __rest$1(_a, ["className", "children", "disableScrollFix", "disableTransition", "persistent"]);
	    var _e = useTabs(), tabsId = _e.tabsId, tabs = _e.tabs, activeIndex = _e.activeIndex;
	    var prevIndex = require$$1.useRef(activeIndex);
	    var _f = __read(require$$1.useState({
	        previous: activeIndex,
	        incrementing: true,
	    }), 2), _g = _f[0], previous = _g.previous, incrementing = _g.incrementing, setState = _f[1];
	    // have to set these in refs since changing these might cause mounting
	    // and unmounting in the Transition group component :/ they should only
	    // be re-evaluated when the activeIndex changes.
	    var transitionable = require$$1.useRef(!persistent && !disableTransition);
	    var animatable = require$$1.useRef(persistent && !disableTransition);
	    if (prevIndex.current !== activeIndex) {
	        prevIndex.current = activeIndex;
	        transitionable.current = !persistent && !disableTransition;
	        animatable.current = persistent && !disableTransition;
	    }
	    require$$1.useEffect(function () {
	        setState(function (_a) {
	            var previous = _a.previous;
	            return ({
	                incrementing: previous < activeIndex,
	                previous: disableTransition ? activeIndex : previous,
	            });
	        });
	        // this is for only updating the incrementing state and should not be fired
	        // again if the disableTransition prop is changed
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [activeIndex]);
	    var onEntered = require$$1.useCallback(function () {
	        setState(function (_a) {
	            var incrementing = _a.incrementing;
	            return ({ incrementing: incrementing, previous: activeIndex });
	        });
	    }, [activeIndex]);
	    var _h = __read(useEnsuredRef(forwardedRef), 2), ref = _h[0], refHandler = _h[1];
	    require$$1.useEffect(function () {
	        if (!ref.current || disableScrollFix) {
	            return;
	        }
	        ref.current.scrollTop = 0;
	        // don't want it to be triggered if only the disableScrollFix prop has changed
	        // since it might be independent from active indexes
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [activeIndex]);
	    return (jsxRuntime.exports.jsx("div", __assign$1({}, props, { ref: refHandler, className: cn(block$1({
	            "slide-left": incrementing,
	            "slide-right": !incrementing,
	        }), className) }, { children: require$$1.Children.map(children, function (child, index) {
	            if (!require$$1.isValidElement(child)) {
	                return child;
	            }
	            var panel = require$$1.Children.only(child);
	            var labelledBy = panel.props["aria-labelledby"];
	            if (!labelledBy && !panel.props["aria-label"] && tabs[index]) {
	                // generally guaranteed to be defined by this point since the TabsManager
	                // will add ids if missing.
	                labelledBy = tabs[index].id;
	            }
	            return require$$1.cloneElement(child, {
	                "aria-labelledby": labelledBy,
	                id: "".concat(tabsId, "-panel-").concat(index + 1),
	                hidden: persistent && index !== activeIndex && index !== previous,
	                temporary: !persistent,
	                transitionIn: index === activeIndex,
	                timeout: disableTransition ? 0 : panel.props.timeout,
	                onEntered: disableTransition ? undefined : onEntered,
	            });
	        }) })));
	});

	var __assign = (undefined && undefined.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __rest = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var block = bem("rmd-tab-panel");
	var prefix = "rmd-tab-panel";
	/** @remarks \@since 4.0.0 */
	var DEFAULT_TABPANEL_TIMEOUT = 150;
	/** @remarks \@since 4.0.0 */
	var DEFAULT_TABPANEL_CLASSNAMES = {
	    enter: "".concat(prefix, "--enter"),
	    enterActive: "".concat(prefix, "--enter-active ").concat(prefix, "--animate"),
	    exit: "".concat(prefix, "--exit"),
	    exitActive: "".concat(prefix, "--exit-active ").concat(prefix, "--animate"),
	};
	/**
	 * This component renders an accessible tab panel with enter and exit
	 * animations.  This probably should only be used internally as it relies on the
	 * `TabPanels` component along with the `TransitionGroup` from
	 * `react-transition-group` to work as expected.
	 */
	var TabPanel = require$$1.forwardRef(function TabPanel(_a, nodeRef) {
	    var propClassName = _a.className, appear = _a.appear, enter = _a.enter, exit = _a.exit, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_TABPANEL_TIMEOUT : _b, _c = _a.classNames, classNames = _c === void 0 ? DEFAULT_TABPANEL_CLASSNAMES : _c, _d = _a.transitionIn, transitionIn = _d === void 0 ? true : _d, temporary = _a.temporary, children = _a.children, hidden = _a.hidden, props = __rest(_a, ["className", "appear", "enter", "exit", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "timeout", "classNames", "transitionIn", "temporary", "children", "hidden"]);
	    var _e = useCSSTransition({
	        nodeRef: nodeRef,
	        timeout: timeout,
	        classNames: classNames,
	        className: cn(block(), propClassName),
	        transitionIn: transitionIn && !hidden,
	        appear: appear,
	        enter: enter,
	        exit: exit,
	        onEnter: onEnter,
	        onEntering: onEntering,
	        onEntered: onEntered,
	        onExit: onExit,
	        onExiting: onExiting,
	        onExited: onExited,
	        temporary: temporary,
	    }), elementProps = _e.elementProps, rendered = _e.rendered;
	    if (!rendered) {
	        return null;
	    }
	    return (jsxRuntime.exports.jsx("div", __assign({}, props, elementProps, { role: "tabpanel", hidden: hidden }, { children: children })));
	});

	exports.AAA_CONTRAST_RATIO = AAA_CONTRAST_RATIO;
	exports.ABOVE_CENTER_ANCHOR = ABOVE_CENTER_ANCHOR;
	exports.ABOVE_INNER_LEFT_ANCHOR = ABOVE_INNER_LEFT_ANCHOR;
	exports.ABOVE_INNER_RIGHT_ANCHOR = ABOVE_INNER_RIGHT_ANCHOR;
	exports.ABOVE_LEFT_ANCHOR = ABOVE_LEFT_ANCHOR;
	exports.ABOVE_RIGHT_ANCHOR = ABOVE_RIGHT_ANCHOR;
	exports.APP_BAR_OFFSET_CLASSNAME = APP_BAR_OFFSET_CLASSNAME;
	exports.APP_BAR_OFFSET_DENSE_CLASSNAME = APP_BAR_OFFSET_DENSE_CLASSNAME;
	exports.APP_BAR_OFFSET_PROMINENT_CLASSNAME = APP_BAR_OFFSET_PROMINENT_CLASSNAME;
	exports.APP_BAR_OFFSET_PROMINENT_DENSE_CLASSNAME = APP_BAR_OFFSET_PROMINENT_DENSE_CLASSNAME;
	exports.ActiveDescendantContextProvider = ActiveDescendantContextProvider;
	exports.ActiveDescendantMovementProvider = ActiveDescendantMovementProvider;
	exports.AddMessageContext = AddMessageContext;
	exports.AppBar = AppBar;
	exports.AppBarAction = AppBarAction;
	exports.AppBarNav = AppBarNav;
	exports.AppBarTitle = AppBarTitle;
	exports.AppSizeContext = AppSizeContext;
	exports.AppSizeListener = AppSizeListener;
	exports.AsyncSwitch = AsyncSwitch;
	exports.AutoComplete = AutoComplete;
	exports.Avatar = Avatar;
	exports.BELOW_CENTER_ANCHOR = BELOW_CENTER_ANCHOR;
	exports.BELOW_INNER_LEFT_ANCHOR = BELOW_INNER_LEFT_ANCHOR;
	exports.BELOW_INNER_RIGHT_ANCHOR = BELOW_INNER_RIGHT_ANCHOR;
	exports.BELOW_LEFT_ANCHOR = BELOW_LEFT_ANCHOR;
	exports.BELOW_RIGHT_ANCHOR = BELOW_RIGHT_ANCHOR;
	exports.BOTTOM_CENTER_ANCHOR = BOTTOM_CENTER_ANCHOR;
	exports.BOTTOM_INNER_LEFT_ANCHOR = BOTTOM_INNER_LEFT_ANCHOR;
	exports.BOTTOM_INNER_RIGHT_ANCHOR = BOTTOM_INNER_RIGHT_ANCHOR;
	exports.BOTTOM_LEFT_ANCHOR = BOTTOM_LEFT_ANCHOR;
	exports.BOTTOM_RIGHT_ANCHOR = BOTTOM_RIGHT_ANCHOR;
	exports.Badge = Badge;
	exports.BadgeContainer = BadgeContainer;
	exports.BadgedButton = BadgedButton;
	exports.Button = Button;
	exports.CELL_MARGIN_VAR = CELL_MARGIN_VAR;
	exports.CELL_SIZE_VAR = CELL_SIZE_VAR;
	exports.CENTER_CENTER_ANCHOR = CENTER_CENTER_ANCHOR;
	exports.CENTER_INNER_LEFT_ANCHOR = CENTER_INNER_LEFT_ANCHOR;
	exports.CENTER_INNER_RIGHT_ANCHOR = CENTER_INNER_RIGHT_ANCHOR;
	exports.CENTER_LEFT_ANCHOR = CENTER_LEFT_ANCHOR;
	exports.CENTER_RIGHT_ANCHOR = CENTER_RIGHT_ANCHOR;
	exports.CROSS_FADE_CLASSNAMES = CROSS_FADE_CLASSNAMES;
	exports.CROSS_FADE_TIMEOUT = CROSS_FADE_TIMEOUT;
	exports.CSSTransition = CSSTransition;
	exports.Caption = Caption;
	exports.Card = Card;
	exports.CardActions = CardActions;
	exports.CardContent = CardContent;
	exports.CardHeader = CardHeader;
	exports.CardSubtitle = CardSubtitle;
	exports.CardTitle = CardTitle;
	exports.Checkbox = Checkbox;
	exports.Chip = Chip;
	exports.CircularProgress = CircularProgress;
	exports.Collapse = Collapse;
	exports.ConditionalPortal = ConditionalPortal;
	exports.Configuration = Configuration;
	exports.CrossFade = CrossFade;
	exports.DATA_RMD_NOSCROLL = DATA_RMD_NOSCROLL;
	exports.DEFAULT_APP_SIZE = DEFAULT_APP_SIZE;
	exports.DEFAULT_COLLAPSE_MIN_HEIGHT = DEFAULT_COLLAPSE_MIN_HEIGHT;
	exports.DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM = DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM;
	exports.DEFAULT_COLLAPSE_MIN_PADDING_TOP = DEFAULT_COLLAPSE_MIN_PADDING_TOP;
	exports.DEFAULT_COLLAPSE_TIMEOUT = DEFAULT_COLLAPSE_TIMEOUT;
	exports.DEFAULT_DESKTOP_LARGE_MIN_WIDTH = DEFAULT_DESKTOP_LARGE_MIN_WIDTH;
	exports.DEFAULT_DESKTOP_LAYOUT = DEFAULT_DESKTOP_LAYOUT;
	exports.DEFAULT_DESKTOP_MIN_WIDTH = DEFAULT_DESKTOP_MIN_WIDTH;
	exports.DEFAULT_DIALOG_CLASSNAMES = DEFAULT_DIALOG_CLASSNAMES;
	exports.DEFAULT_DIALOG_TIMEOUT = DEFAULT_DIALOG_TIMEOUT;
	exports.DEFAULT_DIR = DEFAULT_DIR;
	exports.DEFAULT_GET_DISPLAY_LABEL = getDisplayLabel;
	exports.DEFAULT_GET_ITEM_VALUE = DEFAULT_GET_ITEM_VALUE;
	exports.DEFAULT_GET_OPTION_ID = getOptionId;
	exports.DEFAULT_GET_OPTION_LABEL = getOptionLabel;
	exports.DEFAULT_GET_RESULT_ID = getResultId;
	exports.DEFAULT_GET_RESULT_LABEL = getResultLabel;
	exports.DEFAULT_GET_RESULT_VALUE = getResultValue;
	exports.DEFAULT_GRID_LIST_MAX_CELL_SIZE = DEFAULT_GRID_LIST_MAX_CELL_SIZE;
	exports.DEFAULT_GRID_LIST_PADDING = DEFAULT_GRID_LIST_PADDING;
	exports.DEFAULT_HOVER_MODE_DEACTIVATION_TIME = DEFAULT_HOVER_MODE_DEACTIVATION_TIME;
	exports.DEFAULT_HOVER_MODE_EXIT_TIME = DEFAULT_HOVER_MODE_EXIT_TIME;
	exports.DEFAULT_HOVER_MODE_VISIBLE_IN_TIME = DEFAULT_HOVER_MODE_VISIBLE_IN_TIME;
	exports.DEFAULT_IGNORE_WHITESPACE = DEFAULT_IGNORE_WHITESPACE;
	exports.DEFAULT_KEYBOARD_MOVEMENT = DEFAULT_KEYBOARD_MOVEMENT;
	exports.DEFAULT_LANDSCAPE_TABLET_LAYOUT = DEFAULT_LANDSCAPE_TABLET_LAYOUT;
	exports.DEFAULT_LAYOUT_MAIN_CLASSNAMES = DEFAULT_LAYOUT_MAIN_CLASSNAMES;
	exports.DEFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES = DEFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES;
	exports.DEFAULT_LTR_KEYBOARD_MOVEMENT = DEFAULT_LTR_KEYBOARD_MOVEMENT;
	exports.DEFAULT_MENU_CONFIGURATION = DEFAULT_MENU_CONFIGURATION;
	exports.DEFAULT_MESSAGE_QUEUE_TIMEOUT = DEFAULT_MESSAGE_QUEUE_TIMEOUT;
	exports.DEFAULT_OVERLAY_CLASSNAMES = DEFAULT_OVERLAY_CLASSNAMES;
	exports.DEFAULT_OVERLAY_TIMEOUT = DEFAULT_OVERLAY_TIMEOUT;
	exports.DEFAULT_PHONE_LAYOUT = DEFAULT_PHONE_LAYOUT;
	exports.DEFAULT_PHONE_MAX_WIDTH = DEFAULT_PHONE_MAX_WIDTH;
	exports.DEFAULT_RIPPLE_CLASSNAMES = DEFAULT_RIPPLE_CLASSNAMES;
	exports.DEFAULT_RIPPLE_TIMEOUT = DEFAULT_RIPPLE_TIMEOUT;
	exports.DEFAULT_RTL_KEYBOARD_MOVEMENT = DEFAULT_RTL_KEYBOARD_MOVEMENT;
	exports.DEFAULT_SEARCH_OPTIONS = DEFAULT_SEARCH_OPTIONS;
	exports.DEFAULT_SEARCH_RESET_TIME = DEFAULT_SEARCH_RESET_TIME;
	exports.DEFAULT_SHEET_CLASSNAMES = DEFAULT_SHEET_CLASSNAMES;
	exports.DEFAULT_SHEET_TIMEOUT = DEFAULT_SHEET_TIMEOUT;
	exports.DEFAULT_SLIDER_ANIMATION_TIME = DEFAULT_SLIDER_ANIMATION_TIME;
	exports.DEFAULT_SLIDER_GET_VALUE_TEXT = DEFAULT_SLIDER_GET_VALUE_TEXT;
	exports.DEFAULT_SLIDER_MAX = DEFAULT_SLIDER_MAX;
	exports.DEFAULT_SLIDER_MIN = DEFAULT_SLIDER_MIN;
	exports.DEFAULT_SLIDER_STEP = DEFAULT_SLIDER_STEP;
	exports.DEFAULT_TABLET_LAYOUT = DEFAULT_TABLET_LAYOUT;
	exports.DEFAULT_TABLET_MAX_WIDTH = DEFAULT_TABLET_MAX_WIDTH;
	exports.DEFAULT_TABLET_MIN_WIDTH = DEFAULT_TABLET_MIN_WIDTH;
	exports.DEFAULT_TABPANEL_CLASSNAMES = DEFAULT_TABPANEL_CLASSNAMES;
	exports.DEFAULT_TABPANEL_TIMEOUT = DEFAULT_TABPANEL_TIMEOUT;
	exports.DEFAULT_TOAST_CLASSNAMES = DEFAULT_TOAST_CLASSNAMES;
	exports.DEFAULT_TOAST_TIMEOUT = DEFAULT_TOAST_TIMEOUT;
	exports.DEFAULT_TOOLTIP_CLASSNAMES = DEFAULT_TOOLTIP_CLASSNAMES;
	exports.DEFAULT_TOOLTIP_DELAY = DEFAULT_TOOLTIP_DELAY;
	exports.DEFAULT_TOOLTIP_DENSE_SPACING = DEFAULT_TOOLTIP_DENSE_SPACING;
	exports.DEFAULT_TOOLTIP_MARGIN = DEFAULT_TOOLTIP_MARGIN;
	exports.DEFAULT_TOOLTIP_POSITION = DEFAULT_TOOLTIP_POSITION;
	exports.DEFAULT_TOOLTIP_SPACING = DEFAULT_TOOLTIP_SPACING;
	exports.DEFAULT_TOOLTIP_THRESHOLD = DEFAULT_TOOLTIP_THRESHOLD;
	exports.DEFAULT_TOOLTIP_TIMEOUT = DEFAULT_TOOLTIP_TIMEOUT;
	exports.DEFAULT_TRIM = DEFAULT_TRIM;
	exports.DEFAULT_VALUE_KEY = DEFAULT_VALUE_KEY;
	exports.DEFFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES = DEFFAULT_LAYOUT_NAV_TOGGLE_CLASSNAMES;
	exports.DesktopOnly = DesktopOnly;
	exports.Dialog = Dialog;
	exports.DialogContent = DialogContent;
	exports.DialogFooter = DialogFooter;
	exports.DialogHeader = DialogHeader;
	exports.DialogTitle = DialogTitle;
	exports.Dir = Dir;
	exports.Divider = Divider;
	exports.DropdownMenu = DropdownMenu;
	exports.ExpansionList = ExpansionList;
	exports.ExpansionPanel = ExpansionPanel;
	exports.ExpansionPanelHeader = ExpansionPanelHeader;
	exports.FAB = FAB;
	exports.FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS;
	exports.Fieldset = Fieldset;
	exports.FileAccessError = FileAccessError;
	exports.FileExtensionError = FileExtensionError;
	exports.FileInput = FileInput;
	exports.FileSizeError = FileSizeError;
	exports.FixedDialog = FixedDialog;
	exports.FocusContainer = FocusContainer;
	exports.FontIcon = FontIcon;
	exports.Form = Form;
	exports.FormMessage = FormMessage;
	exports.FormMessageContainer = FormMessageContainer;
	exports.FormMessageCounter = FormMessageCounter;
	exports.FormThemeProvider = FormThemeProvider;
	exports.GRID_COLUMNS_VAR = GRID_COLUMNS_VAR;
	exports.GRID_GUTTER_VAR = GRID_GUTTER_VAR;
	exports.GenericFileError = GenericFileError;
	exports.Grid = Grid;
	exports.GridCell = GridCell;
	exports.GridList = GridList;
	exports.GridListCell = GridListCell;
	exports.GridListSizeProvider = GridListSizeProvider;
	exports.HighlightedResult = HighlightedResult;
	exports.HoverModeContextProvider = HoverModeContextProvider;
	exports.HoverModeProvider = HoverModeProvider;
	exports.IconProvider = IconProvider;
	exports.IconRotator = IconRotator;
	exports.InputToggle = InputToggle;
	exports.InputToggleIcon = InputToggleIcon;
	exports.KeyboardMovementContextProvider = KeyboardMovementContextProvider;
	exports.KeyboardMovementProvider = KeyboardMovementProvider;
	exports.LARGE_TEXT_CONTRAST_RATIO = LARGE_TEXT_CONTRAST_RATIO;
	exports.Label = Label;
	exports.Layout = Layout;
	exports.LayoutAppBar = LayoutAppBar;
	exports.LayoutAppBarTitle = LayoutAppBarTitle;
	exports.LayoutChildren = LayoutChildren;
	exports.LayoutCloseNavigationButton = LayoutCloseNavigationButton;
	exports.LayoutMain = LayoutMain;
	exports.LayoutNavToggle = LayoutNavToggle;
	exports.LayoutNavigation = LayoutNavigation;
	exports.LayoutNavigationHeader = LayoutNavigationHeader;
	exports.LayoutProvider = LayoutProvider;
	exports.LayoutTree = LayoutTree;
	exports.LinearProgress = LinearProgress;
	exports.Link = Link;
	exports.List = List;
	exports.ListItem = ListItem;
	exports.ListItemAddon = ListItemAddon;
	exports.ListItemChildren = ListItemChildren;
	exports.ListItemLink = ListItemLink;
	exports.ListItemText = ListItemText;
	exports.ListSubheader = ListSubheader;
	exports.Listbox = Listbox;
	exports.MediaContainer = MediaContainer;
	exports.MediaOverlay = MediaOverlay;
	exports.Menu = Menu;
	exports.MenuBar = MenuBar;
	exports.MenuBarProvider = MenuBarProvider;
	exports.MenuBarWidget = MenuBarWidget;
	exports.MenuButton = MenuButton;
	exports.MenuConfigurationProvider = MenuConfigurationProvider;
	exports.MenuItem = MenuItem;
	exports.MenuItemButton = MenuItemButton;
	exports.MenuItemCheckbox = MenuItemCheckbox;
	exports.MenuItemFileInput = MenuItemFileInput;
	exports.MenuItemGroup = MenuItemGroup;
	exports.MenuItemInputToggle = MenuItemInputToggle;
	exports.MenuItemLink = MenuItemLink;
	exports.MenuItemRadio = MenuItemRadio;
	exports.MenuItemSeparator = MenuItemSeparator;
	exports.MenuItemSwitch = MenuItemSwitch;
	exports.MenuItemTextField = MenuItemTextField;
	exports.MenuKeyboardFocusProvider = MenuKeyboardFocusProvider;
	exports.MenuRenderer = MenuRenderer;
	exports.MenuSheet = MenuSheet;
	exports.MenuVisibilityProvider = MenuVisibilityProvider;
	exports.MenuWidget = MenuWidget;
	exports.MessageQueue = MessageQueue;
	exports.MessageQueueActionsContext = MessageQueueActionsContext;
	exports.MessageQueueContext = MessageQueueContext;
	exports.MessageVisibilityContext = MessageVisibilityContext;
	exports.MobileOnly = MobileOnly;
	exports.MovementPresets = presets;
	exports.NORMAL_TEXT_CONTRAST_RATIO = NORMAL_TEXT_CONTRAST_RATIO;
	exports.NativeSelect = NativeSelect;
	exports.NestedDialogContextProvider = NestedDialogContextProvider;
	exports.Option = Option;
	exports.Overlay = Overlay;
	exports.PROGRAMATICALLY_FOCUSABLE = PROGRAMATICALLY_FOCUSABLE;
	exports.Password = Password;
	exports.PasswordWithMessage = PasswordWithMessage;
	exports.PhoneOnly = PhoneOnly;
	exports.Portal = Portal;
	exports.RECOMMENDED_NUMBER_STATE_KEYS = RECOMMENDED_NUMBER_STATE_KEYS;
	exports.RECOMMENDED_STATE_KEYS = RECOMMENDED_STATE_KEYS;
	exports.Radio = Radio;
	exports.RadioGroup = RadioGroup;
	exports.RadioWidget = RadioWidget;
	exports.RangeSlider = RangeSlider;
	exports.ResizeListener = ResizeListener;
	exports.SCALE_CLASSNAMES = SCALE_CLASSNAMES;
	exports.SCALE_TIMEOUT = SCALE_TIMEOUT;
	exports.SCALE_Y_CLASSNAMES = SCALE_Y_CLASSNAMES;
	exports.SVGIcon = SVGIcon;
	exports.ScaleTransition = ScaleTransition;
	exports.ScrollListener = ScrollListener;
	exports.Select = Select;
	exports.Sheet = Sheet;
	exports.SimpleListItem = SimpleListItem;
	exports.SkipToMainContent = SkipToMainContent;
	exports.Slider = Slider;
	exports.SliderContainer = SliderContainer;
	exports.SliderThumb = SliderThumb;
	exports.SliderTrack = SliderTrack;
	exports.Snackbar = Snackbar;
	exports.SrOnly = SrOnly;
	exports.StatesConfig = StatesConfig;
	exports.StatesConfigContext = StatesConfigContext;
	exports.Switch = Switch;
	exports.SwitchTrack = SwitchTrack;
	exports.TAB_FOCUSABLE = TAB_FOCUSABLE;
	exports.THUMB_1_VAR = THUMB_1_VAR;
	exports.THUMB_2_VAR = THUMB_2_VAR;
	exports.TOOLTIP_SPACING_VAR = TOOLTIP_SPACING_VAR;
	exports.TOP_CENTER_ANCHOR = TOP_CENTER_ANCHOR;
	exports.TOP_INNER_LEFT_ANCHOR = TOP_INNER_LEFT_ANCHOR;
	exports.TOP_INNER_RIGHT_ANCHOR = TOP_INNER_RIGHT_ANCHOR;
	exports.TOP_LEFT_ANCHOR = TOP_LEFT_ANCHOR;
	exports.TOP_RIGHT_ANCHOR = TOP_RIGHT_ANCHOR;
	exports.Tab = Tab;
	exports.TabPanel = TabPanel;
	exports.TabPanels = TabPanels;
	exports.Table = Table;
	exports.TableBody = TableBody;
	exports.TableCell = TableCell;
	exports.TableCellContent = TableCellContent;
	exports.TableCheckbox = TableCheckbox;
	exports.TableContainer = TableContainer;
	exports.TableFooter = TableFooter;
	exports.TableHeader = TableHeader;
	exports.TableRow = TableRow;
	exports.TabletOnly = TabletOnly;
	exports.Tabs = Tabs;
	exports.TabsList = TabsList;
	exports.TabsManager = TabsManager;
	exports.TextArea = TextArea;
	exports.TextAreaWithMessage = TextAreaWithMessage;
	exports.TextContainer = TextContainer;
	exports.TextField = TextField;
	exports.TextFieldAddon = TextFieldAddon;
	exports.TextFieldContainer = TextFieldContainer;
	exports.TextFieldWithMessage = TextFieldWithMessage;
	exports.TextIconSpacing = TextIconSpacing;
	exports.Toast = Toast;
	exports.ToggleContainer = ToggleContainer;
	exports.TooManyFilesError = TooManyFilesError;
	exports.Tooltip = Tooltip;
	exports.Tooltipped = Tooltipped;
	exports.Tree = Tree;
	exports.TreeGroup = TreeGroup;
	exports.TreeItem = TreeItem;
	exports.Typography = Typography;
	exports.UnstyledButton = UnstyledButton;
	exports.UserInteractionModeListener = UserInteractionModeListener;
	exports.VerticalDivider = VerticalDivider;
	exports.applyRef = applyRef;
	exports.bem = bem;
	exports.buttonThemeClassNames = buttonThemeClassNames;
	exports.caseInsensitiveFilter = caseInsensitiveFilter;
	exports.containsElement = containsElement;
	exports.defaultGetErrorIcon = defaultGetErrorIcon;
	exports.defaultGetErrorMessage = defaultGetErrorMessage;
	exports.defaultGetRadioClassName = defaultGetRadioClassName;
	exports.defaultGetRadioStyle = defaultGetRadioStyle;
	exports.defaultIsErrored = defaultIsErrored;
	exports.defaultMiniNavigationItemRenderer = defaultMiniNavigationItemRenderer;
	exports.defaultNavigationItemRenderer = defaultNavigationItemRenderer;
	exports.defaultTreeItemRenderer = defaultTreeItemRenderer;
	exports.defaults = defaults;
	exports.delegateEvent = delegateEvent;
	exports.disableScrollLock = disableScrollLock;
	exports.enableScrollLock = enableScrollLock;
	exports.extractTextContent = extractTextContent;
	exports.findIgnoreCase = findIgnoreCase;
	exports.findMatchInRange = findMatchInRange;
	exports.findMatchIndex = findMatchIndex;
	exports.findSizingContainer = findSizingContainer;
	exports.focusElementWithin = focusElementWithin;
	exports.fuzzyFilter = fuzzyFilter;
	exports.getChildItems = getChildItems;
	exports.getContrastRatio = getContrastRatio;
	exports.getElement = getElement;
	exports.getElementRect = getElementRect;
	exports.getFileParser = getFileParser;
	exports.getFixedPosition = getFixedPosition;
	exports.getFocusableElements = getFocusableElements;
	exports.getFuzzyRegExp = getFuzzyRegExp;
	exports.getItemId = getItemId;
	exports.getItemValue = getItemValue;
	exports.getItemsFrom = getItemsFrom;
	exports.getLayoutType = getLayoutType;
	exports.getListItemHeight = getListItemHeight;
	exports.getOrientationType = getOrientationType;
	exports.getPercentage = getPercentage;
	exports.getProgressA11y = getProgressA11y;
	exports.getRadioItemValue = getRadioItemValue;
	exports.getSearchString = getSearchString;
	exports.getSplitFileUploads = getSplitFileUploads;
	exports.getViewportSize = getViewportSize;
	exports.hexToRGB = hexToRGB;
	exports.isAudioFile = isAudioFile;
	exports.isContrastCompliant = isContrastCompliant;
	exports.isFileAccessError = isFileAccessError;
	exports.isFileExtensionError = isFileExtensionError;
	exports.isFileSizeError = isFileSizeError;
	exports.isFocusable = isFocusable;
	exports.isFullHeightLayout = isFullHeightLayout;
	exports.isGenericFileError = isGenericFileError;
	exports.isImageFile = isImageFile;
	exports.isListboxOptionProps = isListboxOptionProps;
	exports.isMediaFile = isMediaFile;
	exports.isMiniLayout = isMiniLayout;
	exports.isPersistentLayout = isPersistentLayout;
	exports.isResultOf = isResultOf;
	exports.isTemporaryLayout = isTemporaryLayout;
	exports.isTextFile = isTextFile;
	exports.isToggleableLayout = isToggleableLayout;
	exports.isTooManyFilesError = isTooManyFilesError;
	exports.isValidFileName = isValidFileName;
	exports.isVideoFile = isVideoFile;
	exports.labelStyles = labelStyles;
	exports.loop = loop;
	exports.nearest = nearest;
	exports.omit = omit;
	exports.scrollIntoView = scrollIntoView;
	exports.throttle = throttle;
	exports.toWidthPart = toWidthPart;
	exports.tryToSubmitRelatedForm = tryToSubmitRelatedForm;
	exports.unitToNumber = unitToNumber;
	exports.useActionClassName = useActionClassName;
	exports.useActiveDescendant = useActiveDescendant;
	exports.useActiveDescendantContext = useActiveDescendantContext;
	exports.useActiveDescendantFocus = useActiveDescendantFocus;
	exports.useActiveDescendantMovement = useActiveDescendantMovement;
	exports.useAddMessage = useAddMessage;
	exports.useAppSize = useAppSize;
	exports.useAppSizeMedia = useAppSizeMedia;
	exports.useAutoComplete = useAutoComplete;
	exports.useCSSTransition = useCSSTransition;
	exports.useChecked = useChecked;
	exports.useChoice = useChoice;
	exports.useCloseOnEscape = useCloseOnEscape;
	exports.useCloseOnOutsideClick = useCloseOnOutsideClick;
	exports.useCollapseTransition = useCollapseTransition;
	exports.useContextMenu = useContextMenu;
	exports.useCrossFadeTransition = useCrossFadeTransition;
	exports.useDir = useDir;
	exports.useDropzone = useDropzone;
	exports.useEnsuredRef = useEnsuredRef;
	exports.useFileUpload = useFileUpload;
	exports.useFixedPositioning = useFixedPositioning;
	exports.useFocusMovement = useFocusMovement;
	exports.useFocusOnMount = useFocusOnMount;
	exports.useFormTheme = useFormTheme;
	exports.useGridList = useGridList;
	exports.useGridListSize = useGridListSize;
	exports.useHoverMode = useHoverMode;
	exports.useHoverModeContext = useHoverModeContext;
	exports.useIcon = useIcon;
	exports.useIndeterminateChecked = useIndeterminateChecked;
	exports.useInteractionStates = useInteractionStates;
	exports.useInterval = useInterval;
	exports.useIsUserInteractionMode = useIsUserInteractionMode;
	exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
	exports.useKeyboardFocus = useKeyboardFocus;
	exports.useKeyboardFocusContext = useKeyboardFocusContext;
	exports.useKeyboardFocusableElement = useKeyboardFocusableElement;
	exports.useKeyboardMovement = useKeyboardMovement;
	exports.useKeyboardSearch = useKeyboardSearch;
	exports.useLayoutConfig = useLayoutConfig;
	exports.useLayoutNavigation = useLayoutNavigation;
	exports.useMediaQuery = useMediaQuery;
	exports.useMenu = useMenu;
	exports.useMenuBarContext = useMenuBarContext;
	exports.useMenuBarWidgetFocusId = useMenuBarWidgetFocusId;
	exports.useMenuConfiguration = useMenuConfiguration;
	exports.useMenuVisibility = useMenuVisibility;
	exports.useMessageQueueActions = useMessageQueueActions;
	exports.useMessageVisibility = useMessageVisibility;
	exports.useNumberField = useNumberField;
	exports.useOnUnmount = useOnUnmount;
	exports.useOrientation = useOrientation;
	exports.usePanels = usePanels;
	exports.usePreviousFocus = usePreviousFocus;
	exports.useQueue = useQueue;
	exports.useRangeSlider = useRangeSlider;
	exports.useRefCache = useRefCache;
	exports.useResizeListener = useResizeListener;
	exports.useResizeObserver = useResizeObserver;
	exports.useScaleTransition = useScaleTransition;
	exports.useScrollListener = useScrollListener;
	exports.useScrollLock = useScrollLock;
	exports.useSelectState = useSelectState;
	exports.useSlider = useSlider;
	exports.useStatesConfigContext = useStatesConfigContext;
	exports.useTabs = useTabs;
	exports.useTempValue = useTempValue;
	exports.useTextField = useTextField;
	exports.useTimeout = useTimeout;
	exports.useToggle = useToggle;
	exports.useTooltip = useTooltip;
	exports.useTooltipPosition = useTooltipPosition;
	exports.useTransition = useTransition;
	exports.useTreeItemExpansion = useTreeItemExpansion;
	exports.useTreeItemSelection = useTreeItemSelection;
	exports.useUserInteractionMode = useUserInteractionMode;
	exports.useVerticalDividerHeight = useVerticalDividerHeight;
	exports.useWidthMediaQuery = useWidthMediaQuery;
	exports.validateFiles = validateFiles;
	exports.withinRange = withinRange;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=react-md.development.js.map
